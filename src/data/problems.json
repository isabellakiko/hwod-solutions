[
  {
    "id": "1",
    "title": "IPv4地址转换成整数",
    "examType": "A",
    "score": 100,
    "description": "存在一种虚拟IPv4地址，由4小节组成，每节的范围为0~255，以#号间隔，虚拟IPv4地址可以转换为一个32位的整数，例如：\n128#0#255#255，转换为32位整数的结果为2147549183（0x8000FFFF） 1#0#0#0，转换为32位整数的结果为16777216（0x01000000）\n128#0#255#255，转换为32位整数的结果为2147549183（0x8000FFFF）\n1#0#0#0，转换为32位整数的结果为16777216（0x01000000）\n现以字符串形式给出一个虚拟IPv4地址，限制第1小节的范围为1128，即每一节范围分别为(1128)#(0255)#(0255)#(0~255)，要求每个IPv4地址只能对应到唯一的整数上。如果是非法IPv4，返回invalid IP",
    "inputDesc": "输入一行，虚拟IPv4地址格式字符串",
    "outputDesc": "输出一行，按照要求输出整型或者特定字符",
    "examples": [
      {
        "input": "#101#1#5",
        "output": "",
        "explanation": ""
      },
      {
        "input": "#2#3",
        "output": "invalid IP",
        "explanation": ""
      }
    ],
    "solution": "虚拟IPv4地址由四个小节组成，每个小节用#号分隔。在这个虚拟版本中用#替代。每个小节代表一个整数，范围从0到255，但题目中特别指出第一小节的范围应为1到128。地址的正确形式应该是四部分，例如 1#2#3#4。如果格式不正确或数值不在指定范围内，则视为非法IPv4，输出“invalid IP”。\n异常处理： 确保输入的每一部分（小节）都是数字。确保没有空的小节，例如1##3#4。处理任何非数字字符，例如a#b#c#d。检查是否每个部分都严格为数字，并且没有前导零（除了单独的0），例如01#01#01#01应被视为非法。 范围验证： 第一小节必须在1到128之间。其余三小节必须在0到255之间。任何超出这些范围的值都应该导致输出“invalid IP”。 格式正确性： 确保地址严格由四个数字小节组成，多于或少于四部分都应视为无效。\n异常处理：\n确保输入的每一部分（小节）都是数字。确保没有空的小节，例如1##3#4。处理任何非数字字符，例如a#b#c#d。检查是否每个部分都严格为数字，并且没有前导零（除了单独的0），例如01#01#01#01应被视为非法。\n范围验证：\n第一小节必须在1到128之间。其余三小节必须在0到255之间。任何超出这些范围的值都应该导致输出“invalid IP”。\n格式正确性：\n确保地址严格由四个数字小节组成，多于或少于四部分都应视为无效。\n下面代码有些判断条件可以合并，为了看的更清晰，没有合并",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String input = sc.nextLine();\n    String[] ipSections = input.split(\"#\"); // 将输入的字符串按照\"#\"分割成4个小节\n    \n    if (ipSections.length != 4) { // 如果分割后的小节数量不等于4，则说明输入的IPv4地址格式不正确\n      System.out.println(\"invalid IP\");\n      return; // 结束程序\n    }\n\n    for (String section : ipSections) {\n      if (!isNumeric(section)) { // 检查是否每部分都是数字\n        System.out.println(\"invalid IP\");\n        return; // 结束程序\n      }\n       if (section.length() == 0) { // 检查是否有空字符\n        System.out.println(\"invalid IP\");\n        return; // 结束程序\n      }\n\n            \n      // 检查前导零的情况\n      if (section.length() > 1 && section.charAt(0) == '0') {\n        System.out.println(\"invalid IP\");\n        return; // 结束程序\n      }\n    }\n    \n    int firstSection = Integer.parseInt(ipSections[0]); // 将第一个小节转换为整数\n    if (firstSection < 1 || firstSection > 128) { // 如果第一个小节的值不在1~128的范围内，则说明输入的IPv4地址格式不正确\n      System.out.println(\"invalid IP\");\n      return; // 结束程序\n    }\n    \n    for (int i = 1; i < 4; i++) { // 遍历后面的3个小节\n      int sectionValue = Integer.parseInt(ipSections[i]); // 将当前小节转换为整数\n      if (sectionValue < 0 || sectionValue > 255) { // 如果当前小节的值不在0~255的范围内，则说明输入的IPv4地址格式不正确\n        System.out.println(\"invalid IP\");\n        return; // 结束程序\n      }\n    }\n    \n    long ipValue = 0; // 用于计算32位整数值\n    for (int i = 0; i < 4; i++) {\n      ipValue = ipValue * 256 + Integer.parseInt(ipSections[i]); // 每个小节对应一个字节，计算最终的整数值\n    }\n    \n    System.out.println(ipValue); // 输出最终计算得到的32位整数\n  }\n\n  // 判断字符串是否为数字\n  public static boolean isNumeric(String str) {\n    for (int i = 0; i < str.length(); i++) {\n      if (!Character.isDigit(str.charAt(i))) {\n        return false; // 如果有非数字字符则返回false\n      }\n    }\n    return true; // 全部为数字则返回true\n  }\n}",
      "python": "# 判断字符串是否为数字\ndef is_numeric(s):\n    return s.isdigit()\n\n# 获取输入的字符串\ninput_str = input()\n\n# 将输入的字符串按照\"#\"分割成4个小节\nip_sections = input_str.split(\"#\")\n\n# 如果分割后的小节数量不等于4，则说明输入的IPv4地址格式不正确\nif len(ip_sections) != 4:\n    print(\"invalid IP\")\nelse:\n    valid = True\n    # 遍历每个部分进行检查\n    for section in ip_sections:\n        if len(section) == 0 or not is_numeric(section):  # 检查是否为空或者是否每部分都是数字\n            valid = False\n            break\n        if len(section) > 1 and section[0] == '0':  # 检查前导零的情况\n            valid = False\n            break\n    \n    if not valid:\n        print(\"invalid IP\")\n    else:\n        # 检查第一个小节的范围\n        first_section = int(ip_sections[0])  # 将第一个小节转换为整数\n        if first_section < 1 or first_section > 128:  # 如果第一个小节的值不在1~128的范围内\n            print(\"invalid IP\")\n        else:\n            # 检查其余3个小节的范围\n            for i in range(1, 4):\n                section_value = int(ip_sections[i])  # 将当前小节转换为整数\n                if section_value < 0 or section_value > 255:  # 如果不在0~255范围内\n                    print(\"invalid IP\")\n                    break\n            else:\n                # 计算最终的32位整数\n                ip_value = 0\n                for i in range(4):\n                    ip_value = ip_value * 256 + int(ip_sections[i])  # 每个小节对应一个字节，计算最终的整数值\n                print(ip_value)  # 输出最终的32位整数",
      "javascript": "const readline = require('readline');\n\n// 判断字符串是否为数字\nfunction isNumeric(str) {\n  for (let i = 0; i < str.length; i++) {\n    if (!/\\d/.test(str[i])) {\n      return false; // 如果有非数字字符则返回false\n    }\n  }\n  return true; // 全部为数字则返回true\n}\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', function (input) {\n  const ipSections = input.split('#'); // 将输入的字符串按照\"#\"分割成4个小节\n\n  if (ipSections.length !== 4) { // 如果分割后的小节数量不等于4，则说明输入的IPv4地址格式不正确\n    console.log(\"invalid IP\");\n    rl.close();\n    return;\n  }\n\n  // 遍历每个部分进行检查\n  for (const section of ipSections) {\n    if (section.length === 0 || !isNumeric(section)) { // 检查是否为空或者是否每部分都是数字\n      console.log(\"invalid IP\");\n      rl.close();\n      return;\n    }\n\n    // 检查前导零的情况\n    if (section.length > 1 && section[0] === '0') {\n      console.log(\"invalid IP\");\n      rl.close();\n      return;\n    }\n  }\n\n  const firstSection = parseInt(ipSections[0], 10); // 将第一个小节转换为整数\n  if (firstSection < 1 || firstSection > 128) { // 如果第一个小节的值不在1~128的范围内\n    console.log(\"invalid IP\");\n    rl.close();\n    return;\n  }\n\n  // 检查其余3个小节的范围\n  for (let i = 1; i < 4; i++) {\n    const sectionValue = parseInt(ipSections[i], 10); // 将当前小节转换为整数\n    if (sectionValue < 0 || sectionValue > 255) { // 如果不在0~255范围内\n      console.log(\"invalid IP\");\n      rl.close();\n      return;\n    }\n  }\n\n  // 计算最终的32位整数\n  let ipValue = 0;\n  for (let i = 0; i < 4; i++) {\n    ipValue = ipValue * 256 + parseInt(ipSections[i], 10); // 每个小节对应一个字节，计算最终的整数值\n  }\n\n  console.log(ipValue); // 输出最终的32位整数\n  rl.close();\n});",
      "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\n// 判断字符串是否为数字\nbool isNumeric(const string& str) {\n    for (char c : str) {\n        if (!isdigit(c)) {\n            return false; // 如果有非数字字符则返回false\n        }\n    }\n    return true; // 全部为数字则返回true\n}\n\nint main() {\n    string input;\n    getline(cin, input); // 获取输入的字符串\n\n    // 将输入的字符串按照\"#\"分割成4个小节\n    stringstream ss(input);\n    vector<string> ipSections;\n    string section;\n    while (getline(ss, section, '#')) {\n        ipSections.push_back(section);\n    }\n\n    if (ipSections.size() != 4) { // 如果分割后的小节数量不等于4，则说明输入的IPv4地址格式不正确\n        cout << \"invalid IP\" << endl;\n        return 0; // 结束程序\n    }\n\n    // 遍历每个部分进行检查\n    for (const string& section : ipSections) {\n        if (section.empty() || !isNumeric(section)) { // 检查是否为空或者是否每部分都是数字\n            cout << \"invalid IP\" << endl;\n            return 0; // 结束程序\n        }\n\n        // 检查前导零的情况\n        if (section.length() > 1 && section[0] == '0') {\n            cout << \"invalid IP\" << endl;\n            return 0; // 结束程序\n        }\n    }\n\n    // 检查第一个小节的范围\n    int firstSection = stoi(ipSections[0]); // 将第一个小节转换为整数\n    if (firstSection < 1 || firstSection > 128) { // 如果第一个小节的值不在1~128的范围内\n        cout << \"invalid IP\" << endl;\n        return 0; // 结束程序\n    }\n\n    // 检查其余3个小节的范围\n    for (int i = 1; i < 4; i++) {\n        int sectionValue = stoi(ipSections[i]); // 将当前小节转换为整数\n        if (sectionValue < 0 || sectionValue > 255) { // 如果不在0~255范围内\n            cout << \"invalid IP\" << endl;\n            return 0; // 结束程序\n        }\n    }\n\n    // 计算最终的32位整数\n    long ipValue = 0;\n    for (int i = 0; i < 4; i++) {\n        ipValue = ipValue * 256 + stoi(ipSections[i]); // 每个小节对应一个字节，计算最终的整数值\n    }\n\n    cout << ipValue << endl; // 输出最终的32位整数\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n// 判断字符串是否为数字\nint is_numeric(const char* str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (!isdigit(str[i])) {\n            return 0; // 如果有非数字字符则返回0\n        }\n    }\n    return 1; // 全部为数字则返回1\n}\n\nint main() {\n    char input[256];\n    fgets(input, sizeof(input), stdin); // 获取输入的字符串\n\n    char* ipSections[4];\n    char* token = strtok(input, \"#\"); // 将输入的字符串按照\"#\"分割成4个小节\n    int sectionCount = 0;\n\n    while (token != NULL && sectionCount < 4) {\n        ipSections[sectionCount++] = token;\n        token = strtok(NULL, \"#\");\n    }\n\n    if (sectionCount != 4) { // 如果分割后的小节数量不等于4\n        printf(\"invalid IP\\n\");\n        return 0; // 结束程序\n    }\n\n    // 遍历每个部分进行检查\n    for (int i = 0; i < 4; i++) {\n        char* section = ipSections[i];\n\n        // 去除末尾换行符\n        section[strcspn(section, \"\\n\")] = '\\0';\n\n        if (strlen(section) == 0 || !is_numeric(section)) { // 检查是否为空或者是否每部分都是数字\n            printf(\"invalid IP\\n\");\n            return 0; // 结束程序\n        }\n\n        // 检查前导零的情况\n        if (strlen(section) > 1 && section[0] == '0') {\n            printf(\"invalid IP\\n\");\n            return 0; // 结束程序\n        }\n    }\n\n    // 检查第一个小节的范围\n    int firstSection = atoi(ipSections[0]); // 将第一个小节转换为整数\n    if (firstSection < 1 || firstSection > 128) { // 如果第一个小节的值不在1~128的范围内\n        printf(\"invalid IP\\n\");\n        return 0; // 结束程序\n    }\n\n    // 检查其余3个小节的范围\n    for (int i = 1; i < 4; i++) {\n        int sectionValue = atoi(ipSections[i]); // 将当前小节转换为整数\n        if (sectionValue < 0 || sectionValue > 255) { // 如果不在0~255范围内\n            printf(\"invalid IP\\n\");\n            return 0; // 结束程序\n        }\n    }\n\n    // 计算最终的32位整数\n    long ipValue = 0;\n    for (int i = 0; i < 4; i++) {\n        ipValue = ipValue * 256 + atoi(ipSections[i]); // 每个小节对应一个字节，计算最终的整数值\n    }\n\n    printf(\"%ld\\n\", ipValue); // 输出最终的32位整数\n    return 0;\n}"
    }
  },
  {
    "id": "2",
    "title": "TLV解码",
    "examType": "A",
    "score": 100,
    "description": "TLV编码是按[Tag Length Value]格式进行编码的，一段码流中的信元用Tag标识，Tag在码流中唯一不重复，Length表示信元Value的长度，Value表示信元的值。\n码流以某信元的Tag开头，Tag固定占一个字节，Length固定占两个字节，字节序为小端序。\n现给定TLV格式编码的码流，以及需要解码的信元Tag，请输出该信元的Value。\n输入码流的16进制字符中，不包括小写字母，且要求输出的16进制字符串中也不要包含小写字母；码流字符串的最大长度不超过50000个字节。",
    "inputDesc": "输入的第一行为一个字符串，表示待解码信元的Tag；\n输入的第二行为一个字符串，表示待解码的16进制码流，字节之间用空格分隔。",
    "outputDesc": "输出一个字符串，表示待解码信元以16进制表示的Value。",
    "examples": [
      {
        "input": "01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01 00 CC",
        "output": "33",
        "explanation": "需要解析的信元的Tag是31， 从码流的起始处开始匹配， 第一个信元的Tag是32，信元长度为1（01 00，小端序表示为1）； 第二个信元的Tag是90，其长度为2； 第三个信元的Tag是30，其长度为3； 第四个信元的Tag是31，其长度为2（02 00）， 所以返回长度后面的两个字节即可，即32 33。"
      },
      {
        "input": "01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01 00 CC",
        "output": "01 00 AE 90 02 00 01 02 30 03 00 AB 32 31 31 02 00 32 33 33 01 00 CC",
        "explanation": ""
      }
    ],
    "solution": "题目要求解析一段以 TLV（Tag, Length, Value）格式编码的码流，找到特定的 Tag，并输出该Tag对应的 Value 部分。具体的TLV格式是这样的：\nTag: 用一个字节表示，是信元的唯一标识符。Length: 用两个字节表示，表示信元的 Value 部分的长度，采用小端序，即低位字节在前。Value: 表示信元的值，根据 Length 的值来确定长度。\n给定一个16进制的码流和要查找的Tag值，要求找到对应Tag的 Value，并以16进制格式输出。\n小端序表示的Length： 小端序表示法即低字节在前，高字节在后。比如长度为 01 00，表示的实际长度是 1（即 0001）。而 02 00 表示长度 2（即 0002）。 Tag 的固定长度是1字节， Length 固定是2字节，而 Value 的长度是根据 Length 来决定的。\n小端序表示的Length：\n小端序表示法即低字节在前，高字节在后。比如长度为 01 00，表示的实际长度是 1（即 0001）。而 02 00 表示长度 2（即 0002）。\nTag 的固定长度是1字节， Length 固定是2字节，而 Value 的长度是根据 Length 来决定的。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // 输入待解码信元的Tag\n        String tag = sc.nextLine();\n        \n        // 输入16进制码流\n        String line = sc.nextLine();\n        \n        // 将16进制码流按空格分割成字符串数组\n        String[] hexArray = line.split(\" \");\n        \n        int index = 0;\n        while (index < hexArray.length) {\n            // 获取当前信元的长度\n            int length = Integer.parseInt(hexArray[index + 2] + hexArray[index + 1], 16);\n            \n            // 如果当前信元的Tag与待解码信元的Tag相同\n            if (hexArray[index].equals(tag)) {\n                StringBuilder sb = new StringBuilder();\n                \n                // 将当前信元的Value拼接到StringBuilder中\n                for (int i = index + 3; i < index + 3 + length; i++) {\n                    sb.append(hexArray[i]).append(\" \");\n                }\n                \n                // 输出待解码信元的Value，转换为大写并去除首尾空格\n                System.out.println(sb.toString().toUpperCase().trim());\n                break;\n            } else {\n                // 跳过当前信元\n                index += (2 + length + 1);\n            }\n        }\n    }\n}",
      "python": "# 定义一个函数，用于将给定的16进制字符串转换为整数\n# length_str 是两个16进制字符拼接后的字符串（表示长度）\ndef get_length(length_str):\n    return int(length_str, 16)  # 将16进制字符串转换为10进制整数\n\n# 主函数\ndef main():\n    # 从用户输入中获取目标Tag，并去除首尾空白字符\n    tag = input().strip()\n\n    # 从用户输入中获取码流数据，并去除首尾空白字符\n    line = input().strip()\n\n    # 将码流数据按空格分割，存入hex_array数组中，每个元素是一个16进制字符串\n    hex_array = line.split(\" \")\n\n    index = 0  # 初始化索引，用于遍历 hex_array\n\n    # 使用while循环遍历整个hex_array\n    while index < len(hex_array):\n        # 解析当前信元的 Length 字段\n        # Length 字段由两个字节组成，先拼接hex_array[index+2]（高位）和hex_array[index+1]（低位）\n        # 再调用get_length函数将其转换为十进制整数\n        length = get_length(hex_array[index + 2] + hex_array[index + 1])\n\n        # 如果当前信元的Tag与输入的Tag匹配\n        if hex_array[index] == tag:\n            sb = []  # 定义一个空列表，用于存储匹配Tag后的Value部分\n\n            # 从index+3位置开始（即第一个Value字节），提取length个字节的Value\n            for i in range(index + 3, index + 3 + length):\n                sb.append(hex_array[i])  # 将每个字节加入sb列表\n\n            # 输出提取的Value部分，使用空格连接，并将输出转换为大写，去掉首尾多余空格\n            print(\" \".join(sb).upper().strip())\n            break  # 找到匹配的Tag后，结束循环\n        else:\n            # 如果当前Tag不匹配，则跳过当前信元\n            # 跳过的字节数为：1 个 Tag + 2 个 Length + length 个 Value\n            index += (2 + length + 1)\n\n# 检查是否在直接运行脚本\nif __name__ == \"__main__\":\n    main()  # 调用主函数",
      "javascript": "// 引入 'readline' 模块，用于读取标准输入输出\nconst readline = require('readline');\n\n// 创建接口实例，用于处理输入输出\nconst rl = readline.createInterface({\n  input: process.stdin,   // 标准输入流\n  output: process.stdout  // 标准输出流\n});\n\n// 首次监听 'line' 事件，获取用户输入的目标 Tag\nrl.on('line', (tag) => {\n\n  // 第二次监听 'line' 事件，获取码流数据\n  rl.on('line', (line) => {\n    // 将码流按空格分割，存入 hexArray 数组\n    const hexArray = line.split(\" \");\n    \n    let index = 0;  // 定义索引，用于遍历 hexArray\n\n    // 使用循环遍历整个 hexArray\n    while (index < hexArray.length) {\n      // 解析 Length 字段。Length 由两个字节组成，先拼接后转为16进制整数\n      const length = parseInt(hexArray[index + 2] + hexArray[index + 1], 16);\n\n      // 如果当前的 Tag 和用户输入的 Tag 匹配\n      if (hexArray[index] === tag) {\n        const sb = [];  // 定义一个数组，用于存储 Value 部分\n        \n        // 将 Tag 后的 length 个字节的 Value 加入 sb 数组\n        for (let i = index + 3; i < index + 3 + length; i++) {\n          sb.push(hexArray[i]);\n        }\n\n        // 将 sb 数组中的 Value 转换为大写字符串并输出，去掉多余空格\n        console.log(sb.join(\" \").toUpperCase().trim());\n        break;  // 找到目标 Tag 后，结束循环\n      } else {\n        // 如果 Tag 不匹配，跳过当前信元\n        // 跳过的字节数为：1 个 Tag + 2 个 Length + length 个 Value\n        index += (2 + length + 1);\n      }\n    }\n\n    // 关闭 readline 接口，结束程序\n    rl.close();\n  });\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    string tag;  // 定义一个字符串变量存储要查找的Tag\n    cin >> tag;  // 从输入中读取用户提供的Tag值\n    \n    string tmp;  // 临时字符串变量，用于存储每次输入的16进制字节\n    vector<string> vec;  // 定义一个字符串向量，用于存储码流中按空格分隔的所有16进制字符串\n\n    // 使用循环从标准输入中读取码流数据，直到遇到换行符为止\n    while (cin >> tmp) {\n        vec.push_back(tmp);  // 将每个16进制字节字符串存入向量\n        if (cin.get() == '\\n') break;  // 如果读取到换行符，停止输入\n    }\n\n    // 开始遍历向量vec，解析码流数据\n    for (int i = 0; i < vec.size();) {\n        string t = vec[i];  // 读取当前信元的Tag，即vec[i]\n\n        // 解析Length字段（两个字节，小端序）\n        // vec[i+1] 是低位字节，vec[i+2] 是高位字节\n        // 计算方式为：低位 + 高位 * 16\n        int len = stoi(vec[i + 1]) + 16 * stoi(vec[i + 2]);\n\n        // 如果当前信元的Tag与目标Tag一致\n        if (t == tag) {\n            // 输出该Tag对应的Value部分\n            // 从i + 3（第一个Value字节）开始，输出len个字节的Value\n            for (int j = i + 3; j < i + 3 + len; j++) {\n                cout << vec[j] << \" \";  // 输出Value的每个字节，用空格分隔\n            }\n            cout << endl;  // 输出完毕后换行\n            break;  // 找到匹配的Tag后，直接退出循环\n        } else {\n            // 如果当前Tag不匹配，则跳过该信元\n            // 跳过Tag（1字节）+ Length（2字节）+ Value（len字节）\n            i = i + 2 + len + 1;  // 移动i的位置，跳到下一个信元\n        }\n    }\n\n    return 0;  // 程序结束\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LEN 50000  // 定义码流的最大长度\n\nint main() {\n    char tag[3];  // 存储要查找的信元Tag，2个字符+1个结尾字符\n    scanf(\"%s\", tag);  // 输入要查找的Tag值\n\n    char stream[MAX_LEN];  // 存储整条码流的输入\n    getchar();  // 吸收掉换行符\n\n    fgets(stream, MAX_LEN, stdin);  // 读取整条码流字符串，空格分隔\n\n    // 定义一个数组来存储分割后的16进制字符串\n    char *vec[MAX_LEN];\n    int vec_size = 0;\n\n    // 使用 strtok 函数将码流按空格分割\n    char *tmp = strtok(stream, \" \");\n    while (tmp != NULL) {\n        vec[vec_size++] = tmp;  // 将分割出的部分存入数组\n        tmp = strtok(NULL, \" \");\n    }\n\n    // 遍历解析码流\n    for (int i = 0; i < vec_size;) {\n        char *t = vec[i];  // 当前的Tag\n        // 将长度部分解析为整数（小端序处理），vec[i+1]是低位，vec[i+2]是高位\n        int len = atoi(vec[i + 1]) + 16 * atoi(vec[i + 2]);\n\n        // 如果当前Tag与目标Tag相同\n        if (strcmp(t, tag) == 0) {\n            // 输出该信元的Value部分\n            for (int j = i + 3; j < i + 3 + len; j++) {\n                printf(\"%s \", vec[j]);\n            }\n            printf(\"\\n\");\n            break;  // 找到后直接跳出循环\n        } else {\n            // 如果Tag不匹配，跳过当前信元，i += 2 (长度字节) + len (Value长度) + 1 (Tag字节)\n            i = i + 2 + len + 1;\n        }\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "3",
    "title": "VLAN资源池",
    "examType": "A",
    "score": 100,
    "description": "VLAN是一种对局域网设备进行逻辑划分的技术，为了标识不同的VLAN，引入VLAN ID(1-4094之间的整数)的概念。\n定义一个VLAN ID的资源池(下称VLAN资源池)，资源池中连续的VLAN用开始VLAN-结束VLAN表示，不连续的用单个整数表示，所有的VLAN用英文逗号连接起来。\n现在有一个VLAN资源池，业务需要从资源池中申请一个VLAN，需要你输出从VLAN资源池中移除申请的VLAN后的资源池。",
    "inputDesc": "第一行为字符串格式的VLAN资源池，第二行为业务要申请的VLAN，VLAN的取值范围为[1,4094]之间的整数。",
    "outputDesc": "从输入VLAN资源池中移除申请的VLAN后字符串格式的VLAN资源池，输出要求满足题目描述中的格式，并且按照VLAN从小到大升序输出。 如果申请的VLAN不在原VLAN资源池内，输出原VLAN资源池升序排序后的字符串即可。",
    "examples": [
      {
        "input": "-5",
        "output": ",3-5",
        "explanation": "原VLAN资源池中有VLAN 1、2、3、4、5，从资源池中移除2后，剩下VLAN 1、3、4、5，按照题目描述格式并升序后的结果为1,3-5"
      },
      {
        "input": "-21,15,18,30,5-10",
        "output": "-10,18,20-21,30",
        "explanation": "原VLAN资源池中有VLAN 5、6、7、8、9、10、15、18、20、21、30，从资源池中移除15后，资源池中剩下的VLAN为 5、6、7、8、9、10、18、20、21、30，按照题目描述格式并升序后的结果为5-10,18,20-21,30。"
      },
      {
        "input": ",1-3",
        "output": "-3,5",
        "explanation": "原VLAN资源池中有VLAN 1、2、3，5，申请的VLAN 10不在原资源池中，将原资源池按照题目描述格式并按升序排序后输出的结果为1-3,5。"
      },
      {
        "input": ",1-3",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "VLAN（虚拟局域网）是一种网络技术，用来对局域网中的设备进行逻辑划分。每个VLAN通过一个 VLAN ID 来标识，取值范围是 1 到 4094 的整数。题目中的任务是处理一个字符串格式的 VLAN 资源池，模拟从资源池中申请并移除某个 VLAN，然后返回剩余的资源池。 任务： 输入 包含两个部分： VLAN资源池：用字符串表示，可能是单个 VLAN ID，或者是多个 VLAN ID 或 VLAN ID 范围（用\"-\"连接），各个 VLAN 或范围之间用逗号连接。要申请的 VLAN：一个需要移除的 VLAN ID。 输出 ： 从资源池中移除申请的 VLAN 后，输出剩余的 VLAN 资源池，按从小到大的顺序排列，且格式必须符合题目的描述。 输出格式： 连续的 VLAN ID 应该用范围的方式表示，如 1-5 表示 VLAN 1, 2, 3, 4, 5。不连续的 VLAN ID 用逗号分隔，如 1,3-5。 示例分析： 示例 1： 输入： 1-5 2 12 解释： 原始资源池有 VLAN 1, 2, 3, 4, 5。申请的 VLAN 是 2，所以移除 2 后，剩下的 VLAN 是 1, 3, 4, 5。格式化输出为：1,3-5。 示例 2： 输入： 20-21,15,18,30,5-10 15 12 解释： 原始资源池有 VLAN 5, 6, 7, 8, 9, 10, 15, 18, 20, 21, 30。申请的 VLAN 是 15，移除 15 后，剩下的 VLAN 是 5, 6, 7, 8, 9, 10, 18, 20, 21, 30。格式化输出为：5-10,18,20-21,30。 示例 3： 输入： 5,1-3 10 12 解释： 原始资源池有 VLAN 1, 2, 3, 5。申请的 VLAN 是 10，不在资源池中，所以资源池保持不变。格式化输出为：1-3,5。\nVLAN（虚拟局域网）是一种网络技术，用来对局域网中的设备进行逻辑划分。每个VLAN通过一个 VLAN ID 来标识，取值范围是 1 到 4094 的整数。题目中的任务是处理一个字符串格式的 VLAN 资源池，模拟从资源池中申请并移除某个 VLAN，然后返回剩余的资源池。\n输入 包含两个部分： VLAN资源池：用字符串表示，可能是单个 VLAN ID，或者是多个 VLAN ID 或 VLAN ID 范围（用\"-\"连接），各个 VLAN 或范围之间用逗号连接。要申请的 VLAN：一个需要移除的 VLAN ID。 输出 ： 从资源池中移除申请的 VLAN 后，输出剩余的 VLAN 资源池，按从小到大的顺序排列，且格式必须符合题目的描述。\n输入\n包含两个部分：\nVLAN资源池：用字符串表示，可能是单个 VLAN ID，或者是多个 VLAN ID 或 VLAN ID 范围（用\"-\"连接），各个 VLAN 或范围之间用逗号连接。要申请的 VLAN：一个需要移除的 VLAN ID。\n输出\n：\n从资源池中移除申请的 VLAN 后，输出剩余的 VLAN 资源池，按从小到大的顺序排列，且格式必须符合题目的描述。\n连续的 VLAN ID 应该用范围的方式表示，如 1-5 表示 VLAN 1, 2, 3, 4, 5。不连续的 VLAN ID 用逗号分隔，如 1,3-5。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 输入VLAN资源池\n        String input = sc.nextLine();\n        // 输入业务要申请的VLAN\n        Integer destVlan = Integer.parseInt(sc.nextLine());\n\n        // 解析VLAN资源池\n        List<Integer> vlanPool = parseVlanPool(input);\n\n        // 对VLAN资源池进行升序排序\n        Collections.sort(vlanPool);\n\n        // 从VLAN资源池中移除申请的VLAN\n        vlanPool.remove(destVlan);\n\n        // 格式化VLAN资源池\n        String result = formatVlanPool(vlanPool);\n        System.out.println(result);\n    }\n\n    // 解析VLAN资源池\n    private static List<Integer> parseVlanPool(String input) {\n        List<Integer> vlanPool = new ArrayList<Integer>();\n        // 根据逗号分割VLAN资源池中的VLAN\n        String[] vlanGroup = input.split(\",\");\n        for (String vlanItem : vlanGroup) {\n            if (vlanItem.contains(\"-\")) {\n                // 如果VLAN是连续的，根据连字符分割开始VLAN和结束VLAN\n                String[] vlanItems = vlanItem.split(\"-\");\n                Integer start = Integer.parseInt(vlanItems[0]);\n                Integer end = Integer.parseInt(vlanItems[1]);\n                // 将连续的VLAN添加到VLAN资源池中\n                for (int j = start; j <= end; j++) {\n                    vlanPool.add(j);\n                }\n            } else {\n                // 如果VLAN是单个的，直接添加到VLAN资源池中\n                vlanPool.add(Integer.parseInt(vlanItem));\n            }\n        }\n        return vlanPool;\n    }\n\n    // 格式化VLAN资源池\n    private static String formatVlanPool(List<Integer> vlanPool) {\n        StringBuilder result = new StringBuilder();\n        Integer last = null;\n        for (int index = 0; index < vlanPool.size(); index++) {\n            if (last == null) {\n                // 如果是第一个VLAN，直接添加到结果中\n                result.append(vlanPool.get(index));\n                last = vlanPool.get(index);\n            } else {\n                if (vlanPool.get(index) - last == 1) {\n                    // 如果与上一个VLAN相差1，表示是连续的VLAN\n                    if (result.toString().endsWith(\"-\" + last)) {\n                        // 如果结果中最后一个VLAN已经是连续的VLAN的结束VLAN，替换为当前VLAN\n                        result.replace(result.lastIndexOf(last.toString()), result.length(), vlanPool.get(index).toString());\n                    } else {\n                        // 否则添加连字符和当前VLAN\n                        result.append(\"-\").append(vlanPool.get(index));\n                    }\n                } else {\n                    // 如果与上一个VLAN不连续，直接添加逗号和当前VLAN\n                    result.append(\",\").append(vlanPool.get(index));\n                }\n                last = vlanPool.get(index);\n            }\n        }\n        return result.toString();\n    }\n}",
      "python": "import sys\n\n# 输入VLAN资源池\nvlan_pool_input = input()\n# 输入业务要申请的VLAN\ndest_vlan = int(input())\n\n# 定义存储VLAN的列表\nvlan_pool = []\n\n# 将输入的VLAN资源池按逗号分隔为多个VLAN组\nvlan_group = vlan_pool_input.split(\",\")\n\n# 遍历每个VLAN组\nfor vlan_item in vlan_group:\n    # 如果VLAN组中包含连续的VLAN\n    if \"-\" in vlan_item:\n        # 将连续的VLAN拆分为开始VLAN和结束VLAN\n        vlan_items = vlan_item.split(\"-\")\n        start_vlan = int(vlan_items[0])\n        end_vlan = int(vlan_items[1])\n        # 将连续的VLAN添加到VLAN资源池中\n        for j in range(start_vlan, end_vlan + 1):\n            vlan_pool.append(j)\n        continue\n    # 如果VLAN组中只有一个VLAN\n    vlan_pool.append(int(vlan_item))\n\n# 对VLAN资源池进行升序排序\nvlan_pool.sort()\n\n# 如果申请的VLAN在VLAN资源池中\nif dest_vlan in vlan_pool:\n    # 从VLAN资源池中移除申请的VLAN\n    vlan_pool.remove(dest_vlan)\n\n# 定义存储结果的列表\nresult = []\n# 定义上一个VLAN的变量\nlast_vlan = None\n\n# 遍历VLAN资源池中的每个VLAN\nfor index in range(len(vlan_pool)):\n    # 如果是第一个VLAN\n    if last_vlan is None:\n        result.append(str(vlan_pool[index]))\n        last_vlan = vlan_pool[index]\n        continue\n    # 如果当前VLAN与上一个VLAN连续\n    if vlan_pool[index] - last_vlan == 1:\n        # 如果结果列表中的最后一个元素以\"-上一个VLAN\"结尾\n        if result[-1].endswith(\"-\" + str(last_vlan)):\n            # 将结果列表中的最后一个元素更新为\"-当前VLAN\"\n            result[-1] = result[-1][:result[-1].rindex(str(last_vlan))] + str(vlan_pool[index])\n        else:\n            # 在结果列表中添加\"-当前VLAN\"\n            result.append(\"-\" + str(vlan_pool[index]))\n    else:\n        # 在结果列表中添加\",当前VLAN\"\n        result.append(\",\" + str(vlan_pool[index]))\n    last_vlan = vlan_pool[index]\n\n# 输出结果列表中的VLAN资源池\nprint(\"\".join(result))",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 输入VLAN资源池\nrl.on('line', (vlan_pool_input) => {\n  // 输入业务要申请的VLAN\n  rl.on('line', (dest_vlan_input) => {\n    // 关闭读取接口\n    rl.close();\n\n    const dest_vlan = parseInt(dest_vlan_input);\n\n    // 定义存储VLAN的列表\n    const vlan_pool = [];\n\n    // 将输入的VLAN资源池按逗号分隔为多个VLAN组\n    const vlan_group = vlan_pool_input.split(\",\");\n\n    // 遍历每个VLAN组\n    for (let vlan_item of vlan_group) {\n      // 如果VLAN组中包含连续的VLAN\n      if (vlan_item.includes(\"-\")) {\n        // 将连续的VLAN拆分为开始VLAN和结束VLAN\n        const vlan_items = vlan_item.split(\"-\");\n        const start_vlan = parseInt(vlan_items[0]);\n        const end_vlan = parseInt(vlan_items[1]);\n        // 将连续的VLAN添加到VLAN资源池中\n        for (let j = start_vlan; j <= end_vlan; j++) {\n          vlan_pool.push(j);\n        }\n        continue;\n      }\n      // 如果VLAN组中只有一个VLAN\n      vlan_pool.push(parseInt(vlan_item));\n    }\n\n    // 对VLAN资源池进行升序排序\n    vlan_pool.sort((a, b) => a - b);\n\n    // 如果申请的VLAN在VLAN资源池中\n    if (vlan_pool.includes(dest_vlan)) {\n      // 从VLAN资源池中移除申请的VLAN\n      vlan_pool.splice(vlan_pool.indexOf(dest_vlan), 1);\n    }\n\n    // 定义存储结果的列表\n    const result = [];\n    // 定义上一个VLAN的变量\n    let last_vlan = null;\n\n    // 遍历VLAN资源池中的每个VLAN\n    for (let index = 0; index < vlan_pool.length; index++) {\n      // 如果是第一个VLAN\n      if (last_vlan === null) {\n        result.push(vlan_pool[index].toString());\n        last_vlan = vlan_pool[index];\n        continue;\n      }\n      // 如果当前VLAN与上一个VLAN连续\n      if (vlan_pool[index] - last_vlan === 1) {\n        // 如果结果列表中的最后一个元素以\"-上一个VLAN\"结尾\n        if (result[result.length - 1].endsWith(\"-\" + last_vlan)) {\n          // 将结果列表中的最后一个元素更新为\"-当前VLAN\"\n          result[result.length - 1] = result[result.length - 1].slice(0, result[result.length - 1].lastIndexOf(last_vlan.toString())) + vlan_pool[index].toString();\n        } else {\n          // 在结果列表中添加\"-当前VLAN\"\n          result.push(\"-\" + vlan_pool[index].toString());\n        }\n      } else {\n        // 在结果列表中添加\",当前VLAN\"\n        result.push(\",\" + vlan_pool[index].toString());\n      }\n      last_vlan = vlan_pool[index];\n    }\n\n    // 输出结果列表中的VLAN资源池\n    console.log(result.join(\"\"));\n  });\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing  namespace std;\nint main() {\n    string vlan_pool_input; // 存储输入的VLAN资源池的字符串\n    getline(cin, vlan_pool_input); // 获取输入的VLAN资源池的字符串\n    int dest_vlan; // 存储业务要申请的VLAN\n    cin >> dest_vlan; // 获取业务要申请的VLAN\n\n    vector<int> vlan_pool; // 存储VLAN资源池中的VLAN\n    stringstream ss(vlan_pool_input); // 使用字符串流解析VLAN资源池的字符串\n    string vlan_item; // 存储解析出的每个VLAN\n    while (getline(ss, vlan_item, ',')) { // 按逗号分隔字符串，获取每个VLAN\n        if (vlan_item.find('-') != string::npos) { // 如果VLAN是连续的范围\n            stringstream range_ss(vlan_item); // 使用字符串流解析连续范围的字符串\n            string start_vlan_str, end_vlan_str; // 存储连续范围的起始VLAN和结束VLAN\n            getline(range_ss, start_vlan_str, '-'); // 获取起始VLAN\n            getline(range_ss, end_vlan_str, '-'); // 获取结束VLAN\n            int start_vlan = stoi(start_vlan_str); // 将起始VLAN转换为整数\n            int end_vlan = stoi(end_vlan_str); // 将结束VLAN转换为整数\n            for (int j = start_vlan; j <= end_vlan; j++) { // 将连续范围内的VLAN添加到VLAN资源池中\n                vlan_pool.push_back(j);\n            }\n        } else { // 如果VLAN是单个整数\n            vlan_pool.push_back(stoi(vlan_item)); // 将VLAN转换为整数并添加到VLAN资源池中\n        }\n    }\n\n    sort(vlan_pool.begin(), vlan_pool.end()); // 对VLAN资源池中的VLAN进行排序\n\n    auto it = find(vlan_pool.begin(), vlan_pool.end(), dest_vlan); // 查找业务要申请的VLAN在VLAN资源池中的位置\n    if (it != vlan_pool.end()) { // 如果找到了业务要申请的VLAN\n        vlan_pool.erase(it); // 从VLAN资源池中移除业务要申请的VLAN\n    }\n\n    vector<string> result; // 存储最终输出结果的字符串向量\n    int last_vlan = -1; // 存储上一个输出的VLAN\n\n    for (int i = 0; i < vlan_pool.size(); i++) { // 遍历VLAN资源池中的VLAN\n        if (last_vlan == -1) { // 如果是第一个输出的VLAN\n            result.push_back(to_string(vlan_pool[i])); // 将VLAN转换为字符串并添加到结果向量中\n            last_vlan = vlan_pool[i]; // 更新上一个输出的VLAN\n            continue; // 继续下一次循环\n        }\n        if (vlan_pool[i] - last_vlan == 1) { // 如果当前VLAN与上一个输出的VLAN相差1\n            if (result.back().find('-' + to_string(last_vlan)) != string::npos) { // 如果结果向量的最后一个字符串包含连续范围的结束VLAN\n                result.back() = result.back().substr(0, result.back().rfind(to_string(last_vlan))) + to_string(vlan_pool[i]); // 更新连续范围的结束VLAN\n            } else { // 如果结果向量的最后一个字符串不包含连续范围的结束VLAN\n                result.push_back(\"-\" + to_string(vlan_pool[i])); // 在结果向量中添加连续范围的结束VLAN\n            }\n        } else { // 如果当前VLAN与上一个输出的VLAN不相差1\n            result.push_back(\",\" + to_string(vlan_pool[i])); // 在结果向量中添加当前VLAN\n        }\n        last_vlan = vlan_pool[i]; // 更新上一个输出的VLAN\n    }\n\n    for (int i = 0; i < result.size(); i++) { // 遍历结果向量中的字符串\n        cout << result[i]; // 输出结果向量中的字符串\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义最大VLAN池的大小\n#define MAX_VLAN 4096\n\n// 函数声明\nvoid parseAndFilterVlanPool(char *input, int *vlanPool, int *size, int destVlan);\nvoid formatVlanPool(int *vlanPool, int size, char *result);\n\nint main() {\n    // 存储输入的VLAN资源池和业务申请的VLAN\n    char input[1000];\n    int destVlan;\n\n    fgets(input, sizeof(input), stdin);\n    input[strcspn(input, \"\\n\")] = 0;  // 去除换行符\n\n    scanf(\"%d\", &destVlan);\n\n    // 定义VLAN池数组，用于存储解析后的VLAN，最大为MAX_VLAN\n    int vlanPool[MAX_VLAN];\n    int size = 0;\n\n    // 解析并过滤VLAN资源池（在解析过程中自动移除目标VLAN）\n    parseAndFilterVlanPool(input, vlanPool, &size, destVlan);\n\n    // 定义用于格式化输出的字符串\n    char result[1000] = \"\";\n    \n    // 格式化VLAN资源池\n    formatVlanPool(vlanPool, size, result);\n    \n    // 输出结果\n    printf(\"%s\\n\", result);\n\n    return 0;\n}\n\n \nvoid parseAndFilterVlanPool(char *input, int *vlanPool, int *size, int destVlan) {\n    char *token = strtok(input, \",\");  // 使用逗号分割字符串\n    \n    // 解析每个VLAN或VLAN范围\n    while (token != NULL) {\n        if (strchr(token, '-')) {\n            // 如果包含连字符\"-\"，则为VLAN范围\n            int start, end;\n            sscanf(token, \"%d-%d\", &start, &end);  // 解析范围的起始和结束VLAN\n            \n            // 将范围内的VLAN逐个加入VLAN池，同时移除目标VLAN\n            for (int i = start; i <= end; i++) {\n                if (i == destVlan) {\n                    continue;  // 跳过目标VLAN\n                }\n                // 将VLAN加入有序数组\n                int j;\n                for (j = *size - 1; j >= 0 && vlanPool[j] > i; j--) {\n                    vlanPool[j + 1] = vlanPool[j];\n                }\n                vlanPool[j + 1] = i;\n                (*size)++;\n            }\n        } else {\n            // 如果是单个VLAN，直接处理\n            int vlan = atoi(token);\n            if (vlan == destVlan) {\n                token = strtok(NULL, \",\");\n                continue;  // 跳过目标VLAN\n            }\n            // 将VLAN插入到有序数组中\n            int j;\n            for (j = *size - 1; j >= 0 && vlanPool[j] > vlan; j--) {\n                vlanPool[j + 1] = vlanPool[j];\n            }\n            vlanPool[j + 1] = vlan;\n            (*size)++;\n        }\n        // 获取下一个VLAN或VLAN范围\n        token = strtok(NULL, \",\");\n    }\n}\n\n// 格式化VLAN池为要求的字符串格式\nvoid formatVlanPool(int *vlanPool, int size, char *result) {\n    int last = -1;  // 上一个处理的VLAN\n    int start = -1; // 范围的起始VLAN\n    \n    for (int i = 0; i < size; i++) {\n        if (last == -1) {\n            // 第一个VLAN直接添加\n            start = vlanPool[i];\n            last = vlanPool[i];\n        } else if (vlanPool[i] == last + 1) {\n            // 如果当前VLAN与上一个连续，继续处理\n            last = vlanPool[i];\n        } else {\n            // 如果不连续，检查是否是一个范围\n            if (start == last) {\n                // 如果是单个VLAN，直接添加\n                char temp[20];\n                sprintf(temp, \"%d,\", start);\n                strcat(result, temp);\n            } else {\n                // 否则为范围，添加\"start-end\"格式\n                char temp[40];\n                sprintf(temp, \"%d-%d,\", start, last);\n                strcat(result, temp);\n            }\n            // 处理下一个VLAN范围\n            start = vlanPool[i];\n            last = vlanPool[i];\n        }\n    }\n    \n    // 处理最后一个范围或VLAN\n    if (start == last) {\n        char temp[20];\n        sprintf(temp, \"%d\", start);\n        strcat(result, temp);\n    } else {\n        char temp[40];\n        sprintf(temp, \"%d-%d\", start, last);\n        strcat(result, temp);\n    }\n\n    // 去除最后的逗号\n    if (result[strlen(result) - 1] == ',') {\n        result[strlen(result) - 1] = '\\0';\n    }\n}"
    }
  },
  {
    "id": "4",
    "title": "We Are A Team",
    "examType": "A",
    "score": 100,
    "description": "总共有 n 个人在机房，每个人有一个标号（1<=标号<=n），他们分成了多个团队，需要你根据收到的 m 条消息判定指定的两个人是否在一个团队中，具体的：\n消息构成为 a b c，整数 a、b 分别代表两个人的标号，整数 c 代表指令c == 0 代表 a 和 b 在一个团队内c == 1 代表需要判定 a 和 b 的关系，如果 a 和 b 是一个团队，输出一行’we are a team’,如果不是，输出一行’we are not a team’c 为其他值，或当前行 a 或 b 超出 1~n 的范围，输出‘da pian zi’",
    "inputDesc": "第一行包含两个整数 n，m(1<=n,m<100000),分别表示有 n 个人和 m 条消息随后的 m 行，每行一条消息，消息格式为：a b c(1<=a,b<=n,0<=c<=1)",
    "outputDesc": "",
    "examples": [
      {
        "input": "7\n 2 0\n 5 0\n 3 0\n 2 1\n 3 1\n 5 1\n 5 1",
        "output": "We are a team\nWe are a team\nWe are a team\nWe are not a team",
        "explanation": ""
      },
      {
        "input": "6\n 2 0\n 2 1\n 5 0\n 3 1\n 5 1\n 3 2",
        "output": "we are a team\nwe are not a team\nwe are a team\nda pian zi",
        "explanation": ""
      },
      {
        "input": "7\n 2 0\n 5 0\n 3 0\n 2 1\n 3 1\n 5 1\n 5 1",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "题目要求判断给定的两个人是否在同一个团队中。、\n输入包含 n 个人和 m 条消息。\n每条消息包含 a、b 和 c，其中 a 和 b 是两个人的标号，c 是指令。\nc == 0 表示 a 和 b 在同一个团队c == 1 表示需要判断 a 和 b 是否在同一个团队。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 读取输入，获取人数和消息数量\n        Scanner sc = new Scanner(System.in);\n        int numPeople = sc.nextInt();\n        int numMessages = sc.nextInt();\n\n        // 读取消息并存储到二维数组中\n        int[][] messages = new int[numMessages][3];\n        for (int i = 0; i < numMessages; i++) {\n            messages[i][0] = sc.nextInt();\n            messages[i][1] = sc.nextInt();\n            messages[i][2] = sc.nextInt();\n        }\n\n        // 检查输入范围，如果超出范围则输出 \"Null\"\n        if (numPeople < 1 || numPeople >= 100000 || numMessages < 1 || numMessages >= 100000) {\n            System.out.println(\"Null\");\n            return;\n        }\n\n        // 初始化数组，用于存储每个人的团队信息\n        int[] parent = new int[numPeople + 1];\n        for (int i = 0; i < numPeople + 1; i++) parent[i] = i;\n\n        // 遍历消息，根据指令处理团队关系\n        for (int[] message : messages) {\n            int personA = message[0], personB = message[1], command = message[2];\n\n            // 检查输入范围，如果超出范围则输出 \"da pian zi\"\n            if (personA < 1 || personA > numPeople || personB < 1 || personB > numPeople) {\n                System.out.println(\"da pian zi\");\n                continue;\n            }\n\n            // 如果指令为 0，则合并 personA 和 personB 所在的团队\n            if (command == 0) {\n                int rootA = find(personA, parent);\n                int rootB = find(personB, parent);\n\n                if (rootA != rootB) {\n                    parent[rootB] = rootA;\n                }\n            }\n            // 如果指令为 1，则判断 personA 和 personB 是否在同一个团队\n            else if (command == 1) {\n                System.out.println(find(personA, parent) == find(personB, parent) ? \"We are a team\" : \"We are not a team\");\n            }\n            // 如果指令为其他值，则输出 \"da pian zi\"\n            else {\n                System.out.println(\"da pian zi\");\n            }\n        }\n    }\n\n    // 查找节点，用于判断两个人是否在同一个团队\n    public static int find(int x, int[] parent) {\n        if (parent[x] != x) {\n            return parent[x] = find(parent[x], parent);\n        }\n        return x;\n    }\n}",
      "python": "def find(x, parent):\n    # 查找节点，用于判断两个人是否在同一个团队\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\n\n# 读取输入，获取人数和消息数量\nnum_people, num_messages = map(int, input().split())\n\n# 读取消息并存储到二维数组中\nmessages = [list(map(int, input().split())) for _ in range(num_messages)]\n\n# 检查输入范围，如果超出范围则输出 \"Null\"\nif num_people < 1 or num_people >= 100000 or num_messages < 1 or num_messages >= 100000:\n    print(\"Null\")\nelse:\n    # 初始化数组，用于存储每个人的团队信息\n    parent = list(range(num_people + 1))\n\n    # 遍历消息，根据指令处理团队关系\n    for message in messages:\n        person_a, person_b, command = message\n\n        # 检查输入范围，如果超出范围则输出 \"da pian zi\"\n        if person_a < 1 or person_a > num_people or person_b < 1 or person_b > num_people:\n            print(\"da pian zi\")\n            continue\n\n        # 如果指令为 0，则合并 person_a 和 person_b 所在的团队\n        if command == 0:\n            root_a = find(person_a, parent)\n            root_b = find(person_b, parent)\n\n            if root_a != root_b:\n                parent[root_b] = root_a\n        # 如果指令为 1，则判断 person_a 和 person_b 是否在同一个团队\n        elif command == 1:\n            print(\"We are a team\" if find(person_a, parent) == find(person_b, parent) else \"We are not a team\")\n        # 如果指令为其他值，则输出 \"da pian zi\"\n        else:\n            print(\"da pian zi\")",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 查找节点，用于判断两个人是否在同一个团队\nfunction find(x, parent) {\n  if (parent[x] !== x) {\n    parent[x] = find(parent[x], parent);\n  }\n  return parent[x];\n}\n\nlet inputLines = [];\nrl.on('line', (input) => {\n  inputLines.push(input);\n}).on('close', () => {\n  const [numPeople, numMessages] = inputLines[0].split(' ').map(Number);\n  const messages = inputLines.slice(1).map(line => line.split(' ').map(Number));\n\n  // 检查输入范围，如果超出范围则输出 \"Null\"\n  if (numPeople < 1 || numPeople >= 100000 || numMessages < 1 || numMessages >= 100000) {\n    console.log('Null');\n    return;\n  }\n\n  // 初始化数组，用于存储每个人的团队信息\n  const parent = Array.from({ length: numPeople + 1 }, (_, i) => i);\n\n  // 遍历消息，根据指令处理团队关系\n  for (const message of messages) {\n    const [personA, personB, command] = message;\n\n    // 检查输入范围，如果超出范围则输出 \"da pian zi\"\n    if (personA < 1 || personA > numPeople || personB < 1 || personB > numPeople) {\n      console.log('da pian zi');\n      continue;\n    }\n\n    // 如果指令为 0，则合并 personA 和 personB 所在的团队\n    if (command === 0) {\n      const rootA = find(personA, parent);\n      const rootB = find(personB, parent);\n\n      if (rootA !== rootB) {\n        parent[rootB] = rootA;\n      }\n    }\n    // 如果指令为 1，则判断 personA 和 personB 是否在同一个团队\n    else if (command === 1) {\n      console.log(find(personA, parent) === find(personB, parent) ? 'We are a team' : 'We are not a team');\n    }\n    // 如果指令为其他值，则输出 \"da pian zi\"\n    else {\n      console.log('da pian zi');\n    }\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n\n// 查找节点，用于判断两个人是否在同一个团队\nint find(int x, std::vector<int> &parent) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x], parent);\n    }\n    return parent[x];\n}\n\nint main() {\n    // 读取输入，获取人数和消息数量\n    int numPeople, numMessages;\n    std::cin >> numPeople >> numMessages;\n\n    // 读取消息并存储到二维数组中\n    std::vector<std::vector<int>> messages(numMessages, std::vector<int>(3));\n    for (int i = 0; i < numMessages; i++) {\n        std::cin >> messages[i][0] >> messages[i][1] >> messages[i][2];\n    }\n\n    // 检查输入范围，如果超出范围则输出 \"Null\"\n    if (numPeople < 1 || numPeople >= 100000 || numMessages < 1 || numMessages >= 100000) {\n        std::cout << \"Null\" << std::endl;\n        return 0;\n    }\n\n    // 初始化数组，用于存储每个人的团队信息\n    std::vector<int> parent(numPeople + 1);\n    for (int i = 0; i < numPeople + 1; i++) parent[i] = i;\n\n    // 遍历消息，根据指令处理团队关系\n    for (const auto &message : messages) {\n        int personA = message[0], personB = message[1], command = message[2];\n\n        // 检查输入范围，如果超出范围则输出 \"da pian zi\"\n        if (personA < 1 || personA > numPeople || personB < 1 || personB > numPeople) {\n            std::cout << \"da pian zi\" << std::endl;\n            continue;\n        }\n\n        // 如果指令为 0，则合并 personA 和 personB 所在的团队\n        if (command == 0) {\n            int rootA = find(personA, parent);\n            int rootB = find(personB, parent);\n\n            if (rootA != rootB) {\n                parent[rootB] = rootA;\n            }\n        }\n        // 如果指令为 1，则判断 personA 和 personB 是否在同一个团队\n        else if (command == 1) {\n            std::cout << (find(personA, parent) == find(personB, parent) ? \"We are a team\" : \"We are not a team\") << std::endl;\n        }\n        // 如果指令为其他值，则输出 \"da pian zi\"\n        else {\n            std::cout << \"da pian zi\" << std::endl;\n        }\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n\n// 查找某个节点的根节点（使用路径压缩来优化查找）\nint find(int x, int parent[]) {\n    if (parent[x] != x) {\n        // 递归查找父节点并压缩路径\n        parent[x] = find(parent[x], parent);\n    }\n    return parent[x];\n}\n\nint main() {\n    int n, m;\n\n    // 输入 n 和 m，表示人数和消息数\n    if (scanf(\"%d %d\", &n, &m) != 2) {\n        // 输入读取错误\n        printf(\"Null\\n\");\n        return 0;\n    }\n\n    // 检查人数和消息数的合法性\n    if (n < 1 || n >= 100000 || m < 1 || m >= 100000) {\n        // 如果超出规定范围，输出 \"Null\"\n        printf(\"Null\\n\");\n        return 0;\n    }\n\n    // 初始化并查集数组，每个人初始为自己的团队\n    int parent[n + 1];\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i; // 初始时，每个人的父节点是自己\n    }\n\n    // 处理每条消息\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n\n        // 读取消息 a, b, c\n        if (scanf(\"%d %d %d\", &a, &b, &c) != 3) {\n            // 如果输入格式有误，忽略本条消息\n            continue;\n        }\n\n        // 检查 a 和 b 是否在合法范围内\n        if (a < 1 || a > n || b < 1 || b > n) {\n            printf(\"da pian zi\\n\"); // 输入不合法，输出 \"da pian zi\"\n            continue;\n        }\n\n        // 处理指令\n        if (c == 0) {\n            // 指令为 0，表示将 a 和 b 合并到同一个团队中\n            int rootA = find(a, parent); // 查找 a 的根节点\n            int rootB = find(b, parent); // 查找 b 的根节点\n\n            // 如果 a 和 b 不在同一个团队，合并它们\n            if (rootA != rootB) {\n                parent[rootB] = rootA; // 将 b 的根节点指向 a 的根节点\n            }\n        } else if (c == 1) {\n            // 指令为 1，表示判断 a 和 b 是否在同一个团队\n            if (find(a, parent) == find(b, parent)) {\n                printf(\"We are a team\\n\"); // a 和 b 在同一个团队\n            } else {\n                printf(\"We are not a team\\n\"); // a 和 b 不在同一个团队\n            }\n        } else {\n            // 其他不合法的指令\n            printf(\"da pian zi\\n\");\n        }\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "5",
    "title": "不等式是否满足约束并输出最大差",
    "examType": "A",
    "score": 100,
    "description": "给定一组不等式，判断是否成立并输出不等式的最大差(输出浮点数的整数部分)\n要求:\n不等式系数为 double类型，是一个二维数组 不等式的变量为 int类型，是一维数组; 不等式的目标值为 double类型，是一维数组 不等式约束为字符串数组，只能是:“>”,“>=”,“<”,“<=”,“=”，\n不等式系数为 double类型，是一个二维数组\n不等式的变量为 int类型，是一维数组;\n不等式的目标值为 double类型，是一维数组\n不等式约束为字符串数组，只能是:“>”,“>=”,“<”,“<=”,“=”，\n例如，不等式组:\n123\n最大差 = max{(a11x1+a12x2+a13x3+a14x4+a15x5-b1),(a21x1+a22x2+a23x3+a24x4+ a25x5-b2),(a31x1+a32x2+a33x3+a34x4+a35x5-b3)},\n类型为整数(输出浮点数的整数部分)",
    "inputDesc": "a11,a12,a13,a14,a15,a21,a22,a23,a24,a25, a31,a32,a33,a34,a35,x1,x2,x3,x4,x5,b1,b2,b3,<=,<=,<=\n不等式组系数(double类型): a11,a12,a13,a14,a15 a21,a22,a23,a24,a25 a31,a32,a33,a34,a35 不等式变量(int类型):x1,x2,x3,x4,x5 不等式目标值(double类型):b1,b2,b3 不等式约束(字符串类型):<=,<=,<=\n不等式组系数(double类型):\na11,a12,a13,a14,a15\na21,a22,a23,a24,a25\na31,a32,a33,a34,a35\n不等式变量(int类型):x1,x2,x3,x4,x5\n不等式目标值(double类型):b1,b2,b3\n不等式约束(字符串类型):<=,<=,<=",
    "outputDesc": "true或者 false，最大差",
    "examples": [
      {
        "input": ".3,3,5.6,7.6;11,3,8.6,25,1;0.3,9,5.3,66,7.8;1,3,2,7,5;340,670,80.6;<=,<=,<=",
        "output": "false 458",
        "explanation": ""
      },
      {
        "input": ".36,3,6,7.1,6;1,30,8.6,2.5,21;0.3,69,5.3,6.6,7.8;1,13,2,17,5;340,67,300.6;<=,>=,<=",
        "output": "false 758",
        "explanation": ""
      },
      {
        "input": ".3,3,5.6,7.6;11,3,8.6,25,1;0.3,9,5.3,66,7.8;1,3,2,7,5;340,670,80.6;<=,<=,<=",
        "output": "false 458",
        "explanation": ""
      }
    ],
    "solution": "题目要求你根据一组不等式判断其是否成立，并计算这些不等式中左边表达式和目标值之间的最大差值。具体来说，每个不等式都包含如下内容：\n不等式系数：一个二维数组，表示每个变量的系数。不等式的变量：一个一维数组，表示每个变量的值。不等式的目标值：一个一维数组，表示每个不等式右边的目标值。不等式约束：一个字符串数组，表示不等式的关系，只能是 “>”, “>=”, “<”, “<=”, “=” 其中之一。",
    "codes": {
      "java": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// 计算两个一维数组的点积\ndouble dotProduct(vector<double>& a, vector<double>& b) {\n    double result = 0.0;\n    for (int i = 0; i < a.size(); i++) {\n        result += a[i] * b[i];\n    }\n    return result;\n}\n\n// 根据不等式约束判断一个数是否大于、大于等于、小于、小于等于、等于 0\nbool satisfiesConstraint(double val, string constraint) {\n    if (constraint == \">\") {\n        return val > 0;\n    }\n    else if (constraint == \">=\") {\n        return val >= 0;\n    }\n    else if (constraint == \"<\") {\n        return val < 0;\n    }\n    else if (constraint == \"<=\") {\n        return val <= 0;\n    }\n    else if (constraint == \"=\") {\n        return val == 0;\n    }\n    else {\n        return false;\n    }\n}\n\nint main() {\n    string line;\n    while (getline(cin, line)) {\n        vector<vector<double>> matrix;\n        vector<double> x;\n        vector<double> b;\n        vector<string> y;\n        vector<string> arr;\n\n        stringstream ss(line);\n        string s;\n        while (getline(ss, s, ';')) {\n            arr.push_back(s);\n        }\n\n        // 将不等式系数转换为 Double 类型的二维数组\n        for (int i = 0; i < 3; i++) {\n            vector<double> row;\n            stringstream ss2(arr[i]);\n            string s2;\n            while (getline(ss2, s2, ',')) {\n                row.push_back(stod(s2));\n            }\n            matrix.push_back(row);\n        }\n\n        // 将不等式的变量转换为 Double 类型的一维数组\n        stringstream ss3(arr[3]);\n        string s3;\n        while (getline(ss3, s3, ',')) {\n            x.push_back(stod(s3));\n        }\n\n        // 将不等式的目标值转换为 Double 类型的一维数组\n        stringstream ss4(arr[4]);\n        string s4;\n        while (getline(ss4, s4, ',')) {\n            b.push_back(stod(s4));\n        }\n\n        // 将不等式约束转换为字符串数组\n        stringstream ss5(arr[5]);\n        string s5;\n        while (getline(ss5, s5, ',')) {\n            y.push_back(s5);\n        }\n\n        // 计算每个不等式的差值\n        vector<double> diffs;\n        for (int i = 0; i < 3; i++) {\n            diffs.push_back(dotProduct(matrix[i], x) - b[i]);\n        }\n\n        // 判断所有不等式是否都成立\n        bool flag = satisfiesConstraint(diffs[0], y[0]) && satisfiesConstraint(diffs[1], y[1]) && satisfiesConstraint(diffs[2], y[2]);\n\n        // 计算不等式的最大差值，并输出其整数部分\n        int maxDiff = static_cast<int>(max({ abs(diffs[0]), abs(diffs[1]), abs(diffs[2]) }));\n       string  t = (flag == 0 ? \"false\" : \"true\");\n        cout << t << \" \" << maxDiff << endl;\n    }\n    return 0;\n}",
      "python": "import sys\n\n# 计算两个一维数组的点积\ndef dotProduct(a, b):\n    result = 0.0\n    for i in range(len(a)):\n        result += a[i] * b[i]\n    return result\n\n# 根据不等式约束判断一个数是否大于、大于等于、小于、小于等于、等于 0\ndef satisfiesConstraint(val, constraint):\n    if constraint == '>':\n        return val > 0\n    elif constraint == '>=':\n        return val >= 0\n    elif constraint == '<':\n        return val < 0\n    elif constraint == '<=':\n        return val <= 0\n    elif constraint == '=':\n        return val == 0\n    else:\n        return False\n\n# 读入不等式\nfor line in sys.stdin:\n    arr = [s.split(',') for s in line.strip().split(';')]\n\n    # 将不等式系数转换为 Double 类型的二维数组\n    matrix = [[float(num) for num in row] for row in arr[:3]]\n\n    # 将不等式的变量转换为 Double 类型的一维数组\n    x = [float(num) for num in arr[3]]\n\n    # 将不等式的目标值转换为 Double 类型的一维数组\n    b = [float(num) for num in arr[4]]\n\n    # 将不等式约束转换为字符串数组\n    y = arr[5]\n\n    # 计算每个不等式的差值\n    diffs = [dotProduct(matrix[i], x) - b[i] for i in range(3)]\n\n    # 判断所有不等式是否都成立\n    flag = satisfiesConstraint(diffs[0], y[0]) and satisfiesConstraint(diffs[1], y[1]) and satisfiesConstraint(diffs[2], y[2])\n\n    # 计算不等式的最大差值，并输出其整数部分\n    maxDiff = int(max([abs(num) for num in diffs]))\n    print(str(flag) + ' ' + str(maxDiff))",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (line) => {\n  // 读入不等式\n  const arr = line.split(';').map(s => s.split(','));\n\n  // 将不等式系数转换为 Double 类型的二维数组\n  const matrix = new Array(3).fill(0).map(() => new Array(5));\n  for (let i = 0; i < 3; i++) {\n    matrix[i] = arr[i].map(parseFloat);\n  }\n\n  // 将不等式的变量转换为 Double 类型的一维数组\n  const x = arr[3].map(parseFloat);\n\n  // 将不等式的目标值转换为 Double 类型的一维数组\n  const b = arr[4].map(parseFloat);\n\n  // 将不等式约束转换为字符串数组\n  const y = arr[5];\n\n  // 计算每个不等式的差值\n  const diffs = new Array(3).fill(0);\n  for (let i = 0; i < 3; i++) {\n    diffs[i] = dotProduct(matrix[i], x) - b[i];\n  }\n\n  // 判断所有不等式是否都成立\n  const flag = compareWithZero(diffs[0], y[0])\n    && compareWithZero(diffs[1], y[1])\n    && compareWithZero(diffs[2], y[2]);\n\n  // 计算不等式的最大差值，并输出其整数部分\n  const maxDiff = Math.max(...diffs.map(Math.abs));\n  console.log(flag + ' ' + Math.floor(maxDiff));\n});\n\n// 计算两个一维数组的点积\nfunction dotProduct(a, b) {\n  let result = 0.0;\n  for (let i = 0; i < a.length; i++) {\n    result += a[i] * b[i];\n  }\n  return result;\n}\n\n// 根据不等式约束判断一个数是否大于、大于等于、小于、小于等于、等于 0\nfunction compareWithZero(val, constraint) {\n  switch (constraint) {\n    case '>':\n      return val > 0;\n    case '>=':\n      return val >= 0;\n    case '<':\n      return val < 0;\n    case '<=':\n      return val <= 0;\n    case '=':\n      return val === 0;\n    default:\n      return false;\n  }\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// 计算两个一维数组的点积\ndouble dotProduct(vector<double>& a, vector<double>& b) {\n    double result = 0.0;\n    for (int i = 0; i < a.size(); i++) {\n        result += a[i] * b[i];\n    }\n    return result;\n}\n\n// 根据不等式约束判断一个数是否大于、大于等于、小于、小于等于、等于 0\nbool satisfiesConstraint(double val, string constraint) {\n    if (constraint == \">\") {\n        return val > 0;\n    }\n    else if (constraint == \">=\") {\n        return val >= 0;\n    }\n    else if (constraint == \"<\") {\n        return val < 0;\n    }\n    else if (constraint == \"<=\") {\n        return val <= 0;\n    }\n    else if (constraint == \"=\") {\n        return val == 0;\n    }\n    else {\n        return false;\n    }\n}\n\nint main() {\n    string line;\n    while (getline(cin, line)) {\n        vector<vector<double>> matrix;\n        vector<double> x;\n        vector<double> b;\n        vector<string> y;\n        vector<string> arr;\n\n        stringstream ss(line);\n        string s;\n        while (getline(ss, s, ';')) {\n            arr.push_back(s);\n        }\n\n        // 将不等式系数转换为 Double 类型的二维数组\n        for (int i = 0; i < 3; i++) {\n            vector<double> row;\n            stringstream ss2(arr[i]);\n            string s2;\n            while (getline(ss2, s2, ',')) {\n                row.push_back(stod(s2));\n            }\n            matrix.push_back(row);\n        }\n\n        // 将不等式的变量转换为 Double 类型的一维数组\n        stringstream ss3(arr[3]);\n        string s3;\n        while (getline(ss3, s3, ',')) {\n            x.push_back(stod(s3));\n        }\n\n        // 将不等式的目标值转换为 Double 类型的一维数组\n        stringstream ss4(arr[4]);\n        string s4;\n        while (getline(ss4, s4, ',')) {\n            b.push_back(stod(s4));\n        }\n\n        // 将不等式约束转换为字符串数组\n        stringstream ss5(arr[5]);\n        string s5;\n        while (getline(ss5, s5, ',')) {\n            y.push_back(s5);\n        }\n\n        // 计算每个不等式的差值\n        vector<double> diffs;\n        for (int i = 0; i < 3; i++) {\n            diffs.push_back(dotProduct(matrix[i], x) - b[i]);\n        }\n\n        // 判断所有不等式是否都成立\n        bool flag = satisfiesConstraint(diffs[0], y[0]) && satisfiesConstraint(diffs[1], y[1]) && satisfiesConstraint(diffs[2], y[2]);\n\n        // 计算不等式的最大差值，并输出其整数部分\n        int maxDiff = static_cast<int>(max({ abs(diffs[0]), abs(diffs[1]), abs(diffs[2]) }));\n       string  t = (flag == 0 ? \"false\" : \"true\");\n        cout << t << \" \" << maxDiff << endl;\n    }\n    return 0;\n}",
      "c": ""
    }
  },
  {
    "id": "6",
    "title": "优秀学员统计",
    "examType": "A",
    "score": 100,
    "description": "公司某部门软件教导团正在组织新员工每日打卡学习活动，他们开展这项学习活动已经一个月了，所以想统计下这个月优秀的打卡员工。每个员工会对应一个id，每天的打卡记录记录当天打卡员工的id集合，一共30天。\n请你实现代码帮助统计出打卡次数top5的员工。加入打卡次数相同，将较早参与打卡的员工排在前面，如果开始参与打卡的时间还是一样，将id较小的员工排在前面。\n注：不考虑并列的情况，按规则返回前5名员工的id即可，如果当月打卡的员工少于5个，按规则排序返回所有有打卡记录的员工id。",
    "inputDesc": "第一行输入为新员工数量N，表示新员工编号id为0到N-1，N的范围为[1,100]\n第二行输入为30个整数，表示每天打卡的员工数量，每天至少有1名员工打卡。\n之后30行为每天打卡的员工id集合，id不会重复。",
    "outputDesc": "按顺序输出打卡top5员工的id，用空格隔开。",
    "examples": [
      {
        "input": "4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2\n 1 7 10\n 1 6 10\n 10\n 10",
        "output": "0 1 7 6",
        "explanation": "员工编号范围为0~10，id为10的员工连续打卡30天，排第一，id为0,1,6,7的员工打卡都是两天，id为0,1,7的员工在第一天就打卡，比id为6的员工早，排在前面，0,1,7按id升序排列，所以输出[10,0,1,7,6]"
      },
      {
        "input": "6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5\n 1 2 3 4 5",
        "output": "1 2 3 4",
        "explanation": "员工编号范围为0-6，id为0，1，2，3，4，5的员工打卡次数相同，最早开始打卡的时间也一样，所以按id升序返回前5个id"
      },
      {
        "input": "1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2\n 1\n 1",
        "output": "0",
        "explanation": "只有两名员工参与打卡，按规则排序输出两名员工的id"
      }
    ],
    "solution": "典型的排序类问题。先按照打卡次数，再按照打卡时间先后进行排序即可。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n \npublic class Main {\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n \n    int monthCount = scanner.nextInt(); // 打卡月份数\n \n    int[] dayCount = new int[30]; // 每个月的天数\n    for (int i = 0; i < 30; i++) {\n      dayCount[i] = scanner.nextInt();\n    }\n \n    int[][] dayIds = new int[30][]; // 每天打卡员工的id\n    for (int i = 0; i < 30; i++) {\n      int m = dayCount[i];\n      dayIds[i] = new int[m];\n      for (int j = 0; j < m; j++) {\n        dayIds[i][j] = scanner.nextInt();\n      }\n    }\n \n    System.out.println(getResult(dayIds));\n  }\n \n  public static String getResult(int[][] dayIds) {\n    HashMap<Integer, Integer[]> employees = new HashMap<>(); // 员工id和打卡信息的映射\n \n    for (int i = 0; i < dayIds.length; i++) {\n      int[] ids = dayIds[i];\n \n      for (int id : ids) {\n        if (employees.containsKey(id)) {\n          employees.get(id)[0]++; // 打卡次数+1\n        } else {\n          // 加入数组含义是：该id员工的 [打卡次数，第一天打卡日期]\n          employees.put(id, new Integer[] {1, i});\n        }\n      }\n    }\n \n    ArrayList<Integer[]> list = new ArrayList<>(); // 存储有打卡记录的员工信息\n    for (Integer id : employees.keySet()) {\n      Integer[] employee = employees.get(id);\n      int count = employee[0]; // 打卡次数\n      int firstDay = employee[1]; // 第一天打卡日期\n      list.add(new Integer[] {id, count, firstDay});\n    }\n \n    // 按规则排序\n    list.sort(\n        (a, b) ->\n            a[1].equals(b[1]) ? (a[2].equals(b[2]) ? a[0] - b[0] : a[2] - b[2]) : b[1] - a[1]);\n \n    StringJoiner sj = new StringJoiner(\" \");\n    // 不考虑并列的情况，按规则返回前5名员工的id即可，如果当月打卡的员工少于5个，按规则排序返回所有有打卡记录的员工id\n    for (int i = 0; i < Math.min(5, list.size()); i++) {\n      sj.add(list.get(i)[0] + \"\");\n    }\n    return sj.toString();\n  }\n}",
      "python": "import functools\nimport sys\nfrom collections import Counter, defaultdict\nimport copy\nfrom itertools import permutations\nimport re\nimport math\nimport sys\n\n# 比较函数，按照打卡次数、首次打卡时间、员工ID的顺序进行排序\ndef compare(a, b):\n    if (a[1] == b[1]): # 如果打卡次数相同\n        if (a[2] == b[2]): # 如果首次打卡时间相同\n            return a[0] - b[0] # 按照员工ID升序排列\n        else:\n            return a[2] - b[2] # 按照首次打卡时间升序排列\n    else:\n        return b[1] - a[1] # 按照打卡次数降序排列\n\n# 新员工数量\nnum_new_employees = int(input())\n# 每天打卡的员工数量\nemployee_count_per_day = [int(x) for x in input().split(\" \")]\n# 打卡记录\nemployee_records = []\nfor i in range(30):\n    employee_records.append([int(x) for x in input().split(\" \")])\n\n# key为员工ID， value为其打卡的记录信息：[打卡次数，首次打卡index]\nemployee_info = {}\nfor i in range(30):\n    for j in employee_records[i]:\n        if(j in employee_info): # 如果员工已经在字典中\n            employee_info[j][0] += 1 # 打卡次数加1\n        else:\n            employee_info[j] = [1, i] # 否则，将员工添加到字典中，并记录打卡次数和首次打卡时间\n\n# 将map信息转到list中，以便后续排序\nemployee_list = []\nfor key in employee_info:\n    employee_list.append([key, employee_info[key][0], employee_info[key][1]]);\n\n# 按照打卡次数、首次打卡时间、员工ID的顺序进行排序\nemployee_list = sorted(employee_list, key=functools.cmp_to_key(compare));\n\nres = []\nfor i in range(5):\n    res.append(str(employee_list[i][0]))\n\n# 输出\nprint(\" \".join(res))",
      "javascript": "// 引入 Node.js 内置的 readline 模块\nconst readline = require(\"readline\");\n\n// 创建 readline.Interface 实例\nconst rl = readline.createInterface({\n  input: process.stdin, // 从标准输入流中读取数据\n  output: process.stdout, // 向标准输出流中输出数据\n});\n\n// 用于存储输入的所有行\nconst inputLines = [];\n\n// 当读取到新的一行时，将其添加到 inputLines 数组中\nrl.on(\"line\", (line) => {\n  inputLines.push(line);\n\n  // 当输入的行数达到 32 时，进行处理并输出结果\n  if (inputLines.length === 32) {\n    // 获取员工总数\n    const employeeCount = Number(inputLines[0]);\n\n    // 获取每个员工出现的天数\n    const dayCount = inputLines[1].split(\" \").map(Number);\n\n    // 获取每个员工在每天出现的次数和日期\n    const dayIds = inputLines.slice(2).map((line) => line.split(\" \").map(Number));\n\n    // 输出出现次数最多的前五个员工的 ID\n    console.log(getTopEmployeeIds(dayIds));\n\n    // 清空 inputLines 数组，以便下一次读取数据\n    inputLines.length = 0;\n  }\n});\n\n// 获取出现次数最多的前五个员工的 ID\nfunction getTopEmployeeIds(dayIds) {\n  // 用一个对象来存储每个员工的出现次数和首次出现的日期\n  const employees = {};\n\n  // 遍历 dayIds 数组，统计每个员工的出现次数和首次出现的日期\n  for (let i = 0; i < dayIds.length; i++) {\n    const ids = dayIds[i];\n    for (let id of ids) {\n      if (employees[id]) {\n        employees[id].count++;\n      } else {\n        employees[id] = {\n          count: 1,\n          firstDay: i,\n        };\n      }\n    }\n  }\n\n  // 将 employees 对象转化为数组，并按照出现次数、首次出现日期、ID 的顺序排序\n  let arr = [];\n  for (let id in employees) {\n    const { count, firstDay } = employees[id];\n    arr.push([id, count, firstDay]);\n  }\n  arr.sort((a, b) =>\n    b[1] !== a[1] ? b[1] - a[1] : b[2] !== a[2] ? a[2] - b[2] : a[0] - b[0]\n  );\n\n  // 取出前五个员工的 ID，并以空格分隔返回\n  return arr\n    .slice(0, 5)\n    .map(([id]) => id)\n    .join(\" \");\n}",
      "cpp": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\n\n// 根据规则排序\nbool compare(vector<int> a, vector<int> b) {\n    if (a[1] == b[1]) { // 如果打卡次数相同\n        if (a[2] == b[2]) { // 如果首次打卡时间相同\n            return b[0] > a[0]; // 返回ID大的员工\n        } else {\n            return b[2] > a[2]; // 返回首次打卡时间晚的员工\n        }\n    } else {\n        return a[1] > b[1]; // 返回打卡次数多的员工\n    }\n}\n \nint main()\n{\n    // 输入处理\n    int n; // 新员工数量\n    cin >> n;\n \n    vector<int> employeeCount; // 每天打卡的员工数量\n    for (int i = 0; i < 30; i++) {\n        int count;\n        cin >> count;\n        employeeCount.push_back(count);\n    }\n \n    vector<vector<int>> employeeIds(30, vector<int>()); // 打卡记录\n    for (int i = 0; i < 30; i++) {\n        for (int j = 0; j < employeeCount[i]; j++) {\n            int id;\n            cin >> id;\n            employeeIds[i].push_back(id);\n        }\n    }\n \n    map<int, vector<int>> employeeInfo; // key为员工ID， value为其打卡的记录信息：[打卡次数，首次打卡index]\n    for (int i = 0; i < employeeIds.size(); i++) {\n        for (int id : employeeIds[i]) {\n            if (employeeInfo.count(id)) { // 如果员工已经在map中\n                employeeInfo[id][0]++; // 打卡次数加1\n            } else {\n                vector<int> info;\n                info.push_back(1); // 打卡次数为1\n                info.push_back(i); // 首次打卡时间为i\n                employeeInfo[id] = info; // 将记录添加到map中\n            }\n        }\n    }\n \n    // 将map信息转到list中，以便后续排序\n    vector<vector<int>> employeeList;\n    for (auto item : employeeInfo) {\n        vector<int> temp;\n        temp.push_back(item.first); // 员工ID\n        temp.push_back(item.second[0]); // 打卡次数\n        temp.push_back(item.second[1]); // 首次打卡时间\n        employeeList.push_back(temp);\n    }\n \n    sort(employeeList.begin(), employeeList.end(), compare); // 排序\n    \n    // 输出前5名员工ID\n    for (int i = 0; i < 5; i++) {\n        cout << employeeList[i][0];\n        if (i != 4) {\n            cout << \" \";\n        }\n    }\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_EMPLOYEES 100\n#define DAYS 30\n\n// 结构体存储员工信息\ntypedef struct {\n    int id;\n    int count;      // 打卡次数\n    int first_day;  // 首次打卡的天数\n} EmployeeInfo;\n\n// 根据规则排序的比较函数\nint compare(const void *a, const void *b) {\n    EmployeeInfo *empA = (EmployeeInfo *)a;\n    EmployeeInfo *empB = (EmployeeInfo *)b;\n\n    if (empA->count == empB->count) {\n        if (empA->first_day == empB->first_day) {\n            return empA->id - empB->id; // ID小的员工排前\n        } else {\n            return empA->first_day - empB->first_day; // 首次打卡早的排前\n        }\n    } else {\n        return empB->count - empA->count; // 打卡次数多的排前\n    }\n}\n\nint main() {\n    int n;  // 新员工数量\n    scanf(\"%d\", &n);\n\n    int employeeCount[DAYS];  // 每天打卡的员工数量\n    for (int i = 0; i < DAYS; i++) {\n        scanf(\"%d\", &employeeCount[i]);\n    }\n\n    int employeeIds[DAYS][MAX_EMPLOYEES];  // 每天打卡的员工ID\n    for (int i = 0; i < DAYS; i++) {\n        for (int j = 0; j < employeeCount[i]; j++) {\n            scanf(\"%d\", &employeeIds[i][j]);\n        }\n    }\n\n    EmployeeInfo employees[MAX_EMPLOYEES];  // 存储每个员工的信息\n    int isTracked[MAX_EMPLOYEES] = {0};  // 标记是否已记录该员工\n    int employeeIndex = 0;\n\n    // 统计打卡信息\n    for (int i = 0; i < DAYS; i++) {\n        for (int j = 0; j < employeeCount[i]; j++) {\n            int id = employeeIds[i][j];\n            if (isTracked[id]) {\n                // 如果员工已经记录过，增加打卡次数\n                for (int k = 0; k < employeeIndex; k++) {\n                    if (employees[k].id == id) {\n                        employees[k].count++;\n                        break;\n                    }\n                }\n            } else {\n                // 如果员工没有记录过，新增记录\n                employees[employeeIndex].id = id;\n                employees[employeeIndex].count = 1;\n                employees[employeeIndex].first_day = i;\n                isTracked[id] = 1;\n                employeeIndex++;\n            }\n        }\n    }\n\n    // 按照规则排序\n    qsort(employees, employeeIndex, sizeof(EmployeeInfo), compare);\n\n    // 输出前5名员工的ID\n    for (int i = 0; i < employeeIndex && i < 5; i++) {\n        printf(\"%d\", employees[i].id);\n        if (i != 4 && i != employeeIndex - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
    }
  },
  {
    "id": "7",
    "title": "光伏场地建设规划",
    "examType": "A",
    "score": 100,
    "description": "祖国西北部有一片大片荒地，其中零星的分布着一些湖泊，保护区，矿区; 整体上常年光照良好，但是也有一些地区光照不太好。\n某电力公司希望在这里建设多个光伏电站，生产清洁能源对每平方公里的土地进行了发电评估， 其中不能建设的区域发电量为0kw，可以发电的区域根据光照，地形等给出了每平方公里年发电量x千瓦。 我们希望能够找到其中集中的矩形区域建设电站，能够获得良好的收益。",
    "inputDesc": "第一行输入为调研的地区长，宽，以及准备建设的电站【长宽相等，为正方形】的边长最低要求的发电量 之后每行为调研区域每平方公里的发电量",
    "outputDesc": "输出为这样的区域有多少个",
    "examples": [
      {
        "input": "5 2 6\n 3 4 5 8\n 3 6 7 1",
        "output": "",
        "explanation": "输入含义： 调研的区域大小为长2宽5的矩形，我们要建设的电站的边长为2，建设电站最低发电量为6. 输出含义： 长宽为2的正方形满足发电量大于等于6的区域有4个。"
      },
      {
        "input": "1 6\n 3 4 5 8\n 3 6 7 1",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "本题可以使用动态规划前缀和思想解题。\n解题思路如下：\n首先，将每一行在水平方向上选取c个相邻地块进行发电量合并，用例中是2块相邻的地合并\n行合并完后，接下来对列进行合并\n\n样的话，最终得到【9，16，22，21】\n其中9，起始就是下图中绿色部分，是一个c*c的区域，9是这个区域的发电量总和。其他的16，22，21也同理。\n\n因此，9，16，22，21每一个都是符合要求发电站发电量>6的区域，因此结果输出4个",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // 输入地区长r，宽c，电站边长s，最低发电量min\n        int r = scanner.nextInt();\n        int c = scanner.nextInt();\n        int s = scanner.nextInt();\n        int min = scanner.nextInt();\n\n        // 输入每个区域每平方公里的发电量，存入矩阵matrix中\n        int[][] matrix = new int[r][c];\n        for (int i = 0; i < r; i++) {\n            for (int j = 0; j < c; j++) {\n                matrix[i][j] = scanner.nextInt();\n            }\n        }\n\n        // 遍历所有可能的电站位置，计算该位置的矩形区域发电量\n        int ans = 0;\n        for (int i = s; i <= r; i++) {\n            for (int j = s; j <= c; j++) {\n                int square = 0;\n                for (int x = i - s; x < i; x++) {\n                    for (int y = j - s; y < j; y++) {\n                        square += matrix[x][y];\n                    }\n                }\n                if (square >= min) ans++;\n            }\n        }\n\n        // 输出结果\n        System.out.println(ans);\n    }\n}",
      "python": "def main():\n    r, c, s, min_power = map(int, input().split())  # 输入地区长r，宽c，电站边长s，最低发电量min\n\n    # 输入每个区域每平方公里的发电量，存入矩阵matrix中\n    matrix = [list(map(int, input().split())) for _ in range(r)]\n\n    # 遍历所有可能的电站位置，计算该位置的矩形区域发电量\n    ans = 0\n    for i in range(s, r + 1):\n        for j in range(s, c + 1):\n            square = 0\n            for x in range(i - s, i):\n                for y in range(j - s, j):\n                    square += matrix[x][y]\n            if square >= min_power:\n                ans += 1\n\n    # 输出结果\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nlet length, width, stationSide, minPower;\nconst lines = [];\n\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [length, width, stationSide, minPower] = lines[0].split(\" \").map(Number);\n  }\n\n  if (length && lines.length === length + 1) {\n    const matrix = lines.slice(1).map(line => line.split(\" \").map(Number));\n    let ans = 0;\n\n    for (let i = stationSide; i <= length; i++) {\n      for (let j = stationSide; j <= width; j++) {\n        let square = 0;\n        for (let x = i - stationSide; x < i; x++) {\n          for (let y = j - stationSide; y < j; y++) {\n            square += matrix[x][y];\n          }\n        }\n        if (square >= minPower) {\n          ans += 1;\n        }\n      }\n    }\n\n    console.log(ans);\n    rl.close();\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\n    int r, c, s, min;\n    // 输入调研区域的长、宽，正方形电站的边长，以及最低发电量\n    cin >> r >> c >> s >> min;\n\n    // 创建一个二维矩阵存储每个区域的发电量\n    vector<vector<int>> matrix(r, vector<int>(c));\n    // 输入矩阵的每个元素，即每个区域的发电量\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n\n    int ans = 0;  // 记录满足条件的正方形区域个数\n    // 遍历所有可能的正方形区域\n    for (int i = s; i <= r; i++) {\n        for (int j = s; j <= c; j++) {\n            int square = 0;  // 记录当前正方形区域的总发电量\n            // 计算以(i, j)为右下角的正方形的总发电量\n            for (int x = i - s; x < i; x++) {\n                for (int y = j - s; y < j; y++) {\n                    square += matrix[x][y];\n                }\n            }\n            // 如果当前正方形区域的总发电量满足最低要求，则计数+1\n            if (square >= min) ans++;\n        }\n    }\n\n    // 输出满足条件的正方形区域个数\n    cout << ans << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n\nint main() {\n    int r, c, s, min;\n    // 输入调研区域的长、宽，正方形电站的边长，以及最低发电量\n    scanf(\"%d %d %d %d\", &r, &c, &s, &min);\n\n    int matrix[r][c];\n    // 输入每个区域的发电量\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n\n    int ans = 0;  // 记录满足条件的正方形区域个数\n    // 遍历所有可能的正方形区域\n    for (int i = s; i <= r; i++) {\n        for (int j = s; j <= c; j++) {\n            int square = 0;  // 记录当前正方形区域的总发电量\n            // 计算以(i, j)为右下角的正方形的总发电量\n            for (int x = i - s; x < i; x++) {\n                for (int y = j - s; y < j; y++) {\n                    square += matrix[x][y];\n                }\n            }\n            // 如果当前正方形区域的总发电量满足要求，则计数+1\n            if (square >= min) ans++;\n        }\n    }\n\n    // 输出满足条件的正方形区域个数\n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}"
    }
  },
  {
    "id": "8",
    "title": "免单统计",
    "examType": "A",
    "score": 100,
    "description": "华为商城举办了一个促销活动，如果某顾客是某一秒内最早时刻下单的顾客（可能是多个人），则可以获取免单。\n请你编程计算有多少顾客可以获取免单。",
    "inputDesc": "输入为 n 行数据，每一行表示一位顾客的下单时间\n以（年-月-日时-分-秒.毫秒） yyyy-MM-ddHH:mm:ss.fff 形式给出。\n0<n<500002000<yyyy<20200<MM<=120<dd<=280<=HH<=230<=mm<=590<=ss<=590<=fff<=999\n所有输入保证合法。",
    "outputDesc": "输出一个整数，表示有多少顾客可以获取免单。",
    "examples": [
      {
        "input": "-01-01 00:00:00.001\n-01-01 00:00:00.002\n-01-01 00:00:00.003",
        "output": "",
        "explanation": "样例 1 中，三个订单都是同一秒内下单，只有第一个订单最早下单，可以免单。"
      },
      {
        "input": "-01-01 08:59:00.123\n-01-01 08:59:00.123\n-12-28 10:08:00.999",
        "output": "",
        "explanation": "样例 2 中，前两个订单是同一秒内同一时刻（也是最早）下单，都可免单，第三个订单是当前秒内唯一一个订单（也是最早），也可免单。"
      },
      {
        "input": "-01-01 00:00:00.004\n-01-01 00:00:00.004\n-01-01 00:00:01.006\n-01-01 00:00:01.006\n-01-01 00:00:01.005",
        "output": "",
        "explanation": "样例 3 中，前两个订单是同一秒内同一时刻（也是最早）下单，第三第四个订单不是当前秒内最早下单，不可免单，第五个订单可以免单。"
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建 Scanner 对象用于读取输入\n        Scanner input = new Scanner(System.in);\n        // 读取顾客数量\n        int n = Integer.parseInt(input.nextLine());\n \n        // 使用 TreeMap 存储订单时间，保证有序\n        TreeMap<String, Integer> orderTime = new TreeMap<>();\n\n        // 读取顾客订单时间并存入 TreeMap\n        for (int i = 0; i < n; i++) {\n            String time = input.nextLine();\n            // 将订单时间作为键，值为该时间出现的次数\n            orderTime.put(time, orderTime.getOrDefault(time, 0) + 1);\n        }\n\n        // 初始化免单顾客数量\n        int freeOrders = 0;\n        // 用于存储上一个订单的秒数\n        String prevSecond = \"\";\n\n        // 遍历 TreeMap 中的订单时间\n        for (String time : orderTime.keySet()) {\n            // 获取当前订单时间的秒数\n            String currentSecond = time.substring(0, 19);\n            // 如果当前订单秒数与上一个订单秒数不同，则将当前订单的数量加入免单顾客数\n            if (!currentSecond.equals(prevSecond)) {\n                freeOrders += orderTime.get(time);\n                prevSecond = currentSecond;\n            }\n        }\n\n        // 输出免单顾客数量\n        System.out.println(freeOrders);\n    }\n}",
      "python": "from collections import OrderedDict\n\n# 创建函数用于读取输入\ndef read_input():\n    return input().strip()\n\n# 读取顾客数量\nn = int(read_input())\n\n# 使用 OrderedDict 存储订单时间，保证有序\norder_time = OrderedDict()\n\n# 读取顾客订单时间并存入 OrderedDict\nfor _ in range(n):\n    time = read_input()\n    # 将订单时间作为键，值为该时间出现的次数\n    order_time[time] = order_time.get(time, 0) + 1\n\n# 初始化免单顾客数量\nfree_orders = 0\n# 用于存储上一个订单的秒数\nprev_second = \"\"\n\n# 遍历 OrderedDict 中的订单时间\nfor time, count in order_time.items():\n    # 获取当前订单时间的秒数\n    current_second = time[:19]\n    # 如果当前订单秒数与上一个订单秒数不同，则将当前订单的数量加入免单顾客数\n    if current_second != prev_second:\n        free_orders += count\n        prev_second = current_second\n\n# 输出免单顾客数量\nprint(free_orders)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 创建数组用于存储输入行\nconst lines = [];\n\n// 读取输入行\nrl.on('line', (line) => {\n    lines.push(line);\n});\n\n// 当输入结束时，处理输入数据\nrl.on('close', () => {\n    // 读取顾客数量\n    const n = parseInt(lines.shift());\n\n    // 使用 Map 存储订单时间，保证有序\n    const orderTime = new Map();\n\n    // 读取顾客订单时间并存入 Map\n    for (let i = 0; i < n; i++) {\n        const time = lines.shift();\n        // 将订单时间作为键，值为该时间出现的次数\n        orderTime.set(time, (orderTime.get(time) || 0) + 1);\n    }\n\n    // 初始化免单顾客数量\n    let freeOrders = 0;\n    // 用于存储上一个订单的秒数\n    let prevSecond = \"\";\n\n    // 遍历 Map 中的订单时间\n    for (const [time, count] of orderTime) {\n        // 获取当前订单时间的秒数\n        const currentSecond = time.substring(0, 19);\n        // 如果当前订单秒数与上一个订单秒数不同，则将当前订单的数量加入免单顾客数\n        if (currentSecond !== prevSecond) {\n            freeOrders += count;\n            prevSecond = currentSecond;\n        }\n    }\n\n    // 输出免单顾客数量\n    console.log(freeOrders);\n});",
      "cpp": "#include <iostream>\n#include <string>\n#include <map>\n\n// 创建函数用于读取输入\nstd::string read_input() {\n    std::string input;\n    std::getline(std::cin, input);\n    return input;\n}\n\nint main() {\n    // 读取顾客数量\n    int n;\n    std::cin >> n;\n    std::cin.ignore();\n\n    // 使用 std::map 存储订单时间，保证有序\n    std::map<std::string, int> order_time;\n\n    // 读取顾客订单时间并存入 std::map\n    for (int i = 0; i < n; ++i) {\n        std::string time = read_input();\n        // 将订单时间作为键，值为该时间出现的次数\n        order_time[time]++;\n    }\n\n    // 初始化免单顾客数量\n    int free_orders = 0;\n    // 用于存储上一个订单的秒数\n    std::string prev_second = \"\";\n\n    // 遍历 std::map 中的订单时间\n    for (const auto& kv : order_time) {\n        std::string time = kv.first;\n        int count = kv.second;\n        // 获取当前订单时间的秒数\n        std::string current_second = time.substr(0, 19);\n        // 如果当前订单秒数与上一个订单秒数不同，则将当前订单的数量加入免单顾客数\n        if (current_second != prev_second) {\n            free_orders += count;\n            prev_second = current_second;\n        }\n    }\n\n    // 输出免单顾客数量\n    std::cout << free_orders << std::endl;\n\n    return 0;\n}",
      "c": "-01-01 00:00:00.001\n-01-01 00:00:00.002\n-01-01 00:00:00.003"
    }
  },
  {
    "id": "9",
    "title": "关联子串",
    "examType": "A",
    "score": 100,
    "description": "给定两个字符串str1和str2，如果字符串str1中的字符，经过排列组合后的字符串中，只要有一个字符串是str2的子串，则认为str1是str2的关联子串。\n若str1是str2的关联子串，请返回子串在str2的起始位置；\n若不是关联子串，则返回-1。",
    "inputDesc": "输入两个字符串，分别为题目中描述的str1、str2。\n输入的字符串只包含小写字母； 两个字符串的长度范围[1, 100000]之间；",
    "outputDesc": "若str1是str2的关联子串，请返回子串在str2的起始位置；\n若不是关联子串，则返回-1。\n若str2中有多个str1的组合子串，请返回最小的起始位置。",
    "examples": [
      {
        "input": "abc efghicbaiii",
        "output": "",
        "explanation": "str2包含str1的一种排列组合（“cab”)，此组合在str2的字符串起始位置为5（从0开始计数）"
      },
      {
        "input": "abc efghiccaiii",
        "output": "-1",
        "explanation": "“abc”字符串中三个字母的各种组合（abc、acb、bac、bca、cab、cba），str2中均不包含，因此返回-1"
      },
      {
        "input": "abc efghicbaiii",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "给定两个字符串 str1 和 str2，需要判断 str1 的任意排列组合是否是 str2 的子串。如果是，则返回这个子串在 str2 中的起始位置；如果不是，则返回 -1。\n排列组合： str1 的排列组合是指 str1 的所有字符按不同顺序排列所形成的字符串。比如，如果 str1 = \"abc\"，它的排列组合包括 abc, acb, bac, bca, cab, cba 等。 关联子串： 如果 str2 包含 str1 的某个排列组合作为其子串，则称 str1 是 str2 的关联子串。例如： 如果 str1 = \"abc\"，而 str2 = \"efghicbaiii\"，str2 包含 \"cab\" 这个子串（\"cab\" 是 str1 = \"abc\" 的一个排列组合），因此 str1 是 str2 的关联子串。 起始位置： 如果 str1 是 str2 的关联子串，需要返回这个排列组合在 str2 中的起始位置，从 0 开始计数。如果有多个排列组合出现在 str2 中，需要返回最小的起始位置。\nstr1 的排列组合是指 str1 的所有字符按不同顺序排列所形成的字符串。比如，如果 str1 = \"abc\"，它的排列组合包括 abc, acb, bac, bca, cab, cba 等。\n如果 str2 包含 str1 的某个排列组合作为其子串，则称 str1 是 str2 的关联子串。例如： 如果 str1 = \"abc\"，而 str2 = \"efghicbaiii\"，str2 包含 \"cab\" 这个子串（\"cab\" 是 str1 = \"abc\" 的一个排列组合），因此 str1 是 str2 的关联子串。\n如果 str1 = \"abc\"，而 str2 = \"efghicbaiii\"，str2 包含 \"cab\" 这个子串（\"cab\" 是 str1 = \"abc\" 的一个排列组合），因此 str1 是 str2 的关联子串。\n如果 str1 是 str2 的关联子串，需要返回这个排列组合在 str2 中的起始位置，从 0 开始计数。如果有多个排列组合出现在 str2 中，需要返回最小的起始位置。\n通过字符频率统计的方法，将复杂的排列匹配问题转化为子串字符频率匹配问题。具体来说：\n两个字符串是排列关系，意味着它们的字符组成相同（即每个字符出现的次数相同，但顺序可能不同）。因此，只要找到 str2 中长度为 n1 的子串（n1 是 str1 的长度），其字符频率与 str1 的字符频率一致，那么这个子串就可以被认为是 str1 的一个排列组合。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n        // 输入两个字符串\n        String[] strings = sc.nextLine().split(\" \");\n\n        String str1 = strings[0];\n        String str2 = strings[1];\n        int n1 = str1.length();\n        int n2 = str2.length();\n        int index = -1;\n\n        // 遍历str2，判断是否存在str1的排列组合子串\n        for (int i = 0; i <= n2 - n1; i++) {\n            if (isSubstring(str1, str2, i, n1)) {\n                index = i;\n                break;\n            }\n        }\n\n        System.out.println(index);\n\n    }\n\n    // 判断str1是否是str2的子串\n    public static boolean isSubstring(String str1, String str2, int start, int len) {\n\n        int count = 0;\n        int[] freq = new int[26];\n\n        // 统计str2中子串的字符频次\n        for (int i = 0; i < len; i++) {\n            freq[str2.charAt(start + i) - 'a']++;\n        }\n\n        // 检查str1中的字符是否在str2的子串中出现\n        for (int i = 0; i < len; i++) {\n            if (freq[str1.charAt(i) - 'a'] > 0) {\n                freq[str1.charAt(i) - 'a']--;\n                count++;\n            }\n        }\n\n        // 如果str1的字符都在str2的子串中出现，则返回true\n        return count == len;\n    }\n}",
      "python": "import sys\n\ndef is_substring(str1, str2, start, len):\n    count = 0\n    freq = [0] * 26\n\n    for i in range(len):\n        freq[ord(str2[start + i]) - ord('a')] += 1\n\n    for i in range(len):\n        if freq[ord(str1[i]) - ord('a')] > 0:\n            freq[ord(str1[i]) - ord('a')] -= 1\n            count += 1\n\n    return count == len\n\nif __name__ == \"__main__\":\n    strings = input().split(\" \")\n    str1 = strings[0]\n    str2 = strings[1]\n    n1 = len(str1)\n    n2 = len(str2)\n    index = -1\n\n    for i in range(n2 - n1 + 1):\n        if is_substring(str1, str2, i, n1):\n            index = i\n            break\n\n    print(index)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (input) => {\n  // 输入两个字符串\n  const strings = input.split(\" \");\n\n  const str1 = strings[0];\n  const str2 = strings[1];\n  const n1 = str1.length;\n  const n2 = str2.length;\n  let index = -1;\n\n  // 遍历str2，判断是否存在str1的排列组合子串\n  for (let i = 0; i <= n2 - n1; i++) {\n    if (isSubstring(str1, str2, i, n1)) {\n      index = i;\n      break;\n    }\n  }\n\n  console.log(index);\n\n  rl.close();\n});\n\n// 判断str1是否是str2的子串\nfunction isSubstring(str1, str2, start, len) {\n  let count = 0;\n  const freq = new Array(26).fill(0);\n\n  // 统计str2中子串的字符频次\n  for (let i = 0; i < len; i++) {\n    freq[str2.charCodeAt(start + i) - 'a'.charCodeAt(0)]++;\n  }\n\n  // 检查str1中的字符是否在str2的子串中出现\n  for (let i = 0; i < len; i++) {\n    if (freq[str1.charCodeAt(i) - 'a'.charCodeAt(0)] > 0) {\n      freq[str1.charCodeAt(i) - 'a'.charCodeAt(0)]--;\n      count++;\n    }\n  }\n\n  // 如果str1的字符都在str2的子串中出现，则返回true\n  return count === len;\n}",
      "cpp": "#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isSubstring(string str1, string str2, int start, int len) {\n    int count = 0;\n    int freq[26] = {0};\n\n    for (int i = 0; i < len; i++) {\n        freq[str2[start + i] - 'a']++;\n    }\n\n    for (int i = 0; i < len; i++) {\n        if (freq[str1[i] - 'a'] > 0) {\n            freq[str1[i] - 'a']--;\n            count++;\n        }\n    }\n\n    return count == len;\n}\n\nint main() {\n    string str1, str2;\n    cin >> str1 >> str2;\n    int n1 = str1.length();\n    int n2 = str2.length();\n    int index = -1;\n\n    for (int i = 0; i <= n2 - n1; i++) {\n        if (isSubstring(str1, str2, i, n1)) {\n            index = i;\n            break;\n        }\n    }\n\n    cout << index << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n// 判断 str1 是否是 str2 在位置 start 处的排列子串\nbool isSubstring(const char* str1, const char* str2, int start, int len) {\n    int count = 0;\n    int freq[26] = {0};  // 字符频率数组，针对 a-z 的小写字母\n\n    // 统计 str2 在 start 位置开始 len 长度内的字符频率\n    for (int i = 0; i < len; i++) {\n        freq[str2[start + i] - 'a']++;\n    }\n\n    // 遍历 str1，减少相应字符的频率并统计匹配的字符数\n    for (int i = 0; i < len; i++) {\n        if (freq[str1[i] - 'a'] > 0) {\n            freq[str1[i] - 'a']--;\n            count++;\n        }\n    }\n\n    // 如果匹配字符数等于 len，则返回 true\n    return count == len;\n}\n\nint main() {\n    char str1[100001], str2[100001];\n    \n    // 读取两个字符串\n    scanf(\"%s %s\", str1, str2);\n\n    int n1 = strlen(str1);  // 获取 str1 的长度\n    int n2 = strlen(str2);  // 获取 str2 的长度\n    int index = -1;\n\n    // 遍历 str2，检查从每个可能的起始位置开始的子串是否是 str1 的排列组合\n    for (int i = 0; i <= n2 - n1; i++) {\n        if (isSubstring(str1, str2, i, n1)) {\n            index = i;  // 找到第一个匹配的位置\n            break;      // 直接跳出循环\n        }\n    }\n\n    // 输出结果：找到则输出起始位置，未找到则输出 -1\n    printf(\"%d\\n\", index);\n\n    return 0;\n}"
    }
  },
  {
    "id": "10",
    "title": "内存资源分配",
    "examType": "A",
    "score": 100,
    "description": "有一个简易内存池，内存按照大小粒度分类，每个粒度有若干个可用内存资源，用户会进行一系列内存申请，需要按需分配内存池中的资源返回申请结果成功失败列表。\n分配规则如下：\n分配的内存要大于等于内存的申请量，存在满足需求的内存就必须分配，优先分配粒度小的，但内存不能拆分使用；需要按申请顺序分配，先申请的先分配，有可用内存分配则申请结果为true；没有可用则返回false。\n注意：不考虑内存释放",
    "inputDesc": "输入为两行字符串\n第一行为内存池资源列表，包含内存粒度数据信息，粒度数据间用逗号分割\n一个粒度信息内用冒号分割，冒号前为内存粒度大小，冒号后为数量资源列表不大于1024每个粒度的数量不大于4096\n第二行为申请列表，申请的内存大小间用逗号分割\n申请列表不大于100000\n如: 64:2,128:1,32:4,1:128 50,36,64,128,127",
    "outputDesc": "输出为内存池分配结果\n如true,true,true,false,false",
    "examples": [
      {
        "input": ":2,128:1,32:4,1:128\n,36,64,128,127",
        "output": "true,true,true,false,false",
        "explanation": "内存池资源包含：64K共2个、128K共1个、32K共4个、1K共128个的内存资源； 针对50,36,64,128,127的内存申请序列，分配的内存依次是：64,64,128,NULL,NULL, 第三次申请内存时已经将128分配出去，因此输出结果是： true,true,true,false,false"
      },
      {
        "input": ":2,128:1,32:4,1:128\n,36,64,128,127",
        "output": "true,true,true,false,false",
        "explanation": ""
      }
    ],
    "solution": "按需分配内存，不能拆分。优先分配最小的满足条件的内存块。内存池中的资源一旦分配出去，就无法再次使用。若没有可用内存块满足需求，返回 false。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 处理输入\n        Scanner scanner = new Scanner(System.in); // 创建一个Scanner对象，用于读取控制台的输入\n        String memoryInfo = scanner.next(); // 读取内存池资源列表\n        String applyList = scanner.next(); // 读取申请列表\n\n        // 内存信息\n        List<Integer> memoryList = new ArrayList<>(); // 创建一个ArrayList对象，用于存储内存池中可用的内存大小\n        List<String> memoryInfoList = new ArrayList<>(Arrays.asList(memoryInfo.split(\",\"))); // 将内存池资源列表按逗号分隔，转换为ArrayList对象\n        for (String info : memoryInfoList) { // 遍历内存池资源列表\n            int colonIndex = info.indexOf(\":\"); // 找到冒号的位置\n            int size = Integer.parseInt(info.substring(0, colonIndex)); // 截取内存大小\n            int count = Integer.parseInt(info.substring(colonIndex + 1)); // 截取内存块数量\n            for (int i = 0; i < count; i++) { // 将内存块数量的内存大小添加到内存列表中\n                memoryList.add(size);\n            }\n        }\n\n        // 申请信息\n        List<Integer> applyMemoryList = new ArrayList<>(); // 创建一个ArrayList对象，用于存储申请的内存大小\n        List<String> applyListList = new ArrayList<>(Arrays.asList(applyList.split(\",\"))); // 将申请列表按逗号分隔，转换为ArrayList对象\n        for (String apply : applyListList) { // 遍历申请列表\n            applyMemoryList.add(Integer.parseInt(apply)); // 将申请的内存大小添加到申请内存列表中\n        }\n\n        // 分配内存\n        List<Boolean> resultList = new ArrayList<>(); // 创建一个ArrayList对象，用于存储每个申请是否成功\n        for (int applyMemory : applyMemoryList) { // 遍历申请内存列表\n            boolean flag = false; // 定义一个标志位，用于标记是否成功分配内存\n            for (int i = 0; i < memoryList.size(); i++) { // 遍历内存列表\n                if (memoryList.get(i) >= applyMemory) { // 如果当前内存块的大小大于等于申请的内存大小\n                    flag = true; // 标记成功分配内存\n                    memoryList.remove(i); // 将当前内存块从内存列表中移除\n                    break; // 跳出循环\n                }\n            }\n            resultList.add(flag); // 将是否成功分配内存的结果添加到结果列表中\n        }\n\n        // 输出结果\n        for (int i = 0; i < resultList.size(); i++) { // 遍历结果列表\n            System.out.print(resultList.get(i)); // 输出当前申请是否成功分配内存\n            if (i != resultList.size() - 1) { // 如果不是最后一个结果\n                System.out.print(\",\"); // 输出逗号分隔符\n            }\n        }\n    }\n}",
      "python": "memoryInfo = input() # 读取内存池资源列表\napplyList = input() # 读取申请列表\n\n# 内存信息\nmemoryList = [] # 创建一个列表，用于存储内存池中可用的内存大小\nmemoryInfoList = memoryInfo.split(\",\") # 将内存池资源列表按逗号分隔，转换为列表\nfor info in memoryInfoList: # 遍历内存池资源列表\n    colonIndex = info.index(\":\") # 找到冒号的位置\n    size = int(info[:colonIndex]) # 截取内存大小\n    count = int(info[colonIndex + 1:]) # 截取内存块数量\n    for i in range(count): # 将内存块数量的内存大小添加到内存列表中\n        memoryList.append(size)\n\n# 申请信息\napplyMemoryList = [] # 创建一个列表，用于存储申请的内存大小\napplyListList = applyList.split(\",\") # 将申请列表按逗号分隔，转换为列表\nfor apply in applyListList: # 遍历申请列表\n    applyMemoryList.append(int(apply)) # 将申请的内存大小添加到申请内存列表中\n\n# 分配内存\nresultList = [] # 创建一个列表，用于存储每个申请是否成功\nfor applyMemory in applyMemoryList: # 遍历申请内存列表\n    flag = False # 定义一个标志位，用于标记是否成功分配内存\n    for i in range(len(memoryList)): # 遍历内存列表\n        if memoryList[i] >= applyMemory: # 如果当前内存块的大小大于等于申请的内存大小\n            flag = True # 标记成功分配内存\n            memoryList.pop(i) # 将当前内存块从内存列表中移除\n            break # 跳出循环\n    resultList.append(flag) # 将是否成功分配内存的结果添加到结果列表中\n\n# 输出结果\nfor i in range(len(resultList)): # 遍历结果列表\n    print(resultList[i], end='') # 输出当前申请是否成功分配内存\n    if i != len(resultList) - 1: # 如果不是最后一个结果\n        print(',', end='') # 输出逗号分隔符",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet memoryInfo, applyList;\n\nrl.on('line', (input) => {\n  if (!memoryInfo) {\n    memoryInfo = input;\n  } else if (!applyList) {\n    applyList = input;\n    rl.close();\n  }\n});\n\nrl.on('close', () => {\n  // 处理输入\n  const memoryList = [];\n  const memoryInfoArr = memoryInfo.split(',');\n  for (let i = 0; i < memoryInfoArr.length; i++) {\n    const [sizeStr, countStr] = memoryInfoArr[i].split(':');\n    const size = parseInt(sizeStr);\n    const count = parseInt(countStr);\n    for (let j = 0; j < count; j++) {\n      memoryList.push(size);\n    }\n  }\n\n  // 申请信息\n  const applyMemoryList = applyList.split(',').map(Number);\n\n  // 分配内存\n  const resultList = [];\n  for (let i = 0; i < applyMemoryList.length; i++) {\n    let flag = false;\n    for (let j = 0; j < memoryList.length; j++) {\n      if (memoryList[j] >= applyMemoryList[i]) {\n        flag = true;\n        memoryList.splice(j, 1);\n        break;\n      }\n    }\n    resultList.push(flag);\n  }\n\n  // 输出结果\n  console.log(resultList.map((res) => res ? 'true' : 'false').join(','));\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n    // 处理输入\n    string memoryInfo, applyList;\n    cin >> memoryInfo >> applyList;\n\n    // 内存信息\n    vector<int> memoryList;\n    stringstream ss(memoryInfo);\n    string info;\n    while (getline(ss, info, ',')) {\n        int colonIndex = info.find(\":\");\n        int size = stoi(info.substr(0, colonIndex));\n        int count = stoi(info.substr(colonIndex + 1));\n        for (int i = 0; i < count; i++) {\n            memoryList.push_back(size);\n        }\n    }\n\n    // 申请信息\n    vector<int> applyMemoryList;\n    stringstream ss2(applyList);\n    string apply;\n    while (getline(ss2, apply, ',')) {\n        applyMemoryList.push_back(stoi(apply));\n    }\n\n    // 分配内存\n    vector<bool> resultList;\n    for (int applyMemory : applyMemoryList) {\n        bool flag = false;\n        for (int i = 0; i < memoryList.size(); i++) {\n            if (memoryList[i] >= applyMemory) {\n                flag = true;\n                memoryList.erase(memoryList.begin() + i);\n                break;\n            }\n        }\n        resultList.push_back(flag);\n    }\n\n    // 输出结果\n    for (int i = 0; i < resultList.size(); i++) {\n        cout << (resultList[i] ? \"true\" : \"false\");\n        if (i != resultList.size() - 1) {\n            cout << \",\";\n        }\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_MEMORY_BLOCKS 1000  // 最大内存块数量\n#define MAX_APPLY_REQUESTS 1000 // 最大申请请求数量\n#define MAX_INPUT_LENGTH 1024   // 最大输入字符串长度\n\nint main() {\n    char memoryInfo[MAX_INPUT_LENGTH], applyList[MAX_INPUT_LENGTH];\n    int memoryList[MAX_MEMORY_BLOCKS];   // 用于存储内存块大小的数组\n    int memoryCount = 0;                 // 内存块总数\n    int applyMemoryList[MAX_APPLY_REQUESTS]; // 用于存储内存申请大小的数组\n    int applyCount = 0;                  // 申请总数\n    int resultList[MAX_APPLY_REQUESTS];  // 用于存储每次申请结果的数组\n\n    // 输入内存池信息和申请列表\n    scanf(\"%s\", memoryInfo);\n    scanf(\"%s\", applyList);\n\n    // 处理内存池信息\n    char *token = strtok(memoryInfo, \",\");  // 使用strtok按逗号分割字符串\n    while (token != NULL) {\n        char *colon = strchr(token, ':');   // 找到冒号位置\n        int size = atoi(token);             // 内存块大小\n        int count = atoi(colon + 1);        // 内存块数量\n\n        // 将每个内存块大小添加到内存列表中\n        for (int i = 0; i < count; i++) {\n            if (memoryCount < MAX_MEMORY_BLOCKS) {\n                memoryList[memoryCount++] = size;\n            }\n        }\n\n        token = strtok(NULL, \",\");  // 获取下一个逗号分割的部分\n    }\n\n    // 处理申请列表\n    token = strtok(applyList, \",\");  // 使用strtok按逗号分割字符串\n    while (token != NULL) {\n        if (applyCount < MAX_APPLY_REQUESTS) {\n            applyMemoryList[applyCount++] = atoi(token);  // 将申请大小存入数组\n        }\n        token = strtok(NULL, \",\");  // 获取下一个逗号分割的部分\n    }\n\n    // 处理每次申请\n    for (int i = 0; i < applyCount; i++) {\n        int applyMemory = applyMemoryList[i];\n        int success = 0;  // 标记是否成功分配内存\n\n        // 遍历内存池，找到第一个大于等于申请大小的内存块\n        for (int j = 0; j < memoryCount; j++) {\n            if (memoryList[j] >= applyMemory) {\n                success = 1;  // 找到合适的内存块\n                // 将该内存块从数组中移除，通过覆盖方式\n                for (int k = j; k < memoryCount - 1; k++) {\n                    memoryList[k] = memoryList[k + 1];\n                }\n                memoryCount--;  // 更新内存块数量\n                break;\n            }\n        }\n\n        resultList[i] = success;  // 记录申请结果\n    }\n\n    // 输出分配结果\n    for (int i = 0; i < applyCount; i++) {\n        if (resultList[i]) {\n            printf(\"true\");\n        } else {\n            printf(\"false\");\n        }\n        if (i != applyCount - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
    }
  },
  {
    "id": "11",
    "title": "分割数组的最大差值",
    "examType": "A",
    "score": 100,
    "description": "给定一个由若干整数组成的数组nums ，可以在数组内的任意位置进行分割，将该数组分割成两个非空子数组（即左数组和右数组），分别对子数组求和得到两个值，计算这两个值的差值，请输出所有分割方案中，差值最大的值。",
    "inputDesc": "第一行输入数组中元素个数n，1 < n ≤ 100000 第二行输入数字序列，以空格进行分隔，数字取值为4字节整数",
    "outputDesc": "输出差值的最大取值",
    "examples": [
      {
        "input": "-2 3 4 -9 7",
        "output": "",
        "explanation": "将数组 nums 划分为两个非空数组的可行方案有: 左数组 = [1] 且 右数组 = [-2,3,4,-9,7]，和的差值 = | 1 - 3 | = 2 左数组 = [1,-2] 且 右数组 = [3,4,-9,7]，和的差值 = | -1 - 5 | =6 左数组 = [1,-2,3] 且 右数组 = [4,-9,7]，和的差值 = | 2 - 2 | = 0 左数组 = [1,-2,3,4] 且右数组=[-9,7]，和的差值 = | 6 - (-2) | = 8，"
      }
    ],
    "solution": "首先，定义两个变量leftSum和rightSum，分别表示左数组的和和右数组的和。初始化时，leftSum为0，rightSum为整个数组的和。\n然后，定义一个变量maxDiff，表示差值的最大取值，初始化为0。\n接下来，使用一个循环遍历数组，从第一个元素开始到倒数第二个元素。在每次循环中，更新leftSum和rightSum的值，并计算当前分割方案的差值。\n具体的步骤如下：\n将当前元素加到leftSum中。将当前元素从rightSum中减去。计算当前分割方案的差值，即Math.abs(leftSum - rightSum)。更新maxDiff的值，取当前差值和maxDiff中的较大值。\n最后，输出maxDiff的值。",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n\n    // 输入数组长度\n    int length = Integer.parseInt(scanner.nextLine());\n    \n    // 输入数字序列\n    long[] numbers = Arrays.stream(scanner.nextLine().split(\" \")).mapToLong(Long::parseLong).toArray();\n\n    // 计算前缀和\n    long[] prefixSum = new long[length];\n    prefixSum[0] = numbers[0];\n    for (int i = 1; i < length; i++) {\n      prefixSum[i] = prefixSum[i-1] + numbers[i];\n    }\n\n    // 差值的最大取值\n    long maxDifference = 0;\n    \n    // 计算差值的最大取值\n    for (int i = 0; i < length - 1; i++) {\n      long leftSum = prefixSum[i];\n      long rightSum = prefixSum[length-1] - prefixSum[i];\n      long difference = Math.abs(leftSum - rightSum);\n      maxDifference = Math.max(maxDifference, difference);\n    }\n\n    // 输出差值的最大取值\n    System.out.println(maxDifference);\n  }\n}",
      "python": "import sys\n\n# 输入数组长度\nlength = int(sys.stdin.readline())\n\n# 输入数字序列\nnumbers = list(map(int, sys.stdin.readline().split()))\n\n# 计算前缀和\nprefixSum = [0] * length\nprefixSum[0] = numbers[0]\nfor i in range(1, length):\n  prefixSum[i] = prefixSum[i-1] + numbers[i]\n\n# 差值的最大取值\nmaxDifference = 0\n\n# 计算差值的最大取值\nfor i in range(length - 1):\n  leftSum = prefixSum[i]\n  rightSum = prefixSum[length-1] - prefixSum[i]\n  difference = abs(leftSum - rightSum)\n  maxDifference = max(maxDifference, difference)\n\n# 输出差值的最大取值\nprint(maxDifference)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (length) => {\n  rl.on('line', (numbers) => {\n    numbers = numbers.split(' ').map(Number);\n\n    // 计算前缀和\n    let prefixSum = new Array(length);\n    prefixSum[0] = numbers[0];\n    for (let i = 1; i < length; i++) {\n      prefixSum[i] = prefixSum[i-1] + numbers[i];\n    }\n\n    // 差值的最大取值\n    let maxDifference = 0;\n\n    // 计算差值的最大取值\n    for (let i = 0; i < length - 1; i++) {\n      let leftSum = prefixSum[i];\n      let rightSum = prefixSum[length-1] - prefixSum[i];\n      let difference = Math.abs(leftSum - rightSum);\n      maxDifference = Math.max(maxDifference, difference);\n    }\n\n    // 输出差值的最大取值\n    console.log(maxDifference);\n\n    rl.close();\n  });\n});",
      "cpp": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint main() {\n  string input;\n  getline(cin, input);\n  int length = stoi(input);\n\n  getline(cin, input);\n  istringstream iss(input);\n  vector<long long> numbers(length);\n  for (int i = 0; i < length; i++) {\n    iss >> numbers[i];\n  }\n\n  vector<long long> prefixSum(length);\n  prefixSum[0] = numbers[0];\n  for (int i = 1; i < length; i++) {\n    prefixSum[i] = prefixSum[i-1] + numbers[i];\n  }\n\n  long long maxDifference = 0;\n  for (int i = 0; i < length - 1; i++) {\n    long long leftSum = prefixSum[i];\n    long long rightSum = prefixSum[length-1] - prefixSum[i];\n    long long difference = abs(leftSum - rightSum);\n    maxDifference = max(maxDifference, difference);\n  }\n\n  cout << maxDifference << endl;\n\n  return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint main() {\n    // 输入数组长度\n    int length;\n    scanf(\"%d\", &length);\n\n    // 输入数字序列\n    long long *numbers = (long long *)malloc(length * sizeof(long long));\n    for (int i = 0; i < length; i++) {\n        scanf(\"%lld\", &numbers[i]);\n    }\n\n    // 计算前缀和数组\n    long long *prefixSum = (long long *)malloc(length * sizeof(long long));\n    prefixSum[0] = numbers[0];  // 第一个元素的前缀和即为其自身\n    for (int i = 1; i < length; i++) {\n        prefixSum[i] = prefixSum[i - 1] + numbers[i];  // 计算每个位置的前缀和\n    }\n\n    // 记录差值的最大取值\n    long long maxDifference = 0;\n\n    // 遍历所有的分割点，计算左右子数组和的差值\n    for (int i = 0; i < length - 1; i++) {\n        long long leftSum = prefixSum[i];  // 左子数组的和\n        long long rightSum = prefixSum[length - 1] - prefixSum[i];  // 右子数组的和\n        long long difference = llabs(leftSum - rightSum);  // 计算差值的绝对值\n        if (difference > maxDifference) {\n            maxDifference = difference;  // 更新最大差值\n        }\n    }\n\n    // 输出差值的最大取值\n    printf(\"%lld\\n\", maxDifference);\n\n    // 释放动态分配的内存\n    free(numbers);\n    free(prefixSum);\n\n    return 0;\n}"
    }
  },
  {
    "id": "12",
    "title": "分披萨",
    "examType": "A",
    "score": 100,
    "description": "\"吃货\"和\"馋嘴\"两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数个小块。但是粗心的服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。\n由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从\"吃货\"开始，轮流取披萨。除了第一块披萨可以任意选取外，其他都必须从缺口开始选。\n他俩选披萨的思路不同。\"馋嘴\"每次都会选最大块的披萨，而且\"吃货\"知道\"馋嘴\"的想法。\n已知披萨小块的数量以及每块的大小，求\"吃货\"能分得的最大的披萨大小的总和。",
    "inputDesc": "第 1 行为一个正整数奇数 N，表示披萨小块数量。\n3 ≤ N < 500\n接下来的第 2 行到第 N + 1 行（共 N 行），每行为一个正整数，表示第 i 块披萨的大小\n1 ≤ i ≤ N\n披萨小块从某一块开始，按照一个方向次序顺序编号为 1 ~ N\n每块披萨的大小范围为 [1, 2147483647]",
    "outputDesc": "\"吃货\"能分得到的最大的披萨大小的总和。\n输入\n输出\n说明：\n此例子中，有 5 块披萨。每块大小依次为 8、2、10、5、7。 按照如下顺序拿披萨，可以使\"吃货\"拿到最多披萨： “吃货” 拿大小为 10 的披萨 “馋嘴” 拿大小为 5 的披萨 “吃货” 拿大小为 7 的披萨 “馋嘴” 拿大小为 8 的披萨 “吃货” 拿大小为 2 的披萨 至此，披萨瓜分完毕，\"吃货\"拿到的披萨总大小为 10 + 7 + 2 = 19 可能存在多种拿法，以上只是其中一种。",
    "examples": [],
    "solution": "给定一个环形排列的披萨数组，每块披萨有一个美味值，需要计算出从任意位置开始，能够获得的最大美味值总和。\n环形处理：由于披萨是环形排列的，所以在选择披萨时需要考虑边界情况，即当选择了最左边或最右边的披萨后，如何循环到另一端。 动态规划：使用一个二维数组 dp 作为记忆化存储，其中 dp[L][R] 表示从左边界 L 到右边界 R 能够获得的最大美味值。如果 dp[L][R] 已经被计算过，则直接返回该值。 递归计算：定义一个递归函数来计算 dp[L][R]。如果 a[L]（左边界的披萨美味值）大于 a[R]（右边界的披萨美味值），则选择 L 并将 L 向右移动一位；否则选择 R 并将 R 向左移动一位。这样递归地选择下一步，直到只剩下一块披萨。 递归基：当左右边界相遇时（即 L == R），说明只剩下一块披萨，直接返回这块披萨的美味值作为递归基。 状态转移：在递归过程中，dp[L][R] 的值是通过比较选择左边界披萨和右边界披萨后，剩下披萨的最大美味值之和来确定的。\n环形处理：由于披萨是环形排列的，所以在选择披萨时需要考虑边界情况，即当选择了最左边或最右边的披萨后，如何循环到另一端。\n动态规划：使用一个二维数组 dp 作为记忆化存储，其中 dp[L][R] 表示从左边界 L 到右边界 R 能够获得的最大美味值。如果 dp[L][R] 已经被计算过，则直接返回该值。\n递归计算：定义一个递归函数来计算 dp[L][R]。如果 a[L]（左边界的披萨美味值）大于 a[R]（右边界的披萨美味值），则选择 L 并将 L 向右移动一位；否则选择 R 并将 R 向左移动一位。这样递归地选择下一步，直到只剩下一块披萨。\n递归基：当左右边界相遇时（即 L == R），说明只剩下一块披萨，直接返回这块披萨的美味值作为递归基。\n状态转移：在递归过程中，dp[L][R] 的值是通过比较选择左边界披萨和右边界披萨后，剩下披萨的最大美味值之和来确定的。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    static int n;  // 披萨的数量\n    static int[] a;  // 每块披萨的美味值\n    static int[][] dp;  // 记忆化数组，用于存储已计算过的状态\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();  // 输入披萨的数量\n        a = new int[n];  // 初始化存储每块披萨美味值的数组\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();  // 输入每块披萨的美味值\n        }\n        dp = new int[n][n];  // 初始化记忆化数组，其维度为披萨数量的平方\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);  // 初始化记忆化数组，将所有值设为-1，表示未计算\n        }\n\n        int ans = 0;  // 初始化最大美味值为0\n        // 遍历每块披萨，尝试以每块披萨作为起点计算最大美味值\n        for (int i = 0; i < n; i++) {\n            // 更新最大美味值，allocation函数计算从当前披萨开始的最大美味值\n            ans = Math.max(ans, allocation((i + 1) % n, (i + n - 1) % n) + a[i]);\n        }\n\n        System.out.println(ans);  // 输出最多能吃到的披萨的美味值总和\n    }\n\n    static int allocation(int L, int R) {\n        // 如果当前状态已经计算过，则直接返回结果\n        if (dp[L][R] != -1) {\n            return dp[L][R];\n        }\n        // 根据贪心策略，选择当前美味值较大的披萨\n        if (a[L] > a[R]) {\n            L = (L + 1) % n;  // 如果左边的披萨更美味，则吃掉左边的披萨\n        } else {\n            R = (R + n - 1) % n;  // 如果右边的披萨更美味，则吃掉右边的披萨\n        }\n        // 如果只剩下一块披萨，则直接返回这块披萨的美味值\n        if (L == R) {\n            dp[L][R] = a[L];\n        } else {\n            // 否则，递归计算剩下披萨的最大美味值，并更新记忆化数组\n            dp[L][R] = Math.max(a[L] + allocation((L + 1) % n, R), a[R] + allocation(L, (R + n - 1) % n));\n        }\n        return dp[L][R];  // 返回当前状态下的最大美味值\n    }\n}",
      "python": "# 用于读取输入的标准库\nimport sys\n\n# 用于存储输入行的数组\nlines = []\n# 读取标准输入\nfor line in sys.stdin:\n    lines.append(line.strip())\n\n# 披萨的数量\nn = int(lines[0])\n# 每块披萨的美味值\na = list(map(int, lines[1:1 + n]))\n# 记忆化数组，用于存储已计算过的状态\ndp = [[-1 for _ in range(n)] for _ in range(n)]\n\n# 计算最大美味值的函数\ndef allocation(L, R):\n    # 如果已计算过，直接返回结果\n    if dp[L][R] != -1:\n        return dp[L][R]\n    # 根据美味值选择吃掉左边或右边的披萨\n    if a[L] > a[R]:\n        L = (L + 1) % n\n    else:\n        R = (R + n - 1) % n\n    # 如果只剩一块披萨，返回其美味值\n    if L == R:\n        dp[L][R] = a[L]\n    else:\n        dp[L][R] = max(a[L] + allocation((L + 1) % n, R), a[R] + allocation(L, (R + n - 1) % n))\n    return dp[L][R]\n\n# 初始化最大美味值为 0\nans = 0\n# 计算并更新最大美味值\nfor i in range(n):\n    ans = max(ans, allocation((i + 1) % n, (i + n - 1) % n) + a[i])\n\n# 输出最多能吃到的披萨的美味值总和\nprint(ans)",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm> // 用于 std::max 函数\n\nusing namespace std;\n\nint n; // 披萨的数量\nvector<int> a; // 每块披萨的美味值\nvector<vector<int>> dp; // 记忆化数组，用于存储已计算过的状态\n\n// 计算最大美味值的函数\nint allocation(int L, int R) {\n    if (dp[L][R] != -1) {\n        return dp[L][R]; // 如果已计算过，直接返回结果\n    }\n    if (a[L] > a[R]) {\n        L = (L + 1) % n; // 左边披萨更美味，吃掉左边的\n    } else {\n        R = (R + n - 1) % n; // 右边披萨更美味，吃掉右边的\n    }\n    if (L == R) {\n        dp[L][R] = a[L]; // 只剩一块披萨时，返回其美味值\n    } else {\n        // 否则，递归计算剩下披萨的最大美味值，并更新记忆化数组\n        dp[L][R] = max(a[L] + allocation((L + 1) % n, R), a[R] + allocation(L, (R + n - 1) % n));\n    }\n    return dp[L][R]; // 返回当前状态下的最大美味值\n}\n\nint main() {\n    cin >> n; // 输入披萨的数量\n    a.resize(n); // 调整数组大小以存储每块披萨的美味值\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i]; // 输入每块披萨的美味值\n    }\n    dp.assign(n, vector<int>(n, -1)); // 初始化记忆化数组\n\n    int ans = 0; // 初始化最大美味值为 0\n    for (int i = 0; i < n; ++i) {\n        // 更新最大美味值，allocation函数计算从当前披萨开始的最大美味值\n        ans = max(ans, allocation((i + 1) % n, (i + n - 1) % n) + a[i]);\n    }\n\n    cout << ans << endl;  // 输出最多能吃到的披萨的美味值\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;  // 披萨的数量\n    int *a; // 存储每块披萨美味值的数组\n    int **dp; // 记忆化数组，用于存储已计算过的状态\n\n    // 读取披萨的数量\n    scanf(\"%d\", &n);\n    a = (int *)malloc(n * sizeof(int));\n\n    // 读取每块披萨的美味值\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // 初始化记忆化数组\n    dp = (int **)malloc(n * sizeof(int *));\n    for (int i = 0; i < n; i++) {\n        dp[i] = (int *)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = -1;\n        }\n    }\n\n    // 计算最大美味值的函数声明\n    int allocation(int, int, int, int *, int **);\n\n    int ans = 0; // 初始化最大美味值为 0\n    for (int i = 0; i < n; i++) {\n        ans = (ans > allocation((i + 1) % n, (i + n - 1) % n, n, a, dp) + a[i]) ? ans : allocation((i + 1) % n, (i + n - 1) % n, n, a, dp) + a[i];\n    }\n\n    // 输出最多能吃到的披萨的美味值总和\n    printf(\"%d\\n\", ans);\n\n    // 释放分配的内存\n    for (int i = 0; i < n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    free(a);\n\n    return 0;\n}\n\n// 计算最大美味值的函数\nint allocation(int L, int R, int n, int *a, int **dp) {\n    if (dp[L][R] != -1) {\n        return dp[L][R]; // 如果已计算过，直接返回结果\n    }\n    if (a[L] > a[R]) {\n        L = (L + 1) % n; // 左边披萨更美味，吃掉左边的\n    } else {\n        R = (R + n - 1) % n; // 右边披萨更美味，吃掉右边的\n    }\n    if (L == R) {\n        dp[L][R] = a[L]; // 只剩一块披萨时，返回其美味值\n    } else {\n        dp[L][R] = (a[L] + allocation((L + 1) % n, R, n, a, dp)) > (a[R] + allocation(L, (R + n - 1) % n, n, a, dp)) ? (a[L] + allocation((L + 1) % n, R, n, a, dp)) : (a[R] + allocation(L, (R + n - 1) % n, n, a, dp));\n    }\n    return dp[L][R]; // 返回当前状态下的最大美味值\n}"
    }
  },
  {
    "id": "13",
    "title": "分班问题幼儿园分班",
    "examType": "A",
    "score": 100,
    "description": "儿园两个班的小朋友在排队时混在了一起，每位小朋友都知道自己是否与前面一位小朋友同班，请你帮忙把同班的小朋友找出来。\n小朋友的编号是整数，与前一位小朋友同班用Y表示，不同班用N表示。",
    "inputDesc": "输入为空格分开的小朋友编号和是否同班标志。\n比如：6/N 2/Y 3/N 4/Y，表示4位小朋友，2和6同班，3和2不同班，4和3同班。\n其中，小朋友总数不超过999，每个小朋友编号大于0，小于等于999。\n不考虑输入格式错误问题。",
    "outputDesc": "输出为两行，每一行记录一个班小朋友的编号，编号用空格分开，且：",
    "examples": [
      {
        "input": "/N 2/Y 3/N 4/Y",
        "output": "2\n 4",
        "explanation": "2的同班标记为Y，因此和1同班。 3的同班标记为N，因此和1、2不同班。 4的同班标记为Y，因此和3同班。 所以1、2同班，3、4同班，输出为 1 2 3 4"
      },
      {
        "input": "/N 2/Y 3/N 4/Y 5/Y",
        "output": "2\n 4 5",
        "explanation": "无"
      },
      {
        "input": "/N 2/Y 3/N 4/Y 5/Y",
        "output": "2\n 4 5",
        "explanation": ""
      }
    ],
    "solution": "题目的要求是将一组小朋友按班级进行分类。输入由小朋友的编号和他们是否与前一位小朋友同班的标志组成。任务是根据这些标志将同班的小朋友归类并输出，遵循以下规则：\n输入是小朋友编号与他们是否与前一位小朋友同班的标志，用空格分隔。编号后面跟随一个标志： Y：表示与前一个小朋友同班。N：表示与前一个小朋友不同班。 根据这些标志，小朋友们要被分成不同的班级。\n输入是小朋友编号与他们是否与前一位小朋友同班的标志，用空格分隔。编号后面跟随一个标志：\nY：表示与前一个小朋友同班。N：表示与前一个小朋友不同班。\n根据这些标志，小朋友们要被分成不同的班级。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] nums = scanner.nextLine().split(\" \");\n\n        String[] start = nums[0].split(\"/\");\n        List<String> class_A = new ArrayList<>();\n        class_A.add(start[0]);\n        List<String> class_B = new ArrayList<>();\n\n        List<List<String>> temp = new ArrayList<>();\n        temp.add(class_A);\n        temp.add(class_B);\n\n        for (int i = 1; i < nums.length; i++) {\n            String[] current = nums[i].split(\"/\");\n            String id_ = current[0];\n            String f = current[1];\n\n            if (f.equals(\"Y\")) {\n                temp = temp;\n            } else {\n                Collections.reverse(temp);\n            }\n\n            temp.get(0).add(id_);\n        }\n\n        if (!class_A.isEmpty()) {\n            Collections.sort(class_A, (a, b) -> Integer.parseInt(a) - Integer.parseInt(b));\n            System.out.println(String.join(\" \", class_A));\n        }\n\n        if (!class_B.isEmpty()) {\n            Collections.sort(class_B, (a, b) -> Integer.parseInt(a) - Integer.parseInt(b));\n            System.out.println(String.join(\" \", class_B));\n        }\n    }\n}",
      "python": "nums = input().split()\n\n# 将第一个元素以'/'分隔成两部分，第一部分表示小朋友的编号，第二部分表示是否与前一位小朋友同班\nstart = nums[0].split('/')\n# 创建一个列表class_A，用于存放同班的小朋友的编号\nclass_A = [start[0]]\n# 创建一个列表class_B，用于存放不同班的小朋友的编号\nclass_B = []\n\n# 创建一个临时列表temp，用于存放两个班级的小朋友编号列表\ntemp = [class_A, class_B]   \n\n# 遍历nums列表中的每一个元素\nfor n in nums[1:]:\n    # 将当前元素以'/'分隔成两部分，第一部分表示小朋友的编号，第二部分表示是否与前一位小朋友同班\n    id_, f = n.split(\"/\")\n\n    # 如果与前一位小朋友同班，则temp不变\n    if f == \"Y\":\n        temp = temp\n    else:\n        # 如果与前一位小朋友不同班，则将temp列表中的两个班级的小朋友编号列表颠倒顺序\n        temp = temp[::-1]\n\n    # 将当前小朋友的编号添加到temp列表的第一个班级的小朋友编号列表中\n    temp[0].append(id_)\n\n# 如果class_A列表不为空，则按照编号的大小升序排列，并用空格分隔成字符串输出\nif class_A:\n    print(\" \".join(sorted(class_A, key=lambda x: int(x))))\n# 如果class_B列表不为空，则按照编号的大小升序排列，并用空格分隔成字符串输出\nif class_B:\n    print(\" \".join(sorted(class_B, key=lambda x: int(x))))",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (nums) => {\n  nums = nums.split(' ');\n\n  let start = nums[0].split('/');\n  let class_A = [start[0]];\n  let class_B = [];\n  let temp = [class_A, class_B];\n\n  for (let i = 1; i < nums.length; i++) {\n    let [id_, f] = nums[i].split('/');\n\n    if (f === 'Y') {\n      temp = temp;\n    } else {\n      temp = temp.reverse();\n    }\n\n    temp[0].push(id_);\n  }\n\n  if (class_A.length > 0) {\n    console.log(class_A.sort((a, b) => parseInt(a) - parseInt(b)).join(' '));\n  }\n  if (class_B.length > 0) {\n    console.log(class_B.sort((a, b) => parseInt(a) - parseInt(b)).join(' '));\n  }\n\n  rl.close();\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nvector<string> split(const string& s, char delimiter) {\n    vector<string> tokens;\n    string token;\n    istringstream tokenStream(s);\n    while (getline(tokenStream, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\nint main() {\n    string nums;\n    getline(cin, nums);\n\n    vector<string> nums_vec = split(nums, ' ');\n\n    vector<string> start = split(nums_vec[0], '/');\n    vector<string> class_A = {start[0]};\n    vector<string> class_B;\n    vector<vector<string>> temp = {class_A, class_B};\n\n    for (int i = 1; i < nums_vec.size(); i++) {\n        vector<string> temp_vec = split(nums_vec[i], '/');\n\n        string id_ = temp_vec[0];\n        string f = temp_vec[1];\n\n        if (f == \"Y\") {\n            temp = temp;\n        } else {\n            reverse(temp.begin(), temp.end());\n        }\n\n        temp[0].push_back(id_);\n    }\n\n    class_A = temp[0];\n    class_B = temp[1];\n  if (class_B.size() > 0) {\n        sort(class_B.begin(), class_B.end(), [](string a, string b) { return stoi(a) < stoi(b); });\n        for (string s : class_B) {\n            cout << s << \" \";\n        }\n        cout << endl;\n    }\n    if (class_A.size() > 0) {\n        sort(class_A.begin(), class_A.end(), [](string a, string b) { return stoi(a) < stoi(b); });\n        for (string s : class_A) {\n            cout << s << \" \";\n        }\n        cout << endl;\n    }\n  \n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义最大小朋友数量\n#define MAX_KIDS 1000\n\n// 辅助函数，用于比较两个字符串表示的数字\nint cmp(const void *a, const void *b) {\n    return atoi(*(const char **)a) - atoi(*(const char **)b);\n}\n\n// 主函数\nint main() {\n    char input[5000];  // 假设输入不超过5000字符\n    fgets(input, sizeof(input), stdin);  // 读取整行输入\n\n    char *nums[MAX_KIDS];  // 保存小朋友编号和同班标志\n    int count = 0;  // 输入的条目数量\n\n    // 分割输入的每个小朋友编号和同班标志\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        nums[count++] = token;\n        token = strtok(NULL, \" \");\n    }\n\n    // 定义两个班级的数组\n    char *class_A[MAX_KIDS];\n    int class_A_count = 0;\n    char *class_B[MAX_KIDS];\n    int class_B_count = 0;\n\n    // 初始化第一个小朋友\n    char *start = strtok(nums[0], \"/\");\n    class_A[class_A_count++] = start;\n\n    // 定义指向两个班级的数组\n    char ***temp[2] = { &class_A, &class_B };  // 指向class_A和class_B的指针\n    int temp_index = 0;  // 当前处理的班级\n\n    // 遍历输入的每个小朋友，从第二个开始\n    for (int i = 1; i < count; i++) {\n        char *id_ = strtok(nums[i], \"/\");  // 小朋友编号\n        char *f = strtok(NULL, \"/\");  // 同班标志\n\n        if (strcmp(f, \"N\") == 0) {\n            temp_index = 1 - temp_index;  // 切换到另一个班\n        }\n\n        // 将当前小朋友编号添加到当前班级\n        if (temp_index == 0) {\n            class_A[class_A_count++] = id_;\n        } else {\n            class_B[class_B_count++] = id_;\n        }\n    }\n\n    // 输出班级A的编号，升序排列\n    if (class_A_count > 0) {\n        qsort(class_A, class_A_count, sizeof(char *), cmp);\n        for (int i = 0; i < class_A_count; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%s\", class_A[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    // 输出班级B的编号，升序排列\n    if (class_B_count > 0) {\n        qsort(class_B, class_B_count, sizeof(char *), cmp);\n        for (int i = 0; i < class_B_count; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%s\", class_B[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "14",
    "title": "单向链表中间节点",
    "examType": "A",
    "score": 100,
    "description": "给定一个单链表 L，请编写程序输出 L 中间结点保存的数据。\n如果有两个中间结点，则输出第二个中间结点保存的数据。\n例如：\n给定 L 为 1→7→5，则输出应该为 7；给定 L 为 1→2→3→4，则输出应该为 3。",
    "inputDesc": "每个输入包含 1 个测试用例。每个测试用例:\n第 1 行给出链表首结点的地址、结点总个数正整数 N (≤105)。\n结点的地址是 5 位非负整数，NULL 地址用 −1 表示。\n接下来有 N 行，每行格式为：\n1\n其中 Address 是结点地址，Data 是该结点保存的整数数据(0 ≤ Data ≤ 108)，Next 是下一结点的地址。",
    "outputDesc": "对每个测试用例，在一行中输出 L 中间结点保存的数据。\n如果有两个中间结点，则输出第二个中间结点保存的数据。\n( 如果奇数个节点取中间，偶数个取偏右边的那个值)",
    "examples": [
      {
        "input": "4\n 3 -1\n 5 12309\n 6 00000\n 7 11451",
        "output": "",
        "explanation": "无"
      },
      {
        "input": "3\n 7 12309\n 5 -1\n 1 76892",
        "output": "",
        "explanation": ""
      },
      {
        "input": "4\n 4 -1\n 1 12309\n 3 00000\n 2 33218",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "示例 1： 链表为：5 -> 7 -> 6 -> 3，长度为 4，偶数节点，因此中间两个节点是 7 和 6，输出第二个中间结点的值：6。 示例 2： 链表为：1 -> 7 -> 5，长度为 3，奇数节点，中间结点是 7，输出 7。 示例 3： 链表为：1 -> 2 -> 3 -> 4，长度为 4，偶数节点，中间两个节点是 2 和 3，输出第二个中间结点的值：3。\n示例 1：\n链表为：5 -> 7 -> 6 -> 3，长度为 4，偶数节点，因此中间两个节点是 7 和 6，输出第二个中间结点的值：6。\n示例 2：\n链表为：1 -> 7 -> 5，长度为 3，奇数节点，中间结点是 7，输出 7。\n示例 3：\n链表为：1 -> 2 -> 3 -> 4，长度为 4，偶数节点，中间两个节点是 2 和 3，输出第二个中间结点的值：3。\n这道题的要求是给定一个单链表，输出它的中间结点的数据。如果链表长度是奇数，那么中间结点就是第 $\\frac{n+1}{2} $ 个结点（第一个结点为第 1 个）；如果链表长度是偶数，则中间结点是第 $ \\frac{n}{2} + 1 $ 个结点，也就是偏右的那个结点。\n通过输入中的 Address、Data、Next 信息，首先建立链表的结构。，使用快慢指针法，一个指针每次移动两步，另一个指针每次移动一步，当快指针到达链表末尾时，慢指针刚好位于中间节点。对于偶数长度的链表，这样的算法能自动返回偏右的那个节点。",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 输入链表头节点地址和节点数\n        String[] firstLine = sc.nextLine().split(\" \");\n        String headAddress = firstLine[0];\n        int n = Integer.parseInt(firstLine[1]);\n\n        // 创建 HashMap 存储每个节点的值和下一个节点的地址\n        HashMap<String, String[]> nodeMap = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            String[] nodeData = sc.nextLine().split(\" \");\n            String address = nodeData[0];\n            String value = nodeData[1];\n            String nextAddress = nodeData[2];\n            nodeMap.put(address, new String[]{value, nextAddress});\n        }\n\n        // 初始化慢指针和快指针，均指向头节点\n        String slow = headAddress;\n        String fast = headAddress;\n\n        // 快指针每次走两步，慢指针每次走一步，直到快指针到达链表末尾\n        while (fast != null && nodeMap.containsKey(fast)) {\n            fast = nodeMap.get(fast)[1]; // 快指针走一步\n            if (fast == null || !nodeMap.containsKey(fast)) {\n                break; // 如果快指针到达链表末尾，结束\n            }\n            fast = nodeMap.get(fast)[1]; // 快指针再走一步\n            slow = nodeMap.get(slow)[1]; // 慢指针走一步\n        }\n\n        // 输出慢指针指向的节点的值\n        System.out.println(nodeMap.get(slow)[0]);\n    }\n}",
      "python": "# 使用字典模拟链表\nnode_map = {}\n\n# 读取输入\nhead_address, n = input().split()\nn = int(n)\n\n# 读取每个节点的信息并存储在字典中\nfor _ in range(n):\n    address, value, next_address = input().split()\n    node_map[address] = (value, next_address)\n\n\n# 初始化慢指针和快指针，均指向头节点\nslow = head_address\nfast = head_address\n\n# 快指针每次走两步，慢指针每次走一步，直到快指针到达链表末尾\nwhile fast != '-1' and fast in node_map:\n    fast = node_map[fast][1]  # 快指针走一步\n    if fast == '-1' or fast not in node_map:\n        break  # 快指针到达链表末尾，结束循环\n    fast = node_map[fast][1]  # 快指针再走一步\n    slow = node_map[slow][1]  # 慢指针走一步\n\n# 输出慢指针指向的节点的值\nprint(node_map[slow][0])",
      "javascript": "const readline = require('readline');\n\n// 创建接口读取输入\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 保存链表数据的Map\nlet nodeMap = new Map();\nlet headAddress = '';\nlet n = 0;\nlet lineCount = 0;\n\n// 读取输入的每一行\nrl.on('line', (line) => {\n    lineCount++;\n    let data = line.split(' ');\n    \n    if (lineCount === 1) {\n        // 读取头节点地址和节点数\n        headAddress = data[0];\n        n = parseInt(data[1]);\n    } else {\n        // 存储节点信息\n        nodeMap.set(data[0], [data[1], data[2]]);\n        if (lineCount - 1 === n) {\n            rl.close(); // 读取完毕后关闭输入\n        }\n    }\n});\n\n// 处理逻辑\nrl.on('close', () => {\n\n    let slow = headAddress;\n    let fast = headAddress;\n\n    // 快指针每次走两步，慢指针每次走一步\n    while (fast !== '-1' && nodeMap.has(fast)) {\n        fast = nodeMap.get(fast)[1];\n        if (fast === '-1' || !nodeMap.has(fast)) break;\n        fast = nodeMap.get(fast)[1];\n        slow = nodeMap.get(slow)[1];\n    }\n\n    // 输出慢指针指向的节点的值\n    console.log(nodeMap.get(slow)[0]);\n});",
      "cpp": "#include <iostream>\n#include <unordered_map>\n#include <string>\nusing namespace std;\n\nint main() {\n    int n;\n    string headAddress;\n    cin >> headAddress >> n;\n\n    // 使用unordered_map存储每个节点的值和下一个节点的地址\n    unordered_map<string, pair<string, string>> nodeMap;\n    for (int i = 0; i < n; i++) {\n        string address, value, nextAddress;\n        cin >> address >> value >> nextAddress;\n        nodeMap[address] = {value, nextAddress}; // 将数据存入哈希表\n    }\n\n    // 如果头节点不存在，直接退出\n    if (nodeMap.find(headAddress) == nodeMap.end()) {\n        return 0;\n    }\n\n    // 初始化慢指针和快指针，均指向头节点\n    string slow = headAddress, fast = headAddress;\n\n    // 快指针每次走两步，慢指针每次走一步，直到快指针到达链表末尾\n    while (fast != \"-1\" && nodeMap.find(fast) != nodeMap.end()) {\n        fast = nodeMap[fast].second; // 快指针走一步\n        if (fast == \"-1\" || nodeMap.find(fast) == nodeMap.end()) {\n            break; // 快指针到达链表末尾，退出循环\n        }\n        fast = nodeMap[fast].second; // 快指针再走一步\n        slow = nodeMap[slow].second; // 慢指针走一步\n    }\n\n    // 输出慢指针指向的节点的值\n    cout << nodeMap[slow].first << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\n// 定义节点结构\ntypedef struct Node {\n    char address[6];   // 节点地址\n    char data[9];      // 节点保存的数据\n    char nextAddress[6]; // 下一节点的地址\n} Node;\n\nint main() {\n    int n;\n    char headAddress[6];\n    \n    // 读取头节点地址和节点数\n    scanf(\"%s %d\", headAddress, &n);\n    \n    Node nodes[n]; // 使用数组存储节点信息\n    \n    // 读取每个节点的信息\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s %s %s\", nodes[i].address, nodes[i].data, nodes[i].nextAddress);\n    }\n\n    // 初始化指针，慢指针和快指针均指向头节点\n    char slow[6], fast[6];\n    strcpy(slow, headAddress);\n    strcpy(fast, headAddress);\n\n    // 快慢指针的逻辑\n    while (strcmp(fast, \"-1\") != 0) {\n        int fastIndex = findNodeIndex(fast, nodes, n);\n        if (fastIndex == -1) break;\n        \n        strcpy(fast, nodes[fastIndex].nextAddress); // 快指针走一步\n        if (strcmp(fast, \"-1\") == 0) break;\n        \n        fastIndex = findNodeIndex(fast, nodes, n);\n        if (fastIndex == -1) break;\n        \n        strcpy(fast, nodes[fastIndex].nextAddress); // 快指针再走一步\n        int slowIndex = findNodeIndex(slow, nodes, n);\n        strcpy(slow, nodes[slowIndex].nextAddress); // 慢指针走一步\n    }\n\n    // 输出慢指针指向的节点的值\n    int slowIndex = findNodeIndex(slow, nodes, n);\n    printf(\"%s\\n\", nodes[slowIndex].data);\n\n    return 0;\n}"
    }
  },
  {
    "id": "15",
    "title": "单词接龙",
    "examType": "A",
    "score": 100,
    "description": "单词接龙的规则是：\n可用于接龙的单词首字母必须要前一个单词的尾字母相同； 当存在多个首字母相同的单词时，取长度最长的单词，如果长度也相等，则取字典序最小的单词；已经参与接龙的单词不能重复使用。\n可用于接龙的单词首字母必须要前一个单词的尾字母相同；\n当存在多个首字母相同的单词时，取长度最长的单词，如果长度也相等，则取字典序最小的单词；已经参与接龙的单词不能重复使用。\n现给定一组全部由小写字母组成单词数组，并指定其中的一个单词作为起始单词，进行单词接龙，\n请输出最长的单词串，单词串是单词拼接而成，中间没有空格。",
    "inputDesc": "输入的第一行为一个非负整数，表示起始单词在数组中的索引K，0 <= K < N ；\n输入的第二行为一个非负整数，表示单词的个数N；\n接下来的N行，分别表示单词数组中的单词。\n备注：\n单词个数N的取值范围为[1, 20]；单个单词的长度的取值范围为[1, 30]；",
    "outputDesc": "输出一个字符串，表示最终拼接的单词串。",
    "examples": [
      {
        "input": "word\ndd\nda\ndc\ndword\nd",
        "output": "worddwordda",
        "explanation": "先确定起始单词word，再接以d开头的且长度最长的单词dword，剩余以d开头且长度最长的有dd、da、dc，则取字典序最小的da，所以最后输出worddwordda。"
      },
      {
        "input": "word\ndd\nda\ndc\ndword\nd",
        "output": "dwordda",
        "explanation": "先确定起始单词dword，剩余以d开头且长度最长的有dd、da、dc，则取字典序最小的da，所以最后输出dwordda。"
      },
      {
        "input": "word\ndd\nda\ndc\ndword\nd",
        "output": "word\ndd\nda\ndc\ndword\nd",
        "explanation": ""
      }
    ],
    "solution": "接龙规则： 下一个接龙的单词必须以前一个单词的尾字母开头。当有多个符合条件的单词时： 优先选择长度最长的单词；如果长度相等，选择字典序最小的单词。 已经使用的单词不能重复使用。\n下一个接龙的单词必须以前一个单词的尾字母开头。当有多个符合条件的单词时： 优先选择长度最长的单词；如果长度相等，选择字典序最小的单词。 已经使用的单词不能重复使用。\n优先选择长度最长的单词；如果长度相等，选择字典序最小的单词。\n确定起始单词：从输入的 K 索引中找到起始单词。根据接龙规则选择后续单词： 选择以当前单词尾字母开头的单词。先选长度最长的单词；若长度相等，选字典序最小的单词。将这个单词接到当前的结果串中，重复这个过程，直到没有可以接龙的单词为止。 输出结果：将最终拼接的单词串输出。\n选择以当前单词尾字母开头的单词。先选长度最长的单词；若长度相等，选字典序最小的单词。将这个单词接到当前的结果串中，重复这个过程，直到没有可以接龙的单词为止。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // 输入起始单词的索引\n        int startIndex = Integer.parseInt(scanner.nextLine());\n        \n        // 输入单词的个数\n        int number = Integer.parseInt(scanner.nextLine());\n        \n        // 创建一个存储单词的列表\n        List<String> wordList = new ArrayList<>();\n        \n        // 循环读取单词并添加到列表中\n        for (int i = 0; i < number; i++) {\n            wordList.add(scanner.nextLine());\n        }\n        \n        // 初始化结果字符串为起始单词\n        String result = wordList.get(startIndex);\n        \n        // 从列表中移除起始单词\n        wordList.remove(startIndex);\n        \n        // 获取下一个符合条件的单词\n        String nextWord = getNextWord(wordList, result.charAt(result.length() - 1));\n        \n        // 循环直到没有符合条件的单词为止\n        while (nextWord != null) {\n            // 拼接下一个单词到结果字符串\n            result += nextWord;\n            \n            // 从列表中移除已使用的单词\n            wordList.remove(nextWord);\n            \n            // 获取下一个符合条件的单词\n            nextWord = getNextWord(wordList, result.charAt(result.length() - 1));\n        }\n        \n        // 输出最终拼接的单词串\n        System.out.println(result);\n    }\n\n    public static String getNextWord(List<String> wordList, char suffix) {\n        // 创建一个映射表，键为单词的首字母，值为以该首字母开头的单词列表\n        Map<Character, List<String>> map = new HashMap<>();\n        \n        // 遍历单词列表，将单词按首字母分类存储到映射表中\n        for (String word : wordList) {\n            char firstChar = word.charAt(0);\n            List<String> tempList = map.getOrDefault(firstChar, new ArrayList<>());\n            tempList.add(word);\n            map.put(firstChar, tempList);\n        }\n        \n        // 初始化最长长度和字典序最小的单词\n        int maxLength = 0;\n        String minWord = \"\";\n        \n        // 获取以suffix为首字母的单词列表\n        List<String> tempList = map.get(suffix);\n        \n        // 如果列表为空，则没有符合条件的单词，返回null\n        if (tempList == null || tempList.isEmpty()) {\n            return null;\n        }\n        \n        // 遍历单词列表，找到最长长度和字典序最小的单词\n        for (String word : tempList) {\n            if (word.length() > maxLength || (word.length() == maxLength && word.compareTo(minWord) < 0)) {\n                maxLength = word.length();\n                minWord = word;\n            }\n        }\n        \n        // 如果最小单词为空，则没有符合条件的单词，返回null\n        return minWord.isEmpty() ? null : minWord;\n    }\n}",
      "python": "import sys\n\ndef getNextWord(wordList, suffix):\n    # 创建一个映射表，键为单词的首字母，值为以该首字母开头的单词列表\n    map = {}\n    \n    # 遍历单词列表，将单词按首字母分类存储到映射表中\n    for word in wordList:\n        firstChar = word[0]\n        tempList = map.get(firstChar, [])\n        tempList.append(word)\n        map[firstChar] = tempList\n    \n    # 初始化最长长度和字典序最小的单词\n    maxLength = 0\n    minWord = \"\"\n    \n    # 获取以suffix为首字母的单词列表\n    tempList = map.get(suffix)\n    \n    # 如果列表为空，则没有符合条件的单词，返回None\n    if not tempList:\n        return None\n    \n    # 遍历单词列表，找到最长长度和字典序最小的单词\n    for word in tempList:\n        if len(word) > maxLength or (len(word) == maxLength and word < minWord):\n            maxLength = len(word)\n            minWord = word\n    \n    # 如果最小单词为空，则没有符合条件的单词，返回None\n    return minWord if minWord else None\n\nif __name__ == \"__main__\":\n    # 输入起始单词的索引\n    startIndex = int(input())\n    \n    # 输入单词的个数\n    number = int(input())\n    \n    # 创建一个存储单词的列表\n    wordList = [input().strip() for _ in range(number)]\n\n    \n    # 初始化结果字符串为起始单词\n    result = wordList[startIndex]\n    \n    # 从列表中移除起始单词\n    wordList.pop(startIndex)\n    \n    # 获取下一个符合条件的单词\n    nextWord = getNextWord(wordList, result[-1])\n    \n    # 循环直到没有符合条件的单词为止\n    while nextWord:\n        # 拼接下一个单词到结果字符串\n        result += nextWord\n        \n        # 从列表中移除已使用的单词\n        wordList.remove(nextWord)\n        \n        # 获取下一个符合条件的单词\n        nextWord = getNextWord(wordList, result[-1])\n    \n    # 输出最终拼接的单词串\n    print(result)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 根据当前单词列表和后缀字母获取下一个单词\nfunction getNextWord(wordList, suffix) {\n    let map = {};\n    \n    // 将单词按首字母分组存储在map中\n    for (let word of wordList) {\n        let firstChar = word[0];\n        let tempList = map[firstChar] || [];\n        tempList.push(word);\n        map[firstChar] = tempList;\n    }\n    \n    let maxLength = 0;\n    let minWord = \"\";\n    \n    // 获取与后缀字母相同的单词列表\n    let tempList = map[suffix];\n    \n    if (!tempList) {\n        return null;\n    }\n    \n    // 遍历单词列表，找到长度最长且字典序最小的单词\n    for (let word of tempList) {\n        if (word.length > maxLength || (word.length === maxLength && word < minWord)) {\n            maxLength = word.length;\n            minWord = word;\n        }\n    }\n    \n    return minWord || null;\n}\n\nlet startIndex = -1;\nlet number = -1;\nlet wordList = [];\nlet count = 0;\n\nrl.on(\"line\", (line) => {\n    // 读取输入的起始单词索引\n    if(startIndex ===-1){\n        startIndex = parseInt(line);\n    }\n    // 读取输入的单词个数\n    else if(number ===-1 ){\n        number = parseInt(line);\n    }\n    // 读取输入的单词列表\n    else{\n        wordList.push(line.trim());\n        count++;\n\n        // 当读取完所有单词时，开始进行单词接龙\n        if (count === number) {\n            rl.close();\n\n            let result = wordList[startIndex];\n            wordList.splice(startIndex, 1);\n\n            let nextWord = getNextWord(wordList, result[result.length - 1]);\n\n            // 循环找到下一个单词并拼接到结果中，直到找不到下一个单词为止\n            while (nextWord) {\n                result += nextWord;\n                wordList.splice(wordList.indexOf(nextWord), 1);\n                nextWord = getNextWord(wordList, result[result.length - 1]);\n            }\n\n            console.log(result);\n        }\n    }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstring getNextWord(vector<string>& wordList, char suffix) {\n    // 创建一个映射表，键为单词的首字母，值为以该首字母开头的单词列表\n    map<char, vector<string>> wordMap;\n    \n    // 遍历单词列表，将单词按首字母分类存储到映射表中\n    for (string word : wordList) {\n        char firstChar = word[0];\n        vector<string>& tempList = wordMap[firstChar];\n        tempList.push_back(word);\n    }\n    \n    // 初始化最长长度和字典序最小的单词\n    int maxLength = 0;\n    string minWord = \"\";\n    \n    // 获取以suffix为首字母的单词列表\n    vector<string>& tempList = wordMap[suffix];\n    \n    // 如果列表为空，则没有符合条件的单词，返回空字符串\n    if (tempList.empty()) {\n        return \"\";\n    }\n    \n    // 遍历单词列表，找到最长长度和字典序最小的单词\n    for (string word : tempList) {\n        if (word.length() > maxLength || (word.length() == maxLength && word.compare(minWord) < 0)) {\n            maxLength = word.length();\n            minWord = word;\n        }\n    }\n    \n    // 如果最小单词为空，则没有符合条件的单词，返回空字符串\n    return minWord.empty() ? \"\" : minWord;\n}\n\nint main() {\n    // 输入起始单词的索引\n    int startIndex;\n    cin >> startIndex;\n    \n    // 输入单词的个数\n    int number;\n    cin >> number;\n    \n    // 创建一个存储单词的列表\n    vector<string> wordList;\n    \n    // 循环读取单词并添加到列表中\n    for (int i = 0; i < number; i++) {\n        string word;\n        cin >> word;\n        wordList.push_back(word);\n    }\n    \n    // 初始化结果字符串为起始单词\n    string result = wordList[startIndex];\n    \n    // 从列表中移除起始单词\n    wordList.erase(wordList.begin() + startIndex);\n    \n    // 获取下一个符合条件的单词\n    string nextWord = getNextWord(wordList, result[result.length() - 1]);\n    \n    // 循环直到没有符合条件的单词为止\n    while (!nextWord.empty()) {\n        // 拼接下一个单词到结果字符串\n        result += nextWord;\n        \n        // 从列表中移除已使用的单词\n        wordList.erase(remove(wordList.begin(), wordList.end(), nextWord), wordList.end());\n        \n        // 获取下一个符合条件的单词\n        nextWord = getNextWord(wordList, result[result.length() - 1]);\n    }\n    \n    // 输出最终拼接的单词串\n    cout << result << endl;\n    \n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义一个宏来表示最大单词数量\n#define MAX_WORDS 20\n// 定义一个宏来表示最大单词长度\n#define MAX_WORD_LENGTH 30\n\n// 函数声明\nchar* getNextWord(char** wordList, int* wordCount, char suffix);\n\nint main() {\n    // 定义变量来存储起始索引和单词数量\n    int startIndex, number;\n    \n    // 输入起始单词的索引\n    scanf(\"%d\", &startIndex);\n    \n    // 输入单词的个数\n    scanf(\"%d\", &number);\n    \n    // 创建一个存储单词的数组\n    char* wordList[MAX_WORDS];\n    for (int i = 0; i < number; i++) {\n        // 为每个单词分配空间\n        wordList[i] = (char*)malloc((MAX_WORD_LENGTH + 1) * sizeof(char));\n        // 读取每个单词\n        scanf(\"%s\", wordList[i]);\n    }\n    \n    // 初始化结果字符串为起始单词\n    char result[MAX_WORDS * (MAX_WORD_LENGTH + 1)] = \"\"; // 最大可能长度\n    strcpy(result, wordList[startIndex]);\n    \n    // 将起始单词从数组中移除\n    free(wordList[startIndex]);\n    for (int i = startIndex; i < number - 1; i++) {\n        wordList[i] = wordList[i + 1];\n    }\n    number--; // 减少单词计数\n    \n    // 获取下一个符合条件的单词\n    char nextWord[MAX_WORD_LENGTH + 1];\n    char* nextWordPtr = getNextWord(wordList, &number, result[strlen(result) - 1]);\n    \n    // 循环直到没有符合条件的单词为止\n    while (nextWordPtr != NULL) {\n        // 拼接下一个单词到结果字符串\n        strcat(result, nextWordPtr);\n        \n        // 从数组中移除已使用的单词\n        for (int i = 0; i < number; i++) {\n            if (strcmp(wordList[i], nextWordPtr) == 0) {\n                free(wordList[i]);\n                for (int j = i; j < number - 1; j++) {\n                    wordList[j] = wordList[j + 1];\n                }\n                number--; // 减少单词计数\n                break;\n            }\n        }\n        \n        // 获取下一个符合条件的单词\n        nextWordPtr = getNextWord(wordList, &number, result[strlen(result) - 1]);\n    }\n    \n    // 输出最终拼接的单词串\n    printf(\"%s\\n\", result);\n    \n    // 释放所有剩余单词的内存\n    for (int i = 0; i < number; i++) {\n        free(wordList[i]);\n    }\n    \n    return 0;\n}\n\n// 获取下一个符合条件的单词\nchar* getNextWord(char** wordList, int* wordCount, char suffix) {\n    int maxLength = 0; // 用于存储最长的单词长度\n    char* minWord = NULL; // 用于存储字典序最小的单词\n    \n    // 遍历单词列表\n    for (int i = 0; i < *wordCount; i++) {\n        if (wordList[i][0] == suffix) { // 如果单词的首字母与给定的suffix相同\n            int wordLength = strlen(wordList[i]);\n            // 找到最长长度和字典序最小的单词\n            if (wordLength > maxLength || \n                (wordLength == maxLength && (minWord == NULL || strcmp(wordList[i], minWord) < 0))) {\n                maxLength = wordLength;\n                minWord = wordList[i];\n            }\n        }\n    }\n    \n    // 返回找到的符合条件的单词或NULL\n    return minWord;\n}"
    }
  },
  {
    "id": "16",
    "title": "喊7的次数重排",
    "examType": "A",
    "score": 100,
    "description": "喊7是一个传统的聚会游戏，N个人围成一圈，按顺时针从1到N编号。\n编号为1的人从1开始喊数，下一个人喊的数字为上一个人的数字加1，但是当将要喊出来的数字是7的倍数或者数字本身含有7的话，不能把这个数字直接喊出来，而是要喊”过”。\n假定玩这个游戏的N个人都没有失误地在正确的时机喊了”过”，当喊到数字K时，可以统计每个人喊”过”的次数。\n现给定一个长度为N的数组，存储了打乱顺序的每个人喊”过”的次数，请把它还原成正确的顺序，即数组的第i个元素存储编号i的人喊”过”的次数。",
    "inputDesc": "输入为一行，为空格分隔的喊”过”的次数，注意K并不提供，K不超过200，而数字的个数即为N。",
    "outputDesc": "输出为一行，为顺序正确的喊”过”的次数，也由空格分隔。",
    "examples": [
      {
        "input": "1 0",
        "output": "0 0",
        "explanation": "一共只有一次喊”过”，那只会发生在需要喊7时，按顺序，编号为1的人会遇到7，故输出1 0 0。"
      },
      {
        "input": "一共只有一次喊”过”，那只会发生在需要喊7时，按顺序，编号为1的人会遇到7，故输出1 0 0。",
        "output": "2 0 1 0",
        "explanation": "一共有三次喊”过”，发生在7 14 17，按顺序，编号为2的人会遇到7 17，编号为4的人会遇到14，故输出0 2 0 1 0。"
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n\n    // 读取输入，将喊过的次数存储在数组中\n    int[] counts =\n        Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n    // 计算总共喊过的次数\n    int totalPass = Arrays.stream(counts).sum();\n\n    int numberOfPeople = counts.length;\n    int[] peopleCounts = new int[numberOfPeople]; // 存储每个人喊过的次数\n\n    int currentNumber = 1; // 当前要喊的数字\n    int currentIndex = 0; // 当前喊过的人的索引\n    while (totalPass > 0) {\n      if (currentNumber % 7 == 0 || (currentNumber + \"\").contains(\"7\")) { // 如果当前数字是7的倍数或包含7\n        totalPass--;\n        peopleCounts[currentIndex]++; // 当前喊过的人喊过的次数加1\n      }\n      currentNumber++;\n      currentIndex = (currentIndex + 1) % numberOfPeople; // 更新喊过的人的索引\n    }\n\n    // 构造输出字符串\n    StringJoiner stringJoiner = new StringJoiner(\" \");\n    for (int count : peopleCounts) {\n      stringJoiner.add(Integer.toString(count));\n    }\n    System.out.println(stringJoiner.toString());\n  }\n}",
      "python": "counts = list(map(int, input().split()))\n\ntotalPass = sum(counts)\n\nnumberOfPeople = len(counts)\npeopleCounts = [0] * numberOfPeople\n\ncurrentNumber = 1\ncurrentIndex = 0\nwhile totalPass > 0:\n    if currentNumber % 7 == 0 or str(currentNumber).find('7') != -1:\n        totalPass -= 1\n        peopleCounts[currentIndex] += 1\n    currentNumber += 1\n    currentIndex = (currentIndex + 1) % numberOfPeople\n\noutput = ' '.join(map(str, peopleCounts))\nprint(output)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (countsStr) => {\n  let counts = countsStr.split(\" \").map(Number);\n  let totalPass = counts.reduce((sum, count) => sum + count, 0);\n  let numberOfPeople = counts.length;\n  let peopleCounts = new Array(numberOfPeople).fill(0);\n\n  let currentNumber = 1;\n  let currentIndex = 0;\n  while (totalPass > 0) {\n    if (currentNumber % 7 === 0 || currentNumber.toString().includes(\"7\")) {\n      totalPass--;\n      peopleCounts[currentIndex]++;\n    }\n    currentNumber++;\n    currentIndex = (currentIndex + 1) % numberOfPeople;\n  }\n\n  const result = peopleCounts.join(\" \");\n  console.log(result);\n\n  rl.close();\n});",
      "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  string line;\n  getline(cin, line);\n  istringstream iss(line);\n  \n  vector<int> counts;\n  int count;\n  while (iss >> count) {\n    counts.push_back(count);\n  }\n  \n  int totalPass = 0;\n  for (int i = 0; i < counts.size(); i++) {\n    totalPass += counts[i];\n  }\n  \n  int numberOfPeople = counts.size();\n  vector<int> peopleCounts(numberOfPeople, 0);\n  \n  int currentNumber = 1;\n  int currentIndex = 0;\n  while (totalPass > 0) {\n    if (currentNumber % 7 == 0 || to_string(currentNumber).find(\"7\") != string::npos) {\n      totalPass--;\n      peopleCounts[currentIndex]++;\n    }\n    currentNumber++;\n    currentIndex = (currentIndex + 1) % numberOfPeople;\n  }\n  \n  string output;\n  for (int i = 0; i < peopleCounts.size(); i++) {\n    output += to_string(peopleCounts[i]) + \" \";\n  }\n  output = output.substr(0, output.size() - 1);\n  \n  cout << output << endl;\n  \n  return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 判断一个数字是否是7的倍数或包含数字7\nint isPassNumber(int number) {\n    if (number % 7 == 0) return 1;\n    while (number > 0) {\n        if (number % 10 == 7) return 1;\n        number /= 10;\n    }\n    return 0;\n}\n\nint main() {\n    char input[1000]; // 用于存储输入行的字符数组\n    fgets(input, sizeof(input), stdin); // 读取输入的整行字符串\n\n    // 计算有多少人（即数字个数）\n    int numberOfPeople = 0;\n    for (int i = 0; input[i] != '\\0'; i++) {\n        if (input[i] == ' ') numberOfPeople++;\n    }\n    numberOfPeople++; // 数字个数等于空格数加1\n\n    int counts[numberOfPeople]; // 用于存储每个人的“喊过”次数\n    int peopleCounts[numberOfPeople]; // 用于存储按顺序计算的每个人“喊过”次数\n    memset(peopleCounts, 0, sizeof(peopleCounts)); // 初始化peopleCounts数组为0\n\n    // 将输入的字符串转换为整数数组\n    char* token = strtok(input, \" \");\n    for (int i = 0; i < numberOfPeople; i++) {\n        counts[i] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    // 计算总共的“喊过”次数\n    int totalPass = 0;\n    for (int i = 0; i < numberOfPeople; i++) {\n        totalPass += counts[i];\n    }\n\n    int currentNumber = 1; // 当前要喊的数字\n    int currentIndex = 0; // 当前要处理的人的索引\n\n    // 模拟游戏过程\n    while (totalPass > 0) {\n        // 检查当前数字是否是7的倍数或包含7\n        if (isPassNumber(currentNumber)) {\n            totalPass--; // 总的“喊过”次数减少\n            peopleCounts[currentIndex]++; // 当前人的“喊过”次数增加\n        }\n        currentNumber++; // 增加当前数字\n        currentIndex = (currentIndex + 1) % numberOfPeople; // 更新当前人的索引\n    }\n\n    // 输出结果\n    for (int i = 0; i < numberOfPeople; i++) {\n        printf(\"%d\", peopleCounts[i]);\n        if (i != numberOfPeople - 1) {\n            printf(\" \");\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
    }
  },
  {
    "id": "17",
    "title": "字符串分割转换",
    "examType": "A",
    "score": 100,
    "description": "给定一个非空字符串S，其被N个‘-’分隔成N+1的子串，给定正整数K，要求除第一个子串外，其余的子串每K个字符组成新的子串，并用‘-’分隔。\n对于新组成的每一个子串，如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母；\n反之，如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母；大小写字母的数量相等时，不做转换。",
    "inputDesc": "输入为两行，第一行为参数K，第二行为字符串S。",
    "outputDesc": "输出转换后的字符串。",
    "examples": [
      {
        "input": "abc-abCABc-4aB@",
        "output": "abc-abc-ABC-4aB-@",
        "explanation": "子串为12abc、abCABc、4aB@，第一个子串保留， 后面的子串每3个字符一组为abC、ABc、4aB、@， abC中小写字母较多，转换为abc， ABc中大写字母较多，转换为ABC， 4aB中大小写字母都为1个，不做转换， @中没有字母，连起来即12abc-abc-ABC-4aB-@"
      },
      {
        "input": "abc-abCABc-4aB@",
        "output": "abc-abCABc4aB@",
        "explanation": "子串为12abc、abCABc、4aB@，第一个子串保留， 后面的子串每12个字符一组为abCABc4aB@， 这个子串中大小写字母都为4个，不做转换， 连起来即12abc-abCABc4aB@"
      }
    ],
    "solution": "这个题目的目标是对字符串进行重新分组和大小写转换。题目的关键点和步骤如下：\n字符串分组： 给定一个字符串 S，这个字符串用 '-' 分隔成了多个子串。假设有 N 个 '-'，那么 S 被分隔成 N+1 个子串。给定一个正整数 K，要求除第一个子串外，其余的子串按照每 K 个字符重新分组。 大小写转换： 对于新分组后的每个子串，如果小写字母的数量比大写字母多，就将这个子串的所有大写字母转换为小写字母；如果大写字母的数量比小写字母多，就将这个子串的所有小写字母转换为大写字母；如果大小写字母数量相等，则保持不变。 输出要求： 第一个子串保持不变。后面的子串根据重新分组和大小写转换后的结果，再次用 '-' 分隔，形成最终的输出字符串。\n字符串分组：\n给定一个字符串 S，这个字符串用 '-' 分隔成了多个子串。假设有 N 个 '-'，那么 S 被分隔成 N+1 个子串。给定一个正整数 K，要求除第一个子串外，其余的子串按照每 K 个字符重新分组。\n大小写转换：\n对于新分组后的每个子串，如果小写字母的数量比大写字母多，就将这个子串的所有大写字母转换为小写字母；如果大写字母的数量比小写字母多，就将这个子串的所有小写字母转换为大写字母；如果大小写字母数量相等，则保持不变。\n输出要求：\n第一个子串保持不变。后面的子串根据重新分组和大小写转换后的结果，再次用 '-' 分隔，形成最终的输出字符串。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int k = Integer.parseInt(scanner.nextLine()); // 输入正整数K\n        String s = scanner.nextLine(); // 输入字符串S\n        String[] sArr = s.split(\"-\"); // 将S按照“-”分隔成N+1个子串\n        String prefix = sArr[0]; // 第一个子串\n        StringBuilder postfixSb = new StringBuilder(); // 除第一个子串外的所有子串\n        for (int i = 1; i < sArr.length; i++) {\n            postfixSb.append(sArr[i]);\n        }\n        char[] postfixChars = postfixSb.toString().toCharArray(); // 将除第一个子串外的所有子串拼接成字符数组\n        StringBuilder newSb = new StringBuilder();\n        for (int i = 0; i < postfixChars.length; i++) { // 将除第一个子串外的所有子串每K个字符组成新的子串，并用‘-’分隔\n            if ((i + 1) % k == 0 && i + 1 != postfixChars.length) {\n                newSb.append(postfixChars[i]).append(\"-\");\n            } else {\n                newSb.append(postfixChars[i]);\n            }\n        }\n        String[] newSArr = newSb.toString().split(\"-\"); // 将新组成的每一个子串按照“-”分隔\n        StringBuilder resultSb = new StringBuilder();\n        for (String str : newSArr) { // 对于新组成的每一个子串，如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母；反之，如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母；大小写字母的数量相等时，不做转换\n          \n            long upperCase = str.chars().filter(Character::isUpperCase).count();\n\n            long lowerCase = str.chars().filter(Character::isLowerCase).count();\n            if (upperCase > lowerCase) {\n                resultSb.append(str.toUpperCase()).append(\"-\");\n            } else if (lowerCase > upperCase) {\n                resultSb.append(str.toLowerCase()).append(\"-\");\n            } else {\n                resultSb.append(str).append(\"-\");\n            }\n        }\n        String postfix = resultSb.toString().substring(0, resultSb.length() - 1); // 将处理后的新组成的每一个子串按照“-”拼接成字符串\n        System.out.println(prefix + \"-\" + postfix); // 输出转换后的字符串\n    }\n}",
      "python": "k = int(input()) # 输入正整数K\ns = input() # 输入字符串S\nsArr = s.split(\"-\") # 将S按照“-”分隔成N+1个子串\nprefix = sArr[0] # 第一个子串\npostfixSb = \"\" # 除第一个子串外的所有子串\nfor i in range(1, len(sArr)):\n    postfixSb += sArr[i]\npostfixChars = list(postfixSb) # 将除第一个子串外的所有子串拼接成字符数组\nnewSb = \"\"\nfor i in range(len(postfixChars)): # 将除第一个子串外的所有子串每K个字符组成新的子串，并用‘-’分隔\n    if (i + 1) % k == 0 and i + 1 != len(postfixChars):\n        newSb += postfixChars[i] + \"-\"\n    else:\n        newSb += postfixChars[i]\nnewSArr = newSb.split(\"-\") # 将新组成的每一个子串按照“-”分隔\nresultSb = \"\"\nfor str in newSArr: # 对于新组成的每一个子串，如果它含有的小写字母比大写字母多，则将这个子串的所有大写字母转换为小写字母；反之，如果它含有的大写字母比小写字母多，则将这个子串的所有小写字母转换为大写字母；大小写字母的数量相等时，不做转换\n    upperCase = sum(1 for c in str if c.isupper())\n    lowerCase = sum(1 for c in str if c.islower())\n    if upperCase > lowerCase:\n        resultSb += str.upper() + \"-\"\n    elif lowerCase > upperCase:\n        resultSb += str.lower() + \"-\"\n    else:\n        resultSb += str + \"-\"\npostfix = resultSb[:-1] # 将处理后的新组成的每一个子串按照“-”拼接成字符串\nprint(prefix + \"-\" + postfix) # 输出转换后的字符串",
      "javascript": "const readline = require(\"readline\");\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n \nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n \n  if (lines.length === 2) {\n    const k = parseInt(lines[0]);\n    const s = lines[1];\n     const arr = s.split(\"-\");\n  const prefix = arr.shift();\n  const postfix = arr\n    .join(\"\")\n    .match(new RegExp(`.{1,${k}}`, \"g\"))\n    .map((str) => {\n      let upperCase = 0;\n      let lowerCase = 0;\n      [...str].forEach((char) => {\n        if (/[a-z]/.test(char)) lowerCase++;\n        if (/[A-Z]/.test(char)) upperCase++;\n      });\n      if (upperCase > lowerCase) {\n        return str.toUpperCase();\n      }\n      if (lowerCase > upperCase) {\n        return str.toLowerCase();\n      }\n      return str;\n    })\n    .join(\"-\");\n \n  \n    console.log(prefix + \"-\" + postfix);\n  }\n});",
      "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int k; // 用于存储输入的正整数K\n    string s; // 用于存储输入的字符串S\n    getline(cin, s); // 读取第一行输入，即正整数K\n    k = stoi(s); // 将字符串转换为整数K\n    getline(cin, s); // 读取第二行输入，即字符串S\n\n    vector<string> sArr; // 用于存储分割后的子串\n    size_t pos = 0;\n    while ((pos = s.find(\"-\")) != string::npos) { // 将字符串S按照“-”分隔成多个子串\n        string token = s.substr(0, pos); // 获取当前子串\n        sArr.push_back(token); // 将子串添加到数组中\n        s.erase(0, pos + 1); // 从原字符串中移除已处理的部分\n    }\n    sArr.push_back(s); // 添加最后一个子串（没有“-”的部分）\n\n    string prefix = sArr[0]; // 第一个子串，按照题目要求保留\n    string postfix; // 用于存储除第一个子串外的所有子串\n\n    for (int i = 1; i < sArr.size(); i++) {\n        postfix += sArr[i]; // 将所有其他子串拼接成一个字符串\n    }\n\n    vector<char> postfixChars(postfix.begin(), postfix.end()); // 将拼接后的字符串转换为字符数组\n\n    string newS = \"\"; // 用于存储重新分组后的字符串\n    for (int i = 0; i < postfixChars.size(); i++) {\n        if ((i + 1) % k == 0 && i + 1 != postfixChars.size()) {\n            newS += postfixChars[i]; // 添加当前字符\n            newS += '-'; // 在每K个字符后添加一个“-”作为分隔符\n        } else {\n            newS += postfixChars[i]; // 否则只添加当前字符\n        }\n    }\n\n    vector<string> newSArr; // 用于存储重新分组后的子串\n    pos = 0;\n    while ((pos = newS.find(\"-\")) != string::npos) { // 将重新分组后的字符串按照“-”分隔\n        string token = newS.substr(0, pos); // 获取每个新子串\n        newSArr.push_back(token); // 将子串添加到数组中\n        newS.erase(0, pos + 1); // 从原字符串中移除已处理的部分\n    }\n    newSArr.push_back(newS); // 添加最后一个子串\n\n    string result = \"\"; // 用于存储最终的结果字符串\n    for (string str : newSArr) {\n        int upperCase = count_if(str.begin(), str.end(), [](char c) { return isupper(c); }); // 统计大写字母的数量\n        int lowerCase = count_if(str.begin(), str.end(), [](char c) { return islower(c); }); // 统计小写字母的数量\n\n        // 根据大写字母和小写字母的数量决定是否进行大小写转换\n        if (upperCase > lowerCase) {\n            transform(str.begin(), str.end(), str.begin(), ::toupper); // 大写字母多，全部转换为大写\n            result += str; // 将转换后的子串添加到结果字符串中\n            result += '-'; // 添加“-”作为分隔符\n        } else if (lowerCase > upperCase) {\n            transform(str.begin(), str.end(), str.begin(), ::tolower); // 小写字母多，全部转换为小写\n            result += str; // 将转换后的子串添加到结果字符串中\n            result += '-'; // 添加“-”作为分隔符\n        } else {\n            result += str; // 大小写字母数量相等，不做转换，直接添加子串\n            result += '-'; // 添加“-”作为分隔符\n        }\n    }\n\n    result = result.substr(0, result.length() - 1); // 移除最后一个多余的“-”\n\n    cout << prefix << \"-\" << result << endl; // 输出最终的结果字符串\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_LEN 500001 // 假设字符串的最大长度不超过500000\n\n// 函数：将子串中的字母根据大小写字母数量转换为全大写或全小写\nvoid convert(char *str) {\n    int upper = 0, lower = 0;\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (isupper(str[i])) upper++;\n        if (islower(str[i])) lower++;\n    }\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (upper > lower) str[i] = toupper(str[i]);\n        if (lower > upper) str[i] = tolower(str[i]);\n    }\n}\n\nint main() {\n    int k; // 输入正整数K\n    scanf(\"%d\\n\", &k);\n    \n    char s[MAX_LEN]; // 输入字符串S\n    fgets(s, MAX_LEN, stdin);\n    s[strcspn(s, \"\\n\")] = 0; // 去除换行符\n    \n    char *token = strtok(s, \"-\"); // 第一个子串\n    printf(\"%s\", token); // 输出第一个子串\n    \n    char postfix[MAX_LEN] = \"\"; // 除第一个子串外的所有子串\n    while ((token = strtok(NULL, \"-\")) != NULL) {\n        strcat(postfix, token);\n    }\n    \n    char newStr[MAX_LEN] = \"\"; // 新组成的字符串\n    int len = strlen(postfix);\n    for (int i = 0; i < len; i++) {\n        strncat(newStr, &postfix[i], 1); // 逐个字符拼接到新字符串中\n        if ((i + 1) % k == 0 && i + 1 != len) {\n            strcat(newStr, \"-\"); // 每K个字符后添加分隔符\n        }\n    }\n    \n    char *newToken = strtok(newStr, \"-\"); // 按照“-”分隔新组成的字符串\n    while (newToken != NULL) {\n        convert(newToken); // 转换子串中的字母\n        printf(\"-%s\", newToken); // 输出转换后的子串\n        newToken = strtok(NULL, \"-\"); // 继续获取下一个子串\n    }\n    \n    return 0;\n}"
    }
  },
  {
    "id": "18",
    "title": "字符统计及重排",
    "examType": "A",
    "score": 100,
    "description": "给出一个仅包含字母的字符串，不包含空格，统计字符串中各个字母（区分大小写）出现的次数，\n并按照字母出现次数从大到小的顺序。输出各个字母及其出现次数。\n如果次数相同，按照自然顺序进行排序，且小写字母在大写字母之前。",
    "inputDesc": "输入一行，为一个仅包含字母的字符串。",
    "outputDesc": "按照字母出现次数从大到小的顺序输出各个字母和字母次数，用英文分号分隔，注意末尾的分号；\n字母和次数间用英文冒号分隔。",
    "examples": [
      {
        "input": "xyxyXX",
        "output": "x:2;y:2;X:2;",
        "explanation": "无"
      },
      {
        "input": "abababb",
        "output": "b:4;a:3;",
        "explanation": "b的出现个数比a多，故b排在a之前"
      }
    ],
    "solution": "本题要求对给定的字符串中的字母进行统计，并根据字母的出现次数进行排序，输出格式为 字母:出现次数，并用分号分隔每组结果。需要注意以下几点关键要求：\n区分大小写：小写字母和大写字母被视为不同的字母。例如，a 和 A 是不同的字符。按照字母出现次数排序：首先，输出出现次数最多的字母。如果多个字母的出现次数相同，则需要进一步排序。自然顺序排序： 如果出现次数相同，按照字母的自然顺序进行排序。这里的“自然顺序”指的是 ASCII 顺序。小写字母的 ASCII 值比大写字母的 ASCII 值大，因此需要对同一出现次数的字母进行特殊处理，即 小写字母在同等出现次数的情况下要排在大写字母之前。\n如果出现次数相同，按照字母的自然顺序进行排序。这里的“自然顺序”指的是 ASCII 顺序。小写字母的 ASCII 值比大写字母的 ASCII 值大，因此需要对同一出现次数的字母进行特殊处理，即 小写字母在同等出现次数的情况下要排在大写字母之前。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.nextLine(); //读入字符串\n\n        int[] count = new int[256]; //用一个数组记录每个字符出现的次数\n        for (char ch : str.toCharArray()) {\n            count[ch]++;\n        }\n\n        int max_count = Arrays.stream(count).max().getAsInt(); //获取出现次数最多的字符的出现次数\n        StringBuilder result = new StringBuilder();\n        for (int i = max_count; i > 0; i--) { //从出现次数最多的开始遍历\n            for (int j = 'a'; j <= 'z'; j++) { //先输出小写字母\n                if (count[j] == i) {\n                    result.append((char)j);\n                    result.append(\":\");\n                    result.append(i);\n                    result.append(\";\");\n                }\n            }\n            for (int j = 'A'; j <= 'Z'; j++) { //再输出大写字母\n                if (count[j] == i) {\n                    result.append((char)j);\n                    result.append(\":\");\n                    result.append(i);\n                    result.append(\";\");\n                }\n            }\n        }\n        System.out.println(result.toString());\n    }\n}",
      "python": "import sys\n\nstr1 = input() #读入字符串\n\ncount = [0] * 256 #用一个数组记录每个字符出现的次数\nfor ch in str1:\n    count[ord(ch)] += 1\n\nmax_count = max(count) #获取出现次数最多的字符的出现次数\nresult = \"\"\nfor i in range(max_count, 0, -1): #从出现次数最多的开始遍历\n    for j in range(ord('a'), ord('z')+1): #先输出小写字母\n        if count[j] == i:\n            result += chr(j)\n            result += \":\"\n            result += str(i)\n            result += \";\"\n    for j in range(ord('A'), ord('Z')+1): #再输出大写字母\n        if count[j] == i:\n            result += chr(j)\n            result += \":\"\n            result += str(i)\n            result += \";\"\n\nprint(result)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (input) => {\n  let str = input.trim();\n  let count = new Array(256).fill(0);\n  for (let i = 0; i < str.length; i++) {\n    let ch = str.charCodeAt(i);\n    count[ch]++;\n  }\n  let max_count = Math.max(...count);\n  let result = '';\n  for (let i = max_count; i > 0; i--) {\n    for (let j = 97; j <= 122; j++) {\n      if (count[j] === i) {\n        result += String.fromCharCode(j) + ':' + i + ';';\n      }\n    }\n    for (let j = 65; j <= 90; j++) {\n      if (count[j] === i) {\n        result += String.fromCharCode(j) + ':' + i + ';';\n      }\n    }\n  }\n  console.log(result);\n});",
      "cpp": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    string str;\n    getline(cin, str); //读入字符串\n\n    vector<int> count(256, 0); //用一个容器记录每个字符出现的次数\n    for (char ch : str) {\n        count[ch]++;\n    }\n\n    int max_count = *max_element(count.begin(), count.end()); //获取出现次数最多的字符的出现次数\n    string result;\n    for (int i = max_count; i > 0; i--) { //从出现次数最多的开始遍历\n        for (int j = 'a'; j <= 'z'; j++) { //先输出小写字母\n            if (count[j] == i) {\n                result.push_back(j);\n                result.append(\":\");\n                result.append(to_string(i));\n                result.append(\";\");\n            }\n        }\n        for (int j = 'A'; j <= 'Z'; j++) { //再输出大写字母\n            if (count[j] == i) {\n                result.push_back(j);\n                result.append(\":\");\n                result.append(to_string(i));\n                result.append(\";\");\n            }\n        }\n    }\n    cout << result << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[1000];  // 定义字符串，最大长度为1000\n    fgets(str, 1000, stdin);  // 从输入中读取一行字符串\n\n    int count[256] = {0};  // 定义一个数组，记录每个字符出现的次数，初始化为0\n\n    // 遍历输入的字符串，统计每个字符出现的次数\n    for (int i = 0; i < strlen(str); i++) {\n        count[(unsigned char)str[i]]++;\n    }\n\n    // 找到出现次数最多的字符的出现次数\n    int max_count = 0;\n    for (int i = 0; i < 256; i++) {\n        if (count[i] > max_count) {\n            max_count = count[i];\n        }\n    }\n\n    // 输出结果，按照出现次数从大到小的顺序\n    for (int i = max_count; i > 0; i--) {\n        // 输出小写字母\n        for (int j = 'a'; j <= 'z'; j++) {\n            if (count[j] == i) {\n                printf(\"%c:%d;\", j, i);  // 输出字符及其出现次数\n            }\n        }\n\n        // 输出大写字母\n        for (int j = 'A'; j <= 'Z'; j++) {\n            if (count[j] == i) {\n                printf(\"%c:%d;\", j, i);  // 输出字符及其出现次数\n            }\n        }\n    }\n\n    printf(\"\\n\");  // 输出换行符，表示结束\n    return 0;\n}"
    }
  },
  {
    "id": "19",
    "title": "开心消消乐",
    "examType": "A",
    "score": 100,
    "description": "给定一个N行M列的二维矩阵，矩阵中每个位置的数字取值为0或1。矩阵示例如：\n1234\n现需要将矩阵中所有的1进行反转为0，规则如下：\n当点击一个1时，该1便被反转为0，同时相邻的上、下、左、右，以及左上、左下、右上、右下8 个方向的1（如果存在1）均会自动反转为0；进一步地，一个位置上的1被反转为0时，与其相邻的8个方向的1（如果存在1）均会自动反转为0；\n按照上述规则示例中的矩阵只最少需要点击2次后，所有值均为0。\n请问，给定一个矩阵，最少需要点击几次后，所有数字均为0？",
    "inputDesc": "第一行为两个整数，分别表示句子的行数 N 和列数 M，取值范围均为 [1, 100]\n接下来 N 行表示矩阵的初始值，每行均为 M 个数，取值范围 [0, 1]",
    "outputDesc": "输出一个整数，表示最少需要点击的次数",
    "examples": [
      {
        "input": "3\n 0 1\n 1 0\n 0 1",
        "output": "",
        "explanation": "上述样例中，四个角上的 1 均在中间的 1 的相邻 8 个方向上，因此只需要点击一次即可"
      },
      {
        "input": "输入：\n 4\n 1 0 0\n 0 0 1\n 0 1 1\n 1 1 1",
        "output": "输入：\n 3\n 0 1\n 1 0\n 0 1",
        "explanation": ""
      }
    ],
    "solution": "本题的原型题：https://leetcode.cn/problems/number-of-islands/description/\n给定一个二维矩阵，矩阵中的每个元素取值为0或1。题目要求我们通过点击矩阵中的1，将其反转为0，并且它周围8个方向上的1也会被自动反转为0，直到所有的1都被反转成0。我们需要找到最少点击次数，使得所有的1都变为0。\n这个问题可以看作是一个联通区域的统计问题。每次点击一个1，它不仅自身变为0，它所在的整个联通的1的区域（包括上下左右以及四个对角线上的方向）都会变为0。因此，求最少点击次数相当于求矩阵中有多少个1的联通区域。\n每个联通区域内的1可以通过一次点击全部变为0，因此我们只需找到有多少个这样的联通区域，就能得出最少的点击次数。",
    "codes": {
      "java": "import java.util.Scanner;\n\nclass Main {\n    public static void main(String[] args) {\n        // 处理输入\n        Scanner in = new Scanner(System.in);\n        int rows = in.nextInt(); // 输入矩阵的行数\n        int cols = in.nextInt(); // 输入矩阵的列数\n        int[][] matrix = new int[rows][cols]; // 定义一个rows行cols列的矩阵\n        for (int i = 0; i < rows; i++) { // 遍历矩阵的每一行\n            for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n                matrix[i][j] = in.nextInt(); // 读入矩阵的每一个元素\n            }\n        }\n\n        int result = 0; // 定义结果变量，表示矩阵中1的连通块数量\n        for (int i = 0; i < rows; i++) { // 遍历矩阵的每一行\n            for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n                // 从任意一个位置的1开始遍历\n                if (matrix[i][j] == 1) { // 如果当前位置是1\n                    result++; // 连通块数量加1\n                    dfs(matrix, i, j); // 对以当前位置为起点的连通块进行深度优先遍历\n                }\n            }\n        }\n        System.out.println(result); // 输出矩阵中1的连通块数量\n    }\n\n    public static void dfs(int[][] matrix, int x, int y) {\n        matrix[x][y] = 0; // 将当前位置的值设为0，表示已经遍历过\n        int rows = matrix.length; // 矩阵的行数\n        int cols = matrix[0].length; // 矩阵的列数\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}}; // 定义8个方向的偏移量\n        for (int[] dir : directions) { // 遍历8个方向\n            int nextX = x + dir[0]; // 计算下一个位置的行坐标\n            int nextY = y + dir[1]; // 计算下一个位置的列坐标\n            if (nextX >= 0 && nextX < rows && nextY >= 0 && nextY < cols && matrix[nextX][nextY] == 1) { // 如果下一个位置在矩阵范围内且值为1\n                dfs(matrix, nextX, nextY); // 对下一个位置进行深度优先遍历\n            }\n        }\n    }\n}",
      "python": "def dfs(matrix, x, y):\n    matrix[x][y] = 0 # 将当前位置的值设为0，表示已经遍历过\n    rows, cols = len(matrix), len(matrix[0]) # 矩阵的行数和列数\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] # 定义8个方向的偏移量\n    for dir in directions: # 遍历8个方向\n        nextX, nextY = x + dir[0], y + dir[1] # 计算下一个位置的行坐标和列坐标\n        if 0 <= nextX < rows and 0 <= nextY < cols and matrix[nextX][nextY] == 1: # 如果下一个位置在矩阵范围内且值为1\n            dfs(matrix, nextX, nextY) # 对下一个位置进行深度优先遍历\nrows, cols = map(int, input().split()) # 输入矩阵的行数和列数\nmatrix = [] # 定义一个空列表存放矩阵\nfor i in range(rows): # 遍历矩阵的每一行\n    row = list(map(int, input().split())) # 读入矩阵的每一行\n    matrix.append(row) # 将每一行添加到矩阵中\n\nresult = 0 # 定义结果变量，表示矩阵中1的连通块数量\nfor i in range(rows): # 遍历矩阵的每一行\n    for j in range(cols): # 遍历矩阵的每一列\n        # 从任意一个位置的1开始遍历\n        if matrix[i][j] == 1: # 如果当前位置是1\n            result += 1 # 连通块数量加1\n            dfs(matrix, i, j) # 对以当前位置为起点的连通块进行深度优先遍历\n\nprint(result) # 输出矩阵中1的连通块数量",
      "javascript": "function dfs(matrix, x, y) {\n  matrix[x][y] = 0; // 将当前位置的值设为0，表示已经遍历过\n  const rows = matrix.length;\n  const cols = matrix[0].length; // 矩阵的行数和列数\n  const directions = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n    [-1, -1],\n    [-1, 1],\n    [1, -1],\n    [1, 1],\n  ]; // 定义8个方向的偏移量\n  for (let dir of directions) {\n    // 遍历8个方向\n    const nextX = x + dir[0];\n    const nextY = y + dir[1]; // 计算下一个位置的行坐标和列坐标\n    if (\n      nextX >= 0 &&\n      nextX < rows &&\n      nextY >= 0 &&\n      nextY < cols &&\n      matrix[nextX][nextY] === 1\n    ) {\n      // 如果下一个位置在矩阵范围内且值为1\n      dfs(matrix, nextX, nextY); // 对下一个位置进行深度优先遍历\n    }\n  }\n}\n\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nlet rows, cols;\nlet matrix = []; // 定义一个空列表存放矩阵\n\nrl.on(\"line\", (line) => {\n  if (!rows && !cols) {\n    [rows, cols] = line.split(\" \").map(Number); // 输入矩阵的行数和列数\n  } else {\n    const row = line.split(\" \").map(Number); // 读入矩阵的每一行\n    matrix.push(row); // 将每一行添加到矩阵中\n    if (matrix.length === rows) {\n      let result = 0; // 定义结果变量，表示矩阵中1的连通块数量\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n          // 从任意一个位置的1开始遍历\n          if (matrix[i][j] === 1) {\n            // 如果当前位置是1\n            result += 1; // 连通块数量加1\n            dfs(matrix, i, j); // 对以当前位置为起点的连通块进行深度优先遍历\n          }\n        }\n      }\n      console.log(result); // 输出矩阵中1的连通块数量\n      rl.close();\n    }\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfs(vector<vector<int>>& matrix, int x, int y) {\n    matrix[x][y] = 0; // 将当前位置的值设为0，表示已经遍历过\n    int rows = matrix.size(); // 矩阵的行数\n    int cols = matrix[0].size(); // 矩阵的列数\n    vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}}; // 定义8个方向的偏移量\n    for (auto dir : directions) { // 遍历8个方向\n        int nextX = x + dir[0]; // 计算下一个位置的行坐标\n        int nextY = y + dir[1]; // 计算下一个位置的列坐标\n        if (nextX >= 0 && nextX < rows && nextY >= 0 && nextY < cols && matrix[nextX][nextY] == 1) { // 如果下一个位置在矩阵范围内且值为1\n            dfs(matrix, nextX, nextY); // 对下一个位置进行深度优先遍历\n        }\n    }\n}\n\nint main() {\n    // 处理输入\n    int rows, cols;\n    cin >> rows >> cols; // 输入矩阵的行数和列数\n    vector<vector<int>> matrix(rows, vector<int>(cols)); // 定义一个rows行cols列的矩阵\n    for (int i = 0; i < rows; i++) { // 遍历矩阵的每一行\n        for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n            cin >> matrix[i][j]; // 读入矩阵的每一个元素\n        }\n    }\n\n    int result = 0; // 定义结果变量，表示矩阵中1的连通块数量\n    for (int i = 0; i < rows; i++) { // 遍历矩阵的每一行\n        for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n            // 从任意一个位置的1开始遍历\n            if (matrix[i][j] == 1) { // 如果当前位置是1\n                result++; // 连通块数量加1\n                dfs(matrix, i, j); // 对以当前位置为起点的连通块进行深度优先遍历\n            }\n        }\n    }\n    cout << result << endl; // 输出矩阵中1的连通块数量\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\n#define MAXN 100\n\nint matrix[MAXN][MAXN];\nint rows, cols;\n\n// 8个方向的移动向量\nint directions[8][2] = {\n    {-1, 0}, {1, 0}, {0, -1}, {0, 1}, \n    {-1, -1}, {-1, 1}, {1, -1}, {1, 1}\n};\n\n// 深度优先搜索\nvoid dfs(int x, int y) {\n    // 将当前位置的值设为0，表示已经遍历过\n    matrix[x][y] = 0;\n\n    // 遍历8个方向\n    for (int i = 0; i < 8; i++) {\n        int nextX = x + directions[i][0];\n        int nextY = y + directions[i][1];\n\n        // 判断下一个位置是否在矩阵范围内且值为1\n        if (nextX >= 0 && nextX < rows && nextY >= 0 && nextY < cols && matrix[nextX][nextY] == 1) {\n            dfs(nextX, nextY);\n        }\n    }\n}\n\nint main() {\n    // 处理输入\n    scanf(\"%d %d\", &rows, &cols);\n\n    // 读入矩阵的每一个元素\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n\n    int result = 0; // 定义结果变量，表示矩阵中1的连通块数量\n\n    // 遍历矩阵的每一个元素\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            // 从任意一个位置的1开始遍历\n            if (matrix[i][j] == 1) {\n                result++; // 连通块数量加1\n                dfs(i, j); // 对以当前位置为起点的连通块进行深度优先遍历\n            }\n        }\n    }\n\n    // 输出结果\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}"
    }
  },
  {
    "id": "20",
    "title": "恢复数字序列",
    "examType": "A",
    "score": 100,
    "description": "对于一个连续正整数组成的序列，可以将其拼接成一个字符串，再将字符串里的部分字符打乱顺序。如序列8 9 10 11 12，拼接成的字符串为89101112，打乱一部分字符后得到90811211，原来的正整数10就被拆成了0和1。\n现给定一个按如上规则得到的打乱字符的字符串，请将其还原成连续正整数序列，并输出序列中最小的数字。",
    "inputDesc": "输入一行，为打乱字符的字符串和正整数序列的长度，两者间用空格分隔，字符串长度不超过200，正整数不超过1000，保证输入可以还原成唯一序列。",
    "outputDesc": "输出一个数字，为序列中最小的数字。",
    "examples": [
      {
        "input": "5",
        "output": "",
        "explanation": ""
      },
      {
        "input": "4",
        "output": "",
        "explanation": ""
      },
      {
        "input": "输入：19801211 5\n输出：8",
        "output": "输入：432111111111 4\n输出：111",
        "explanation": ""
      }
    ],
    "solution": "题目要求从一个打乱了部分字符的字符串中还原出一个连续的正整数序列，找出其中最小的数字。\n输入内容： 字符串部分：表示将某个连续正整数序列拼接后、打乱部分字符得到的字符串。序列长度部分：表示原来的连续正整数序列中有多少个数字。 任务： 根据打乱后的字符串和给定的序列长度，找出原来连续正整数序列的最小数字。注意：输入字符串是由原来的一些连续正整数组成的，但某些数字可能被拆分成了单个字符，且这些字符被打乱后可能不再连贯。因此，需要将这些打乱的字符重新组合成连续的正整数。 关键点： 字符打乱：原本连续的数字可能在字符串中被拆分并打乱顺序，因此需要将它们重新组合成完整的数字。唯一还原性：题目保证每一个输入都能还原成唯一的连续正整数序列，这意味着不存在多个可能的解。\n字符串部分：表示将某个连续正整数序列拼接后、打乱部分字符得到的字符串。序列长度部分：表示原来的连续正整数序列中有多少个数字。\n根据打乱后的字符串和给定的序列长度，找出原来连续正整数序列的最小数字。注意：输入字符串是由原来的一些连续正整数组成的，但某些数字可能被拆分成了单个字符，且这些字符被打乱后可能不再连贯。因此，需要将这些打乱的字符重新组合成连续的正整数。\n字符打乱：原本连续的数字可能在字符串中被拆分并打乱顺序，因此需要将它们重新组合成完整的数字。唯一还原性：题目保证每一个输入都能还原成唯一的连续正整数序列，这意味着不存在多个可能的解。",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个Scanner对象，用于读取输入\n        Scanner sc = new Scanner(System.in);\n\n        // 读取输入的打乱字符的字符串\n        String s = sc.next();\n        // 读取输入的正整数序列的长度\n        int k = sc.nextInt();\n\n        // 创建一个HashMap，用于统计打乱字符的字符串中各字符的数量\n        HashMap<Character, Integer> base = new HashMap<>();\n        // 遍历打乱字符的字符串\n        for (int i = 0; i < s.length(); i++) {\n            // 获取字符串中的字符\n            char c = s.charAt(i);\n            // 将字符及其数量存入HashMap\n            base.put(c, base.getOrDefault(c, 0) + 1);\n        }\n\n        // 初始化滑动窗口的起始位置\n        int i = 1;\n        // 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\n        while (i <= 1000 - k + 1) {\n            // 创建一个HashMap，用于计算滑动窗口内各字符的数量\n            HashMap<Character, Integer> count = new HashMap<>();\n            // 遍历滑动窗口内的正整数\n            for (int j = i; j < i + k; j++) {\n                // 将正整数转换为字符串\n                String num = String.valueOf(j);\n                // 遍历正整数字符串中的字符\n                for (int m = 0; m < num.length(); m++) {\n                    // 获取正整数字符串中的字符\n                    char c = num.charAt(m);\n                    // 将字符及其数量存入HashMap\n                    count.put(c, count.getOrDefault(c, 0) + 1);\n                }\n            }\n\n            // 初始化一个布尔变量，用于判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n            boolean isMatch = true;\n            // 遍历打乱字符的字符串中的字符\n            for (Character c : base.keySet()) {\n                // 如果滑动窗口内的字符数量与打乱字符的字符串中的字符数量不一致，将isMatch设为false并跳出循环\n                if (!count.containsKey(c) || count.get(c) - base.get(c) != 0) {\n                    isMatch = false;\n                    break;\n                }\n            }\n\n            // 如果滑动窗口内各字符数量与打乱字符的字符串中各字符数量一致，则输出滑动窗口的起始位置并返回\n            if (isMatch) {\n                System.out.println(i);\n                return;\n            }\n\n            // 更新滑动窗口的起始位置\n            i++;\n        }\n    }\n}",
      "python": "import sys\nfrom collections import defaultdict\n\n# 读取输入的打乱字符的字符串和正整数序列的长度\ns, k = input().strip().split()\nk = int(k)\n\n# 创建一个字典，用于统计打乱字符的字符串中各字符的数量\nbase = defaultdict(int)\nfor c in s:\n    base[c] += 1\n\n# 初始化滑动窗口的起始位置\ni = 1\n# 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\nwhile i <= 1000 - k + 1:\n    # 创建一个字典，用于计算滑动窗口内各字符的数量\n    count = defaultdict(int)\n    # 遍历滑动窗口内的正整数\n    for j in range(i, i + k):\n        # 将正整数转换为字符串\n        num = str(j)\n        # 遍历正整数字符串中的字符\n        for c in num:\n            # 将字符及其数量存入字典\n            count[c] += 1\n\n    # 初始化一个布尔变量，用于判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n    is_match = True\n    # 遍历打乱字符的字符串中的字符\n    for c in base:\n        # 如果滑动窗口内的字符数量与打乱字符的字符串中的字符数量不一致，将is_match设为False并跳出循环\n        if count[c] != base[c]:\n            is_match = False\n            break\n\n    # 如果滑动窗口内各字符数量与打乱字符的字符串中各字符数量一致，则输出滑动窗口的起始位置并退出循环\n    if is_match:\n        print(i)\n        break\n\n    # 更新滑动窗口的起始位置\n    i += 1",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (input) => {\n  // 输入打乱字符的字符串和正整数序列的长度\n  const s = input.split(' ')[0];\n  const k = parseInt(input.split(' ')[1]);\n\n  // 创建一个Map，用于统计打乱字符的字符串中各字符的数量\n  const base = new Map();\n  for (const c of s) {\n    base.set(c, (base.get(c) || 0) + 1);\n  }\n\n  // 初始化滑动窗口的起始位置\n  let i = 1;\n  // 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\n  while (i <= 1000 - k + 1) {\n    // 创建一个Map，用于计算滑动窗口内各字符的数量\n    const count = new Map();\n    // 遍历滑动窗口内的正整数\n    for (let j = i; j < i + k; j++) {\n      // 将正整数转换为字符串\n      const num = String(j);\n      // 遍历正整数字符串中的字符\n      for (const c of num) {\n        // 将字符及其数量存入Map\n        count.set(c, (count.get(c) || 0) + 1);\n      }\n    }\n\n    // 初始化一个布尔变量，用于判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n    let isMatch = true;\n    // 遍历打乱字符的字符串中的字符\n    for (const c of base.keys()) {\n      // 如果滑动窗口内的字符数量与打乱字符的字符串中的字符数量不一致，将isMatch设为false并跳出循环\n      if (!count.has(c) || count.get(c) - base.get(c) !== 0) {\n        isMatch = false;\n        break;\n      }\n    }\n\n    // 如果滑动窗口内各字符数量与打乱字符的字符串中各字符数量一致，则输出滑动窗口的起始位置并返回\n    if (isMatch) {\n      console.log(i);\n      return;\n    }\n\n    // 更新滑动窗口的起始位置\n    i++;\n  }\n});",
      "cpp": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\nint main() {\n    // 创建一个字符串变量，用于读取输入的打乱字符的字符串\n    std::string s;\n    // 创建一个整数变量，用于读取输入的正整数序列的长度\n    int k;\n\n    // 读取输入\n    std::cin >> s >> k;\n\n    // 创建一个unordered_map，用于统计打乱字符的字符串中各字符的数量\n    std::unordered_map<char, int> base;\n    // 遍历打乱字符的字符串\n    for (char c : s) {\n        // 将字符及其数量存入unordered_map\n        base[c]++;\n    }\n\n    // 初始化滑动窗口的起始位置\n    int i = 1;\n    // 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\n    while (i <= 1000 - k + 1) {\n        // 创建一个unordered_map，用于计算滑动窗口内各字符的数量\n        std::unordered_map<char, int> count;\n        // 遍历滑动窗口内的正整数\n        for (int j = i; j < i + k; j++) {\n            // 将正整数转换为字符串\n            std::string num = std::to_string(j);\n            // 遍历正整数字符串中的字符\n            for (char c : num) {\n                // 将字符及其数量存入unordered_map\n                count[c]++;\n            }\n        }\n\n        // 初始化一个布尔变量，用于判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n        bool isMatch = true;\n        // 遍历打乱字符的字符串中的字符\n        for (const auto& p : base) {\n            char c = p.first;\n            // 如果滑动窗口内的字符数量与打乱字符的字符串中的字符数量不一致，将isMatch设为false并跳出循环\n            if (count[c] != base[c]) {\n                isMatch = false;\n                break;\n            }\n        }\n\n        // 如果滑动窗口内各字符数量与打乱字符的字符串中各字符数量一致，则输出滑动窗口的起始位置并返回\n        if (isMatch) {\n            std::cout << i << std::endl;\n            return 0;\n        }\n\n        // 更新滑动窗口的起始位置\n        i++;\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nint main() {\n    char s[201]; // 输入的打乱字符的字符串，长度不超过200\n    int k;       // 正整数序列的长度\n\n    // 读取输入\n    scanf(\"%s %d\", s, &k);\n\n    int base[10] = {0}; // 用于统计打乱字符的字符串中各数字字符的数量\n\n    // 遍历打乱字符的字符串，统计各字符的数量\n    for (int i = 0; i < strlen(s); i++) {\n        base[s[i] - '0']++; // 将字符数字转为整型进行统计\n    }\n\n    // 初始化滑动窗口的起始位置\n    int i = 1;\n    \n    // 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\n    while (i <= 1000 - k + 1) {\n        int count[10] = {0}; // 用于计算滑动窗口内各字符的数量\n\n        // 遍历滑动窗口内的正整数\n        for (int j = i; j < i + k; j++) {\n            char num[6];\n            sprintf(num, \"%d\", j); // 将正整数转换为字符串\n            \n            // 遍历正整数字符串中的字符，统计各字符数量\n            for (int x = 0; x < strlen(num); x++) {\n                count[num[x] - '0']++; // 将字符数字转为整型进行统计\n            }\n        }\n\n        // 判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n        bool isMatch = true;\n        for (int c = 0; c < 10; c++) {\n            if (count[c] != base[c]) {\n                isMatch = false;\n                break;\n            }\n        }\n\n        // 如果滑动窗口内各字符数量一致，输出滑动窗口的起始位置并退出程序\n        if (isMatch) {\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n\n        // 更新滑动窗口的起始位置\n        i++;\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "21",
    "title": "悄悄话",
    "examType": "A",
    "score": 100,
    "description": "给定一个二叉树，每个节点上站一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。\n初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。",
    "inputDesc": "给定二叉树\n0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2\n注：-1表示空节点\n",
    "outputDesc": "返回所有节点都接收到悄悄话花费的时间\n38",
    "examples": [],
    "solution": "读取输入： 读取一行输入，这行输入包含了一系列的整数，每个整数代表从父节点到子节点的悄悄话传递时间。 处理根节点： 将根节点（索引为0）加入队列，并设置其悄悄话接收时间为0。 层次遍历： 当队列不为空时，循环执行以下步骤： 从队列中取出一个节点（包括节点索引和该节点的悄悄话接收时间）。计算左右子节点的索引。检查左右子节点是否存在（索引有效且不为-1）。 更新子节点时间： 如果子节点存在，将当前节点的悄悄话接收时间加上从当前节点到子节点的悄悄话传递时间，得到子节点的悄悄话接收时间。将子节点及其悄悄话接收时间加入队列。 更新最大时间： 每次子节点的悄悄话接收时间被计算后，更新最大时间为当前子节点时间和已记录的最大时间中的较大值。\n读取一行输入，这行输入包含了一系列的整数，每个整数代表从父节点到子节点的悄悄话传递时间。\n将根节点（索引为0）加入队列，并设置其悄悄话接收时间为0。\n当队列不为空时，循环执行以下步骤： 从队列中取出一个节点（包括节点索引和该节点的悄悄话接收时间）。计算左右子节点的索引。检查左右子节点是否存在（索引有效且不为-1）。\n从队列中取出一个节点（包括节点索引和该节点的悄悄话接收时间）。计算左右子节点的索引。检查左右子节点是否存在（索引有效且不为-1）。\n如果子节点存在，将当前节点的悄悄话接收时间加上从当前节点到子节点的悄悄话传递时间，得到子节点的悄悄话接收时间。将子节点及其悄悄话接收时间加入队列。\n每次子节点的悄悄话接收时间被计算后，更新最大时间为当前子节点时间和已记录的最大时间中的较大值。\n给定的输入数组0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2代表一棵二叉树，其中每个值代表从父节点到子节点的悄悄话传递时间。数组中的-1表示没有子节点。数组索引代表节点的顺序，按照完全二叉树的顺序排列。\n模拟计算过程如下：\n初始化队列： 将根节点索引0加入队列，此时队列为[0]。 开始层次遍历： 队列非空，继续遍历。 处理根节点： 取出队列头部元素（根节点索引0），队列变为[]。计算左子节点索引1（2*0+1），右子节点索引2（2*0+2）。左子节点值为9，更新为0+9=9，加入队列，队列变为[1]。右子节点值为20，更新为0+20=20，加入队列，队列变为[1, 2]。更新maxTime为20。 处理索引为1的节点： 取出队列头部元素1，队列变为[2]。计算左子节点索引3（2*1+1），右子节点索引4（2*1+2）。左右子节点值均为-1，没有子节点，不做操作。 处理索引为2的节点： 取出队列头部元素2，队列变为[]。计算左子节点索引5（2*2+1），右子节点索引6（2*2+2）。左子节点值为15，更新为20+15=35，加入队列，队列变为[5]。右子节点值为7，更新为20+7=27，加入队列，队列变为[5, 6]。更新maxTime为35。 处理索引为5的节点： 取出队列头部元素5，队列变为[6]。计算左子节点索引11（2*5+1），右子节点索引12（2*5+2）。左子节点值为3，更新为35+3=38，加入队列，队列变为[6, 11]。右子节点值为2，更新为35+2=37，加入队列，队列变为[6, 11, 12]。更新maxTime为38。 处理索引为6的节点： 取出队列头部元素6，队列变为[11, 12]。计算左子节点索引13（2*6+1），右子节点索引14（2*6+2）。由于索引超出数组长度，没有子节点，不做操作。 处理索引为11和12的节点： 取出队列头部元素11和12，队列变为[]。由于索引超出数组长度，没有子节点，不做操作。 结束遍历： 队列为空，遍历结束。 输出结果： 最大时间maxTime为38，这是最后一个节点接收悄悄话的时间。\n初始化队列：\n将根节点索引0加入队列，此时队列为[0]。\n开始层次遍历：\n队列非空，继续遍历。\n处理根节点：\n取出队列头部元素（根节点索引0），队列变为[]。计算左子节点索引1（2*0+1），右子节点索引2（2*0+2）。左子节点值为9，更新为0+9=9，加入队列，队列变为[1]。右子节点值为20，更新为0+20=20，加入队列，队列变为[1, 2]。更新maxTime为20。\n处理索引为1的节点：\n取出队列头部元素1，队列变为[2]。计算左子节点索引3（2*1+1），右子节点索引4（2*1+2）。左右子节点值均为-1，没有子节点，不做操作。\n处理索引为2的节点：\n取出队列头部元素2，队列变为[]。计算左子节点索引5（2*2+1），右子节点索引6（2*2+2）。左子节点值为15，更新为20+15=35，加入队列，队列变为[5]。右子节点值为7，更新为20+7=27，加入队列，队列变为[5, 6]。更新maxTime为35。\n处理索引为5的节点：\n取出队列头部元素5，队列变为[6]。计算左子节点索引11（2*5+1），右子节点索引12（2*5+2）。左子节点值为3，更新为35+3=38，加入队列，队列变为[6, 11]。右子节点值为2，更新为35+2=37，加入队列，队列变为[6, 11, 12]。更新maxTime为38。\n处理索引为6的节点：\n取出队列头部元素6，队列变为[11, 12]。计算左子节点索引13（2*6+1），右子节点索引14（2*6+2）。由于索引超出数组长度，没有子节点，不做操作。\n处理索引为11和12的节点：\n取出队列头部元素11和12，队列变为[]。由于索引超出数组长度，没有子节点，不做操作。\n结束遍历：\n队列为空，遍历结束。\n输出结果：\n最大时间maxTime为38，这是最后一个节点接收悄悄话的时间。\n因此，所有节点接收悄悄话的总时间为38。\n",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建扫描器读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取一行输入并将其转换为整数数组，数组中的每个元素代表从父节点到当前节点的时间\n        int[] whisperTimes = Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 关闭扫描器\n        scanner.close();\n\n        // 记录最后一个节点接收悄悄话的时间\n        int maxTime = 0;\n\n        // 使用队列来进行二叉树的层次遍历\n        Queue<Integer> nodeQueue = new LinkedList<>();\n        // 将根节点索引0加入队列\n        nodeQueue.add(0);\n\n        // 当队列不为空时，继续遍历\n        while (!nodeQueue.isEmpty()) {\n            // 从队列中取出一个节点索引\n            int parentNodeIndex = nodeQueue.poll();\n\n            // 计算左子节点索引\n            int leftChildIndex = 2 * parentNodeIndex + 1;\n            // 计算右子节点索引\n            int rightChildIndex = 2 * parentNodeIndex + 2;\n\n            // 如果左子节点存在，处理左子节点\n            if (leftChildIndex < whisperTimes.length && whisperTimes[leftChildIndex] != -1) {\n                // 更新左子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n                // 将左子节点加入队列\n                nodeQueue.add(leftChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[leftChildIndex]);\n            }\n\n            // 如果右子节点存在，处理右子节点\n            if (rightChildIndex < whisperTimes.length && whisperTimes[rightChildIndex] != -1) {\n                // 更新右子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n                // 将右子节点加入队列\n                nodeQueue.add(rightChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[rightChildIndex]);\n            }\n        }\n\n        // 所有节点都接收到悄悄话后，打印最大时间\n        System.out.println(maxTime);\n    }\n}",
      "python": "from collections import deque\n\n# 读取一行输入并将其转换为整数列表\n# 列表中的每个元素代表从父节点到当前节点的时间\nwhisper_times = list(map(int, input().split()))\n\n# 记录最后一个节点接收悄悄话的时间\nmax_time = 0\n\n# 使用队列来进行二叉树的层次遍历\nnode_queue = deque([0])  # 将根节点索引0加入队列\n\n# 当队列不为空时，继续遍历\nwhile node_queue:\n    # 从队列中取出一个节点索引\n    parent_node_index = node_queue.popleft()\n\n    # 计算左子节点索引\n    left_child_index = 2 * parent_node_index + 1\n    # 计算右子节点索引\n    right_child_index = 2 * parent_node_index + 2\n\n    # 如果左子节点存在，处理左子节点\n    if left_child_index < len(whisper_times) and whisper_times[left_child_index] != -1:\n        # 更新左子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[left_child_index] += whisper_times[parent_node_index]\n        # 将左子节点加入队列\n        node_queue.append(left_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[left_child_index])\n\n    # 如果右子节点存在，处理右子节点\n    if right_child_index < len(whisper_times) and whisper_times[right_child_index] != -1:\n        # 更新右子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[right_child_index] += whisper_times[parent_node_index]\n        # 将右子节点加入队列\n        node_queue.append(right_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[right_child_index])\n\n# 所有节点都接收到悄悄话后，打印最大时间\nprint(max_time)",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    // 数组中的每个元素代表从父节点到当前节点的时间\n    string line;\n    getline(cin, line);\n    istringstream iss(line);\n    vector<int> whisperTimes;\n    int time;\n    while (iss >> time) {\n        whisperTimes.push_back(time);\n    }\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用队列来进行二叉树的层次遍历\n    queue<int> nodeQueue;\n    // 将根节点索引0加入队列\n    nodeQueue.push(0);\n\n    // 当队列不为空时，继续遍历\n    while (!nodeQueue.empty()) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = nodeQueue.front();\n        nodeQueue.pop();\n\n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < whisperTimes.size() && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            nodeQueue.push(leftChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[leftChildIndex]);\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < whisperTimes.size() && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            nodeQueue.push(rightChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[rightChildIndex]);\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    cout << maxTime << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 10000 // 假设二叉树节点数不超过10000\n\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    char input[MAX_SIZE];\n    fgets(input, sizeof(input), stdin);\n    \n    int whisperTimes[MAX_SIZE];\n    int i = 0, time;\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        sscanf(token, \"%d\", &time);\n        whisperTimes[i++] = time;\n        token = strtok(NULL, \" \");\n    }\n    int length = i; // 数组长度\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用数组模拟队列进行二叉树的层次遍历\n    int queue[MAX_SIZE];\n    int front = 0, rear = 0; // 队列的头和尾索引\n\n    // 将根节点索引0加入队列\n    queue[rear++] = 0;\n\n    // 当队列不为空时，继续遍历\n    while (front < rear) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = queue[front++];\n        \n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < length && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            queue[rear++] = leftChildIndex;\n            // 更新最大时间\n            if (whisperTimes[leftChildIndex] > maxTime) {\n                maxTime = whisperTimes[leftChildIndex];\n            }\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < length && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            queue[rear++] = rightChildIndex;\n            // 更新最大时间\n            if (whisperTimes[rightChildIndex] > maxTime) {\n                maxTime = whisperTimes[rightChildIndex];\n            }\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    printf(\"%d\\n\", maxTime);\n    return 0;\n}"
    }
  },
  {
    "id": "22",
    "title": "手机App防沉迷系统",
    "examType": "A",
    "score": 100,
    "description": "智能手机方便了我们生活的同时，也侵占了我们不少的时间。“手机App防沉迷系统”能够让我们每天合理地规划手机App使用时间，在正确的时间做正确的事。\n它的大概原理是这样的：\n在一天24小时内，可以注册每个App的允许使用时段一个时间段只能使用一个AppApp有优先级，数值越高，优先级越高。注册使用时段时，如果高优先级的App时间和低优先级的时段有冲突，则系统会自动注销低优先级的时段，如果App的优先级相同，则后添加的App不能注册。\n请编程实现，根据输入数据注册App，并根据输入的时间点，返回时间点使用的App名称，如果该时间点没有注册任何App，请返回字符串“NA”。",
    "inputDesc": "第一行表示注册的App数量 N（N ≤ 100）\n第二部分包括 N 行，每行表示一条App注册数据\n最后一行输入一个时间点，程序即返回该时间点使用的App\n2 App1 1 09:00 10:00 App2 2 11:00 11:30 09:30\n数据说明如下：\nN行注册数据以空格分隔，四项数依次表示：App名称、优先级、起始时间、结束时间优先级1~5，数字越大，优先级越高时间格式 HH:MM，小时和分钟都是两位，不足两位前面补0起始时间需小于结束时间，否则注册不上注册信息中的时间段包含起始时间点，不包含结束时间点",
    "outputDesc": "输出一个字符串，表示App名称，或NA表示空闲时间",
    "examples": [
      {
        "input": "App1 1 09:00 10:00\n:30",
        "output": "App1",
        "explanation": "App1注册在9点到10点间，9点半可用的应用名是App1"
      },
      {
        "input": "App1 1 09:00 10:00\nApp2 2 09:10 09:30\n:20",
        "output": "App2",
        "explanation": "APP1和App2的时段有冲突，App2优先级高，注册App2之后，App1自动注销，因此输出App2。"
      },
      {
        "input": "App1 1 09:00 10:00\nApp2 2 09:10 09:30\n:50",
        "output": "NA",
        "explanation": ""
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n    // 定义App类，用于存储App的相关信息\n    static class App {\n        String name; // App名称\n        int priority; // App优先级\n        int startTime; // App允许使用的起始时间（以分钟为单位）\n        int endTime; // App允许使用的结束时间（以分钟为单位）\n\n        // App类的构造函数，用于创建App对象\n        public App(String name, int priority, int startTime, int endTime) {\n            this.name = name;\n            this.priority = priority;\n            this.startTime = startTime;\n            this.endTime = endTime;\n        }\n    }\n\n    // 主函数\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in); // 创建Scanner对象，用于读取标准输入\n        int n = sc.nextInt(); // 读取App数量\n\n        ArrayList<App> apps = new ArrayList<>(); // 创建App列表，用于存储所有App\n        for (int i = 0; i < n; i++) {\n            // 循环读取每个App的信息，并创建App对象添加到列表中\n            String appName = sc.next();\n            int appPriority = sc.nextInt();\n            int appStartTime = convertTime(sc.next());\n            int appEndTime = convertTime(sc.next());\n            apps.add(new App(appName, appPriority, appStartTime, appEndTime));\n        }\n\n        int queryTime = convertTime(sc.next()); // 读取查询时间，并转换为分钟\n        String appAtTime = \"NA\"; // 初始化查询时间对应的App名称为\"NA\"\n\n        // 创建已注册App列表\n        ArrayList<App> registeredApps = new ArrayList<>();\n        for (App app : apps) {\n            if (app.startTime >= app.endTime) continue; // 如果起始时间不小于结束时间，则跳过\n\n            // 遍历已注册的App列表，检查时间冲突\n            for (int i = registeredApps.size() - 1; i >= 0; i--) {\n                App registered = registeredApps.get(i);\n                // 如果存在时间冲突\n                if (Math.max(app.startTime, registered.startTime) < Math.min(app.endTime, registered.endTime)) {\n                    // 如果当前App的优先级高于已注册App的优先级\n                    if (app.priority > registered.priority) {\n                        registeredApps.remove(i); // 注销低优先级的App\n                    } else {\n                        continue; // 如果优先级不高，继续检查下一个已注册App\n                    }\n                }\n            }\n\n            // 将当前App添加到已注册App列表中\n            registeredApps.add(app);\n        }\n\n        // 遍历已注册App列表，找到查询时间对应的App\n        for (App app : registeredApps) {\n            if (queryTime >= app.startTime && queryTime < app.endTime) {\n                appAtTime = app.name; // 更新查询时间对应的App名称\n                break; // 找到后退出循环\n            }\n        }\n\n        System.out.println(appAtTime); // 输出查询时间对应的App名称\n    }\n\n    // 时间转换函数，将时间字符串转换为以分钟为单位的整数\n    private static int convertTime(String time) {\n        String[] parts = time.split(\":\"); // 将时间字符串按照\":\"分割\n        return Integer.parseInt(parts[0]) * 60 + Integer.parseInt(parts[1]); // 将小时和分钟转换为分钟\n    }\n}",
      "python": "class App:\n    \"\"\"定义App类，用于存储App的相关信息\"\"\"\n\n    def __init__(self, name, priority, start_time, end_time):\n        self.name = name  # App名称\n        self.priority = priority  # App优先级\n        self.start_time = start_time  # App允许使用的起始时间（以分钟为单位）\n        self.end_time = end_time  # App允许使用的结束时间（以分钟为单位）\n\ndef convert_time(time_str):\n    \"\"\"\n    时间转换函数，将时间字符串转换为以分钟为单位的整数\n    :param time_str: 时间字符串，格式为\"小时:分钟\"\n    :return: 转换后的分钟数\n    \"\"\"\n    hours, minutes = map(int, time_str.split(\":\"))  # 将时间字符串按照\":\"分割并转换为整数\n    return hours * 60 + minutes  # 将小时和分钟转换为分钟\n\ndef main():\n    n = int(input())  # 读取App数量\n    apps = []  # 创建App列表，用于存储所有App\n\n    for _ in range(n):\n        # 循环读取每个App的信息，并创建App对象添加到列表中\n        app_name, app_priority, app_start_time, app_end_time = input().split()\n        app_priority = int(app_priority)\n        app_start_time = convert_time(app_start_time)\n        app_end_time = convert_time(app_end_time)\n        apps.append(App(app_name, app_priority, app_start_time, app_end_time))\n\n    query_time = convert_time(input())  # 读取查询时间，并转换为分钟\n    app_at_time = \"NA\"  # 初始化查询时间对应的App名称为\"NA\"\n\n    # 创建已注册App列表\n    registered_apps = []\n    for app in apps:\n        if app.start_time >= app.end_time:\n            continue  # 如果起始时间不小于结束时间，则跳过\n\n        # 遍历已注册的App列表，检查时间冲突\n        for i in range(len(registered_apps) - 1, -1, -1):\n            registered = registered_apps[i]\n            # 如果存在时间冲突\n            if max(app.start_time, registered.start_time) < min(app.end_time, registered.end_time):\n                # 如果当前App的优先级高于已注册App的优先级\n                if app.priority > registered.priority:\n                    registered_apps.pop(i)  # 注销低优先级的App\n                else:\n                    continue  # 如果优先级不高，继续检查下一个已注册App\n\n        # 将当前App添加到已注册App列表中\n        registered_apps.append(app)\n\n    # 遍历已注册App列表，找到查询时间对应的App\n    for app in registered_apps:\n        if query_time >= app.start_time and query_time < app.end_time:\n            app_at_time = app.name  # 更新查询时间对应的App名称\n            break  # 找到后退出循环\n\n    print(app_at_time)  # 输出查询时间对应的App名称\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "const readline = require('readline');\n\n// 定义App类，用于存储App的相关信息\nclass App {\n  constructor(name, priority, startTime, endTime) {\n    this.name = name; // App名称\n    this.priority = priority; // App优先级\n    this.startTime = startTime; // App允许使用的起始时间（以分钟为单位）\n    this.endTime = endTime; // App允许使用的结束时间（以分钟为单位）\n  }\n}\n\n// 创建readline接口实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 用于存储输入行的数组\nconst lines = [];\n// 读取输入\nrl.on('line', (line) => {\n  lines.push(line);\n}).on('close', () => {\n  // 当输入完成后开始处理数据\n  processInput(lines);\n});\n\n// 处理输入数据的函数\nfunction processInput(lines) {\n  const n = parseInt(lines.shift()); // 读取App数量\n  const apps = []; // 创建App列表，用于存储所有App\n\n  for (let i = 0; i < n; i++) {\n    // 循环读取每个App的信息，并创建App对象添加到列表中\n    const [appName, appPriority, appStartTime, appEndTime] = lines.shift().split(' ');\n    apps.push(new App(appName, parseInt(appPriority), convertTime(appStartTime), convertTime(appEndTime)));\n  }\n\n  const queryTime = convertTime(lines.shift()); // 读取查询时间，并转换为分钟\n  let appAtTime = \"NA\"; // 初始化查询时间对应的App名称为\"NA\"\n\n  // 创建已注册App列表\n  const registeredApps = [];\n  for (const app of apps) {\n    if (app.startTime >= app.endTime) continue; // 如果起始时间不小于结束时间，则跳过\n\n    // 遍历已注册的App列表，检查时间冲突\n    for (let i = registeredApps.length - 1; i >= 0; i--) {\n      const registered = registeredApps[i];\n      // 如果存在时间冲突\n      if (Math.max(app.startTime, registered.startTime) < Math.min(app.endTime, registered.endTime)) {\n        // 如果当前App的优先级高于已注册App的优先级\n        if (app.priority > registered.priority) {\n          registeredApps.splice(i, 1); // 注销低优先级的App\n        } else {\n          continue; // 如果优先级不高，继续检查下一个已注册App\n        }\n      }\n    }\n\n    // 将当前App添加到已注册App列表中\n    registeredApps.push(app);\n  }\n\n  // 遍历已注册App列表，找到查询时间对应的App\n  for (const app of registeredApps) {\n    if (queryTime >= app.startTime && queryTime < app.endTime) {\n      appAtTime = app.name; // 更新查询时间对应的App名称\n      break; // 找到后退出循环\n    }\n  }\n\n  console.log(appAtTime); // 输出查询时间对应的App名称\n}\n\n// 时间转换函数，将时间字符串转换为以分钟为单位的整数\nfunction convertTime(time) {\n  const [hours, minutes] = time.split(':').map(Number); // 将时间字符串按照\":\"分割并转换为数字\n  return hours * 60 + minutes; // 将小时和分钟转换为分钟\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\n// 定义App类，用于存储App的相关信息\nclass App {\npublic:\n    std::string name; // App名称\n    int priority; // App优先级\n    int startTime; // App允许使用的起始时间（以分钟为单位）\n    int endTime; // App允许使用的结束时间（以分钟为单位）\n\n    // App类的构造函数，用于创建App对象\n    App(std::string name, int priority, int startTime, int endTime)\n        : name(name), priority(priority), startTime(startTime), endTime(endTime) {}\n};\n\n// 时间转换函数，将时间字符串转换为以分钟为单位的整数\nint convertTime(const std::string& time) {\n    int hours, minutes;\n    char colon;\n    std::istringstream iss(time);\n    iss >> hours >> colon >> minutes; // 将时间字符串按照\":\"分割并转换为小时和分钟\n    return hours * 60 + minutes; // 将小时和分钟转换为分钟\n}\n\nint main() {\n    int n; // 读取App数量\n    std::cin >> n;\n\n    std::vector<App> apps; // 创建App列表，用于存储所有App\n    for (int i = 0; i < n; i++) {\n        // 循环读取每个App的信息，并创建App对象添加到列表中\n        std::string appName;\n        int appPriority, appStartTime, appEndTime;\n        std::string startTimeStr, endTimeStr;\n        std::cin >> appName >> appPriority >> startTimeStr >> endTimeStr;\n        appStartTime = convertTime(startTimeStr);\n        appEndTime = convertTime(endTimeStr);\n        apps.emplace_back(appName, appPriority, appStartTime, appEndTime);\n    }\n\n    std::string queryTimeStr;\n    std::cin >> queryTimeStr;\n    int queryTime = convertTime(queryTimeStr); // 读取查询时间，并转换为分钟\n    std::string appAtTime = \"NA\"; // 初始化查询时间对应的App名称为\"NA\"\n\n    std::vector<App> registeredApps; // 创建已注册App列表\n    for (const App& app : apps) {\n        if (app.startTime >= app.endTime) continue; // 如果起始时间不小于结束时间，则跳过\n\n        // 遍历已注册的App列表，检查时间冲突\n        for (int i = registeredApps.size() - 1; i >= 0; --i) {\n            const App& registered = registeredApps[i];\n            // 如果存在时间冲突\n            if (std::max(app.startTime, registered.startTime) < std::min(app.endTime, registered.endTime)) {\n                // 如果当前App的优先级高于已注册App的优先级\n                if (app.priority > registered.priority) {\n                    registeredApps.erase(registeredApps.begin() + i); // 注销低优先级的App\n                } else {\n                    continue; // 如果优先级不高，继续检查下一个已注册App\n                }\n            }\n        }\n\n        // 将当前App添加到已注册App列表中\n        registeredApps.push_back(app);\n    }\n\n    // 遍历已注册App列表，找到查询时间对应的App\n    for (const App& app : registeredApps) {\n        if (queryTime >= app.startTime && queryTime < app.endTime) {\n            appAtTime = app.name; // 更新查询时间对应的App名称\n            break; // 找到后退出循环\n        }\n    }\n\n    std::cout << appAtTime << std::endl; // 输出查询时间对应的App名称\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义App结构体，用于存储App的相关信息\ntypedef struct {\n    char name[30]; // App名称\n    int priority;  // App优先级\n    int startTime; // App允许使用的起始时间（以分钟为单位）\n    int endTime;   // App允许使用的结束时间（以分钟为单位）\n} App;\n\n// 时间转换函数，将时间字符串转换为以分钟为单位的整数\nint convertTime(char *time) {\n    int hours, minutes;\n    sscanf(time, \"%d:%d\", &hours, &minutes); // 将时间字符串按照\":\"分割并转换为整数\n    return hours * 60 + minutes; // 将小时和分钟转换为分钟\n}\n\nint main() {\n    int n; // 读取App数量\n    scanf(\"%d\", &n);\n\n    App *apps = (App *)malloc(n * sizeof(App)); // 创建App数组，用于存储所有App\n\n    for (int i = 0; i < n; i++) {\n        // 循环读取每个App的信息，并创建App对象添加到数组中\n        scanf(\"%s %d\", apps[i].name, &apps[i].priority);\n        char startTimeStr[6], endTimeStr[6];\n        scanf(\"%s %s\", startTimeStr, endTimeStr);\n        apps[i].startTime = convertTime(startTimeStr);\n        apps[i].endTime = convertTime(endTimeStr);\n    }\n\n    char queryTimeStr[6];\n    scanf(\"%s\", queryTimeStr);\n    int queryTime = convertTime(queryTimeStr); // 读取查询时间，并转换为分钟\n    char *appAtTime = \"NA\"; // 初始化查询时间对应的App名称为\"NA\"\n\n    // 创建已注册App数组和计数器\n    App *registeredApps = (App *)malloc(n * sizeof(App));\n    int registeredCount = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (apps[i].startTime >= apps[i].endTime) continue; // 如果起始时间不小于结束时间，则跳过\n\n        // 遍历已注册的App数组，检查时间冲突\n        for (int j = registeredCount - 1; j >= 0; j--) {\n            // 如果存在时间冲突\n            if (apps[i].startTime < registeredApps[j].endTime && apps[i].endTime > registeredApps[j].startTime) {\n                // 如果当前App的优先级高于已注册App的优先级\n                if (apps[i].priority > registeredApps[j].priority) {\n                    // 注销低优先级的App\n                    for (int k = j; k < registeredCount - 1; k++) {\n                        registeredApps[k] = registeredApps[k + 1];\n                    }\n                    registeredCount--; // 减少已注册App的计数\n                } else {\n                    goto continue_outer; // 如果优先级不高，继续检查下一个已注册App\n                }\n            }\n        }\n\n        // 将当前App添加到已注册App数组中\n        registeredApps[registeredCount++] = apps[i];\n\n        continue_outer: ; // 标签用于跳过当前循环\n    }\n\n    // 遍历已注册App数组，找到查询时间对应的App\n    for (int i = 0; i < registeredCount; i++) {\n        if (queryTime >= registeredApps[i].startTime && queryTime < registeredApps[i].endTime) {\n            appAtTime = registeredApps[i].name; // 更新查询时间对应的App名称\n            break; // 找到后退出循环\n        }\n    }\n\n    printf(\"%s\\n\", appAtTime); // 输出查询时间对应的App名称\n\n    // 释放动态分配的内存\n    free(apps);\n    free(registeredApps);\n\n    return 0;\n}"
    }
  },
  {
    "id": "23",
    "title": "找数字找等值元素",
    "examType": "A",
    "score": 100,
    "description": "给一个二维数组 nums，对于每一个元素 nums[i]，找出距离最近的且值相等的元素，\n输出横纵坐标差值的绝对值之和，如果没有等值元素，则输出-1。",
    "inputDesc": "输入第一行为二维数组的行\n输入第二行为二维数组的列\n输入的数字以空格隔开。\n针对数组 nums[i][j]，满足 0 < i ≤ 100，0 < j ≤ 100对于每个数字，最多存在 100 个与其相等的数字",
    "outputDesc": "数组形式返回所有坐标值。",
    "examples": [
      {
        "input": "3 5 4 2\n 5 7 8 3\n 5 4 2 4",
        "output": "[[-1, 4, 2, 3, 3], [1, 1, -1, -1, 4], [1, 1, 2, 3, 2]]",
        "explanation": ""
      }
    ],
    "solution": "给定一个二维数组 nums，对于数组中的每个元素 nums[i][j]，需要找到距离最近的、与其值相等的另一个元素 nums[x][y]，并计算这两个元素之间的“曼哈顿距离”（即横纵坐标差值的绝对值之和）。 如果找不到其他等值的元素，则返回 -1。\n12345\n输入格式解释： 第一行表示二维数组有 3 行。第二行表示二维数组有 5 列。接下来的 3 行是具体的二维数组内容：0 3 5 4 2 2 5 7 8 3 2 5 4 2 4 123 输出格式解释： 输出的结果为一个二维数组，格式如下：[[-1, 4, 2, 3, 3], [1, 1, -1, -1, 4], [1, 1, 2, 3, 2]] 1\n输入格式解释：\n第一行表示二维数组有 3 行。第二行表示二维数组有 5 列。接下来的 3 行是具体的二维数组内容：0 3 5 4 2 2 5 7 8 3 2 5 4 2 4 123\n123\n输出格式解释：\n输出的结果为一个二维数组，格式如下：[[-1, 4, 2, 3, 3], [1, 1, -1, -1, 4], [1, 1, 2, 3, 2]] 1\n1\n对于每个元素，计算与其值相等的其他元素的曼哈顿距离，选择最小的距离。 示例计算： 对于 nums[0][0] = 0，没有其他值为 0 的元素，因此输出 -1。对于 nums[0][1] = 3，最近的等值元素是 nums[1][4]，距离为 |0-1| + |1-4| = 4。对于 nums[0][2] = 5，最近的等值元素是 nums[1][1]，距离为 |0-1| + |2-1| = 2。以此类推，计算其他元素的距离。\n示例计算： 对于 nums[0][0] = 0，没有其他值为 0 的元素，因此输出 -1。对于 nums[0][1] = 3，最近的等值元素是 nums[1][4]，距离为 |0-1| + |1-4| = 4。对于 nums[0][2] = 5，最近的等值元素是 nums[1][1]，距离为 |0-1| + |2-1| = 2。以此类推，计算其他元素的距离。\n对于 nums[0][0] = 0，没有其他值为 0 的元素，因此输出 -1。对于 nums[0][1] = 3，最近的等值元素是 nums[1][4]，距离为 |0-1| + |1-4| = 4。对于 nums[0][2] = 5，最近的等值元素是 nums[1][1]，距离为 |0-1| + |2-1| = 2。以此类推，计算其他元素的距离。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 读取输入的行数和列数\n        int rows = sc.nextInt(); // 输入行数\n        int cols = sc.nextInt(); // 输入列数\n\n        // 创建一个二维数组来存储输入的矩阵\n        int[][] mat = new int[rows][cols];\n        // 创建一个哈希表来记录每个数字在矩阵中的所有位置\n        Map<Integer, List<int[]>> posMap = new HashMap<>();\n\n        // 读取输入的矩阵数据并同时记录每个数字出现的位置\n        for (int r = 0; r < rows; r++) { // 遍历每一行\n            for (int c = 0; c < cols; c++) { // 遍历每一列\n                int val = sc.nextInt(); // 读取当前元素\n                mat[r][c] = val; // 将元素存入矩阵\n                // 如果哈希表中还没有这个数字，则初始化一个列表来存储位置\n                posMap.putIfAbsent(val, new ArrayList<>());\n                // 将当前元素的坐标 (r, c) 加入到数字对应的列表中\n                posMap.get(val).add(new int[]{r, c});\n            }\n        }\n\n        // 用来存放最终输出的结果矩阵\n        int[][] res = new int[rows][cols];\n\n        // 遍历矩阵中的每个元素，计算到最近的相同元素的距离\n        for (int r = 0; r < rows; r++) { // 遍历每一行\n            for (int c = 0; c < cols; c++) { // 遍历每一列\n                int val = mat[r][c]; // 获取当前元素的值\n                // 如果这个数字只出现一次，即只有一个位置，则没有相同元素，输出 -1\n                if (posMap.get(val).size() == 1) {\n                    res[r][c] = -1; // 该位置没有相同元素，返回 -1\n                } else {\n                    // 否则调用 bfs 函数，计算到最近的相同元素的距离\n                    res[r][c] = bfs(mat, posMap.get(val), r, c);\n                }\n            }\n        }\n\n        // 将结果矩阵转换为字符串并输出\n         String[] resultStrings = new String[res.length];\n        for (int i = 0; i < res.length; i++) {\n            resultStrings[i] = Arrays.toString(res[i]);\n        }\n        System.out.println(Arrays.toString(resultStrings));\n        \n    }\n\n    //  搜索函数，用于找到与 (x, y) 坐标最近的相同元素\n    private static int bfs(int[][] mat, List<int[]> positions, int x, int y) {\n        int minDist = Integer.MAX_VALUE; // 初始化最小距离为最大值\n        // 遍历所有相同数字的坐标\n        for (int[] p : positions) {\n            int px = p[0]; // 相同数字的行坐标\n            int py = p[1]; // 相同数字的列坐标\n            // 如果这个相同数字的位置与当前坐标不同\n            if (px != x || py != y) {\n                // 计算当前元素与相同数字的曼哈顿距离\n                int dist = Math.abs(px - x) + Math.abs(py - y);\n                // 更新最小距离\n                minDist = Math.min(minDist, dist);\n            }\n        }\n        return minDist; // 返回最小的距离\n    }\n}",
      "python": "import sys\nfrom collections import defaultdict\n\n# 读取输入的行数和列数\nn = int(input())\nm = int(input())\n\n# 读取矩阵数据\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# 用字典记录每个数字出现的位置\nposMap = defaultdict(list)\n\n# 遍历矩阵，记录每个数字的位置\nfor i in range(n):\n    for j in range(m):\n        num = matrix[i][j]\n        posMap[num].append((i, j))\n\n# 初始化结果矩阵\nresult = [[-1] * m for _ in range(n)]\n\n# 遍历矩阵中的每个元素，计算到最近的相同元素的距离\nfor i in range(n):\n    for j in range(m):\n        num = matrix[i][j]\n        minDist = float('inf')\n        \n        # 如果该数字只出现一次，则返回 -1\n        if len(posMap[num]) == 1:\n            result[i][j] = -1\n        else:\n            # 遍历相同数字的所有位置，计算曼哈顿距离\n            for (x, y) in posMap[num]:\n                if (x, y) != (i, j):\n                    dist = abs(x - i) + abs(y - j)\n                    minDist = min(minDist, dist)\n            \n            result[i][j] = minDist\nprint(result)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst lines = [];\nlet n, m;\n\nrl.on('line', (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    n = parseInt(lines[0]);\n    m = parseInt(lines[1]);\n  }\n\n  if (n && lines.length === n + 2) {\n    const matrix = lines.slice(2).map(line => line.split(' ').map(Number));\n    const posMap = {};\n\n    // 记录每个数字出现的位置\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        const num = matrix[i][j];\n        if (!posMap[num]) posMap[num] = [];\n        posMap[num].push([i, j]);\n      }\n    }\n\n    const result = Array.from({ length: n }, () => Array(m).fill(-1));\n\n    // 遍历矩阵，计算最近的相同元素的距离\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        const num = matrix[i][j];\n        const positions = posMap[num];\n\n        if (positions.length > 1) {\n          result[i][j] = findMinDistance(positions, i, j);\n        }\n      }\n    }\n\n    \n    console.log(JSON.stringify(result).replace(/,/g, \", \"));\n    rl.close();\n  }\n});\n\n// 计算当前位置到相同数字最近元素的曼哈顿距离\nfunction findMinDistance(positions, x, y) {\n  let minDist = Infinity;\n  for (const [px, py] of positions) {\n    if (px !== x || py !== y) {\n      const dist = Math.abs(px - x) + Math.abs(py - y);\n      minDist = Math.min(minDist, dist);\n    }\n  }\n  return minDist;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n\n    vector<vector<int>> matrix(rows, vector<int>(cols));\n    unordered_map<int, vector<pair<int, int>>> posMap;\n\n    // 读取输入的矩阵数据并记录每个数字出现的位置\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cin >> matrix[i][j];\n            posMap[matrix[i][j]].emplace_back(i, j);\n        }\n    }\n\n    vector<vector<int>> result(rows, vector<int>(cols, -1));\n\n    // 遍历矩阵中的每个元素，计算到最近的相同元素的距离\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int num = matrix[i][j];\n            int minDist = INT_MAX;\n            \n            // 如果该数字只出现一次，则直接设为 -1\n            if (posMap[num].size() > 1) {\n                // 遍历相同数字的所有位置，计算曼哈顿距离\n                for (const auto& pos : posMap[num]) {\n                    int x = pos.first;\n                    int y = pos.second;\n                    if (x != i || y != j) {\n                        int dist = abs(x - i) + abs(y - j);\n                        minDist = min(minDist, dist);\n                    }\n                }\n                result[i][j] = minDist;\n            }\n        }\n    }\n    cout << \"[\";\n    // 输出结果矩阵\n    for (int i = 0; i < rows; i++) {\n        cout << \"[\";\n        for (int j = 0; j < cols; j++) {\n            cout << result[i][j];\n            if (j != cols - 1) {\n                cout << \", \";\n            }\n        }\n        cout << \"]\" ;\n        if (i != rows - 1) {\n                cout << \", \";\n        }\n    }  \n    cout << \"]\" ;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\n// 定义最大数字值及矩阵大小的上限\n#define MAX_NUM 101\n#define MAX_SIZE 100\n\n// 定义二维数组，用于记录数字出现的坐标\nint posMap[MAX_NUM][MAX_SIZE][2];\nint posCount[MAX_NUM];  // 记录每个数字出现的次数\n\nint main() {\n    int rows, cols;\n    \n    // 输入矩阵的行数和列数\n    scanf(\"%d %d\", &rows, &cols);\n    \n    int matrix[MAX_SIZE][MAX_SIZE];   // 定义一个二维数组来存储输入的矩阵\n    int result[MAX_SIZE][MAX_SIZE];   // 定义一个二维数组来存储结果\n    \n    // 初始化 posMap 数组的计数\n    for (int i = 0; i < MAX_NUM; i++) {\n        posCount[i] = 0;\n    }\n    \n    // 读取输入的矩阵数据并记录每个数字出现的位置\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &matrix[i][j]);  // 输入矩阵的元素\n            int num = matrix[i][j];\n            // 记录数字的位置\n            posMap[num][posCount[num]][0] = i;\n            posMap[num][posCount[num]][1] = j;\n            posCount[num]++;  // 计数加一\n        }\n    }\n\n    // 初始化结果矩阵为 -1\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = -1;\n        }\n    }\n\n    // 遍历矩阵中的每个元素，计算到最近的相同元素的距离\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int num = matrix[i][j];  // 获取当前元素的值\n            int minDist = INT_MAX;   // 初始化最小距离为最大值\n            \n            // 如果该数字出现多次，计算到最近的相同数字的距离\n            if (posCount[num] > 1) {\n                for (int k = 0; k < posCount[num]; k++) {\n                    int x = posMap[num][k][0];\n                    int y = posMap[num][k][1];\n                    if (x != i || y != j) {  // 排除当前位置\n                        // 计算曼哈顿距离\n                        int dist = abs(x - i) + abs(y - j);\n                        if (dist < minDist) {\n                            minDist = dist;  // 更新最小距离\n                        }\n                    }\n                }\n                result[i][j] = minDist;  // 记录结果\n            }\n        }\n    }\n\n    // 输出结果矩阵\n    printf(\"[\");\n    for (int i = 0; i < rows; i++) {\n        printf(\"[\");\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d\", result[i][j]);\n            if (j != cols - 1) {\n                printf(\", \");\n            }\n        }\n        printf(\"]\");\n        if (i != rows - 1) {\n            printf(\", \");\n        }\n    }\n    printf(\"]\\n\");\n\n    return 0;\n}"
    }
  },
  {
    "id": "24",
    "title": "找最小数",
    "examType": "A",
    "score": 100,
    "description": "给一个正整数NUM1，计算出新正整数NUM2，NUM2为NUM1中移除N位数字后的结果，需要使得NUM2的值最小。",
    "inputDesc": "1.输入的第一行为一个字符串，字符串由0-9字符组成，记录正整数NUM1，NUM1长度小于32。 2.输入的第二行为需要移除的数字的个数，小于NUM1长度。",
    "outputDesc": "输出一个数字字符串，记录最小值NUM2。\n输入\n输出",
    "examples": [],
    "solution": "原题：https://leetcode.cn/problems/remove-k-digits/solutions/\n维护一个单调递增的栈来实现移除数字\n初始化一个空栈 stack，用于存储需要保留的数字。遍历输入的正整数 NUM1 中的每个字符。对于当前字符，检查栈顶元素是否大于当前字符，如果是，则出栈并减少需要移除的数字个数。这样可以确保移除的数字使得新正整数 NUM2 的值最小。将当前字符入栈。遍历完成后，如果仍有需要移除的数字个数，从栈顶开始移除剩余的数字。将栈中的字符连接成一个字符串，去除前导零，输出结果。如果结果为空，则输出 “0”。",
    "codes": {
      "java": "",
      "python": "",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <string>\n#include <vector>\n\nint main() {\n    // 读取输入的正整数 NUM1 和需要移除的数字个数\n    std::string num;\n    int k;\n    std::cin >> num >> k;\n\n    // 使用一个 vector 作为栈来存储结果\n    std::vector<char> stack;\n\n    // 遍历输入的数字字符串\n    for (char i : num) {\n        // 当栈非空、k 大于 0 且栈顶元素大于当前数字时，弹出栈顶元素并减小 k\n        while (!stack.empty() && k > 0 && stack.back() > i) {\n            k--;\n            stack.pop_back();\n        }\n        // 将当前数字压入栈中\n        stack.push_back(i);\n    }\n\n    // 构建结果字符串，移除多余的 k 个数字\n    std::string result(stack.begin(), stack.end() - k);\n    // 删除结果字符串中的前导零\n    result.erase(0, result.find_first_not_of('0'));\n    // 如果结果为空，则输出 \"0\"\n    if (result.empty()) {\n        result = \"0\";\n    }\n\n    // 输出结果\n    std::cout << result << std::endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    char num[32]; // 存储输入的正整数NUM1，长度小于32\n    int k;        // 需要移除的数字个数\n    scanf(\"%s %d\", num, &k); // 读取NUM1和k\n\n    char stack[32]; // 使用一个字符数组作为栈来存储结果\n    int top = -1;   // 栈顶指针，初始为-1表示空栈\n\n    // 遍历输入的数字字符串\n    for (int i = 0; i < strlen(num); i++) {\n        char current = num[i];\n        // 当栈非空、k大于0且栈顶元素大于当前数字时，弹出栈顶元素并减小k\n        while (top >= 0 && k > 0 && stack[top] > current) {\n            top--;\n            k--;\n        }\n        // 将当前数字压入栈中\n        stack[++top] = current;\n    }\n\n    // 移除多余的k个数字\n    top -= k;\n\n    // 构建结果字符串\n    char result[32];\n    for (int i = 0; i <= top; i++) {\n        result[i] = stack[i];\n    }\n    result[top + 1] = '\\0'; // 添加字符串结束符\n\n    // 删除结果字符串中的前导零\n    char *start = result;\n    while (*start == '0') {\n        start++;\n    }\n    if (*start == '\\0') { // 如果所有数字都被移除，输出\"0\"\n        printf(\"0\\n\");\n    } else {\n        printf(\"%s\\n\", start); // 输出结果\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "25",
    "title": "找终点",
    "examType": "A",
    "score": 100,
    "description": "给定一个正整数数组，设为nums，最大为100个成员，求从第一个成员开始，正好走到数组最后一个成员，所使用的最少步骤数。\n要求：\n第一步必须从第一元素开始，且1<=第一步的步长<len/2;（len为数组的长度，需要自行解析）。从第二步开始，只能以所在成员的数字走相应的步数，不能多也不能少, 如果目标不可达返回**-1**，只输出最少的步骤数量。只能向数组的尾部走，不能往回走。",
    "inputDesc": "由正整数组成的数组，以空格分隔，数组长度小于100，请自行解析数据数量。",
    "outputDesc": "正整数，表示最少的步数，如果不存在输出**-1**",
    "examples": [
      {
        "input": "5 9 4 2 6 8 3 5 4 3 9",
        "output": "",
        "explanation": "第一步： 第一个可选步长选择2，从第一个成员7开始走2步，到达9； 第二步： 从9开始，经过自身数字9对应的9个成员到最后。"
      },
      {
        "input": "2 3 7 1 5 9 3 2 1",
        "output": "-1",
        "explanation": "无"
      }
    ],
    "solution": "给定一个由正整数组成的数组，要求从数组的第一个元素开始，通过逐步前进最终到达数组的最后一个元素。你需要找出最少的步骤数，并且必须满足以下条件：\n第一步：必须从数组的第一个元素开始，步长的选择范围是1到数组长度的一半之间（即 1 ≤ 步长 < len 2 1 \\leq \\text{步长} < \\frac{\\text{len}}{2} 1≤步长<2len​）。第二步及之后：从当前停留的元素开始，必须按照该元素的值走相应的步数。例如，当前停留在值为9的元素，则你只能前进9步。只能向数组尾部前进，不能后退。如果无法到达数组的最后一个元素，则输出 -1。\n这里需要注意的是：本题是整除",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine(); // 读取用户输入的整数字符串，以空格分隔\n        String[] numberStrings = input.split(\" \"); // 将输入的字符串分割成字符串数组\n        int[] numbers = new int[numberStrings.length]; // 创建一个与字符串数组长度相同的整型数组\n        for (int i = 0; i < numberStrings.length; i++) {\n            numbers[i] = Integer.parseInt(numberStrings[i]); // 将字符串数组的每个元素转换为整数，并存入整型数组\n        }\n        int length = numbers.length; // 获取数组的长度\n        List<Integer> result = new ArrayList<>(); // 用于存储所有可能的步数结果\n        for (int i = 1; i < length / 2; i++) { // 遍历所有从第一个元素开始的有效步长\n            int step = 1; // 初始化步数为1，因为第一步已经走出\n            int index = i; // 将索引设为当前步长\n            while (index < length - 1) { // 只要没有走到数组的最后一个元素\n                index += numbers[index]; // 按照当前索引位置的数字值前进\n                step++; // 每走一步，步数加1\n            }\n            if (index == length - 1) { // 如果恰好到达数组的最后一个元素\n                result.add(step); // 将步数结果存入结果列表\n            }\n        }\n        if (result.size() > 0) {\n            Integer[] resultArray = result.toArray(new Integer[0]); // 将结果列表转换为数组\n            Arrays.sort(resultArray); // 对步数结果进行排序\n            System.out.println(resultArray[0]); // 输出最小的步数\n        } else {\n            System.out.println(-1); // 如果没有结果，输出-1\n        }\n    }\n}",
      "python": "numbers = list(map(int, input().split())) # 将输入的字符串分割并映射为整数列表\nlength = len(numbers) # 获取数组的长度\nresult = [] # 用于存储所有可能的步数结果\nfor i in range(1, length // 2): # 遍历所有从第一个元素开始的有效步长\n    step = 1 # 初始化步数为1，因为第一步已经走出\n    index = i # 将索引设为当前步长\n    while index < length - 1: # 只要没有走到数组的最后一个元素\n        index += numbers[index] # 按照当前索引位置的数字值前进\n        step += 1 # 每走一步，步数加1\n    if index == length - 1: # 如果恰好到达数组的最后一个元素\n        result.append(step) # 将步数结果存入结果列表\nif len(result) > 0:\n    result.sort() # 对步数结果进行排序\n    print(result[0]) # 输出最小的步数\nelse:\n    print(-1) # 如果没有结果，输出-1",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (numbersInput) => {\n  const numbers = numbersInput.split(' ').map(Number); // 将输入的字符串分割并映射为整数数组\n  const length = numbers.length; // 获取数组的长度\n  const result = []; // 用于存储所有可能的步数结果\n\n  for (let i = 1; i < Math.floor(length / 2); i++) { // 遍历所有从第一个元素开始的有效步长\n    let step = 1; // 初始化步数为1，因为第一步已经走出\n    let index = i; // 将索引设为当前步长\n\n    while (index < length - 1) { // 只要没有走到数组的最后一个元素\n      index += numbers[index]; // 按照当前索引位置的数字值前进\n      step++; // 每走一步，步数加1\n    }\n\n    if (index === length - 1) { // 如果恰好到达数组的最后一个元素\n      result.push(step); // 将步数结果存入结果列表\n    }\n  }\n\n  if (result.length > 0) {\n    result.sort(); // 对步数结果进行排序\n    console.log(result[0]); // 输出最小的步数\n  } else {\n    console.log(-1); // 如果没有结果，输出-1\n  }\n\n  rl.close();\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> numbers; // 用于存储输入的整数\n    int num;\n    while(std::cin >> num) {\n        numbers.push_back(num); // 将输入的整数存入向量\n    }\n    int length = numbers.size(); // 获取数组的长度\n    std::vector<int> result; // 用于存储所有可能的步数结果\n    for(int i = 1; i < length / 2; i++) { // 遍历所有从第一个元素开始的有效步长\n        int step = 1; // 初始化步数为1，因为第一步已经走出\n        int index = i; // 将索引设为当前步长\n        while(index < length - 1) { // 只要没有走到数组的最后一个元素\n            index += numbers[index]; // 按照当前索引位置的数字值前进\n            step += 1; // 每走一步，步数加1\n        }\n        if(index == length - 1) { // 如果恰好到达数组的最后一个元素\n            result.push_back(step); // 将步数结果存入结果列表\n        }\n    }\n    if(result.size() > 0) {\n        std::sort(result.begin(), result.end()); // 对步数结果进行排序\n        std::cout << result[0] << std::endl; // 输出最小的步数\n    } else {\n        std::cout << -1 << std::endl; // 如果没有结果，输出-1\n    }\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int numbers[100];  \n    int length = 0; // 实际输入的元素个数\n    int num;\n\n    // 从标准输入读取一系列整数，直到遇到非数字或文件结束\n    while (scanf(\"%d\", &num) == 1) {\n        numbers[length++] = num;\n    }\n\n    int result[100]; // 存储所有可能的步数结果\n    int result_count = 0; // 记录结果数量\n\n    // 遍历所有从第一个元素开始的有效步长\n    for (int i = 1; i < length / 2; i++) {\n        int step = 1; // 初始化步数为1，因为第一步已经走出\n        int index = i; // 将索引设为当前步长\n\n        // 只要没有走到数组的最后一个元素\n        while (index < length - 1) {\n            index += numbers[index]; // 按照当前索引位置的数字值前进\n            step++; // 每走一步，步数加1\n        }\n\n        // 如果恰好到达数组的最后一个元素\n        if (index == length - 1) {\n            result[result_count++] = step; // 将步数结果存入结果数组\n        }\n    }\n\n    // 如果有有效的步数结果\n    if (result_count > 0) {\n        int min_step = result[0];\n        // 找出最小的步数\n        for (int i = 1; i < result_count; i++) {\n            if (result[i] < min_step) {\n                min_step = result[i];\n            }\n        }\n        printf(\"%d\\n\", min_step); // 输出最小的步数\n    } else {\n        printf(\"-1\\n\"); // 如果没有结果，输出-1\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "26",
    "title": "报数游戏",
    "examType": "A",
    "score": 100,
    "description": "100个人围成一圈，每个人有一个编码，编号从1开始到100。\n他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。\n请问最后剩余的人在原先的编号为多少？",
    "inputDesc": "输入一个整数参数 M",
    "outputDesc": "如果输入参数M小于等于1或者大于等于100，输出“ERROR!”；\n否则按照原先的编号从小到大的顺序，以英文逗号分割输出编号字符串",
    "examples": [
      {
        "input": "",
        "output": ",91",
        "explanation": ""
      },
      {
        "input": "",
        "output": ",45,97",
        "explanation": ""
      }
    ],
    "solution": "题目描述的是一个经典的约瑟夫环（Josephus）问题的变种。题目要求在100个人围成一圈的情况下，进行报数，每次报到数字为M的那个人自动退出，直到剩下的人数少于M为止。我们需要找出最后剩下的人的编号。\n初始状态：有100个人，编号从1到100。报数规则： 每个人从1开始依次报数，每当某个人报到M时，该人退出圈子，剩下的人继续报数。报数是连续进行的，即如果当前报数人退出，接下来的人从1重新开始报数。 停止条件：当剩余人数小于M时，停止报数，输出剩余人的编号。输入限制： 如果输入的M不符合1 < M < 100的条件，输出\"ERROR!\"。 输出：当程序结束时，按原先编号从小到大的顺序，输出剩余的人的编号，多个编号之间以英文逗号分隔。\n每个人从1开始依次报数，每当某个人报到M时，该人退出圈子，剩下的人继续报数。报数是连续进行的，即如果当前报数人退出，接下来的人从1重新开始报数。\n如果输入的M不符合1 < M < 100的条件，输出\"ERROR!\"。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n   \n    public static List<Integer> find_last_person(List<Integer> numbers, int M) {\n        // 遍历numbers数组\n        for (int i = 1; i <= numbers.size(); i++) {\n            // 当索引i等于M时，执行以下操作\n            if (i == M) {\n                // 将第M个元素之后的元素放入新的临时列表temp\n                List<Integer> temp = new ArrayList<>(numbers.subList(M, numbers.size()));\n                // 将原数组从0到M-1的元素加到临时列表的末尾\n                temp.addAll(numbers.subList(0, M - 1));\n                // 递归调用find_last_person函数，以新的temp列表继续进行处理\n                return find_last_person(temp, M);\n            }\n        }\n        // 当数组遍历完成，返回最终的numbers列表\n        return numbers;\n    }\n\n    public static void main(String[] args) {\n       \n        Scanner scanner = new Scanner(System.in);\n    \n        int M = scanner.nextInt();\n\n        // 如果M的值不在1到100之间，输出错误信息\n        if (M <= 1 || M >= 100) {\n            System.out.println(\"ERROR!\");\n        } else {\n            // 创建一个存储1到100的列表\n            List<Integer> numbers = new ArrayList<>();\n            for (int i = 0; i < 100; i++) {\n                numbers.add(i + 1);  // 将1到100依次加入numbers列表\n            }\n\n            // 调用find_last_person函数，处理numbers列表\n            List<Integer> result = find_last_person(numbers, M);\n            // 对结果进行排序\n            Collections.sort(result);\n\n            // 遍历result列表，按格式输出结果\n            for (int i = 0; i < result.size(); i++) {\n                System.out.print(result.get(i));\n                // 在元素之间添加逗号，最后一个元素后不加逗号\n                if (i != result.size() - 1) {\n                    System.out.print(\",\");\n                }\n            }\n            // 输出换行符\n            System.out.println();\n        }\n    }\n}",
      "python": "def find_last_person(numbers, M):\n    while len(numbers) >= M:  # 如果当前人数不小于M，则继续执行\n        temp = numbers[M:] + numbers[:M-1]  # 将第M个元素以后的部分和前M-1个元素合并\n        numbers = temp  # 更新numbers\n    return numbers\n\n \nM = int(input())  # 读入整数M\n\nif M <= 1 or M >= 100:\n    print(\"ERROR!\")  # 如果M不在规定范围内，输出错误信息\nelse:\n    numbers = list(range(1, 101))  # 生成1到100的列表\n    result = find_last_person(numbers, M)  # 获取最后剩下的人\n    result.sort()  # 对结果进行排序\n\n    # 打印结果，用逗号分隔\n    print(\",\".join(map(str, result)))",
      "javascript": "const readline = require('readline');\n\n\nconst rl = readline.createInterface({\n  input: process.stdin,   \n  output: process.stdout  \n});\n\n \nfunction find_last_person(numbers, M) {\n  // 遍历数字数组\n  for (let i = 1; i <= numbers.length; i++) {\n    // 当索引等于M时，执行操作\n    if (i === M) {\n        // 构造新数组：从第M个元素开始到数组结束，再拼接从数组开始到第M-1个元素\n        const temp = [...numbers.slice(M), ...numbers.slice(0, M - 1)];\n        // 递归调用，以新的数组和M为参数\n        return find_last_person(temp, M);\n    }\n  }\n  // 当数组遍历完成，返回最终数组\n   return numbers;\n}\n\n \nrl.on('line', (M) => {\n  M = parseInt(M); // 将输入转换为整数\n\n  // 如果输入的M小于等于1或大于等于100，输出错误信息\n  if (M <= 1 || M >= 100) {\n    console.log(\"ERROR!\");\n  } else {\n    // 否则，创建一个从1到100的数组\n    const numbers = Array.from({length: 100}, (_, i) => i + 1);\n\n    // 调用find_last_person函数处理numbers数组\n    const result = find_last_person(numbers, M);\n    // 对结果进行排序\n    result.sort((a, b) => a - b);\n\n    // 使用逗号将数组元素连接成一个字符串，并打印输出\n    console.log(result.join(','));\n  }\n\n  // 完成输入后关闭readline接口\n  rl.close();\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>  \n\nusing namespace std;\n\n \nvector<int> find_last_person(vector<int>& numbers, int M) {\n    while (numbers.size() >= M) { // 只要人数不小于M，就继续进行\n        vector<int> temp; // 创建一个临时向量存储剩余的人\n        // 将M位置以后的人加到temp的末尾，并将前M-1个人也加到末尾\n        for (size_t i = M; i < numbers.size(); i++) {\n            temp.push_back(numbers[i]);\n        }\n        for (size_t i = 0; i < M - 1; i++) {\n            temp.push_back(numbers[i]);\n        }\n        numbers = temp; // 更新numbers为temp\n    }\n    return numbers;\n}\n\nint main() {\n    int M;\n    cin >> M; // 读入M值\n\n    if (M <= 1 || M >= 100) {\n        cout << \"ERROR!\" << endl; // 检查M值是否合法\n    } else {\n        vector<int> numbers(100); // 创建一个向量存放1到100的编号\n        for (int i = 0; i < 100; i++) {\n            numbers[i] = i + 1;\n        }\n\n        vector<int> result = find_last_person(numbers, M);\n        sort(result.begin(), result.end()); // 对结果进行排序\n\n        // 输出结果，用逗号分隔\n        for (size_t i = 0; i < result.size(); i++) {\n            cout << result[i];\n            if (i != result.size() - 1) {\n                cout << \",\";\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}",
      "c": "#include <stdio.h>   \n#include <stdlib.h> \n\n \nint* find_last_person(int* numbers, int size, int M, int* result_size) {\n    while (size >= M) { // 只要人数不小于M，就继续进行\n        int* temp = (int*)malloc(sizeof(int) * size); // 动态分配临时数组\n        int temp_size = 0;\n        for (int i = M; i < size; i++) {\n            temp[temp_size++] = numbers[i]; // 添加M之后的元素到临时数组\n        }\n        for (int i = 0; i < M - 1; i++) {\n            temp[temp_size++] = numbers[i]; // 添加前M-1的元素到临时数组\n        }\n        free(numbers); // 释放原始数组\n        numbers = temp; // 更新指向新数组\n        size = temp_size; // 更新大小\n    }\n    *result_size = size; // 设置返回大小\n    return numbers;\n}\n\nint cmpfunc(const void* a, const void* b) { // 用于qsort的比较函数\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int M;\n    scanf(\"%d\", &M); // 输入M\n\n    if (M <= 1 || M >= 100) {\n        printf(\"ERROR!\\n\"); // 检查M的合法性\n    } else {\n        int* numbers = (int*)malloc(sizeof(int) * 100); // 动态分配数组\n        for (int i = 0; i < 100; i++) {\n            numbers[i] = i + 1; // 初始化1到100\n        }\n\n        int result_size;\n        int* result = find_last_person(numbers, 100, M, &result_size);\n        qsort(result, result_size, sizeof(int), cmpfunc); // 对结果排序\n\n        // 输出结果\n        for (int i = 0; i < result_size; i++) {\n            printf(\"%d\", result[i]);\n            if (i != result_size - 1) {\n                printf(\",\");\n            }\n        }\n        printf(\"\\n\");\n\n        free(result); // 释放结果数组\n    }\n    return 0;\n}"
    }
  },
  {
    "id": "27",
    "title": "数字排列",
    "examType": "A",
    "score": 100,
    "description": "小明负责公司年会，想出一个趣味游戏：\n屏幕给出 1 ~ 9 中任意 4 个不重复的数字，大家以最快时间给出这几个数字可拼成的数字从小到大排列位于第 N 位置的数字，其中 N 为给出数字中最大的（如果不到这么多数字则给出最后一个即可）。\n注意：\n2 可以当作 5 来使用，5 也可以当作 2 来使用进行数字拼接，且屏幕不能同时给出 2 和 5；6 可以当作 9 来使用，9 也可以当作 6 来使用进行数字拼接，且屏幕不能同时给出 6 和 9。\n如给出：1，4，8，7，则可以拼接的数字为：\n1，4，7，8，14，17，18，41，47，48，71，74，78，81，84，87，147，148，178 … (省略后面的数字)\n那么第 N （即8）个的数字为 41。",
    "inputDesc": "输入以逗号分隔的 4 个 int 类型整数的字符串。",
    "outputDesc": "输出为这几个数字可拼成的数字从小大大排列位于第 N （N为输入数字中最大的数字）位置的数字，\n如果输入的数字不在范围内或者有重复，则输出-1。",
    "examples": [
      {
        "input": ",4,8,7",
        "output": "",
        "explanation": "可以构成的数字按从小到大排序为： 1，4，7，8，14，17，18，41，47，48，71，74，78，81，84，87，147，148，178 … （省略后面的数字）， 故第8个为41"
      },
      {
        "input": ",5,1",
        "output": "-1",
        "explanation": "2和5不能同时出现"
      },
      {
        "input": ",0,9",
        "output": "-1",
        "explanation": "0不在1到9范围内"
      },
      {
        "input": ",9,7,8",
        "output": "",
        "explanation": "注意9可以当6使用，所以可以构成的数字按从小到大排序为：3，6，7，8，9，36，37，38，39，63，67，68，73，76，78，79，83 … （省略后面的数字）， 故第9个为39"
      }
    ],
    "solution": "小明的游戏需要从给定的4个不同的数字中，找到所有可以拼接出来的数字，按从小到大的顺序排列，最后取出第 N 个数字输出，N 是给定4个数字中最大的那个数字。\n数字只能从1到9中选择。数字2和5互相可以替代，6和9互相可以替代，但不能同时出现（例如，2和5不能同时出现在输入中，6和9也不能同时出现）。输入数字必须是4个且无重复。如果输入的数字不符合上述要求（比如含有重复数字、包含不在范围内的数字，或同时包含了2和5、6和9），则输出-1。取出第N个排列的数字： 找到这些排列中第 N 个位置的数字（N 是输入中最大的数字）。如果排列数量不够N个，则取最后一个数字。\n找到这些排列中第 N 个位置的数字（N 是输入中最大的数字）。如果排列数量不够N个，则取最后一个数字。\n检查输入的合法性： 检查输入数字的数量是否为4个。检查数字是否都在1到9之间。检查是否有重复数字。检查是否同时包含2和5，或同时包含6和9，如果有则直接输出-1。 生成所有排列：因为本题数量级不大，可以考虑生成所有数字的排列组合，并将结果按从小到大的顺序排列。\n检查输入的合法性：\n检查输入数字的数量是否为4个。检查数字是否都在1到9之间。检查是否有重复数字。检查是否同时包含2和5，或同时包含6和9，如果有则直接输出-1。\n生成所有排列：因为本题数量级不大，可以考虑生成所有数字的排列组合，并将结果按从小到大的顺序排列。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 读取输入的一行字符串，将逗号分隔的数字转换为整数数组\n        int[] nums = Arrays.stream(sc.nextLine().split(\",\"))\n                           .mapToInt(Integer::parseInt)\n                           .toArray();\n\n        // 使用HashSet来记录输入的数字，避免重复，同时用于后续的检查\n        HashSet<Integer> set = new HashSet<>();\n        // 记录输入数字中的最大值，用于后续决定输出的排列结果\n        int n = Integer.MIN_VALUE;\n\n        // 遍历输入的每一个数字，进行合法性检查和找出最大值\n        for (int num : nums) {\n            // 检查数字是否在1到9的范围内，且是否重复\n            if (num < 1 || num > 9 || !set.add(num)) {\n                // 如果数字不在范围内或者重复，则输出-1并结束程序\n                System.out.println(-1);\n                return;\n            }\n            // 更新当前的最大值\n            n = Math.max(n, num);\n        }\n\n        // 检查是否输入了4个数字，并且不允许2和5同时出现，或6和9同时出现\n        if (set.size() != 4 || (set.contains(2) && set.contains(5)) || (set.contains(6) && set.contains(9))) {\n            // 如果条件不满足，输出-1并结束程序\n            System.out.println(-1);\n            return;\n        }\n\n        // 创建一个映射数组，用于定义数字替代规则，例如2替代5，5替代2，6替代9，9替代6\n        int[] map = new int[10];\n        map[2] = 5;\n        map[5] = 2;\n        map[6] = 9;\n        map[9] = 6;\n\n        // 创建一个列表用于存储生成的所有可能的排列结果\n        ArrayList<Integer> resList = new ArrayList<>();\n\n        // 调用递归函数，生成所有排列组合，并将结果存储到resList中\n        dfs(nums, new HashSet<>(), \"\", map, resList);\n\n        // 如果没有生成任何有效的排列结果，输出-1\n        if (resList.isEmpty()) {\n            System.out.println(-1);\n            return;\n        }\n\n        // 对结果列表进行自然顺序排序（升序）\n        resList.sort(Comparator.naturalOrder());\n\n        // 确定要输出的第n个数字，其中n为输入的最大值，如果结果集数量不足，则输出最后一个\n        int nth = Math.min(n, resList.size());\n        // 输出排序后的第nth个数字（因为索引从0开始，所以为nth - 1）\n        System.out.println(resList.get(nth - 1));\n    }\n\n   \n    public static void dfs(int[] nums, Set<Integer> used, String path, int[] map, List<Integer> res) {\n        // 如果当前路径不为空，将路径转换为整数并加入结果集中\n        if (!path.isEmpty()) {\n            res.add(Integer.parseInt(path));\n        }\n\n        // 如果当前路径的长度已经等于输入的数字数量，返回（递归结束条件）\n        if (path.length() == nums.length) {\n            return;\n        }\n\n        // 遍历所有输入的数字，尝试将每个数字放入当前路径中\n        for (int num : nums) {\n            // 如果当前数字已经在路径中使用，跳过此数字\n            if (used.contains(num)) continue;\n\n            // 标记当前数字为使用中\n            used.add(num);\n\n            // 递归调用，将当前数字加入路径中\n            dfs(nums, used, path + num, map, res);\n\n            // 如果当前数字有替代规则，且替代数字未被使用，则尝试使用替代数字\n            if (map[num] != 0 && !used.contains(map[num])) {\n                dfs(nums, used, path + map[num], map, res);\n            }\n\n            // 回溯，取消当前数字的使用标记\n            used.remove(num);\n        }\n    }\n}",
      "python": "# 导入所需模块\nfrom itertools import permutations\n\ndef main():\n    # 读取输入的一行字符串，并将其转换为整数列表\n    nums = list(map(int, input().split(',')))\n\n    # 使用集合来记录输入的数字，避免重复，并进行后续检查\n    num_set = set()\n    # 记录输入数字中的最大值，用于后续输出\n    n = float('-inf')\n\n    # 遍历输入的每一个数字，进行合法性检查并找出最大值\n    for num in nums:\n        # 检查数字是否在1到9的范围内，且是否重复\n        if num < 1 or num > 9 or num in num_set:\n            print(-1)\n            return\n        num_set.add(num)\n        n = max(n, num)\n    \n    # 检查是否输入了4个数字，并且不允许2和5同时出现，或6和9同时出现\n    if len(num_set) != 4 or (2 in num_set and 5 in num_set) or (6 in num_set and 9 in num_set):\n        print(-1)\n        return\n\n    # 定义替换规则\n    replace_map = {2: 5, 5: 2, 6: 9, 9: 6}\n\n    # 初始化结果列表\n    res_list = []\n\n    # 调用递归函数，生成所有排列组合\n    dfs(nums, set(), \"\", replace_map, res_list)\n\n    # 如果没有生成任何有效的排列结果，输出-1\n    if not res_list:\n        print(-1)\n        return\n\n    # 对结果列表进行升序排序\n    res_list.sort()\n\n    # 确定要输出的第n个数字，n为输入的最大值\n    nth = min(n, len(res_list))\n\n    # 输出排序后的第nth个数字\n    print(res_list[nth - 1])\n\ndef dfs(nums, used, path, replace_map, res):\n    # 如果当前路径不为空，将路径转换为整数并加入结果集中\n    if path:\n        res.append(int(path))\n\n    # 如果当前路径的长度已经等于输入的数字数量，返回（递归结束条件）\n    if len(path) == len(nums):\n        return\n\n    # 遍历所有输入的数字，尝试将每个数字放入当前路径中\n    for num in nums:\n        if num in used:\n            continue\n\n        used.add(num)\n\n        # 递归调用，将当前数字加入路径中\n        dfs(nums, used, path + str(num), replace_map, res)\n\n        # 如果当前数字有替代规则且替代数字未被使用，则尝试使用替代数字\n        if num in replace_map and replace_map[num] not in used:\n            dfs(nums, used, path + str(replace_map[num]), replace_map, res)\n\n        # 回溯\n        used.remove(num)\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "const readline = require('readline');\n \nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n \nrl.on(\"line\", (input) => {\n    // 将输入的字符串转换为整数数组\n    const nums = input.split(',').map(Number);\n\n    // 使用Set来记录输入的数字，避免重复\n    let numSet = new Set();\n    let n = Number.MIN_SAFE_INTEGER;\n\n    // 遍历每个数字，进行合法性检查并找出最大值\n    for (let num of nums) {\n        if (num < 1 || num > 9 || numSet.has(num)) {\n            console.log(-1);\n            rl.close();\n            return;\n        }\n        numSet.add(num);\n        n = Math.max(n, num);\n    }\n\n    // 检查条件\n    if (numSet.size !== 4 || (numSet.has(2) && numSet.has(5)) || (numSet.has(6) && numSet.has(9))) {\n        console.log(-1);\n        rl.close();\n        return;\n    }\n\n    // 定义替换规则\n    const replaceMap = { 2: 5, 5: 2, 6: 9, 9: 6 };\n\n    // 存储结果的数组\n    let resList = [];\n\n    // 调用递归函数\n    dfs(nums, new Set(), \"\", replaceMap, resList);\n\n    // 如果没有结果，输出-1\n    if (resList.length === 0) {\n        console.log(-1);\n        rl.close();\n        return;\n    }\n\n    // 排序\n    resList.sort((a, b) => a - b);\n\n    // 输出第n个结果\n    let nth = Math.min(n, resList.length);\n    console.log(resList[nth - 1]);\n    rl.close();\n});\n \n\n// 递归函数\nfunction dfs(nums, used, path, replaceMap, res) {\n    if (path !== \"\") res.push(parseInt(path));\n\n    if (path.length === nums.length) return;\n\n    for (let num of nums) {\n        if (used.has(num)) continue;\n\n        used.add(num);\n        dfs(nums, used, path + num, replaceMap, res);\n\n        if (replaceMap[num] && !used.has(replaceMap[num])) {\n            dfs(nums, used, path + replaceMap[num], replaceMap, res);\n        }\n\n        used.delete(num);\n    }\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <climits>\nusing namespace std;\n\n// 递归函数，用于生成所有的排列组合\nvoid dfs(const vector<int>& nums, set<int>& used, string path, int map[], vector<int>& res) {\n    // 如果当前路径不为空，将路径转换为整数并加入结果集\n    if (!path.empty()) {\n        res.push_back(stoi(path));\n    }\n\n    // 如果当前路径的长度已经等于输入的数字数量，递归结束\n    if (path.length() == nums.size()) {\n        return;\n    }\n\n    // 遍历所有输入的数字，尝试将每个数字放入当前路径中\n    for (int num : nums) {\n        // 如果当前数字已经在路径中使用，跳过此数字\n        if (used.count(num)) continue;\n\n        // 标记当前数字为使用中\n        used.insert(num);\n        // 递归调用，将当前数字加入路径中\n        dfs(nums, used, path + to_string(num), map, res);\n        // 如果当前数字有替代规则且替代数字未被使用，则尝试使用替代数字\n        if (map[num] != 0 && !used.count(map[num])) {\n            dfs(nums, used, path + to_string(map[num]), map, res);\n        }\n        // 回溯，取消当前数字的使用标记\n        used.erase(num);\n    }\n}\n\nint main() {\n    string input;\n    // 读取输入的一行字符串\n    getline(cin, input);\n\n    vector<int> nums;\n    set<int> numSet;\n    int n = INT_MIN;\n\n    // 将逗号分隔的字符串转换为整数数组\n    size_t pos = 0;\n    while ((pos = input.find(',')) != string::npos) {\n        int num = stoi(input.substr(0, pos));\n        nums.push_back(num);\n        input.erase(0, pos + 1);\n    }\n    nums.push_back(stoi(input));\n\n    // 遍历输入的每一个数字，进行合法性检查和找出最大值\n    for (int num : nums) {\n        // 检查数字是否在1到9的范围内，且是否重复\n        if (num < 1 || num > 9 || !numSet.insert(num).second) {\n            // 如果数字不在范围内或者重复，则输出-1并结束程序\n            cout << -1 << endl;\n            return 0;\n        }\n        // 更新当前的最大值\n        n = max(n, num);\n    }\n\n    // 检查是否输入了4个数字，并且不允许2和5同时出现，或6和9同时出现\n    if (numSet.size() != 4 || (numSet.count(2) && numSet.count(5)) || (numSet.count(6) && numSet.count(9))) {\n        // 如果条件不满足，输出-1并结束程序\n        cout << -1 << endl;\n        return 0;\n    }\n\n    // 创建一个映射数组，用于定义数字替代规则\n    int map[10] = {0};\n    map[2] = 5;\n    map[5] = 2;\n    map[6] = 9;\n    map[9] = 6;\n\n    // 创建一个列表用于存储生成的所有可能的排列结果\n    vector<int> resList;\n\n    // 调用递归函数，生成所有排列组合，并将结果存储到resList中\n    set<int> used;\n    dfs(nums, used, \"\", map, resList);\n\n    // 如果没有生成任何有效的排列结果，输出-1\n    if (resList.empty()) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    // 对结果列表进行自然顺序排序（升序）\n    sort(resList.begin(), resList.end());\n\n    // 确定要输出的第n个数字，其中n为输入的最大值，如果结果集数量不足，则输出最后一个\n    int nth = min(n, (int)resList.size());\n    // 输出排序后的第nth个数字（因为索引从0开始，所以为nth - 1）\n    cout << resList[nth - 1] << endl;\n\n    return 0;\n}",
      "c": ""
    }
  },
  {
    "id": "28",
    "title": "数字涂色",
    "examType": "A",
    "score": 100,
    "description": "疫情过后，希望小学终于又重新开学了，三年二班开学第一天的任务是将后面的黑板报重新制作。\n黑板上已经写上了N个正整数，同学们需要给这每个数分别上一种颜色。\n为了让黑板报既美观又有学习意义，老师要求同种颜色的所有数都可以被这种颜色中最小的那个数整除。\n现在请你帮帮小朋友们，算算最少需要多少种颜色才能给这N个数进行上色。",
    "inputDesc": "第一行有一个正整数N，其中。\n第二行有N个int型数(保证输入数据在[1,100]范围中)，表示黑板上各个正整数的值。",
    "outputDesc": "输出只有一个整数，为最少需要的颜色种数。",
    "examples": [
      {
        "input": "4 6",
        "output": "4 6",
        "explanation": "有数都能被2整除"
      },
      {
        "input": "3 4 9",
        "output": "",
        "explanation": "与4涂一种颜色，4能被2整除；3与9涂另一种颜色，9能被3整除。不能4个数涂同一个颜色，因为3与9不能被2整除。所以最少的颜色是两种。"
      }
    ],
    "solution": "题目要求给黑板上的 N 个正整数 上色，具体的要求是：同种颜色的所有数都可以被这一颜色中最小的那个数整除。\n换句话说，如果我们为某个数字选择了一种颜色，那么所有和它涂同种颜色的数都应该是它的倍数。目标是找到最少的颜色种类来满足这个条件。\n颜色分配逻辑：每个数字从最小开始，尝试加入已经存在的组中，只有当它无法整除任何一个已有组的最小数时，才新建一个组。这种策略确保了所有组中，数字都满足题目要求——同组内的所有数字都可以被该组的最小数整除。\n可以分为以下几个步骤：\n排序后的数组便于我们从最小的数字开始处理，因为最小数决定了它这一组的颜色。\n创建一个数组 colors，用来存储已经作为组最小数的数字。colorCount 用来统计已经使用了多少种颜色，即有多少个组。\n遍历排序后的 numList 数组，对于每个数字 numList[i]： 检查是否能被已有颜色组的最小数整除：通过 for 循环遍历 colors 数组，检查 numList[i] % colors[j] == 0，如果当前数字可以被某个已经存在的组的最小数整除（即 colors[j]），则认为这个数字可以归入该颜色组，设置 foundColor = true，并退出循环。如果没有找到合适的颜色组（即 foundColor == false），那么当前数字 numList[i] 就必须作为一个新的组的最小数。因此，将它添加到 colors 数组中，并增加颜色计数 colorCount。\n检查是否能被已有颜色组的最小数整除：通过 for 循环遍历 colors 数组，检查 numList[i] % colors[j] == 0，如果当前数字可以被某个已经存在的组的最小数整除（即 colors[j]），则认为这个数字可以归入该颜色组，设置 foundColor = true，并退出循环。如果没有找到合适的颜色组（即 foundColor == false），那么当前数字 numList[i] 就必须作为一个新的组的最小数。因此，将它添加到 colors 数组中，并增加颜色计数 colorCount。\n以示例2为例：\n输入：\n12\n对输入数据排序：[2, 3, 4, 9]遍历每个数字： 2：没有已有组，所以新建一个组，colors = [2]，colorCount = 13：没有现有组能够整除 3，所以新建一个组，colors = [2, 3]，colorCount = 24：能被 2 整除，所以加入 2 所在的组，颜色数不增加。9：能被 3 整除，所以加入 3 所在的组，颜色数不增加。 输出结果：2（需要两种颜色）。\n2：没有已有组，所以新建一个组，colors = [2]，colorCount = 13：没有现有组能够整除 3，所以新建一个组，colors = [2, 3]，colorCount = 24：能被 2 整除，所以加入 2 所在的组，颜色数不增加。9：能被 3 整除，所以加入 3 所在的组，颜色数不增加。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n \n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);   \n        int N = input.nextInt();  // 读取整数N，表示黑板上数字的数量\n        int[] numList = new int[N];  // 创建一个数组存储N个数字\n        for (int i = 0; i < N; i++) {\n            numList[i] = input.nextInt();  // 读取N个数字并存储在numList数组中\n        }\n        Arrays.sort(numList);  // 对numList数组进行从小到大排序\n        \n        int[] colors = new int[N];  // 创建一个数组colors来存储颜色组的最小数\n        int colorCount = 0;  // 记录使用的颜色种数\n        for (int i = 0; i < N; i++) {\n            boolean foundColor = false;  // 标志位，用于检查当前数字是否找到合适的颜色组\n            for (int j = 0; j < colorCount; j++) {\n                if (numList[i] % colors[j] == 0) {  // 检查当前数字能否被已有颜色组的最小数整除\n                    foundColor = true;  // 如果找到合适的颜色组，标志位置为true\n                    break;  // 跳出循环\n                }\n            }\n            if (!foundColor) {  // 如果没有找到合适的颜色组\n                colors[colorCount] = numList[i];  // 将当前数字作为一个新的颜色组的最小数\n                colorCount++;  // 增加颜色组数量\n            }\n        }\n        \n        System.out.println(colorCount);  // 输出最少需要的颜色种数\n    }\n}",
      "python": "import sys\n\nN = int(input())  # 读取整数N，表示黑板上数字的数量\nnumList = list(map(int, input().split()))  # 读取N个数字并存储在列表numList中\nnumList.sort()  # 对numList进行从小到大排序\n\ncolors = []  # 创建一个列表colors来存储颜色组的最小数\ncolorCount = 0  # 记录使用的颜色种数\nfor i in range(N):\n    foundColor = False  # 标志位，用于检查当前数字是否找到合适的颜色组\n    for j in range(colorCount):\n        if numList[i] % colors[j] == 0:  # 检查当前数字能否被已有颜色组的最小数整除\n            foundColor = True  # 如果找到合适的颜色组，标志位置为True\n            break  # 跳出循环\n    if not foundColor:  # 如果没有找到合适的颜色组\n        colors.append(numList[i])  # 将当前数字作为一个新的颜色组的最小数添加到colors列表中\n        colorCount += 1  # 增加颜色组数量\n\nprint(colorCount)  # 输出最少需要的颜色种数",
      "javascript": "const readline = require('readline');  // 导入readline模块以读取标准输入\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (N) => {  // 读取第一行输入，表示数字数量N\n  let numList = [];  // 用于存储输入的数字列表\n  let colorCount = 0;  // 记录使用的颜色种数\n\n  rl.on('line', (numbers) => {  // 读取第二行输入的N个数字\n    numList = numbers.split(' ').map(Number);  // 将输入的字符串转化为数字数组\n    numList.sort((a, b) => a - b);  // 对数字数组进行从小到大排序\n\n    let colors = new Array(N).fill(0);  // 创建一个数组用于存储颜色组的最小数\n\n    for (let i = 0; i < N; i++) {\n      let foundColor = false;  // 标志位，用于检查当前数字是否找到合适的颜色组\n      for (let j = 0; j < colorCount; j++) {\n        if (numList[i] % colors[j] === 0) {  // 检查当前数字能否被已有颜色组的最小数整除\n          foundColor = true;  // 如果找到合适的颜色组，标志位置为true\n          break;  // 跳出循环\n        }\n      }\n      if (!foundColor) {  // 如果没有找到合适的颜色组\n        colors[colorCount] = numList[i];  // 将当前数字作为一个新的颜色组的最小数\n        colorCount++;  // 增加颜色组数量\n      }\n    }\n\n    console.log(colorCount);  // 输出最少需要的颜色种数\n    rl.close();  // 关闭输入接口\n  });\n});",
      "cpp": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;  // 读取整数N，表示黑板上数字的数量\n    int* numList = new int[N];  // 动态分配一个数组用于存储N个数字\n    for (int i = 0; i < N; i++) {\n        cin >> numList[i];  // 读取N个数字并存储在numList数组中\n    }\n    sort(numList, numList + N);  // 对numList数组进行从小到大排序\n    \n    int* colors = new int[N];  // 动态分配一个数组用于存储颜色组的最小数\n    int colorCount = 0;  // 记录使用的颜色种数\n    for (int i = 0; i < N; i++) {\n        bool foundColor = false;  // 标志位，用于检查当前数字是否找到合适的颜色组\n        for (int j = 0; j < colorCount; j++) {\n            if (numList[i] % colors[j] == 0) {  // 检查当前数字能否被已有颜色组的最小数整除\n                foundColor = true;  // 如果找到合适的颜色组，标志位置为true\n                break;  // 跳出循环\n            }\n        }\n        if (!foundColor) {  // 如果没有找到合适的颜色组\n            colors[colorCount] = numList[i];  // 将当前数字作为一个新的颜色组的最小数\n            colorCount++;  // 增加颜色组数量\n        }\n    }\n    \n    cout << colorCount << endl;  // 输出最少需要的颜色种数\n    \n    delete[] numList;  // 释放动态分配的numList数组\n    delete[] colors;  // 释放动态分配的colors数组\n    \n    return 0;\n}",
      "c": "#include <stdio.h>    \n#include <stdlib.h>    \n#include <stdbool.h>   \n#include <string.h>    \n\n// 定义比较函数，用于qsort的排序\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);  // 比较两个整数的大小\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);  // 读取整数N，表示黑板上数字的数量\n\n    // 动态分配一个数组用于存储N个数字\n    int* numList = (int*)malloc(N * sizeof(int));\n \n\n    // 读取N个数字并存储在numList数组中\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &numList[i]);\n    }\n\n    // 使用qsort对numList数组进行从小到大排序\n    qsort(numList, N, sizeof(int), compare);\n\n    // 动态分配一个数组用于存储颜色组的最小数\n    int* colors = (int*)malloc(N * sizeof(int));\n \n\n    int colorCount = 0;  // 记录使用的颜色种数\n\n    // 遍历numList中的每个数字，决定是否能归入已有颜色组\n    for (int i = 0; i < N; i++) {\n        bool foundColor = false;  // 标志位，用于检查当前数字是否找到合适的颜色组\n\n        // 检查当前数字是否可以加入已有的颜色组\n        for (int j = 0; j < colorCount; j++) {\n            if (numList[i] % colors[j] == 0) {  // 如果能被已有颜色组的最小数整除\n                foundColor = true;  // 找到合适的颜色组，标志位设为true\n                break;  // 跳出循环，不再需要检查其他颜色组\n            }\n        }\n\n        // 如果没有找到合适的颜色组，创建新的颜色组\n        if (!foundColor) {\n            colors[colorCount] = numList[i];  // 将当前数字作为一个新的颜色组的最小数\n            colorCount++;  // 增加颜色组数量\n        }\n    }\n\n    // 输出最少需要的颜色种数\n    printf(\"%d\\n\", colorCount);\n\n \n\n    return 0;  // 程序正常结束\n}"
    }
  },
  {
    "id": "29",
    "title": "数组拼接",
    "examType": "A",
    "score": 100,
    "description": "现在有多组整数数组，需要将它们合并成一个新的数组。\n合并规则，从每个数组里按顺序取出固定长度的内容合并到新的数组中，取完的内容会删除掉，\n如果该行不足固定长度或者已经为空，则直接取出剩余部分的内容放到新的数组中，继续下一行。",
    "inputDesc": "第一行是每次读取的固定长度，0<长度<10\n第二行是整数数组的数目，0<数目<1000\n第3-n行是需要合并的数组，不同的数组用回车换行分隔，数组内部用逗号分隔，最大不超过100个元素。",
    "outputDesc": "输出一个新的数组，用逗号分隔。",
    "examples": [
      {
        "input": ",5,6,7,9,5,7\n,7,4,3,4",
        "output": ",5,6,1,7,4,7,9,5,3,4,7",
        "explanation": "1、获得长度3和数组数目2 2、先遍历第一行，获得2,5,6 3、再遍历第二行，获得1,7,4 4、再循环回到第一行，获得7,9,5 5、再遍历第二行，获得3,4 6、再回到第一行，获得7，按顺序拼接成最终结果"
      },
      {
        "input": ",2,3,4,5,6\n,2,3\n,2,3,4",
        "output": ",2,3,4,1,2,3,1,2,3,4,5,6",
        "explanation": ""
      },
      {
        "input": ",5,6,7,9,5,7\n,7,4,3,4",
        "output": ",5,6,1,7,4,7,9,5,3,4,7",
        "explanation": ""
      }
    ],
    "solution": "题目的要求是将多组整数数组合并成一个新的数组，合并的规则是从每个数组中按顺序取出指定长度的元素，然后将取出的元素拼接到新的数组中，直到所有数组中的元素全部被取完为止。\n固定长度：每次从一个数组中取出的元素个数是固定的，假设为L。多数组操作：数组的数目是N个，需要按顺序逐个遍历这些数组。按序取元素： 如果一个数组剩余的元素不足L，则取出剩余的所有元素。如果一个数组的元素已经全部取完，则跳过该数组，继续处理下一个数组。 循环合并：每次遍历完所有数组后，若还有未取完的数组，继续从第一个数组开始按顺序取，直到所有数组都取完为止。\n如果一个数组剩余的元素不足L，则取出剩余的所有元素。如果一个数组的元素已经全部取完，则跳过该数组，继续处理下一个数组。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 读取固定长度和整数数组的数目\n        Scanner scanner = new Scanner(System.in);\n        int fixedLength = scanner.nextInt(); // 输入每次取出的固定长度\n        int arrayNum = scanner.nextInt(); // 输入数组数量\n        int totalCount = 0; // 记录所有数组中元素的总数\n\n        // 读取需要合并的数组\n        List<List<Integer>> inputArrays = new ArrayList<>(); // 用于存储所有输入的数组\n        for (int i = 0; i < arrayNum; i++) { // 读取每个数组\n            String inputStr = scanner.next(); // 读取一行输入\n            List<Integer> v = new ArrayList<>(); // 存储当前数组\n            while (inputStr.indexOf(\",\") != -1) { // 查找逗号分隔符\n                int found = inputStr.indexOf(\",\"); // 找到逗号的位置\n                v.add(Integer.parseInt(inputStr.substring(0, found))); // 转换逗号前的部分为整数并添加到数组中\n                inputStr = inputStr.substring(found + 1); // 去除已经处理过的部分\n                totalCount += 1; // 更新总元素个数\n            }\n            v.add(Integer.parseInt(inputStr)); // 添加最后一个元素\n            totalCount += 1; // 更新总元素个数\n            inputArrays.add(v); // 将当前数组添加到数组集合中\n        }\n\n        // 合并数组\n        List<Integer> result = new ArrayList<>(); // 用于存储合并后的结果\n        int num = 0; // 记录已合并的元素数量\n        while (num < totalCount) { // 当合并的元素数量少于总数时继续\n            for (int i = 0; i < inputArrays.size(); i++) { // 遍历所有数组\n                for (int j = 0; j < fixedLength; j++) { // 每次从当前数组中取固定长度的元素\n                    if (inputArrays.get(i).size() > 0) { // 如果当前数组不为空\n                        num += 1; // 更新已处理的元素数量\n                        result.add(inputArrays.get(i).get(0)); // 将第一个元素添加到结果中\n                        inputArrays.get(i).remove(0); // 删除该元素\n                    } else {\n                        break; // 如果当前数组为空，则跳过\n                    }\n                }\n            }\n        }\n\n        // 输出结果\n        for (int i = 0; i < result.size() - 1; i++) { // 输出结果数组，元素之间用逗号分隔\n            System.out.print(result.get(i) + \",\");\n        }\n        System.out.print(result.get(result.size() - 1)); // 输出最后一个元素时不加逗号\n    }\n}",
      "python": "# 读取固定长度和数组的数量\nfixedLength = int(input())  # 每次取出的固定长度\narrayNum = int(input())  # 数组数量\ntotalCount = 0  # 用于记录所有数组中元素的总数\ninputArrays = []  # 存储所有输入的数组\n\n# 读取输入的数组并存储\nfor i in range(arrayNum):  # 读取每个数组\n    inputStr = input()  # 读取输入字符串\n    v = []  # 用于存储当前数组\n    while ',' in inputStr:  # 查找逗号分隔符\n        found = inputStr.index(\",\")  # 找到逗号的位置\n        v.append(int(inputStr[:found]))  # 提取逗号前的部分并转换为整数\n        inputStr = inputStr[found + 1:]  # 删除已经处理过的部分\n        totalCount += 1  # 更新总元素个数\n    v.append(int(inputStr))  # 添加最后一个元素\n    totalCount += 1  # 更新总元素个数\n    inputArrays.append(v)  # 将当前数组添加到数组集合中\n\n# 合并数组\nresult = []  # 用于存储合并后的结果\nnum = 0  # 记录已合并的元素数量\nwhile num < totalCount:  # 当合并的元素数量少于总数时继续\n    for i in range(len(inputArrays)):  # 遍历所有数组\n        for j in range(fixedLength):  # 每次从当前数组中取固定长度的元素\n            if len(inputArrays[i]) > 0:  # 如果当前数组不为空\n                num += 1  # 更新已处理的元素数量\n                result.append(inputArrays[i][0])  # 将第一个元素添加到结果中\n                inputArrays[i].pop(0)  # 删除该元素\n            else:\n                break  # 如果当前数组为空，则跳过\n\n# 输出结果\nfor i in range(len(result) - 1):  # 输出结果数组，元素之间用逗号分隔\n    print(result[i], end=',')\nprint(result[-1])  # 输出最后一个元素时不加逗号",
      "javascript": "const readline = require(\"readline\");  // 引入读取输入的模块\n\nconst rl = readline.createInterface({\n  input: process.stdin,  // 定义输入流\n  output: process.stdout,  // 定义输出流\n});\n\nconst input = [];  // 存储输入的所有数据\n\nrl.on(\"line\", (line) => {  // 监听每一行的输入\n  input.push(line);  // 将输入的行添加到数组中\n\n  if (input.length === parseInt(input[1]) + 2) {  // 当输入完所有数据后\n    const fixedLength = parseInt(input[0]);  // 获取固定长度\n    const numOfArrays = parseInt(input[1]);  // 获取数组数量\n    const arrays = input.slice(2).map((line) => line.split(\",\").map(Number));  // 将输入的字符串转换为二维数组\n    const mergedArray = [];  // 用于存储合并后的数组\n\n    while (arrays.length) {  // 当还有未处理的数组时继续\n      for (let i = 0; i < arrays.length; i++) {  // 遍历每个数组\n        const array = arrays[i];  // 获取当前数组\n        if (array.length === 0) {  // 如果当前数组为空，则删除它\n          arrays.splice(i, 1);\n        } else {\n          mergedArray.push(...array.splice(0, fixedLength));  // 否则取出固定长度的元素并添加到合并后的数组中\n        }\n      }\n    }\n\n    console.log(mergedArray.join(\",\"));  // 输出最终合并的数组\n\n    input.length = 0;  // 清空输入数组，准备下一次输入\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    // 读取固定长度和整数数组的数目\n    int fixedLength, arrayNum;\n    cin >> fixedLength >> arrayNum; // 输入每次取出的固定长度和数组的数量\n    int totalCount = 0; // 记录所有数组中元素的总数\n\n    // 读取需要合并的数组\n    vector<vector<int>> inputArrays; // 创建二维数组来存储所有输入的整数数组\n    for (int i = 0; i < arrayNum; i++) { // 循环读取每个数组\n        string inputStr;\n        cin >> inputStr; // 读取数组输入字符串\n        vector<int> v; // 用于存储当前数组的整数\n        while (inputStr.find(',') != string::npos) { // 查找逗号分隔符来分割字符串\n            int found = inputStr.find(','); // 找到逗号的位置\n            v.push_back(stoi(inputStr.substr(0, found))); // 截取逗号前的部分转换为整数并存储\n            inputStr = inputStr.substr(found + 1); // 去除已经处理过的部分\n            totalCount += 1; // 更新总元素个数\n        }\n        v.push_back(stoi(inputStr)); // 添加最后一个元素\n        totalCount += 1; // 更新总元素个数\n        inputArrays.push_back(v); // 将当前数组存储到数组集合中\n    }\n\n    // 合并数组\n    vector<int> result; // 存储合并后的结果\n    int num = 0; // 记录已经合并的元素数量\n    while (num < totalCount) { // 当合并的元素数量少于总数时继续\n        for (int i = 0; i < inputArrays.size(); i++) { // 遍历所有数组\n            for (int j = 0; j < fixedLength; j++) { // 每次从当前数组中取固定长度的元素\n                if (!inputArrays[i].empty()) { // 如果数组不为空\n                    num += 1; // 更新已处理的元素数量\n                    result.push_back(inputArrays[i][0]); // 将第一个元素添加到结果中\n                    inputArrays[i].erase(inputArrays[i].begin()); // 删除该元素\n                } else {\n                    break; // 如果当前数组为空，则跳过\n                }\n            }\n        }\n    }\n\n    // 输出结果\n    for (int i = 0; i < result.size() - 1; i++) { // 输出结果数组，元素之间用逗号分隔\n        cout << result[i] << \",\";\n    }\n    cout << result[result.size() - 1]; // 输出最后一个元素时不加逗号\n\n    return 0; // 程序结束\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int fixedLength, arrayNum;\n    int totalCount = 0;  // 记录所有数组中元素的总数\n    \n    // 读取固定长度和数组数量\n    scanf(\"%d %d\", &fixedLength, &arrayNum);\n    \n    // 分配二维数组的内存用于存储输入的数组\n    int** inputArrays = (int**)malloc(arrayNum * sizeof(int*));\n    int* arrayLengths = (int*)malloc(arrayNum * sizeof(int));  // 记录每个数组的长度\n\n    // 读取输入的数组\n    for (int i = 0; i < arrayNum; i++) {\n        char inputStr[2000];   \n        scanf(\"%s\", inputStr);  // 读取一行输入\n        \n        // 分配空间存储当前数组的元素 \n        inputArrays[i] = (int*)malloc(2000 * sizeof(int));\n        int len = 0;  // 当前数组的长度\n        char* token = strtok(inputStr, \",\");  // 使用逗号作为分隔符分割字符串\n        \n        // 分割字符串并转换为整数存入当前数组\n        while (token != NULL) {\n            inputArrays[i][len++] = atoi(token);  // 将字符串转换为整数并存入数组\n            token = strtok(NULL, \",\");  // 获取下一个逗号后的字符串\n            totalCount++;  // 更新总元素个数\n        }\n        arrayLengths[i] = len;  // 记录当前数组的长度\n    }\n    \n    // 合并数组\n    int* result = (int*)malloc(totalCount * sizeof(int));  // 分配空间存储合并后的数组\n    int num = 0;  // 已经处理的元素数量\n    \n    // 按顺序合并所有数组中的元素\n    while (num < totalCount) {\n        for (int i = 0; i < arrayNum; i++) {  // 遍历所有数组\n            for (int j = 0; j < fixedLength; j++) {  // 每次取出固定长度的元素\n                if (arrayLengths[i] > 0) {  // 如果当前数组还有剩余元素\n                    result[num++] = inputArrays[i][0];  // 将第一个元素加入结果数组\n                    // 移动数组，将当前数组的元素向前平移\n                    for (int k = 0; k < arrayLengths[i] - 1; k++) {\n                        inputArrays[i][k] = inputArrays[i][k + 1];\n                    }\n                    arrayLengths[i]--;  // 更新当前数组的长度\n                } else {\n                    break;  // 如果当前数组为空，跳出循环\n                }\n            }\n        }\n    }\n    \n    // 输出合并后的结果\n    for (int i = 0; i < totalCount - 1; i++) {\n        printf(\"%d,\", result[i]);  // 输出每个元素，并在元素之间加上逗号\n    }\n    printf(\"%d\\n\", result[totalCount - 1]);  // 输出最后一个元素，不加逗号\n\n    // 释放分配的内存\n    for (int i = 0; i < arrayNum; i++) {\n        free(inputArrays[i]);  // 释放每个数组的内存\n    }\n    free(inputArrays);  // 释放存储所有数组的指针\n    free(arrayLengths);  // 释放记录数组长度的内存\n    free(result);  // 释放结果数组的内存\n\n    return 0;\n}"
    }
  },
  {
    "id": "30",
    "title": "整数对最小和",
    "examType": "A",
    "score": 100,
    "description": "给定两个整数数组array1、array2，数组元素按升序排列。\n假设从array1、array2中分别取出一个元素可构成一对元素，现在需要取出k对元素，\n并对取出的所有元素求和，计算和的最小值。\n注意：\n两对元素如果对应于array1、array2中的两个下标均相同，则视为同一对元素。",
    "inputDesc": "输入两行数组array1、array2，每行首个数字为数组大小size(0 < size <= 100);\n0 < array1[i] <= 1000\n0 < array2[i] <= 1000\n接下来一行为正整数k\n0 < k <= array1.size() * array2.size()",
    "outputDesc": "满足要求的最小和",
    "examples": [
      {
        "input": "1 1 2\n 1 2 3",
        "output": "1 1 2\n 1 2 3",
        "explanation": "用例中，需要取2对元素 取第一个数组第0个元素与第二个数组第0个元素组成1对元素[1,1]; 取第一个数组第1个元素与第二个数组第0个元素组成1对元素[1,1]; 求和为1+1+1+1=4，为满足要求的最小和。"
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 输入第一个数组\n        int size1 = scanner.nextInt();\n        List<Integer> array1 = new ArrayList<>();\n        for (int i = 0; i < size1; i++) {\n            array1.add(scanner.nextInt());\n        }\n\n        // 输入第二个数组\n        int size2 = scanner.nextInt();\n        List<Integer> array2 = new ArrayList<>();\n        for (int i = 0; i < size2; i++) {\n            array2.add(scanner.nextInt());\n        }\n\n        // 输入需要取出的元素对数\n        int k = scanner.nextInt();\n\n        // 存储所有可能的元素对的和\n        List<Integer> pairsSum = new ArrayList<>();\n        for (int value1 : array1) {\n            for (int value2 : array2) {\n                pairsSum.add(value1 + value2);\n            }\n        }\n\n        // 对和进行排序\n        Collections.sort(pairsSum);\n\n        // 取前k个元素进行求和\n        int minSum = 0;\n        for (int i = 0; i < k; i++) {\n            minSum += pairsSum.get(i);\n        }\n\n        System.out.println(minSum);\n    }\n}",
      "python": "# 从输入中获取数组array1，使用map函数将输入的字符串转换为整数，并使用列表切片[1:]去除第一个元素\narray1 = list(map(int, input().split()))[1:]\n\n# 从输入中获取数组array2，使用map函数将输入的字符串转换为整数，并使用列表切片[1:]去除第一个元素\narray2 = list(map(int, input().split()))[1:]\n\n# 从输入中获取k的值，将其转换为整数\nk = int(input())\n\n# 存储所有可能的元素对的和\npairsSum = []\nfor value1 in array1:\n    for value2 in array2:\n        pairsSum.append(value1 + value2)\n\n# 对和进行排序\npairsSum.sort()\n\n# 取前k个元素进行求和\nminSum = sum(pairsSum[:k])\n\n# 输出最小和\nprint(minSum)",
      "javascript": "const readline = require('readline');\n\n// 创建readline接口实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n rl.on('line', (array1Input) => {\n  // 将输入的字符串按空格分割为数组，并将每个元素转换为数字，然后去除第一个元素\n  const array1 = array1Input.split(' ').map(Number).slice(1);\n\n   rl.on('line', (array2Input) => {\n    // 将输入的字符串按空格分割为数组，并将每个元素转换为数字，然后去除第一个元素\n    const array2 = array2Input.split(' ').map(Number).slice(1);\n\n     rl.on('line', (kInput) => {\n      // 将输入的字符串转换为整数\n      const k = parseInt(kInput);\n\n      // 创建一个空数组pairsSum\n      const pairsSum = [];\n\n      // 嵌套循环，将array1和array2中的元素两两相加，并将结果存储到pairsSum中\n      for (const value1 of array1) {\n        for (const value2 of array2) {\n          pairsSum.push(value1 + value2);\n        }\n      }\n\n      // 对pairsSum中的元素进行排序\n      pairsSum.sort();\n\n      // 取出pairsSum中前k个元素，并使用reduce方法计算它们的和\n      const minSum = pairsSum.slice(0, k).reduce((sum, value) => sum + value, 0);\n\n      // 输出最小和\n      console.log(minSum);\n\n      // 关闭readline接口，结束程序的执行\n      rl.close();\n    });\n  });\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // 输入数组array1的大小\n    int size1;\n    std::cin >> size1;\n\n    // 创建大小为size1的vector来存储array1的元素\n    std::vector<int> array1(size1);\n    for (int i = 0; i < size1; i++) {\n        // 逐个读取array1的元素并存储到vector中\n        std::cin >> array1[i];\n    }\n\n    // 输入数组array2的大小\n    int size2;\n    std::cin >> size2;\n\n    // 创建大小为size2的vector来存储array2的元素\n    std::vector<int> array2(size2);\n    for (int i = 0; i < size2; i++) {\n        // 逐个读取array2的元素并存储到vector中\n        std::cin >> array2[i];\n    }\n\n    // 输入k的值\n    int k;\n    std::cin >> k;\n\n    // 创建一个vector来存储所有可能的元素对的和\n    std::vector<int> pairsSum;\n    for (int value1 : array1) {\n        for (int value2 : array2) {\n            // 将array1和array2中的元素两两相加，并将结果存储到pairsSum中\n            pairsSum.push_back(value1 + value2);\n        }\n    }\n\n    // 对pairsSum中的元素进行排序\n    std::sort(pairsSum.begin(), pairsSum.end());\n\n    // 计算前k个元素的和\n    int minSum = 0;\n    for (int i = 0; i < k; i++) {\n        minSum += pairsSum[i];\n    }\n\n    // 输出最小和\n    std::cout << minSum << std::endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 比较函数，用于qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int size1, size2, k;\n    // 输入数组array1和array2的大小\n    scanf(\"%d\", &size1);\n    int array1[size1];\n    for (int i = 0; i < size1; i++) {\n        scanf(\"%d\", &array1[i]);\n    }\n\n    scanf(\"%d\", &size2);\n    int array2[size2];\n    for (int i = 0; i < size2; i++) {\n        scanf(\"%d\", &array2[i]);\n    }\n\n    // 输入k的值\n    scanf(\"%d\", &k);\n\n    // 创建数组来存储所有可能的元素对的和\n    int pairsSum[size1 * size2];\n    int count = 0;\n    for (int i = 0; i < size1; i++) {\n        for (int j = 0; j < size2; j++) {\n            // 将array1和array2中的元素两两相加，并将结果存储到pairsSum中\n            pairsSum[count++] = array1[i] + array2[j];\n        }\n    }\n\n    // 对pairsSum中的元素进行排序\n    qsort(pairsSum, count, sizeof(int), compare);\n\n    // 计算前k个元素的和\n    int minSum = 0;\n    for (int i = 0; i < k; i++) {\n        minSum += pairsSum[i];\n    }\n\n    // 输出最小和\n    printf(\"%d\\n\", minSum);\n\n    return 0;\n}"
    }
  },
  {
    "id": "31",
    "title": "新工号中数字的最短长度",
    "examType": "A",
    "score": 100,
    "description": "3020年，空间通信集团的员工人数突破20亿人，即将遇到现有工号不够用的窘境。\n现在，请你负责调研新工号系统。继承历史传统，新的工号系统由小写英文字母（a-z）和数字（0-9）两部分构成。\n新工号由一段英文字母开头，之后跟随一段数字，比如”aaahw0001″,”a12345″,”abcd1″,”a00″。\n注意新工号不能全为字母或者数字,允许数字部分有前导0或者全为0。\n但是过长的工号会增加同事们的记忆成本，现在给出新工号至少需要分配的人数X和新工号中字母的长度Y，求新工号中数字的最短长度Z。",
    "inputDesc": "一行两个非负整数 X Y，用数字用单个空格分隔。\n0< X <=2^50 – 1\n0< Y <=5",
    "outputDesc": "输出新工号中数字的最短长度Z",
    "examples": [
      {
        "input": "1",
        "output": "",
        "explanation": "无"
      },
      {
        "input": "1",
        "output": "",
        "explanation": "数字长度不能为0"
      },
      {
        "input": "1",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "这是一个数学问题，我们需要找到一个最小的数字长度Z，使得26的Y次方乘以10的Z次方大于等于X。这是因为26个小写字母可以组成26的Y次方种可能，10个数字可以组成10的Z次方种可能，所以总共可以组成26的Y次方乘以10的Z次方种工号。我们需要找到最小的Z使得这个数大于等于X。\n下面我来分解为几个关键点来解释。\n工号由两部分构成：\n一段英文字母（小写字母 a-z）一段数字（数字0-9）\n新工号必须以字母开头，然后是数字部分。数字部分可以有前导0或全为0。\n假设字母部分长度为 Y，那么字母部分可以生成的不同组合数为 2 6 Y 26^Y 26Y（因为每个位置可以是26个字母中的一个）。这代表着，当字母长度固定为 Y 时，数字部分的长度 Z 决定了能够生成的工号总数。\n对于给定的字母部分长度 Y，总共有 2 6 Y 26^Y 26Y 种不同的字母组合。每种字母组合对应一段数字部分。如果我们要生成 X 个不同的工号，那么数字部分的长度 Z 需要满足以下条件：\n1 0 Z × 2 6 Y ≥ X 10^Z \\times 26^Y \\geq X 10Z×26Y≥X\n因此，数字部分的最小长度 Z 可以通过计算以下公式得到：\nZ = ⌈ log ⁡ 10 ( X 2 6 Y ) ⌉ Z = \\lceil \\log_{10}(\\frac{X}{26^Y}) \\rceil Z=⌈log10​(26YX​)⌉\n其中， ⌈ ⋅ ⌉ \\lceil \\cdot \\rceil ⌈⋅⌉ 表示向上取整的操作，保证数字部分长度足够大以生成 X 个不同的工号。\nX: 需要生成的工号数量Y: 工号中字母部分的长度\nZ: 工号中数字部分的最短长度",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        long num_people = scanner.nextLong();\n        long len_letter = scanner.nextLong();\n        long min_len_num = Math.max(1L, (long) Math.ceil(Math.log10(num_people / Math.pow(26, len_letter))));\n        System.out.println(min_len_num);\n        scanner.close();\n    }\n}",
      "python": "import math\n\nnum_people, len_letter = map(int, input().split())\nmin_len_num = max(1, math.ceil(math.log10(num_people / pow(26, len_letter))))\nprint(min_len_num)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (input) => {\n  const [num_people, len_letter] = input.split(' ').map(Number);\n  const min_len_num = Math.max(1, Math.ceil(Math.log10(num_people / Math.pow(26, len_letter))));\n  console.log(min_len_num);\n});",
      "cpp": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    long long num_people, len_letter;\n    cin >> num_people >> len_letter;\n    long long min_len_num = max(1LL, (long long) ceil(log10(num_people / pow(26, len_letter))));\n    cout << min_len_num << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    long long num_people, len_letter;\n    \n    scanf(\"%lld %lld\", &num_people, &len_letter);\n    \n    long long min_len_num = (long long) fmax(1.0, ceil(log10(num_people / pow(26, len_letter))));\n    \n    printf(\"%lld\\n\", min_len_num);\n    \n    return 0;\n}"
    }
  },
  {
    "id": "32",
    "title": "智能成绩表",
    "examType": "A",
    "score": 100,
    "description": "小明来到学校当老师，需要将学生按考试总分或单科分数进行排名，你能帮帮他吗？",
    "inputDesc": "第 1 行输入两个整数，学生人数 n 和科目数量 m。\n0 < n < 1000 < m < 10\n第 2 行输入 m 个科目名称，彼此之间用空格隔开。\n科目名称只由英文字母构成，单个长度不超过10个字符。科目的出现顺序和后续输入的学生成绩一一对应。不会出现重复的科目名称。\n第 3 行开始的 n 行，每行包含一个学生的姓名和该生 m 个科目的成绩（空格隔开）\n学生不会重名。学生姓名只由英文字母构成，长度不超过10个字符。成绩是0~100的整数，依次对应第2行种输入的科目。\n第n+2行，输入用作排名的科目名称。若科目不存在，则按总分进行排序。",
    "outputDesc": "输出一行，按成绩排序后的学生名字，空格隔开。成绩相同的按照学生姓名字典顺序排序。",
    "examples": [
      {
        "input": "2\nyuwen shuxue\nfangfang 95 90\nxiaohua 88 98\nminmin 100 82\nshuxue",
        "output": "xiaohua fangfang minmin",
        "explanation": "按照shuxue成绩排名依次是 xiaohua fangfang minmin"
      },
      {
        "input": "2\nyuwen shuxue\nfangfang 95 90\nxiaohua 88 95\nminmin 90 95\nzongfen",
        "output": "fangfang minmin xiaohua",
        "explanation": "排序科目不存在，按总分排序 , fangfang 和 minmin 总分相同，按姓名的字典序顺序， fangfang 排在前面"
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    // 定义学生类\n    static class Student {\n        String name; // 学生姓名\n        int totalScore; // 学生总分\n        Map<String, Integer> scores; // 存储学生各科成绩的映射\n\n        // 构造函数，初始化学生姓名、成绩映射和总分\n        Student(String name) {\n            this.name = name;\n            this.scores = new HashMap<>();\n            this.totalScore = 0;\n        }\n\n        // 添加成绩的方法，同时累加到总分\n        void addScore(String subject, int score) {\n            scores.put(subject, score);\n            totalScore += score;\n        }\n\n        // 获取指定科目的成绩，若没有则返回0\n        int getScore(String subject) {\n            return scores.getOrDefault(subject, 0);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // 读取学生人数和科目数量\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        scanner.nextLine(); // 读取并忽略换行符\n\n        // 读取科目名称\n        String[] subjects = scanner.nextLine().split(\" \");\n        List<Student> students = new ArrayList<>();\n\n        // 读取每个学生的姓名和成绩\n        for (int i = 0; i < n; i++) {\n            String[] tokens = scanner.nextLine().split(\" \");\n            Student student = new Student(tokens[0]);\n            for (int j = 0; j < m; j++) {\n                student.addScore(subjects[j], Integer.parseInt(tokens[j + 1]));\n            }\n            students.add(student);\n        }\n\n        // 读取用作排名的科目名称\n        String rankSubject = scanner.nextLine();\n        // 关闭扫描器\n        scanner.close();\n\n        // 对学生列表进行排序\n        students.sort((s1, s2) -> {\n            // 根据指定科目或总分进行比较\n            int score1 = rankSubject.equals(\"\") ? s1.totalScore : s1.getScore(rankSubject);\n            int score2 = rankSubject.equals(\"\") ? s2.totalScore : s2.getScore(rankSubject);\n            if (score1 != score2) {\n                return score2 - score1; // 降序排序\n            } else {\n                return s1.name.compareTo(s2.name); // 成绩相同则按姓名升序排序\n            }\n        });\n\n        // 输出排序后的学生姓名\n        students.forEach(student -> System.out.print(student.name + \" \"));\n    }\n}",
      "python": "# 导入必要的库\nfrom collections import defaultdict\n\n# 定义学生类\nclass Student:\n    def __init__(self, name):\n        self.name = name  # 学生姓名\n        self.total_score = 0  # 学生总分\n        self.scores = defaultdict(int)  # 存储学生各科成绩的字典，默认值为0\n\n    # 添加成绩的方法，同时累加到总分\n    def add_score(self, subject, score):\n        self.scores[subject] = score\n        self.total_score += score\n\n    # 获取指定科目的成绩\n    def get_score(self, subject):\n        return self.scores[subject]\n\n# 主函数\ndef main():\n    # 读取学生人数和科目数量\n    n, m = map(int, input().split())\n    \n    # 读取科目名称\n    subjects = input().split()\n    students = []\n\n    # 读取每个学生的姓名和成绩\n    for _ in range(n):\n        tokens = input().split()\n        student = Student(tokens[0])\n        for j in range(m):\n            student.add_score(subjects[j], int(tokens[j + 1]))\n        students.append(student)\n\n    # 读取用作排名的科目名称\n    rank_subject = input()\n\n    # 对学生列表进行排序\n    students.sort(key=lambda s: (-s.get_score(rank_subject) if rank_subject else -s.total_score, s.name))\n\n    # 输出排序后的学生姓名\n    for student in students:\n        print(student.name, end=' ')\n\n# 调用主函数\nif __name__ == \"__main__\":\n    main()",
      "javascript": "// 引入 readline 模块用于读取命令行输入\nconst readline = require('readline');\n\n// 创建 readline 接口实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 定义学生类\nclass Student {\n  constructor(name) {\n    this.name = name; // 学生姓名\n    this.totalScore = 0; // 学生总分\n    this.scores = {}; // 存储学生各科成绩的映射\n  }\n\n  // 添加成绩的方法，同时累加到总分\n  addScore(subject, score) {\n    this.scores[subject] = score;\n    this.totalScore += score;\n  }\n\n  // 获取指定科目的成绩，若没有则返回0\n  getScore(subject) {\n    return this.scores[subject] || 0;\n  }\n}\n\n// 创建一个异步处理函数\nasync function processInput() {\n  // 通过 readline 逐行读取输入\n  const lines = [];\n  for await (const line of rl) {\n    lines.push(line);\n  }\n\n  // 解析输入数据\n  const [n, m] = lines[0].split(' ').map(Number);\n  const subjects = lines[1].split(' ');\n  const students = [];\n\n  // 读取每个学生的姓名和成绩\n  for (let i = 0; i < n; i++) {\n    const tokens = lines[i + 2].split(' ');\n    const student = new Student(tokens[0]);\n    for (let j = 0; j < m; j++) {\n      student.addScore(subjects[j], parseInt(tokens[j + 1], 10));\n    }\n    students.push(student);\n  }\n\n  // 读取用作排名的科目名称\n  const rankSubject = lines[n + 2];\n\n  // 对学生列表进行排序\n  students.sort((s1, s2) => {\n    const score1 = rankSubject === '' ? s1.totalScore : s1.getScore(rankSubject);\n    const score2 = rankSubject === '' ? s2.totalScore : s2.getScore(rankSubject);\n    if (score1 !== score2) {\n      return score2 - score1; // 降序排序\n    } else {\n      return s1.name.localeCompare(s2.name); // 成绩相同则按姓名升序排序\n    }\n  });\n\n  // 输出排序后的学生姓名\n  students.forEach(student => process.stdout.write(`${student.name} `));\n  process.stdout.write('\\n');\n\n  // 关闭 readline 接口\n  rl.close();\n}\n\n// 调用异步处理函数\nprocessInput();",
      "cpp": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n// 定义学生类\nclass Student {\npublic:\n    string name; // 学生姓名\n    int totalScore; // 学生总分\n    map<string, int> scores; // 存储学生各科成绩的映射\n\n    // 构造函数，初始化学生姓名和总分\n    Student(const string& name) : name(name), totalScore(0) {}\n\n    // 添加成绩的方法，同时累加到总分\n    void addScore(const string& subject, int score) {\n        scores[subject] = score; // 设置指定科目的成绩\n        totalScore += score; // 累加到总分\n    }\n\n    // 获取指定科目的成绩\n    int getScore(const string& subject) const {\n        auto it = scores.find(subject); // 查找科目对应的成绩\n        return it != scores.end() ? it->second : 0; // 如果找到，则返回成绩，否则返回0\n    }\n};\n\nint main() {\n    int n, m; // n为学生数量，m为科目数量\n    cin >> n >> m;\n    vector<string> subjects(m); // 存储科目名称的向量\n    for (int i = 0; i < m; ++i) {\n        cin >> subjects[i]; // 输入科目名称\n    }\n    vector<Student> students; // 存储学生对象的向量\n\n    for (int i = 0; i < n; ++i) {\n        string name; // 学生姓名\n        cin >> name; // 输入学生姓名\n        Student student(name); // 创建学生对象\n        for (int j = 0; j < m; ++j) {\n            int score; // 成绩\n            cin >> score; // 输入成绩\n            student.addScore(subjects[j], score); // 添加成绩到学生对象\n        }\n        students.push_back(student); // 将学生对象添加到向量中\n    }\n\n    string rankSubject; // 用作排名的科目名称\n    cin >> rankSubject; // 输入排名科目\n\n    // 对学生进行排序\n    sort(students.begin(), students.end(), [&](const Student& a, const Student& b) {\n        int scoreA = rankSubject.empty() ? a.totalScore : a.getScore(rankSubject); // 获取a的排名科目成绩或总分\n        int scoreB = rankSubject.empty() ? b.totalScore : b.getScore(rankSubject); // 获取b的排名科目成绩或总分\n        if (scoreA != scoreB) {\n            return scoreA > scoreB; // 成绩高的排前面\n        }\n        return a.name < b.name; // 成绩相同则按姓名字典序排列\n    });\n\n    // 输出排序后的学生姓名\n    for (const auto& student : students) {\n        cout << student.name << ' ';\n    }\n    cout << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_STUDENTS 100\n#define MAX_SUBJECTS 10\n#define MAX_NAME_LEN 11\n\n// 定义学生结构体\ntypedef struct {\n    char name[MAX_NAME_LEN]; // 学生姓名\n    int totalScore; // 学生总分\n    int scores[MAX_SUBJECTS]; // 存储学生各科成绩的数组\n} Student;\n\n// 定义全局变量\nint n, m; // n为学生数量，m为科目数量\nchar subjects[MAX_SUBJECTS][MAX_NAME_LEN]; // 存储科目名称的数组\nStudent students[MAX_STUDENTS]; // 存储学生对象的数组\nchar rankSubject[MAX_NAME_LEN]; // 用作排名的科目名称\n\n// 定义比较函数，用于 qsort 函数\nint cmp(const void *a, const void *b) {\n    Student *studentA = (Student *)a;\n    Student *studentB = (Student *)b;\n    int scoreA = studentA->totalScore;\n    int scoreB = studentB->totalScore;\n    if (strcmp(rankSubject, \"\") != 0) {\n        for (int i = 0; i < m; ++i) {\n            if (strcmp(rankSubject, subjects[i]) == 0) {\n                scoreA = studentA->scores[i];\n                scoreB = studentB->scores[i];\n                break;\n            }\n        }\n    }\n    if (scoreA != scoreB) {\n        return scoreB - scoreA; // 成绩高的排前面\n    }\n    return strcmp(studentA->name, studentB->name); // 成绩相同则按姓名字典序排列\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 0; i < m; ++i) {\n        scanf(\"%s\", subjects[i]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%s\", students[i].name);\n        students[i].totalScore = 0;\n        for (int j = 0; j < m; ++j) {\n            scanf(\"%d\", &students[i].scores[j]);\n            students[i].totalScore += students[i].scores[j];\n        }\n    }\n\n    scanf(\"%s\", rankSubject);\n\n    // 对学生进行排序\n    qsort(students, n, sizeof(Student), cmp);\n\n    // 输出排序后的学生姓名\n    for (int i = 0; i < n; ++i) {\n        printf(\"%s \", students[i].name);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
    }
  },
  {
    "id": "33",
    "title": "最大值",
    "examType": "A",
    "score": 100,
    "description": "给定一组整数（非负），重排顺序后输出一个最大的整数。\n示例1\n输入：[10,9]\n输出：910\n说明:输出结果可能非常大，所以你需要返回一个字符串而不是整数。",
    "inputDesc": "数字组合",
    "outputDesc": "最大的整数",
    "examples": [
      {
        "input": "9",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "题目要求是：给定一组非负整数，通过重新排列这些整数的顺序，拼接成一个最大的整数，并返回该结果。\n由于输出的结果可能非常大，题目要求返回的结果是一个字符串，而不是整数类型。\n跟这道题一致：https://leetcode.cn/problems/largest-number/description/",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 读取输入\n        Scanner sc = new Scanner(System.in);\n        String[] input = sc.nextLine().split(\" \");  // 读取并拆分输入\n        int[] nums = new int[input.length];\n        \n        // 将输入的字符串数组转换为整数数组\n        for (int i = 0; i < input.length; i++) {\n            nums[i] = Integer.parseInt(input[i]);\n        }\n        \n       \n        int n = nums.length;\n        String[] ss = new String[n];\n        \n        // 将整数数组转换为字符串数组\n        for (int i = 0; i < n; i++) {\n            ss[i] = String.valueOf(nums[i]);\n        }\n\n        // 自定义排序规则，比较两个字符串拼接后的大小\n        Arrays.sort(ss, (a, b) -> {\n            String sa = a + b, sb = b + a;\n            return sb.compareTo(sa);  // 按照拼接后的字符串从大到小排序\n        });\n\n        // 拼接排序后的字符串\n        StringBuilder sb = new StringBuilder();\n        for (String s : ss) {\n            sb.append(s);\n        }\n\n        // 去除多余的前导零\n        int len = sb.length();\n        int k = 0;\n        while (k < len - 1 && sb.charAt(k) == '0') {\n            k++;\n        }\n\n        // 输出最终的结果字符串\n        System.out.println(sb.substring(k));\n    }\n}",
      "python": "# 导入需要的模块\nimport functools\n\n# 读取输入并分割\ninput_str = input().split()\n\n# 将字符串数组转换为整数数组\nnums = [int(i) for i in input_str]\n\n# 将整数数组转换为字符串数组\nstr_nums = [str(num) for num in nums]\n\n# 定义自定义排序规则，比较两个字符串拼接后的大小\ndef compare(a, b):\n    if a + b > b + a:\n        return -1\n    elif a + b < b + a:\n        return 1\n    else:\n        return 0\n\n# 对字符串数组进行排序\nstr_nums.sort(key=functools.cmp_to_key(compare))\n\n# 拼接排序后的字符串\nresult = ''.join(str_nums)\n\n# 去除前导零，如果全是零，则只返回一个零\nresult = result.lstrip('0') or '0'\n\n# 输出最终结果\nprint(result)",
      "javascript": "const readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n \n\n  // 将后续的输入处理为整数数组\n  const nums = line.split(\" \").map(Number);\n\n  // 将整数数组转换为字符串数组\n  let str_nums = nums.map(num => num.toString());\n\n  // 自定义排序规则，比较两个字符串拼接后的大小\n  str_nums.sort((a, b) => (b + a).localeCompare(a + b));\n\n  // 拼接排序后的字符串\n  let result = str_nums.join(\"\");\n\n  // 去除前导零，如果全是零，则只返回一个零\n  result = result.replace(/^0+/, \"\") || \"0\";\n\n  // 输出最终结果\n  console.log(result);\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\n// 自定义比较函数，比较拼接后的字符串\nbool compare(const string &a, const string &b) {\n    return a + b > b + a;\n}\n\nint main() {\n    // 读取输入\n    string input;\n    getline(cin, input);\n    \n    vector<string> nums;\n    string temp = \"\";\n    \n    // 将输入的字符串分割为单独的数字\n    for (char c : input) {\n        if (c == ' ') {\n            nums.push_back(temp);\n            temp = \"\";\n        } else {\n            temp += c;\n        }\n    }\n    nums.push_back(temp);\n    \n    // 对字符串数组进行排序\n    sort(nums.begin(), nums.end(), compare);\n    \n    // 拼接排序后的字符串\n    string result = \"\";\n    for (const string &num : nums) {\n        result += num;\n    }\n    \n    // 去除前导零\n    int k = 0;\n    while (k < result.size() - 1 && result[k] == '0') {\n        k++;\n    }\n    \n    // 输出最终结果\n    cout << result.substr(k) << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 自定义比较函数，比较拼接后的字符串\nint compare(const void *a, const void *b) {\n    char sa[40], sb[40];\n    strcpy(sa, *(const char **)a);\n    strcat(sa, *(const char **)b);\n    strcpy(sb, *(const char **)b);\n    strcat(sb, *(const char **)a);\n    return strcmp(sb, sa);\n}\n\nint main() {\n    char input[1000];\n    char *nums[500];\n    int n = 0;\n\n    // 读取输入\n    fgets(input, sizeof(input), stdin);\n\n    // 使用 strtok 分割输入的字符串\n    char *token = strtok(input, \" \\n\");\n    while (token != NULL) {\n        nums[n++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n\n    // 使用 qsort 排序\n    qsort(nums, n, sizeof(char *), compare);\n\n    // 拼接排序后的字符串\n    char result[1000] = \"\";\n    for (int i = 0; i < n; i++) {\n        strcat(result, nums[i]);\n    }\n\n    // 去除前导零\n    int k = 0;\n    while (result[k] == '0' && result[k + 1] != '\\0') {\n        k++;\n    }\n\n    // 输出最终结果\n    printf(\"%s\\n\", result + k);\n\n    return 0;\n}"
    }
  },
  {
    "id": "34",
    "title": "最小的调整次数特异性双端队列",
    "examType": "A",
    "score": 100,
    "description": "有一个特异性的双端队列，该队列可以从头部或尾部添加数据，但是只能从头部移出数据。\n小A依次执行2n个指令往队列中添加数据和移出数据。其中n个指令是添加数据（可能从头部添加、也可能从尾部添加），依次添加1到n；n个指令是移出数据。\n现在要求移除数据的顺序为1到n。\n为了满足最后输出的要求，小A可以在任何时候调整队列中数据的顺序。\n请问 小A 最少需要调整几次才能够满足移除数据的顺序正好是1到n。",
    "inputDesc": "第一行一个数据n，表示数据的范围。\n接下来的2n行，其中有n行为添加数据，指令为：\nhead add x表示从头部添加数据 x，tail add x 表示从尾部添加数据x，\n另外 n 行为移出数据指令，指令为：remove 的形式，表示移出1个数据；\n1 ≤ n ≤ 3 * 10^5。\n所有的数据均合法。",
    "outputDesc": "一个整数，表示 小A 要调整的最小次数。",
    "examples": [
      {
        "input": "head add 1\ntail add 2\nremove\nhead add 3\ntail add 4\nhead add 5\nremove\nremove\nremove\nremove",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int number = scanner.nextInt();//数据的范围\n        scanner.nextLine();\n\n        Queue<Integer> queue = new LinkedList<>();//模拟双端队列\n        boolean in_order = true;//是否按顺序删除\n        int result = 0;//最小的调整顺序次数\n\n        for (int i = 0; i < 2 * number; i++) {\n            String input_str = scanner.nextLine();\n            String[] operation = input_str.split(\" \");\n            if (operation[0].equals(\"head\")) {//从头部添加元素\n                if (!queue.isEmpty() && in_order) {//不按顺序删除\n                    in_order = false;\n                }\n                queue.add(Integer.parseInt(operation[2]));\n            } else if (operation[0].equals(\"tail\")) {//从尾部添加元素\n                queue.add(Integer.parseInt(operation[2]));\n            } else {//删除元素\n                if (queue.isEmpty()) {\n                    continue;\n                }\n                if (!in_order) {//不按顺序删除\n                    result++;\n                    in_order = true;\n                }\n                queue.poll();\n            }\n        }\n\n        System.out.println(result);//输出最小的调整顺序次数\n    }\n}",
      "python": "from collections import deque\n\nnumber = int(input()) # 数据的范围\n\nqueue = deque() # 模拟双端队列\nin_order = True # 是否按顺序删除\nresult = 0 # 最小的调整顺序次数\n\nfor i in range(2 * number):\n    input_str = input()\n    operation = input_str.split(\" \")\n    if operation[0] == \"head\": # 从头部添加元素\n        if len(queue) != 0 and in_order: # 不按顺序删除\n            in_order = False\n        queue.appendleft(int(operation[2]))\n    elif operation[0] == \"tail\": # 从尾部添加元素\n        queue.append(int(operation[2]))\n    else: # 删除元素\n        if len(queue) == 0:\n            continue\n        if not in_order: # 不按顺序删除\n            result += 1\n            in_order = True\n        queue.pop()\n\nprint(result) # 输出最小的调整顺序次数",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet number = 0;\nlet operations = [];\n\nrl.on('line', (input) => {\n  if (number === 0) {\n    number = parseInt(input);\n  } else {\n    operations.push(input.split(\" \"));\n    if (operations.length === 2 * number) {\n      rl.close();\n    }\n  }\n});\n\nconst queue = []; // 模拟双端队列\nlet in_order = true; // 是否按顺序删除\nlet result = 0; // 最小的调整顺序次数\n\nrl.on('close', () => {\n  for (let i = 0; i < 2 * number; i++) {\n    const operation = operations[i];\n     if (operation[0] === \"head\") { // 从头部添加元素\n      if (queue.length !== 0 && in_order) { // 不按顺序删除\n        in_order = false;\n      }\n      queue.unshift(parseInt(operation[2]));\n    } else if (operation[0] === \"tail\") { // 从尾部添加元素\n      queue.push(parseInt(operation[2]));\n    } else { // 删除元素\n      if (queue.length === 0) {\n        continue;\n      }\n      if (!in_order) { // 不按顺序删除\n        result += 1;\n        in_order = true;\n      }\n      queue.pop();\n    }\n  }\n  console.log(result); // 输出最小的调整顺序次数\n});",
      "cpp": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int number;\n    cin >> number;\n    cin.ignore();\n\n    queue<int> queue;\n    bool in_order = true;\n    int result = 0;\n\n    for (int i = 0; i < 2 * number; i++) {\n        string input_str;\n        getline(cin, input_str);\n        string operation[3];\n        int j = 0;\n        for (char c : input_str) {\n            if (c == ' ') {\n                j++;\n            } else {\n                operation[j] += c;\n            }\n        }\n        if (operation[0] == \"head\") {\n            if (!queue.empty() && in_order) {\n                in_order = false;\n            }\n            queue.push(stoi(operation[2]));\n        } else if (operation[0] == \"tail\") {\n            queue.push(stoi(operation[2]));\n        } else {\n            if (queue.empty()) {\n                continue;\n            }\n            if (!in_order) {\n                result++;\n                in_order = true;\n            }\n            queue.pop();\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 600000 // 定义队列的最大容量（2n）\n\nint queue[MAX_SIZE]; // 模拟双端队列的数组\nint front = 0; // 队列头部索引\nint rear = -1; // 队列尾部索引\nint size = 0; // 当前队列中的元素数量\n\nint main() {\n    int n;\n    scanf(\"%d\", &n); // 读取数据范围n\n\n    int result = 0; // 记录最小的调整顺序次数\n    int expected = 1; // 期望移除的下一个元素\n    int in_order = 1; // 标记是否按顺序删除\n\n    for (int i = 0; i < 2 * n; i++) {\n        char operation[10];\n        int x;\n\n        scanf(\"%s\", operation); // 读取操作类型\n\n        if (operation[0] == 'r') { // 如果是 \"remove\" 操作\n            if (queue[front] != expected) { // 如果移除的元素不是期望的\n                in_order = 0; // 标记为不按顺序\n            } else {\n                expected++; // 移除的元素符合预期，更新下一个期望值\n            }\n            front = (front + 1) % MAX_SIZE; // 更新头部索引\n            size--; // 减少队列中的元素数量\n        } else { // 如果是 \"head add\" 或 \"tail add\" 操作\n            scanf(\"%*s %d\", &x); // 读取要添加的元素x\n\n            if (operation[0] == 'h') { // 如果是 \"head add\"\n                front = (front - 1 + MAX_SIZE) % MAX_SIZE; // 更新头部索引\n                queue[front] = x; // 从头部添加元素\n            } else { // 如果是 \"tail add\"\n                rear = (rear + 1) % MAX_SIZE; // 更新尾部索引\n                queue[rear] = x; // 从尾部添加元素\n            }\n            size++; // 增加队列中的元素数量\n        }\n        \n        if (!in_order && size == 0) { // 如果当前不按顺序且队列为空\n            result++; // 增加调整次数\n            in_order = 1; // 重置为按顺序状态\n        }\n    }\n\n    printf(\"%d\\n\", result); // 输出最小的调整顺序次数\n\n    return 0;\n}"
    }
  },
  {
    "id": "35",
    "title": "最少交换次数",
    "examType": "A",
    "score": 100,
    "description": "给出数字K,请输出所有结果小于K的整数组合到一起的最少交换次数。 组合一起是指满足条件的数字相邻，不要求相邻后在数组中的位置。\n数据范围：\n100 <= K <= 100 100 <= 数组中数值 <= 100\n100 <= K <= 100\n100 <= 数组中数值 <= 100",
    "inputDesc": "第一行输入数组：1 3 1 4 0\n第二行输入K数值：2",
    "outputDesc": "第一行输出最少交换次数：1",
    "examples": [
      {
        "input": "3 1 4 0",
        "output": "",
        "explanation": "小于2的表达式是1 1 0, 共三种可能将所有符合要求数字组合一起，最少交换1次。"
      }
    ],
    "solution": "12\n找到小于 2 的元素：在给定数组 [1, 3, 1, 4, 0] 中，小于 2 的元素是 1, 1, 和 0。所以我们需要将这三个元素组合在一起。组合方式：要将这三个元素组合在一起，可以有多种方式。由于题目没有要求元素必须按照原来的顺序排列，所以我们只关心这些元素最终相邻排列的情况。最少交换次数： 原数组是 [1, 3, 1, 4, 0]。将 1, 1, 0 组合在一起，最少的交换次数为 1： 例如，可以通过一次交换操作，将位置 4 的 0 与位置 2 的 3 交换，得到数组 [1, 0, 1, 4, 3]，使得 1, 1, 0 相邻。\n原数组是 [1, 3, 1, 4, 0]。将 1, 1, 0 组合在一起，最少的交换次数为 1： 例如，可以通过一次交换操作，将位置 4 的 0 与位置 2 的 3 交换，得到数组 [1, 0, 1, 4, 3]，使得 1, 1, 0 相邻。\n例如，可以通过一次交换操作，将位置 4 的 0 与位置 2 的 3 交换，得到数组 [1, 0, 1, 4, 3]，使得 1, 1, 0 相邻。\n所以，这句话的重点在于，通过最少的交换次数，将三个小于 2 的元素组合在一起（相邻），而这个最少次数在这个例子中是 1。\n标记小于 ( K ) 的元素：首先遍历数组，找出所有小于 ( K ) 的元素，标记它们的位置。 计算最少交换次数： 想象一个窗口，这个窗口长度等于标记元素的数量，窗口可以在数组中滑动。对于窗口中每个可能的位置，计算窗口内已经包含的目标元素数量（即窗口内小于 ( K ) 的元素数量）。窗口中包含最多目标元素的位置意味着需要的交换次数最少。交换次数等于窗口大小减去窗口内目标元素的数量。 给定数组为 [1, 3, 1, 4, 0]，( K ) 值为 2。小于 2 的元素是 1, 1, 0。 这些元素的索引是 [0, 2, 4]。可以把这些元素想象为需要放在一个长度为 3 的窗口中。滑动这个窗口，尝试找到包含最多目标元素的窗口。例如，如果窗口覆盖 1, 3, 1，那么窗口已经包含两个目标元素，还需要一个交换将 0 换入窗口。找到一个位置，比如 [1, 1, 0]，只需要交换一次就可以将所有小于 2 的元素组合在一起。 所以，最少交换次数是 1。\n标记小于 ( K ) 的元素：首先遍历数组，找出所有小于 ( K ) 的元素，标记它们的位置。\n计算最少交换次数：\n想象一个窗口，这个窗口长度等于标记元素的数量，窗口可以在数组中滑动。对于窗口中每个可能的位置，计算窗口内已经包含的目标元素数量（即窗口内小于 ( K ) 的元素数量）。窗口中包含最多目标元素的位置意味着需要的交换次数最少。交换次数等于窗口大小减去窗口内目标元素的数量。\n给定数组为 [1, 3, 1, 4, 0]，( K ) 值为 2。小于 2 的元素是 1, 1, 0。\n这些元素的索引是 [0, 2, 4]。可以把这些元素想象为需要放在一个长度为 3 的窗口中。滑动这个窗口，尝试找到包含最多目标元素的窗口。例如，如果窗口覆盖 1, 3, 1，那么窗口已经包含两个目标元素，还需要一个交换将 0 换入窗口。找到一个位置，比如 [1, 1, 0]，只需要交换一次就可以将所有小于 2 的元素组合在一起。\n所以，最少交换次数是 1。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // 使用Scanner读取一行输入\n        String numsStr = scanner.nextLine();\n        // 按空格分割字符串并转换为整数数组\n        String[] numParts = numsStr.split(\" \");\n        int[] nums = new int[numParts.length];\n        for (int i = 0; i < numParts.length; i++) {\n            nums[i] = Integer.parseInt(numParts[i]);\n        }\n        // 读取一个整数k\n        int k = scanner.nextInt();\n        // 计算数组中小于k的元素数量\n        int count = 0;\n        for (int num : nums) {\n            if (num < k) {\n                count++;\n            }\n        }\n        // 如果小于k的元素数量为1，直接输出0\n        if (count == 1) {\n            System.out.println(0);\n            return;\n        }\n        // 计算最少交换次数\n        int minSwapCount = 0;\n        for (int i = 0; i < count; i++) {\n            if (nums[i] >= k) {\n                minSwapCount++;\n            }\n        }\n        int tmpSwapCount = minSwapCount;\n        // 使用滑动窗口更新最小交换次数\n        for (int j = count; j < nums.length; j++) {\n            int preLeft = j - count;\n            int curRight = j;\n            if (nums[preLeft] >= k && nums[curRight] < k) {\n                tmpSwapCount--;\n            } else if (nums[preLeft] < k && nums[curRight] >= k) {\n                tmpSwapCount++;\n            }\n            minSwapCount = Math.min(minSwapCount, tmpSwapCount);\n        }\n        // 输出最终的最小交换次数\n        System.out.println(minSwapCount);\n    }\n}",
      "python": "nums = list(map(int, input().split()))\nk = int(input())\n\ncount = sum(1 for num in nums if num < k)\nif count == 1:\n    print(0)\n    exit()\n\nmin_swap_count = sum(1 for num in nums[:count] if num >= k)\ntmp_swap_count = min_swap_count\n\nfor j in range(count, len(nums)):\n    pre_left = j - count\n    cur_right = j\n    if nums[pre_left] >= k and nums[cur_right] < k:\n        tmp_swap_count -= 1\n    elif nums[pre_left] < k and nums[cur_right] >= k:\n        tmp_swap_count += 1\n    min_swap_count = min(min_swap_count, tmp_swap_count)\n\nprint(min_swap_count)",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', (numsStr) => {\n    const nums = numsStr.split(' ').map(Number);\n    rl.on('line', (k) => {\n        k = parseInt(k);\n        // 计算小于k的元素的数量\n        let count = nums.filter(num => num < k).length;\n        if (count === 1) {\n            console.log(0);\n            rl.close();\n            return;\n        }\n        // 计算需要交换的初始数量\n        let minSwapCount = nums.slice(0, count).filter(num => num >= k).length;\n        let tmpSwapCount = minSwapCount;\n        for (let j = count; j < nums.length; j++) {\n            let preLeft = j - count;\n            let curRight = j;\n            if (nums[preLeft] >= k && nums[curRight] < k) {\n                tmpSwapCount--;\n            } else if (nums[preLeft] < k && nums[curRight] >= k) {\n                tmpSwapCount++;\n            }\n            minSwapCount = Math.min(minSwapCount, tmpSwapCount);\n        }\n        console.log(minSwapCount);\n        rl.close();\n    });\n});",
      "cpp": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    char line[1024];\n    fgets(line, 1024, stdin);\n    int nums[100];\n    int length = 0;\n    char *token = strtok(line, \" \");\n    while (token) {\n        nums[length++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n\n    int count = 0;\n    for (int i = 0; i < length; i++) {\n        if (nums[i] < k) count++;\n    }\n\n    if (count == 1) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    int minSwapCount = 0;\n    for (int i = 0; i < count; i++) {\n        if (nums[i] >= k) minSwapCount++;\n    }\n\n    int tmpSwapCount = minSwapCount;\n    for (int j = count; j < length; j++) {\n        int preLeft = j - count;\n        int curRight = j;\n        if (nums[preLeft] >= k && nums[curRight] < k) {\n            tmpSwapCount--;\n        } else if (nums[preLeft] < k && nums[curRight] >= k) {\n            tmpSwapCount++;\n        }\n        if (tmpSwapCount < minSwapCount) {\n            minSwapCount = tmpSwapCount;\n        }\n    }\n\n    printf(\"%d\\n\", minSwapCount);\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    char line[1024];\n    fgets(line, 1024, stdin);\n    int nums[100];\n    int length = 0;\n    char *token = strtok(line, \" \");\n    while (token) {\n        nums[length++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n\n    int count = 0;\n    for (int i = 0; i < length; i++) {\n        if (nums[i] < k) count++;\n    }\n\n    if (count == 1) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    int minSwapCount = 0;\n    for (int i = 0; i < count; i++) {\n        if (nums[i] >= k) minSwapCount++;\n    }\n\n    int tmpSwapCount = minSwapCount;\n    for (int j = count; j < length; j++) {\n        int preLeft = j - count;\n        int curRight = j;\n        if (nums[preLeft] >= k && nums[curRight] < k) {\n            tmpSwapCount--;\n        } else if (nums[preLeft] < k && nums[curRight] >= k) {\n            tmpSwapCount++;\n        }\n        if (tmpSwapCount < minSwapCount) {\n            minSwapCount = tmpSwapCount;\n        }\n    }\n\n    printf(\"%d\\n\", minSwapCount);\n\n    return 0;\n}"
    }
  },
  {
    "id": "36",
    "title": "服务器广播需要广播的服务器数量",
    "examType": "A",
    "score": 100,
    "description": "服务器连接方式包括直接相连，间接连接。\nA和B直接连接，B和C直接连接，则A和C间接连接。\n直接连接和间接连接都可以发送广播。\n给出一个N*N数组，代表N个服务器，\nmatrix[i][j] == 1， 则代表i和j直接连接；不等于 1 时，代表i和j不直接连接。\nmatrix[i][i] == 1，\n即自己和自己直接连接。matrix[i][j] == matrix[j][i]。\n计算初始需要给几台服务器广播， 才可以使每个服务器都收到广播。",
    "inputDesc": "输入为N行，每行有N个数字，为0或1，由空格分隔，\n构成N*N的数组，N的范围为 1 <= N <= 40",
    "outputDesc": "输出一个数字，为需要广播的服务器的数量",
    "examples": [
      {
        "input": "0 0\n 1 0\n 0 1",
        "output": "",
        "explanation": "3 台服务器互不连接，所以需要分别广播这 3 台服务器"
      },
      {
        "input": "1\n 1",
        "output": "",
        "explanation": "2 台服务器相互连接，所以只需要广播其中一台服务器"
      },
      {
        "input": "1\n 1",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "这道题可以理解为在一组服务器之间进行广播传播。服务器之间既可以直接相连，也可以通过其他服务器间接相连。题目的目的是计算最少需要对几台服务器进行广播，才能保证所有服务器都能收到广播信号。\n服务器的直接连接与间接连接： 如果服务器 A 和服务器 B 直接连接，或者服务器 A 可以通过其他服务器间接连接到 B，则广播信号可以通过这些连接传播。 如果服务器 A 和服务器 B 不存在直接或间接的连接，说明它们属于不同的独立网络，广播信号无法在这些网络间传播。 矩阵描述： 给定的 N*N 矩阵 matrix 描述了服务器的连接状态： matrix[i][j] == 1 表示服务器 i 和服务器 j 直接相连。matrix[i][j] == 0 表示服务器 i 和服务器 j 之间没有直接连接。matrix[i][i] == 1，表示每台服务器都和自己直接相连。矩阵是对称的，即 matrix[i][j] == matrix[j][i]，意味着连接是双向的。 广播的最小台数： 要使每一台服务器都能接收到广播，需要确保每一个相互不连通的服务器组至少有一台服务器接收到初始广播。题目中需要计算最少要对多少台服务器发起广播，才能使所有服务器都能通过直接或间接连接接收到广播。\n服务器的直接连接与间接连接：\n如果服务器 A 和服务器 B 直接连接，或者服务器 A 可以通过其他服务器间接连接到 B，则广播信号可以通过这些连接传播。 如果服务器 A 和服务器 B 不存在直接或间接的连接，说明它们属于不同的独立网络，广播信号无法在这些网络间传播。\n如果服务器 A 和服务器 B 直接连接，或者服务器 A 可以通过其他服务器间接连接到 B，则广播信号可以通过这些连接传播。\n如果服务器 A 和服务器 B 不存在直接或间接的连接，说明它们属于不同的独立网络，广播信号无法在这些网络间传播。\n矩阵描述：\n给定的 N*N 矩阵 matrix 描述了服务器的连接状态： matrix[i][j] == 1 表示服务器 i 和服务器 j 直接相连。matrix[i][j] == 0 表示服务器 i 和服务器 j 之间没有直接连接。matrix[i][i] == 1，表示每台服务器都和自己直接相连。矩阵是对称的，即 matrix[i][j] == matrix[j][i]，意味着连接是双向的。\nmatrix[i][j] == 1 表示服务器 i 和服务器 j 直接相连。matrix[i][j] == 0 表示服务器 i 和服务器 j 之间没有直接连接。matrix[i][i] == 1，表示每台服务器都和自己直接相连。矩阵是对称的，即 matrix[i][j] == matrix[j][i]，意味着连接是双向的。\n广播的最小台数：\n要使每一台服务器都能接收到广播，需要确保每一个相互不连通的服务器组至少有一台服务器接收到初始广播。题目中需要计算最少要对多少台服务器发起广播，才能使所有服务器都能通过直接或间接连接接收到广播。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n    \n        Scanner in = new Scanner(System.in);\n\n        // 首先读取第一行，并将其通过空格拆分成字符串数组\n        String[] str = in.nextLine().split(\" \");\n        int n = str.length;  // 服务器的数量，n 为矩阵的维度\n\n        // 创建 n*n 的二维数组来存储服务器连接状态\n        int[][] arr = new int[n][n];\n\n        // 将第一行的连接状态转换为整数并存入数组 arr\n        for(int i = 0; i < n; i++) {   \n            arr[0][i] = Integer.parseInt(str[i]);\n        }\n\n        // 读取剩下的 n-1 行，并逐行存入 arr 矩阵\n        for(int i = 1; i < n; i++) {   \n            String[] s = in.nextLine().split(\" \");\n            for(int j = 0; j < n; j++) {\n                arr[i][j] = Integer.parseInt(s[j]);\n            }\n        }\n\n        int count = 0;  // 计数器，记录连通分量的数量（即需要广播的服务器数量）\n\n        // 使用队列来记录访问过的节点（服务器）\n        Queue<Integer> queue = new LinkedList<>();\n\n        // 遍历每个服务器，如果该服务器没有被访问过，就执行 DFS，找到其所有连通的服务器\n        for(int i = 0; i < n; i++) {\n            if(!queue.contains(i)) {  // 如果该服务器不在已访问队列中\n                dfs(arr, queue, i);  // 执行深度优先搜索\n                count++;  // 每次找到一个新的连通分量，计数器加1\n            }\n        }\n\n        // 输出需要广播的服务器数量\n        System.out.println(count);\n    }\n    \n    // 深度优先搜索函数，递归查找服务器的所有连通节点\n    public static void dfs(int[][] arr, Queue<Integer> queue, int index) {\n        queue.offer(index);  // 将当前服务器加入已访问队列\n\n        // 从当前服务器开始，查找所有直接相连的服务器\n        for (int i = index + 1; i < arr.length; i++) {\n            // 如果服务器 i 和当前服务器相连且还没有访问过，则继续递归搜索\n            if (arr[index][i] == 1 && !queue.contains(i)) {\n                dfs(arr, queue, i);\n            }\n        }\n    }\n}",
      "python": "import sys\n\n# 深度优先搜索函数，递归遍历图中与当前服务器相连的所有服务器\ndef dfs(arr, visited, index):\n    visited[index] = True  # 标记当前服务器为已访问\n    flag = True  # 标记是否存在相连的服务器\n    for i in range(index + 1, len(arr)):  # 遍历所有服务器\n        if arr[index][i] == 1:  # 如果当前服务器与服务器 i 相连\n            flag = False  # 发现相连的服务器，设置 flag 为 False\n            dfs(arr, visited, i)  # 递归搜索与服务器 i 相连的所有服务器\n    if flag:  # 如果没有发现相连的服务器，即 flag 仍为 True\n        global count  # 使用全局变量 count 计数\n        count += 1  # 说明这是一个新的连通分量，计数加 1\n\n# 初始化计数器\ncount = 0\n\n# 读取输入的第一行，表示服务器的连接矩阵的第一行\nstr = input().split(\" \")\nn = len(str)  # 服务器的数量，也就是矩阵的维度\n\n# 初始化 n*n 的二维数组 arr 来存储服务器连接状态\narr = [[0]*n for _ in range(n)]\n\n# 将第一行数据存入 arr 的第一行\nfor i in range(n):\n    arr[0][i] = int(str[i])\n\n# 读取剩下的行并存入 arr 中\nfor i in range(1, n):\n    s = input().split(\" \")\n    for j in range(n):\n        arr[i][j] = int(s[j])\n\n# 初始化 visited 数组，用来标记每个服务器是否已经被访问\nvisited = [False] * n\n\n# 遍历每个服务器，执行 DFS 查找连通分量\nfor i in range(n):\n    if not visited[i]:  # 如果该服务器没有被访问\n        dfs(arr, visited, i)  # 递归查找所有与该服务器相连的服务器\n\n# 输出连通分量的数量，即需要广播的服务器数量\nprint(count)",
      "javascript": "const readline = require('readline');\n\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 深度优先搜索函数，递归查找与当前服务器相连的所有服务器\nfunction dfs(arr, visited, index) {\n  visited[index] = true;  // 标记当前服务器为已访问\n  let flag = true;  // 标记是否发现相连的服务器\n  for (let i = index + 1; i < arr.length; i++) {  // 遍历服务器\n    if (arr[index][i] === 1) {  // 如果服务器 i 和当前服务器相连\n      flag = false;  // 发现相连的服务器，设置 flag 为 false\n      dfs(arr, visited, i);  // 递归搜索与服务器 i 相连的服务器\n    }\n  }\n  if (flag) {  // 如果 flag 仍为 true，表示该服务器为单独的连通分量\n    count++;  // 增加连通分量计数\n  }\n}\n\n// 初始化计数器\nlet count = 0;\nlet input = '';\n\n \nrl.on('line', (line) => {\n  input += line + '\\n';  // 收集每一行输入\n}).on('close', () => {\n  const lines = input.trim().split('\\n');  // 将输入按行拆分\n  const str = lines[0].split(' ');  // 读取第一行\n  const n = str.length;  // 获取服务器数量\n  const arr = Array(n).fill(0).map(() => Array(n).fill(0));  // 初始化二维数组\n  \n  // 将第一行输入转换为二维数组的第一行\n  for (let i = 0; i < n; i++) {\n    arr[0][i] = parseInt(str[i]);\n  }\n  \n  // 读取剩余行并存入二维数组\n  for (let i = 1; i < n; i++) {\n    const s = lines[i].split(' ');\n    for (let j = 0; j < n; j++) {\n      arr[i][j] = parseInt(s[j]);\n    }\n  }\n  \n  // 初始化访问数组，记录每个服务器是否已访问\n  const visited = Array(n).fill(false);\n  \n  // 遍历每个服务器，查找未访问过的服务器并进行 DFS\n  for (let i = 0; i < n; i++) {\n    if (!visited[i]) {\n      dfs(arr, visited, i);\n    }\n  }\n\n  // 输出连通分量的数量\n  console.log(count);\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count = 0;  // 全局变量，用于记录连通分量的数量\n\n// 深度优先搜索函数，递归查找与当前服务器相连的服务器\nvoid dfs(vector<vector<int>>& arr, vector<bool>& visited, int index) {\n    visited[index] = true;  // 标记当前服务器为已访问\n    bool flag = true;  // 标记是否发现相连的服务器\n\n    // 遍历当前服务器的所有可能相连的服务器\n    for (int i = index + 1; i < arr.size(); i++) {\n        if (arr[index][i] == 1) {  // 如果服务器 i 和当前服务器直接相连\n            flag = false;  // 发现相连服务器，设置 flag 为 false\n            dfs(arr, visited, i);  // 递归查找与服务器 i 相连的服务器\n        }\n    }\n\n    if (flag) {  // 如果 flag 仍然为 true，表示这是一个新的连通分量\n        count++;  // 增加连通分量计数\n    }\n}\n\nint main() {\n    string input;\n    getline(cin, input);  // 读取输入的第一行\n    vector<string> str;  // 用于存储拆分后的字符串\n    size_t pos = 0;\n\n    // 将输入按空格拆分存入 str\n    while ((pos = input.find(\" \")) != string::npos) {\n        str.push_back(input.substr(0, pos));\n        input.erase(0, pos + 1);\n    }\n    str.push_back(input);  // 最后一个元素也存入 str\n\n    int n = str.size();  // 服务器数量\n    vector<vector<int>> arr(n, vector<int>(n, 0));  // 初始化 n*n 的二维数组\n\n    // 将第一行输入数据存入 arr 的第一行\n    for (int i = 0; i < n; i++) {\n        arr[0][i] = stoi(str[i]);\n    }\n\n    // 读取剩余行并存入 arr\n    for (int i = 1; i < n; i++) {\n        getline(cin, input);\n        pos = 0;\n        vector<string> s;\n        while ((pos = input.find(\" \")) != string::npos) {\n            s.push_back(input.substr(0, pos));\n            input.erase(0, pos + 1);\n        }\n        s.push_back(input);  // 最后一个元素也存入 s\n\n        // 将该行数据存入 arr\n        for (int j = 0; j < n; j++) {\n            arr[i][j] = stoi(s[j]);\n        }\n    }\n\n    vector<bool> visited(n, false);  // 初始化 visited 数组，标记服务器是否已访问\n\n    // 遍历每个服务器，查找未访问过的服务器并进行 DFS\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(arr, visited, i);\n        }\n    }\n\n    // 输出连通分量的数量\n    cout << count << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nint count = 0;  // 全局变量，用于记录连通分量的数量\n\n// 深度优先搜索函数，递归查找与当前服务器相连的服务器\nvoid dfs(int** arr, bool* visited, int n, int index) {\n    visited[index] = true;  // 标记当前服务器为已访问\n    bool flag = true;  // 标记是否发现相连的服务器\n\n    // 遍历当前服务器的所有可能相连的服务器\n    for (int i = index + 1; i < n; i++) {\n        if (arr[index][i] == 1) {  // 如果服务器 i 和当前服务器直接相连\n            flag = false;  // 发现相连服务器，设置 flag 为 false\n            dfs(arr, visited, n, i);  // 递归查找与服务器 i 相连的服务器\n        }\n    }\n\n    if (flag) {  // 如果 flag 仍然为 true，表示这是一个新的连通分量\n        count++;  // 增加连通分量计数\n    }\n}\n\nint main() {\n    char input[1024];\n    \n    // 读取输入的第一行\n    fgets(input, sizeof(input), stdin);\n\n    // 按空格拆分输入的字符串，计算服务器数量\n    int n = 0;\n    char* token = strtok(input, \" \");\n    int* str = (int*)malloc(sizeof(int) * 100);  // 假设最多100个服务器\n\n    while (token != NULL) {\n        str[n++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    // 初始化 n*n 的二维数组\n    int** arr = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        arr[i] = (int*)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            arr[i][j] = 0;\n        }\n    }\n\n    // 将第一行输入数据存入 arr 的第一行\n    for (int i = 0; i < n; i++) {\n        arr[0][i] = str[i];\n    }\n\n    // 读取剩余行并存入 arr\n    for (int i = 1; i < n; i++) {\n        fgets(input, sizeof(input), stdin);\n        token = strtok(input, \" \");\n        for (int j = 0; j < n; j++) {\n            arr[i][j] = atoi(token);\n            token = strtok(NULL, \" \");\n        }\n    }\n\n    // 初始化 visited 数组，标记服务器是否已访问\n    bool* visited = (bool*)malloc(n * sizeof(bool));\n    for (int i = 0; i < n; i++) {\n        visited[i] = false;\n    }\n\n    // 遍历每个服务器，查找未访问过的服务器并进行 DFS\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(arr, visited, n, i);\n        }\n    }\n\n    // 输出连通分量的数量\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
    }
  },
  {
    "id": "37",
    "title": "构成正方形的数量",
    "examType": "A",
    "score": 100,
    "description": "输入N个互不相同的二维整数坐标，求这N个坐标可以构成的正方形数量。[内积为零的的两个向量垂直]",
    "inputDesc": "第一行输入为N，N代表坐标数量，N为正整数。N <= 100\n之后的 K 行输入为坐标x y以空格分隔，x，y为整数，-10<=x, y<=10",
    "outputDesc": "输出可以构成的正方形数量。",
    "examples": [
      {
        "input": "3\n 4\n 1",
        "output": "",
        "explanation": "（3个点不足以构成正方形）"
      },
      {
        "input": "0\n 2\n 1\n -1",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "内积（Dot Product）是向量代数中的一个重要概念。给定两个向量 a = ( a 1 , a 2 ) \\mathbf{a} = (a_1, a_2) a=(a1​,a2​) 和 b = ( b 1 , b 2 ) \\mathbf{b} = (b_1, b_2) b=(b1​,b2​)，它们的内积定义为：\na ⋅ b = a 1 × b 1 + a 2 × b 2 \\mathbf{a} \\cdot \\mathbf{b} = a_1 \\times b_1 + a_2 \\times b_2 a⋅b=a1​×b1​+a2​×b2​\n如果两个向量的内积为零，即 a ⋅ b = 0 \\mathbf{a} \\cdot \\mathbf{b} = 0 a⋅b=0，那么这两个向量互相垂直（即成90度角）。\n遍历所有点对，寻找可能的正方形： 对于每一对点 ( A , B ) (A, B) (A,B)，我们假设这两个点为正方形的对角线的两个端点。通过计算向量 A B → \\overrightarrow{AB} AB 的垂直向量，可以找到另外两个点的坐标。检查这两个点是否都在集合中，如果在，则构成一个正方形。 避免重复计算： 在统计正方形时，每个正方形会被计算四次（每个顶点都可能作为起始点），所以最终的正方形数量应该除以4。\n遍历所有点对，寻找可能的正方形：\n对于每一对点 ( A , B ) (A, B) (A,B)，我们假设这两个点为正方形的对角线的两个端点。通过计算向量 A B → \\overrightarrow{AB} AB 的垂直向量，可以找到另外两个点的坐标。检查这两个点是否都在集合中，如果在，则构成一个正方形。\n避免重复计算：\n在统计正方形时，每个正方形会被计算四次（每个顶点都可能作为起始点），所以最终的正方形数量应该除以4。\n12345\nA (0, 0)B (1, 2)C (3, 1)D (2, -1)\n遍历点对： 遍历所有的点对，检查是否能构成正方形。共有 6 对点组合：(A, B), (A, C), (A, D), (B, C), (B, D), (C, D)。 判断正方形： 以点对 (A, B) 为例： 计算可能的两个正方形对角点： (x3, y3) = (-2, 1) 和 (x4, y4) = (3, 1)。(x5, y5) = (-2, -1) 和 (x6, y6) = (-1, 1)。 检查这些点是否存在于输入的坐标集合中： (x3, y3) 不存在，但 (x4, y4) 即 C 存在。(x5, y5) 即 D 存在，但 (x6, y6) 不存在。 因此，通过 (A, B) 这一对，找到了一个正方形 ABCD。 结果： 通过遍历所有点对，只找到一个正方形 ABCD，最终正方形数量为 1。\n遍历点对：\n遍历所有的点对，检查是否能构成正方形。共有 6 对点组合：(A, B), (A, C), (A, D), (B, C), (B, D), (C, D)。\n判断正方形：\n以点对 (A, B) 为例： 计算可能的两个正方形对角点： (x3, y3) = (-2, 1) 和 (x4, y4) = (3, 1)。(x5, y5) = (-2, -1) 和 (x6, y6) = (-1, 1)。 检查这些点是否存在于输入的坐标集合中： (x3, y3) 不存在，但 (x4, y4) 即 C 存在。(x5, y5) 即 D 存在，但 (x6, y6) 不存在。 因此，通过 (A, B) 这一对，找到了一个正方形 ABCD。\n计算可能的两个正方形对角点： (x3, y3) = (-2, 1) 和 (x4, y4) = (3, 1)。(x5, y5) = (-2, -1) 和 (x6, y6) = (-1, 1)。 检查这些点是否存在于输入的坐标集合中： (x3, y3) 不存在，但 (x4, y4) 即 C 存在。(x5, y5) 即 D 存在，但 (x6, y6) 不存在。 因此，通过 (A, B) 这一对，找到了一个正方形 ABCD。\n(x3, y3) = (-2, 1) 和 (x4, y4) = (3, 1)。(x5, y5) = (-2, -1) 和 (x6, y6) = (-1, 1)。\n(x3, y3) 不存在，但 (x4, y4) 即 C 存在。(x5, y5) 即 D 存在，但 (x6, y6) 不存在。\n结果：\n通过遍历所有点对，只找到一个正方形 ABCD，最终正方形数量为 1。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n\n\npublic class Main {\n    static class Point {\n        int x, y;\n\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        // 判断两个点是否相等\n        boolean equals(Point p) {\n            return this.x == p.x && this.y == p.y;\n        }\n    }\n    // 检查点是否存在于点列表中\n    static boolean pointExists(ArrayList<Point> points, Point p) {\n        for (Point point : points) {\n            if (point.equals(p)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        ArrayList<Point> points = new ArrayList<>();\n\n        // 读取所有点的坐标\n        for (int i = 0; i < n; i++) {\n            int x = scanner.nextInt();\n            int y = scanner.nextInt();\n            points.add(new Point(x, y));\n        }\n\n        int squareCount = 0;\n\n        // 遍历所有点对，检查是否能构成正方形\n        for (int i = 0; i < n; i++) {\n            Point p1 = points.get(i);\n\n            for (int j = i + 1; j < n; j++) {\n                Point p2 = points.get(j);\n\n                // 计算两个可能的对角点\n                Point p3 = new Point(p1.x - (p1.y - p2.y), p1.y + (p1.x - p2.x));\n                Point p4 = new Point(p2.x - (p1.y - p2.y), p2.y + (p1.x - p2.x));\n\n                if (pointExists(points, p3) && pointExists(points, p4)) {\n                    squareCount++;\n                }\n\n                // 计算另外两个可能的对角点\n                Point p5 = new Point(p1.x + (p1.y - p2.y), p1.y - (p1.x - p2.x));\n                Point p6 = new Point(p2.x + (p1.y - p2.y), p2.y - (p1.x - p2.x));\n\n                if (pointExists(points, p5) && pointExists(points, p6)) {\n                    squareCount++;\n                }\n            }\n        }\n\n        // 每个正方形被计算了4次，因此结果需要除以4\n        System.out.println(squareCount / 4);\n\n        scanner.close();\n    }\n}\n// 代码2\nimport java.util.Scanner;\nimport java.util.Vector;\nimport java.util.HashSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建Scanner对象，用于从控制台读取输入\n        Scanner scanner = new Scanner(System.in);\n        \n        // 读取第一个输入的整数，表示坐标数量\n        int n = scanner.nextInt();\n        // 读取整行输入并忽略换行符\n        scanner.nextLine();\n\n        // 创建一个Vector来存储坐标点的字符串形式\n        Vector<String> coordinates = new Vector<>(n);\n        for (int i = 0; i < n; i++) {\n            // 逐行读取坐标点，并存储到Vector中\n            coordinates.add(scanner.nextLine());\n        }\n\n        // 初始化正方形计数器\n        int squareCount = 0;\n        // 使用HashSet存储坐标点，便于快速查找\n        HashSet<String> set = new HashSet<>(coordinates);\n\n        // 遍历所有坐标点对\n        for (int i = 0; i < n; i++) {\n            // 将第一个坐标点分割为x1和y1\n            String[] coordinate1 = coordinates.get(i).split(\" \");\n            int x1 = Integer.parseInt(coordinate1[0]);\n            int y1 = Integer.parseInt(coordinate1[1]);\n\n            for (int j = i + 1; j < n; j++) {\n                // 将第二个坐标点分割为x2和y2\n                String[] coordinate2 = coordinates.get(j).split(\" \");\n                int x2 = Integer.parseInt(coordinate2[0]);\n                int y2 = Integer.parseInt(coordinate2[1]);\n\n                // 计算两个可能的对角点\n                int x3 = x1 - (y1 - y2), y3 = y1 + (x1 - x2);\n                int x4 = x2 - (y1 - y2), y4 = y2 + (x1 - x2);\n\n                // 检查这两个对角点是否存在于坐标集合中\n                if (set.contains(x3 + \" \" + y3) && set.contains(x4 + \" \" + y4)) {\n                    squareCount++;\n                }\n\n                // 计算另外两个可能的对角点\n                int x5 = x1 + (y1 - y2), y5 = y1 - (x1 - x2);\n                int x6 = x2 + (y1 - y2), y6 = y2 - (x1 - x2);\n\n                // 检查这两个对角点是否存在于坐标集合中\n                if (set.contains(x5 + \" \" + y5) && set.contains(x6 + \" \" + y6)) {\n                    squareCount++;\n                }\n            }\n        }\n\n        // 每个正方形被计算了4次，因此结果需要除以4\n        System.out.println(squareCount / 4);\n\n        // 关闭Scanner对象，释放资源\n        scanner.close();\n    }\n}",
      "python": "# 定义一个函数来判断两个点是否相等\ndef are_points_equal(p1, p2):\n    return p1[0] == p2[0] and p1[1] == p2[1]\n\n# 定义一个函数来检查一个点是否存在于点列表中\ndef point_exists(points, p):\n    for point in points:\n        if are_points_equal(point, p):\n            return True\n    return False\n\n# 读取坐标数量\nn = int(input())\ncoordinates = []\n\n# 读取坐标并存入列表\nfor _ in range(n):\n    x, y = map(int, input().split())\n    coordinates.append((x, y))\n\nsquare_count = 0\n\n# 遍历所有点对，检查是否能构成正方形\nfor i in range(n):\n    x1, y1 = coordinates[i]\n\n    for j in range(i + 1, n):\n        x2, y2 = coordinates[j]\n\n        # 计算两个可能的对角点\n        x3, y3 = x1 - (y1 - y2), y1 + (x1 - x2)\n        x4, y4 = x2 - (y1 - y2), y2 + (x1 - x2)\n        p3 = (x3, y3)\n        p4 = (x4, y4)\n\n        if point_exists(coordinates, p3) and point_exists(coordinates, p4):\n            square_count += 1\n\n        # 计算另外两个可能的对角点\n        x5, y5 = x1 + (y1 - y2), y1 - (x1 - x2)\n        x6, y6 = x2 + (y1 - y2), y2 - (x1 - x2)\n        p5 = (x5, y5)\n        p6 = (x6, y6)\n\n        if point_exists(coordinates, p5) and point_exists(coordinates, p6):\n            square_count += 1\n\n# 每个正方形被计算了4次，因此结果需要除以4\nprint(square_count // 4)\n\n\n\n# 代码2\n\nimport sys\n\n# 读取第一个输入的整数，表示坐标数量\nn = int(input())\n\n# 存储坐标的字符串形式的列表\ncoordinates = []\nfor i in range(n):\n    # 读取坐标点的字符串，并去掉两端的空白字符\n    coordinates.append(input().strip())\n\n# 初始化正方形计数器\nsquareCount = 0\n# 使用集合存储坐标点，便于快速查找\ncoordinate_set = set(coordinates)\n\n# 遍历所有坐标点对\nfor i in range(n):\n    # 将第一个坐标点分割为x1和y1\n    x1, y1 = map(int, coordinates[i].split())\n\n    for j in range(i + 1, n):\n        # 将第二个坐标点分割为x2和y2\n        x2, y2 = map(int, coordinates[j].split())\n\n        # 计算两个可能的对角点\n        x3, y3 = x1 - (y1 - y2), y1 + (x1 - x2)\n        x4, y4 = x2 - (y1 - y2), y2 + (x1 - x2)\n\n        # 检查这两个对角点是否存在于坐标集合中\n        if f\"{x3} {y3}\" in coordinate_set and f\"{x4} {y4}\" in coordinate_set:\n            squareCount += 1\n\n        # 计算另外两个可能的对角点\n        x5, y5 = x1 + (y1 - y2), y1 - (x1 - x2)\n        x6, y6 = x2 + (y1 - y2), y2 - (x1 - x2)\n\n        # 检查这两个对角点是否存在于坐标集合中\n        if f\"{x5} {y5}\" in coordinate_set and f\"{x6} {y6}\" in coordinate_set:\n            squareCount += 1\n\n# 每个正方形被计算了4次，因此结果需要除以4\nprint(squareCount // 4)",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet n;\nlet coordinates = [];\n\n// 判断两个点是否相等\nfunction arePointsEqual(p1, p2) {\n  return p1[0] === p2[0] && p1[1] === p2[1];\n}\n\n// 检查一个点是否存在于点数组中\nfunction pointExists(points, p) {\n  for (let point of points) {\n    if (arePointsEqual(point, p)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nrl.on('line', (line) => {\n  if (n === undefined) {\n    n = parseInt(line);\n  } else {\n    coordinates.push(line.split(' ').map(Number));\n    if (coordinates.length === n) rl.close();\n  }\n});\n\nrl.on('close', () => {\n  let squareCount = 0;\n\n  // 遍历所有点对，检查是否能构成正方形\n  for (let i = 0; i < n; i++) {\n    let [x1, y1] = coordinates[i];\n\n    for (let j = i + 1; j < n; j++) {\n      let [x2, y2] = coordinates[j];\n\n      // 计算两个可能的对角点\n      let x3 = x1 - (y1 - y2), y3 = y1 + (x1 - x2);\n      let x4 = x2 - (y1 - y2), y4 = y2 + (x1 - x2);\n\n      if (pointExists(coordinates, [x3, y3]) && pointExists(coordinates, [x4, y4])) {\n        squareCount++;\n      }\n\n      // 计算另外两个可能的对角点\n      let x5 = x1 + (y1 - y2), y5 = y1 - (x1 - x2);\n      let x6 = x2 + (y1 - y2), y6 = y2 - (x1 - x2);\n\n      if (pointExists(coordinates, [x5, y5]) && pointExists(coordinates, [x6, y6])) {\n        squareCount++;\n      }\n    }\n  }\n\n  // 每个正方形被计算了4次，因此结果需要除以4\n  console.log(Math.floor(squareCount / 4));\n});\n\n// 代码2\nconst readline = require('readline');\n\n// 创建接口读取标准输入输出\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet n; // 用于存储坐标数量\nlet coordinates = []; // 存储坐标的数组\n\n// 监听每行输入\nrl.on('line', (line) => {\n  if (!n) {\n    // 第一行输入是坐标数量\n    n = parseInt(line);\n    return;\n  }\n\n  // 其余的行是坐标点\n  coordinates.push(line);\n\n  // 当输入的坐标数达到n时，关闭输入流\n  if (coordinates.length === n) {\n    rl.close();\n  }\n});\n\n// 当输入完成时\nrl.on('close', () => {\n  let squareCount = 0; // 记录正方形数量\n  let set = new Set(coordinates); // 用集合存储坐标点，便于快速查找\n\n  // 遍历所有坐标点对\n  for (let i = 0; i < n; i++) {\n    // 将第一个坐标点分割为x1和y1\n    let [x1, y1] = coordinates[i].split(' ').map(Number);\n\n    for (let j = i + 1; j < n; j++) {\n      // 将第二个坐标点分割为x2和y2\n      let [x2, y2] = coordinates[j].split(' ').map(Number);\n\n      // 计算两个可能的对角点\n      let x3 = x1 - (y1 - y2), y3 = y1 + (x1 - x2);\n      let x4 = x2 - (y1 - y2), y4 = y2 + (x1 - x2);\n\n      // 检查这两个对角点是否存在于坐标集合中\n      if (set.has(`${x3} ${y3}`) && set.has(`${x4} ${y4}`)) {\n        squareCount++;\n      }\n\n      // 计算另外两个可能的对角点\n      let x5 = x1 + (y1 - y2), y5 = y1 - (x1 - x2);\n      let x6 = x2 + (y1 - y2), y6 = y2 - (x1 - x2);\n\n      // 检查这两个对角点是否存在于坐标集合中\n      if (set.has(`${x5} ${y5}`) && set.has(`${x6} ${y6}`)) {\n        squareCount++;\n      }\n    }\n  }\n\n  // 每个正方形被计算了4次，因此结果需要除以4\n  console.log(Math.floor(squareCount / 4));\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// 定义一个点结构体\nstruct Point {\n    int x, y;\n};\n\n// 判断两个点是否相等\nbool arePointsEqual(Point a, Point b) {\n    return a.x == b.x && a.y == b.y;\n}\n\n// 检查数组中是否存在某点\nbool pointExists(vector<Point>& points, Point p) {\n    for (auto& point : points) {\n        if (arePointsEqual(point, p)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Point> points(n);\n\n    // 读取坐标并存入数组\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    int squareCount = 0;\n\n    // 遍历所有点对，检查是否能构成正方形\n    for (int i = 0; i < n; i++) {\n        int x1 = points[i].x;\n        int y1 = points[i].y;\n\n        for (int j = i + 1; j < n; j++) {\n            int x2 = points[j].x;\n            int y2 = points[j].y;\n\n            // 计算两个可能的对角点\n            Point p3 = {x1 - (y1 - y2), y1 + (x1 - x2)};\n            Point p4 = {x2 - (y1 - y2), y2 + (x1 - x2)};\n\n            if (pointExists(points, p3) && pointExists(points, p4)) {\n                squareCount++;\n            }\n\n            // 计算另外两个可能的对角点\n            Point p5 = {x1 + (y1 - y2), y1 - (x1 - x2)};\n            Point p6 = {x2 + (y1 - y2), y2 - (x1 - x2)};\n\n            if (pointExists(points, p5) && pointExists(points, p6)) {\n                squareCount++;\n            }\n        }\n    }\n\n    // 每个正方形被计算了4次，因此结果需要除以4\n    cout << squareCount / 4 << endl;\n\n    return 0;\n}\n\n// 代码2\n#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint main() {\n    int n;\n    // 读取坐标数量\n    cin >> n;\n    // 忽略换行符\n    cin.ignore();\n\n    // 创建一个二维数组来存储坐标\n    vector<vector<int>> coordinates(n, vector<int>(2));\n    for (int i = 0; i < n; i++) {\n        // 读取坐标并存储到数组中\n        cin >> coordinates[i][0] >> coordinates[i][1];\n    }\n\n    int squareCount = 0; // 记录正方形数量\n    unordered_set<string> set;\n    // 将坐标转换为字符串形式并存入哈希集合\n    for (int i = 0; i < n; i++) {\n        set.insert(to_string(coordinates[i][0]) + \" \" + to_string(coordinates[i][1]));\n    }\n\n    // 遍历所有坐标点对\n    for (int i = 0; i < n; i++) {\n        int x1 = coordinates[i][0];\n        int y1 = coordinates[i][1];\n\n        for (int j = i + 1; j < n; j++) {\n            int x2 = coordinates[j][0];\n            int y2 = coordinates[j][1];\n\n            // 计算两个可能的对角点\n            int x3 = x1 - (y1 - y2), y3 = y1 + (x1 - x2);\n            int x4 = x2 - (y1 - y2), y4 = y2 + (x1 - x2);\n\n            // 检查这两个对角点是否存在于坐标集合中\n            if (set.count(to_string(x3) + \" \" + to_string(y3)) && set.count(to_string(x4) + \" \" + to_string(y4))) {\n                squareCount++;\n            }\n\n            // 计算另外两个可能的对角点\n            int x5 = x1 + (y1 - y2), y5 = y1 - (x1 - x2);\n            int x6 = x2 + (y1 - y2), y6 = y2 - (x1 - x2);\n\n            // 检查这两个对角点是否存在于坐标集合中\n            if (set.count(to_string(x5) + \" \" + to_string(y5)) && set.count(to_string(x6) + \" \" + to_string(y6))) {\n                squareCount++;\n            }\n        }\n    }\n\n    // 每个正方形被计算了4次，因此结果需要除以4\n    cout << squareCount / 4 << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\n// 判断两个点是否相等\nint arePointsEqual(Point a, Point b) {\n    return a.x == b.x && a.y == b.y;\n}\n\n// 检查数组中是否存在某点\nint pointExists(Point points[], int n, Point p) {\n    for (int i = 0; i < n; i++) {\n        if (arePointsEqual(points[i], p)) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Point points[n];\n\n    // 读取坐标并存入数组\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    int squareCount = 0;\n\n    // 遍历所有点对，检查是否能构成正方形\n    for (int i = 0; i < n; i++) {\n        int x1 = points[i].x;\n        int y1 = points[i].y;\n\n        for (int j = i + 1; j < n; j++) {\n            int x2 = points[j].x;\n            int y2 = points[j].y;\n\n            // 计算两个可能的对角点\n            Point p3 = {x1 - (y1 - y2), y1 + (x1 - x2)};\n            Point p4 = {x2 - (y1 - y2), y2 + (x1 - x2)};\n\n            if (pointExists(points, n, p3) && pointExists(points, n, p4)) {\n                squareCount++;\n            }\n\n            // 计算另外两个可能的对角点\n            Point p5 = {x1 + (y1 - y2), y1 - (x1 - x2)};\n            Point p6 = {x2 + (y1 - y2), y2 - (x1 - x2)};\n\n            if (pointExists(points, n, p5) && pointExists(points, n, p6)) {\n                squareCount++;\n            }\n        }\n    }\n\n    // 每个正方形被计算了4次，因此结果需要除以4\n    printf(\"%d\\n\", squareCount / 4);\n\n    return 0;\n}"
    }
  },
  {
    "id": "38",
    "title": "查找接口成功率最优时间段",
    "examType": "A",
    "score": 100,
    "description": "服务之间交换的接口成功率作为服务调用关键质量特性，某个时间段内的接口失败率使用一个数组表示，\n数组中每个元素都是单位时间内失败率数值，数组中的数值为0~100的整数，\n给定一个数值(minAverageLost)表示某个时间段内平均失败率容忍值，即平均失败率小于等于minAverageLost，\n找出数组中最长时间段，如果未找到则直接返回NULL。",
    "inputDesc": "输入有两行内容，第一行为{minAverageLost}，第二行为{数组}，数组元素通过空格(” “)分隔，\nminAverageLost及数组中元素取值范围为0~100的整数，数组元素的个数不会超过100个。",
    "outputDesc": "找出平均值小于等于minAverageLost的最长时间段，输出数组下标对，格式{beginIndex}-{endIndx}(下标从0开始)，\n如果同时存在多个最长时间段，则输出多个下标对且下标对之间使用空格(” “)拼接，多个下标对按下标从小到大排序。\n输入解释：minAverageLost=1，数组[0, 1, 2, 3, 4]\n前3个元素的平均值为1，因此数组第一个至第三个数组下标，即0-2\n输入解释：minAverageLost=2，数组[0, 0, 100, 2, 2, 99, 0, 2]\n通过计算小于等于2的最长时间段为：\n数组下标为0-1即[0, 0]，数组下标为3-4即[2, 2]，数组下标为6-7即[0, 2]，这三个部分都满足平均值小于等于2的要求，\n因此输出0-1 3-4 6-7\n解题思路如下：\n首先，我们需要读取输入的数据，包括容忍的平均失败率和失败率数组。\n然后，我们创建一个累积和数组，用于快速计算任意时间段的失败率总和。这个数组的每个元素都是从数组开始到当前位置的失败率的总和。\n接下来，我们遍历所有可能的时间段，包括所有可能的开始和结束索引。对于每个时间段，我们计算其失败率总和，然后计算其平均失败率。我们可以通过查找累积和数组来快速计算失败率总和。\n对于每个时间段，我们检查其平均失败率是否小于等于容忍的平均失败率。如果是，我们就找到了一个满足条件的时间段。\n我们需要找到最长的满足条件的时间段。因此，我们需要跟踪找到的最长时间段的长度。如果我们找到一个比当前最长时间段更长的时间段，我们就更新最长时间段的长度，并清空结果列表，然后将新的时间段添加到结果列表中。如果我们找到一个和当前最长时间段一样长的时间段，我们就将它添加到结果列表中。\n最后，我们检查结果列表。如果结果列表为空，说明我们没有找到任何满足条件的时间段，我们就输出\"NULL\"。否则，我们输出所有满足条件的时间段。如果有多个时间段，我们需要按照开始索引从小到大的顺序输出。\n这个解题思路的关键是使用累积和数组来快速计算任意时间段的失败率总和，以及使用一个结果列表来跟踪所有满足条件的时间段。这样，我们可以在一次遍历中找到所有满足条件的时间段，并且可以快速找到最长的时间段。",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n\n    // 容忍的平均失败率\n    int toleratedAverageLoss = Integer.parseInt(scanner.nextLine());\n\n    // 读取失败率数组\n    Integer[] failureRates =\n        Arrays.stream(scanner.nextLine().split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    int arrayLength = failureRates.length;\n\n    // 创建一个累积和数组，用于快速计算任意时间段的失败率总和\n    int[] cumulativeSum = new int[arrayLength];\n    cumulativeSum[0] = failureRates[0];\n    for (int i = 1; i < arrayLength; i++) cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i];\n\n    // 存储满足条件的时间段的开始和结束索引\n    ArrayList<Integer[]> validPeriods = new ArrayList<>();\n    int maxLength = 0;\n    for (int start = 0; start < arrayLength; start++) {\n      for (int end = start; end < arrayLength; end++) {\n        int sum = start == 0 ? cumulativeSum[end] : cumulativeSum[end] - cumulativeSum[start - 1];\n        int length = end - start + 1;\n        int toleratedLoss = length * toleratedAverageLoss;\n\n        // 如果这个时间段的平均失败率小于等于容忍的平均失败率\n        if (sum <= toleratedLoss) {\n          // 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n          if (length > maxLength) {\n            validPeriods = new ArrayList<>();\n            validPeriods.add(new Integer[] {start, end});\n            maxLength = length;\n          } \n          // 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n          else if (length == maxLength) {\n            validPeriods.add(new Integer[] {start, end});\n          }\n        }\n      }\n    }\n\n    // 如果没有找到满足条件的时间段，输出\"NULL\"\n    if (validPeriods.size() == 0) {\n      System.out.println(\"NULL\");\n    } \n    // 否则，输出所有满足条件的时间段\n    else {\n      validPeriods.sort((a, b) -> a[0] - b[0]);\n\n      StringJoiner sj = new StringJoiner(\" \");\n      for (Integer[] period : validPeriods) sj.add(period[0] + \"-\" + period[1]);\n      System.out.println(sj.toString());\n    }\n  }\n}",
      "python": "# 容忍的平均失败率\ntoleratedAverageLoss = int(input())\n\n# 读取失败率数组\nfailureRates = list(map(int, input().split()))\n\narrayLength = len(failureRates)\n\n# 创建一个累积和数组，用于快速计算任意时间段的失败率总和\ncumulativeSum = [0] * arrayLength\ncumulativeSum[0] = failureRates[0] \nfor i in range(1, arrayLength):\n    cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i]\n\n# 存储满足条件的时间段的开始和结束索引\nvalidPeriods = []\nmaxLength = 0\nfor start in range(arrayLength):\n    for end in range(start, arrayLength):\n        sum = cumulativeSum[end] if start == 0 else cumulativeSum[end] - cumulativeSum[start - 1]\n        length = end - start + 1\n        toleratedLoss = length * toleratedAverageLoss\n\n        # 如果这个时间段的平均失败率小于等于容忍的平均失败率\n        if sum <= toleratedLoss:\n            # 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n            if length > maxLength:\n                validPeriods = []\n                validPeriods.append((start, end))\n                maxLength = length\n            # 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n            elif length == maxLength:\n                validPeriods.append((start, end))\n\n# 如果没有找到满足条件的时间段，输出\"NULL\"\nif len(validPeriods) == 0:\n    print(\"NULL\")\n# 否则，输出所有满足条件的时间段\nelse:\n    validPeriods.sort()\n\n    print(' '.join(f'{start}-{end}' for start, end in validPeriods))",
      "javascript": "const readline = require('readline').createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n \n\nreadline.on('line', tolerated => {\n const toleratedAverageLoss = parseInt(tolerated);\n  readline.on('line', rates => {a\n    const failureRates = rates.split(' ').map(Number);\n \n    const arrayLength = failureRates.length;\n\n    // 创建一个累积和数组，用于快速计算任意时间段的失败率总和\n    const cumulativeSum = new Array(arrayLength);\n    cumulativeSum[0] = failureRates[0];\n    for (let i = 1; i < arrayLength; i++) cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i];\n\n    // 存储满足条件的时间段的开始和结束索引\n    let validPeriods = [];\n    let maxLength = 0;\n    for (let start = 0; start < arrayLength; start++) {\n      for (let end = start; end < arrayLength; end++) {\n        const sum = start === 0 ? cumulativeSum[end] : cumulativeSum[end] - cumulativeSum[start - 1];\n        const length = end - start + 1;\n        const toleratedLoss = length * toleratedAverageLoss;\n\n        // 如果这个时间段的平均失败率小于等于容忍的平均失败率\n        if (sum <= toleratedLoss) {\n          // 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n          if (length > maxLength) {\n            validPeriods = [];\n            validPeriods.push([start, end]);\n            maxLength = length;\n          } \n          // 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n          else if (length === maxLength) {\n            validPeriods.push([start, end]);\n          }\n        }\n      }\n    }\n\n    // 如果没有找到满足条件的时间段，输出\"NULL\"\n    if (validPeriods.length === 0) {\n      console.log(\"NULL\");\n    } \n    // 否则，输出所有满足条件的时间段\n    else {\n      validPeriods.sort((a, b) => a[0] - b[0]);\n\n      console.log(validPeriods.map(period => period.join('-')).join(' '));\n    }\n  });\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    // 容忍的平均失败率\n    int toleratedAverageLoss;\n    cin >> toleratedAverageLoss;\n\n    // 读取失败率数组\n    vector<int> failureRates;\n    string line;\n    getline(cin >> ws, line);\n    istringstream iss(line);\n    int num;\n    while (iss >> num) {\n        failureRates.push_back(num);\n    }\n\n    int arrayLength = failureRates.size();\n\n    // 创建一个累积和数组，用于快速计算任意时间段的失败率总和\n    vector<int> cumulativeSum(arrayLength);\n    cumulativeSum[0] = failureRates[0];\n    for (int i = 1; i < arrayLength; i++) cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i];\n\n    // 存储满足条件的时间段的开始和结束索引\n    vector<pair<int, int>> validPeriods;\n    int maxLength = 0;\n    for (int start = 0; start < arrayLength; start++) {\n        for (int end = start; end < arrayLength; end++) {\n            int sum = start == 0 ? cumulativeSum[end] : cumulativeSum[end] - cumulativeSum[start - 1];\n            int length = end - start + 1;\n            int toleratedLoss = length * toleratedAverageLoss;\n\n            // 如果这个时间段的平均失败率小于等于容忍的平均失败率\n            if (sum <= toleratedLoss) {\n                // 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n                if (length > maxLength) {\n                    validPeriods.clear();\n                    validPeriods.push_back({start, end});\n                    maxLength = length;\n                } \n                // 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n                else if (length == maxLength) {\n                    validPeriods.push_back({start, end});\n                }\n            }\n        }\n    }\n\n    // 如果没有找到满足条件的时间段，输出\"NULL\"\n    if (validPeriods.empty()) {\n        cout << \"NULL\" << endl;\n    } \n    // 否则，输出所有满足条件的时间段\n    else {\n        sort(validPeriods.begin(), validPeriods.end());\n\n        for (auto& period : validPeriods) {\n            cout << period.first << \"-\" << period.second << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    // 容忍的平均失败率\n    int toleratedAverageLoss;\n    scanf(\"%d\", &toleratedAverageLoss);\n\n    // 读取失败率数组\n    int failureRates[100];\n    int arrayLength = 0;\n    while (scanf(\"%d\", &failureRates[arrayLength]) == 1) {\n        arrayLength++;\n    }\n\n    // 创建一个累积和数组，用于快速计算任意时间段的失败率总和\n    int cumulativeSum[100] = {0};\n    cumulativeSum[0] = failureRates[0];\n    for (int i = 1; i < arrayLength; i++) {\n        cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i];\n    }\n\n    // 存储满足条件的时间段的开始和结束索引\n    int validPeriods[100][2];\n    int validPeriodCount = 0;\n    int maxLength = 0;\n    for (int start = 0; start < arrayLength; start++) {\n        for (int end = start; end < arrayLength; end++) {\n            int sum = start == 0 ? cumulativeSum[end] : cumulativeSum[end] - cumulativeSum[start - 1];\n            int length = end - start + 1;\n            int toleratedLoss = length * toleratedAverageLoss;\n\n            // 如果这个时间段的平均失败率小于等于容忍的平均失败率\n            if (sum <= toleratedLoss) {\n                // 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n                if (length > maxLength) {\n                    validPeriodCount = 0;\n                    validPeriods[validPeriodCount][0] = start;\n                    validPeriods[validPeriodCount][1] = end;\n                    validPeriodCount++;\n                    maxLength = length;\n                } \n                // 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n                else if (length == maxLength) {\n                    validPeriods[validPeriodCount][0] = start;\n                    validPeriods[validPeriodCount][1] = end;\n                    validPeriodCount++;\n                }\n            }\n        }\n    }\n\n    // 如果没有找到满足条件的时间段，输出\"NULL\"\n    if (validPeriodCount == 0) {\n        printf(\"NULL\\n\");\n    } \n    // 否则，输出所有满足条件的时间段\n    else {\n        for (int i = 0; i < validPeriodCount; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%d-%d\", validPeriods[i][0], validPeriods[i][1]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "39",
    "title": "水仙花数 Ⅰ",
    "examType": "A",
    "score": 100,
    "description": "所谓水仙花数，是指一个n位的正整数，其各位数字的n次方和等于该数本身。\n例如153是水仙花数，153是一个3位数，并且153 = 1^3 + 5^3 + 3^3。",
    "inputDesc": "第一行输入一个整数n，表示一个n位的正整数。n在3到7之间，包含3和7。\n第二行输入一个正整数m，表示需要返回第m个水仙花数。",
    "outputDesc": "返回长度是n的第m个水仙花数。个数从0开始编号。\n若m大于水仙花数的个数，返回最后一个水仙花数和m的乘积。\n若输入不合法，返回-1。",
    "examples": [
      {
        "input": "",
        "output": "-1",
        "explanation": "9超出范围"
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n     public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // 输入n和m\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        \n        // 判断输入是否合法\n        if (n < 3 || n > 7) {\n            System.out.println(\"-1\");\n            return;\n        }\n        \n        // 计算水仙花数的范围\n        int start = (int) Math.pow(10, n - 1);\n        int end = (int) Math.pow(10, n);\n        \n        // 存储水仙花数的列表\n        List<Integer> narcissusList = new ArrayList<>();\n        \n        // 遍历范围内的数，判断是否为水仙花数并加入列表\n        for (int i = start; i < end; i++) {\n            if (isNarcissusNumber(i, n)) {\n                narcissusList.add(i);\n            }\n        }\n        \n        // 获取水仙花数列表的长度\n        int size = narcissusList.size();\n        \n        // 若列表为空，输出-1\n        if (size == 0) {\n            System.out.println(\"-1\");\n            return;\n        }\n        \n        // 输出第m个水仙花数，若m大于列表长度，则输出最后一个水仙花数乘以m\n        System.out.println(m >= size ? narcissusList.get(size - 1) : narcissusList.get(m));\n    }\n    \n    // 判断一个数是否为水仙花数\n    public static boolean isNarcissusNumber(int num, int n) {\n        int sum = 0;\n        String numStr = String.valueOf(num);\n        \n        // 计算各位数字的n次方和\n        for (int i = 0; i < n; i++) {\n            sum += Math.pow(Integer.parseInt(numStr.substring(i, i + 1)), n);\n        }\n        \n        // 判断是否为水仙花数\n        return sum == num;\n    }\n}",
      "python": "def isNarcissusNumber(num, n):\n    sum = 0\n    numStr = str(num)\n\n    for i in range(n):\n        sum += int(numStr[i]) ** n\n\n    return sum == num\nn = int(input())\nm = int(input())\n\nif n < 3 or n > 7:\n    print(\"-1\")\n    exit()\n\nstart = 10 ** (n - 1)\nend = 10 ** n\n\nnarcissusList = []\n\nfor i in range(start, end):\n    if isNarcissusNumber(i, n):\n        narcissusList.append(i)\n\nsize = len(narcissusList)\n\nif size == 0:\n    print(\"-1\")\n    exit()\n\nprint(narcissusList[size - 1] if m >= size else narcissusList[m])",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (n) => {\n  rl.on('line', (m) => {\n    n= parseInt(n);\n    m= parseInt(m);\n // 判断输入是否合法\n  if (n < 3 || n > 7) {\n    console.log(\"-1\");\n    rl.close();\n    return;\n  }\n  \n  // 计算水仙花数的范围\n  const start = Math.pow(10, n - 1);\n  const end = Math.pow(10, n);\n  \n  // 存储水仙花数的列表\n  const narcissusList = [];\n  \n  // 遍历范围内的数，判断是否为水仙花数并加入列表\n  for (let i = start; i < end; i++) {\n    if (isNarcissusNumber(i, n)) {\n      narcissusList.push(i);\n    }\n  }\n  \n  // 获取水仙花数列表的长度\n  const size = narcissusList.length;\n  \n  // 若列表为空，输出-1\n  if (size === 0) {\n    console.log(\"-1\");\n    rl.close();\n    return;\n  }\n  \n  // 输出第m个水仙花数，若m大于列表长度，则输出最后一个水仙花数乘以m\n  console.log(m >= size ? narcissusList[size - 1] : narcissusList[m]);\n  \n  rl.close();\n});\n});\n \n\n// 判断一个数是否为水仙花数\nfunction isNarcissusNumber(num, n) {\n  let sum = 0;\n  const numStr = String(num);\n  \n  // 计算各位数字的n次方和\n  for (let i = 0; i < n; i++) {\n    sum += Math.pow(parseInt(numStr.substring(i, i + 1)), n);\n  }\n  \n  // 判断是否为水仙花数\n  return sum === num;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nbool isNarcissusNumber(int num, int n) {\n    int sum = 0;\n    string numStr = to_string(num);\n    \n    for (int i = 0; i < n; i++) {\n        sum += pow(stoi(numStr.substr(i, 1)), n);\n    }\n    \n    return sum == num;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    if (n < 3 || n > 7) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n    \n    int start = pow(10, n - 1);\n    int end = pow(10, n);\n    \n    vector<int> narcissusList;\n    \n    for (int i = start; i < end; i++) {\n        if (isNarcissusNumber(i, n)) {\n            narcissusList.push_back(i);\n        }\n    }\n    \n    int size = narcissusList.size();\n    \n    if (size == 0) {\n        cout << \"-1\" << endl;\n        return 0;\n    }\n    \n    cout << (m >= size ? narcissusList[size - 1] : narcissusList[m]) << endl;\n    \n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n// 判断一个数是否为水仙花数的函数声明\nint isNarcissusNumber(int num, int n);\n\nint main() {\n    int n, m;\n    \n    // 输入n和m\n    if (scanf(\"%d %d\", &n, &m) != 2) {\n        printf(\"-1\\n\");\n        return -1;\n    }\n\n    // 判断输入是否合法，n必须在3到7之间\n    if (n < 3 || n > 7) {\n        printf(\"-1\\n\");\n        return -1;\n    }\n    \n    // 计算n位数的范围\n    int start = pow(10, n - 1); // n位数的起始值，例如3位数从100开始\n    int end = pow(10, n);       // n位数的结束值，例如3位数到999结束\n\n    // 存储水仙花数的数组，最大长度为end - start\n    int narcissusList[end - start];\n    int count = 0; // 用于记录找到的水仙花数数量\n\n    // 遍历范围内的数，判断是否为水仙花数\n    for (int i = start; i < end; i++) {\n        if (isNarcissusNumber(i, n)) {\n            narcissusList[count++] = i; // 将水仙花数加入数组\n        }\n    }\n\n    // 若没有找到任何水仙花数，输出-1\n    if (count == 0) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    // 判断m的值是否超出找到的水仙花数的数量\n    if (m >= count) {\n        // m大于或等于水仙花数的数量时，返回最后一个水仙花数乘以m\n        printf(\"%ld\\n\", narcissusList[count - 1] * m);\n    } else {\n        // 否则，返回第m个水仙花数\n        printf(\"%ld\\n\", narcissusList[m]);\n    }\n\n    return 0;\n}\n\n// 判断一个数是否为水仙花数\nint isNarcissusNumber(int num, int n) {\n    int sum = 0;          // 用于存储各位数字的n次方和\n    int original_num = num; // 保留原始数值用于最后比较\n\n    // 逐位提取数字并计算n次方和\n    while (num > 0) {\n        int digit = num % 10;           // 获取当前数的最后一位数字\n        sum += pow(digit, n);           // 计算该数字的n次方并加到总和中\n        num /= 10;                      // 移除最后一位数字，继续处理剩下的数字\n    }\n\n    // 若n次方和等于原始数值，则该数为水仙花数\n    return sum == original_num;\n}"
    }
  },
  {
    "id": "40",
    "title": "游戏分组王者荣耀",
    "examType": "A",
    "score": 100,
    "description": "2020年题：\n英雄联盟是一款十分火热的对战类游戏。每一场对战有10位玩家参与，分为两组，每组5人。每位玩家都有一个战斗力，代表着这位玩家的厉害程度。为了对战尽可能精彩，我们需要把玩家们分为实力尽量相等的两组。一组的实力可以表示为这一组5位玩家的战斗力和。现在，给你10位玩家的战斗力，请你把他们分为实力尽量相等的两组。请你输出这两组的实力差。\n2023年题：\n部门准备举办一场王者荣耀表演赛，有10名游戏爱好者参与，分5为两队，每队5人。每位参与者都有一个评分，代表着他的游戏水平。为了表演赛尽可能精彩，我们需要把10名参赛者分为实力尽量相近的两队。一队的实力可以表示为这一队5名队员的评分总和。 现在给你10名参与者的游戏水平评分，请你根据上述要求分队最后输出这两组的实力差绝对值。 例: 10名参赛者的评分分别为5 1 8 3 4 6 710 9 2，分组为 (135 8 10) (24 679)，两组实力差最小，差值为1。有多种分法，但实力差的绝对值最小为1。",
    "inputDesc": "10个整数，表示10名参与者的游戏水平评分。范围在[1,10000]之间",
    "outputDesc": "1个整数，表示分组后两组实力差绝对值的最小值.\n输入：\n输出：\n说明：\n10名队员分成两组，两组实力差绝对值最小为1.",
    "examples": [],
    "solution": "在这个问题中，我们通过深度优先搜索（DFS）尝试所有可能的分队方式，以找到实力差的绝对值最小的分队方案。整个算法的目标是遍历所有可能的组合，并计算出两队实力差的最小绝对值。\n这里使用的深度优先搜索算法中，每一步都有两种选择：将当前玩家分配给第一队，或者不分配给第一队（即默认分配给第二队）。这样的策略保证了覆盖所有可能的分队方式。\n12345\n这两行代码是DFS递归的核心，它们代表了在每一步有两种选择：\n选择当前玩家加入第一队：这是通过dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);实现的。这里idx + 1表示考虑下一个玩家，count + 1表示第一队的玩家数增加了1，currentSum + nums[idx]表示第一队的总评分增加了当前玩家的评分。 不选择当前玩家加入第一队：即留给第二队，通过dfs(nums, idx + 1, count, currentSum);实现。这里只将idx增加1，移动到下一个玩家，而count和currentSum保持不变，因为没有新的玩家加入第一队。\n选择当前玩家加入第一队：这是通过dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);实现的。这里idx + 1表示考虑下一个玩家，count + 1表示第一队的玩家数增加了1，currentSum + nums[idx]表示第一队的总评分增加了当前玩家的评分。\n不选择当前玩家加入第一队：即留给第二队，通过dfs(nums, idx + 1, count, currentSum);实现。这里只将idx增加1，移动到下一个玩家，而count和currentSum保持不变，因为没有新的玩家加入第一队。\n初始时，totalSum计算了所有玩家的评分总和，targetSum是总和的一半。这是因为我们的目标是使两队的评分尽可能接近totalSum / 2。通过DFS尝试所有可能的分队方式，每次递归都有两种选择：将当前玩家加入第一队或不加入。当一个队伍选满5名玩家时，计算两队的评分差，并更新最小差值res。继续递归直到所有玩家都被考虑过，最终res会是实力差的最小绝对值。\n注释中提到的剪枝条件if (currentSum > targetSum) return;， 经过考友的反馈，去掉的话是100%的通过率，请各位机考时都加上去试试。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    static int res = Integer.MAX_VALUE;\n    static int totalSum = 0;\n    static int targetSum = 0;\n\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        int[] nums = Arrays.stream(cin.nextLine().split(\" \"))\n                .mapToInt(Integer::parseInt).toArray();\n        for (int num : nums) {\n            totalSum += num;\n        }\n        targetSum = totalSum / 2;\n        dfs(nums, 0, 0, 0);\n        System.out.println(res);\n        cin.close();\n    }\n\n    static void dfs(int[] nums, int idx, int count, int currentSum) {\n        // 剪枝条件：如果当前总和超过目标，则停止.考友反馈，去掉可得100%\n        // if (currentSum > targetSum) return;\n\n        // 当我们为一个队伍选择了5名玩家时\n        if (count == 5) {\n            // 计算另一个队伍的总和\n            int otherTeamSum = totalSum - currentSum;\n            // 用较小的差值更新结果\n            res = Math.min(res, Math.abs(currentSum - otherTeamSum));\n            return;\n        }\n\n        // 如果我们已经考虑了所有玩家，停止递归\n        if (idx == 10) return;\n\n        // 为第一个队伍选择当前玩家\n        dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);\n        \n        // 不为第一个队伍选择当前玩家\n        dfs(nums, idx + 1, count, currentSum);\n    }\n}",
      "python": "import sys\n\nres = sys.maxsize\ntotalSum = 0\ntargetSum = 0\n\n# 深度优先搜索函数\ndef dfs(nums, idx, count, currentSum):\n    global res, totalSum, targetSum\n    # 剪枝条件：如果当前总和超过目标，则停止.考友反馈，去掉可得100%\n    # if currentSum > targetSum:\n    #    return\n\n    # 当我们为一个队伍选择了5名玩家时\n    if count == 5:\n        # 计算另一个队伍的总和\n        otherTeamSum = totalSum - currentSum\n        # 用较小的差值更新结果\n        res = min(res, abs(currentSum - otherTeamSum))\n        return\n\n    # 如果我们已经考虑了所有玩家，停止递归\n    if idx == 10:\n        return\n\n    # 为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count + 1, currentSum + nums[idx])\n    \n    # 不为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count, currentSum)\n\nnums = list(map(int, input().split()))\nfor num in nums:\n    totalSum += num\ntargetSum = totalSum // 2\ndfs(nums, 0, 0, 0)\nprint(res)",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nint res = INT_MAX;\nint totalSum = 0;\nint targetSum = 0;\n\n// 深度优先搜索函数\nvoid dfs(vector<int>& nums, int idx, int count, int currentSum) {\n    // 剪枝条件：如果当前总和超过目标，则停止 ,考友反馈，去掉可得100%\n    // if (currentSum > targetSum) return;\n\n    // 当我们为一个队伍选择了5名玩家时\n    if (count == 5) {\n        // 计算另一个队伍的总和\n        int otherTeamSum = totalSum - currentSum;\n        // 用较小的差值更新结果\n        res = min(res, abs(currentSum - otherTeamSum));\n        return;\n    }\n\n    // 如果我们已经考虑了所有玩家，停止递归\n    if (idx == 10) return;\n\n    // 为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);\n    \n    // 不为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count, currentSum);\n}\n\nint main() {\n    vector<int> nums(10);\n    for (int i = 0; i < 10; ++i) {\n        cin >> nums[i];\n        totalSum += nums[i];\n    }\n    targetSum = totalSum / 2;\n    dfs(nums, 0, 0, 0);\n    cout << res << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint res = INT_MAX;\nint totalSum = 0;\nint targetSum = 0;\n\n// 深度优先搜索函数\nvoid dfs(int nums[10], int idx, int count, int currentSum) {\n    // 剪枝条件：如果当前总和超过目标，则停止.考友反馈，去掉可得100%\n    // if (currentSum > targetSum) return;\n\n    // 当我们为一个队伍选择了5名玩家时\n    if (count == 5) {\n        // 计算另一个队伍的总和\n        int otherTeamSum = totalSum - currentSum;\n        // 用较小的差值更新结果\n        res = abs(currentSum - otherTeamSum) < res ? abs(currentSum - otherTeamSum) : res;\n        return;\n    }\n\n    // 如果我们已经考虑了所有玩家，停止递归\n    if (idx == 10) return;\n\n    // 为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);\n    \n    // 不为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count, currentSum);\n}\n\nint main() {\n    int nums[10];\n    for (int i = 0; i < 10; ++i) {\n        scanf(\"%d\", &nums[i]);\n        totalSum += nums[i];\n    }\n    targetSum = totalSum / 2;\n    dfs(nums, 0, 0, 0);\n    printf(\"%d\\n\", res);\n    return 0;\n}"
    }
  },
  {
    "id": "41",
    "title": "热点网站统计",
    "examType": "A",
    "score": 100,
    "description": "企业路由器的统计页面，有一个功能需要动态统计公司访问最多的网页URL top N。请设计一个算法，可以高效动态统计Top N的页面。",
    "inputDesc": "每一行都是一个URL或一个数字，如果是URL，代表一段时间内的网页访问； 如果是一个数字N，代表本次需要输出的Top N个URL。\n输入约束：\n1、总访问网页数量小于5000个，单网页访问次数小于65535次； 2、网页URL仅由字母，数字和点分隔符组成，且长度小于等于127字节； 3、数字是正整数，小于等于10且小于当前总访问网页数；",
    "outputDesc": "行输入要对应一行输出，输出按访问次数排序的前N个URL，用逗号分隔。\n输出要求：\n1、每次输出要统计之前所有输入，不仅是本次输入； 2、如果有访问次数相等的URL，按URL的字符串字典序升序排列，输出排序靠前的URL；",
    "examples": [
      {
        "input": "news.qq.com\nnews.sina.com.cn\nnews.qq.com\nnews.qq.com\ngame.163.com\ngame.163.com\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com",
        "output": "news.qq.com,game.163.com,news.sina.com.cn\nwww.huawei.com,www.cctv.com,news.qq.com",
        "explanation": ""
      },
      {
        "input": "news.qq.com\nwww.cctv.com\nwww.huawei.com\nwww.huawei.com",
        "output": "news.qq.com\nwww.huawei.com,news.qq.com\nwww.huawei.com,news.qq.com,www.cctv.com",
        "explanation": ""
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<String> lines = new ArrayList<>(); // 创建一个字符串列表，用于存储输入的每一行数据\n        Map<String, Integer> cache = new HashMap<>(); // 创建一个哈希表，用于存储每个 URL 出现的次数\n        while (scanner.hasNext()) { // 不断读取输入，直到没有下一行\n            String line = scanner.nextLine(); // 读取一行数据\n            lines.add(line); // 将该行数据添加到字符串列表中\n            if (line.matches(\"^\\\\d+$\")) { // 如果该行数据只包含数字，说明已经读取完了一个测试用例\n                System.out.println(sortURL(lines, cache)); // 调用 sortURL 方法进行处理，并输出结果\n                lines.clear(); // 清空字符串列表，为下一个测试用例做准备\n            }\n        }\n    }\n\n    public static String sortURL(List<String> lines, Map<String, Integer> cache) {\n        int n = Integer.parseInt(lines.remove(lines.size() - 1)); // 从字符串列表中取出最后一个元素，即需要输出的 URL 数量\n        for (String url : lines) { // 遍历字符串列表中的每一个 URL\n            cache.put(url, cache.getOrDefault(url, 0) + 1); // 将该 URL 在哈希表中的计数加一\n        }\n        List<Map.Entry<String, Integer>> list = new ArrayList<>(cache.entrySet()); // 将哈希表中的每一项转换成一个键值对，并存入一个列表中\n        list.sort((a, b) -> { // 对列表进行排序，按照计数从大到小排序，如果计数相同则按照字典序从小到大排序\n            int res = b.getValue() - a.getValue();\n            return res == 0 ? a.getKey().compareTo(b.getKey()) : res;\n        });\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n && i < list.size(); i++) { // 取出前 n 个 URL，并将它们拼接成一个字符串\n            sb.append(list.get(i).getKey()).append(\",\");\n        }\n        if (sb.length() > 0) { // 如果字符串不为空，则删除最后一个逗号\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString(); // 返回拼接好的字符串\n    }\n}",
      "python": "import sys\ndef sortURL(lines, cache):\n    n = int(lines.pop())\n \n    for url in lines:\n        cache[url] = cache.get(url, 0) + 1\n \n    arr = []\n    for key in cache:\n        arr.append({\n            \"count\": cache[key],\n            \"url\": key\n        })\n \n    return \",\".join([ele[\"url\"] for ele in sorted(arr, key=lambda x: (-x[\"count\"], x[\"url\"]))[:n]]) \nlines = []\ncache = {}\nfor line in sys.stdin:\n    lines.append(line.strip())\n \n    if line.strip().isdigit():\n        print(sortURL(lines, cache))\n        lines = []",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst lines = [];\nconst cache = {};\n\nrl.on('line', (line) => {\n  lines.push(line);\n\n  if (/^\\d+$/.test(line)) {\n    console.log(sortURL(lines, cache));\n    lines.length = 0;\n  }\n});\n\nfunction sortURL(lines, cache) {\n  const n = parseInt(lines.pop());\n  for (const url of lines) {\n    cache[url] = (cache[url] || 0) + 1;\n  }\n  const list = Object.entries(cache);\n  list.sort((a, b) => {\n    const res = b[1] - a[1];\n    return res === 0 ? a[0].localeCompare(b[0]) : res;\n  });\n  let sb = '';\n  for (let i = 0; i < n && i < list.length; i++) {\n    sb += list[i][0] + ',';\n  }\n  if (sb.length > 0) {\n    sb = sb.slice(0, -1);\n  }\n  return sb;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <regex>\n\nusing namespace std;\n\nstring sortURL(vector<string>& lines, map<string, int>& cache);\n\nint main() {\n    vector<string> lines; // 创建一个字符串列表，用于存储输入的每一行数据\n    map<string, int> cache; // 创建一个哈希表，用于存储每个 URL 出现的次数\n    string line;\n    while (getline(cin, line)) { // 不断读取输入，直到没有下一行\n        lines.push_back(line); // 将该行数据添加到字符串列表中\n        if (regex_match(line, regex(\"^\\\\d+$\"))) { // 如果该行数据只包含数字，说明已经读取完了一个测试用例\n            cout << sortURL(lines, cache) << endl; // 调用 sortURL 方法进行处理，并输出结果\n            lines.clear(); // 清空字符串列表，为下一个测试用例做准备\n        }\n    }\n    return 0;\n}\n\nstring sortURL(vector<string>& lines, map<string, int>& cache) {\n    int n = stoi(lines.back()); // 从字符串列表中取出最后一个元素，即需要输出的 URL 数量\n    lines.pop_back(); // 删除最后一个元素\n    for (string url : lines) { // 遍历字符串列表中的每一个 URL\n        cache[url]++; // 将该 URL 在哈希表中的计数加一\n    }\n    vector<pair<string, int>> list(cache.begin(), cache.end()); // 将哈希表中的每一项转换成一个键值对，并存入一个列表中\n    sort(list.begin(), list.end(), [](const pair<string, int>& a, const pair<string, int>& b) { // 对列表进行排序，按照计数从大到小排序，如果计数相同则按照字典序从小到大排序\n        if (a.second != b.second) {\n            return a.second > b.second;\n        } else {\n            return a.first < b.first;\n        }\n    });\n    string res;\n    for (int i = 0; i < n && i < list.size(); i++) { // 取出前 n 个 URL，并将它们拼接成一个字符串\n        res += list[i].first + \",\";\n    }\n    if (!res.empty()) { // 如果字符串不为空，则删除最后一个逗号\n        res.pop_back();\n    }\n    return res; // 返回拼接好的字符串\n}",
      "c": "#include <stdio.h>   // 包含标准输入输出库，用于使用 printf 和 fgets\n#include <stdlib.h>  // 包含标准库，用于使用 atoi 和 qsort\n#include <string.h>  // 包含字符串处理库，用于使用 strcmp 和 strcpy\n#include <ctype.h>   // 包含字符处理库，用于使用 isdigit\n\n// 定义常量，最大 URL 长度为 128，最大 URL 记录数量为 5000\n#define MAX_URL_LENGTH 128\n#define MAX_URL_COUNT 5000\n\n// 定义结构体，用于存储 URL 和该 URL 的访问计数\ntypedef struct {\n    char url[MAX_URL_LENGTH]; // URL 字符串，最大长度为 128\n    int count; // 该 URL 被访问的次数\n} UrlCount;\n\n// 自定义比较函数，用于 qsort 函数排序\n// 按照 URL 访问次数从大到小排序，如果访问次数相同则按照字典序从小到大排序\nint urlCompare(const void *a, const void *b) {\n    UrlCount *url1 = (UrlCount *)a; // 将 void 指针转换为 UrlCount 指针\n    UrlCount *url2 = (UrlCount *)b;\n    \n    // 如果两个 URL 的访问次数不相等，按照访问次数从大到小排序\n    if (url1->count != url2->count) {\n        return url2->count - url1->count; // 返回负值表示 url2 应该排在 url1 前面\n    }\n    \n    // 如果访问次数相等，按照字典序排序\n    return strcmp(url1->url, url2->url); // strcmp 返回值：负值表示 url1 小于 url2\n}\n\n// 排序并输出访问次数最多的 n 个 URL\nvoid sortURLs(UrlCount urls[], int size, int n) {\n    // 使用 qsort 对 URL 数组进行排序\n    qsort(urls, size, sizeof(UrlCount), urlCompare);\n    \n    // 输出前 n 个 URL，按照排序后的顺序\n    for (int i = 0; i < n && i < size; i++) {\n        printf(\"%s\", urls[i].url); // 输出当前 URL\n        // 如果还未输出到第 n 个 URL 或最后一个 URL，继续打印逗号分隔\n        if (i < n - 1 && i < size - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"\\n\"); // 输出完毕后换行\n}\n\nint main() {\n    UrlCount cache[MAX_URL_COUNT] = {0}; // 创建一个 URL 数组用于缓存，初始值为 0\n    int urlCount = 0; // 当前缓存的 URL 数量，初始为 0\n    char line[128]; // 用于存储每一行输入的字符串\n\n \n    while (fgets(line, sizeof(line), stdin)) {\n        line[strcspn(line, \"\\n\")] = 0; // 去掉字符串末尾的换行符\n        \n        // 判断输入行是否为数字（用于请求输出前 n 个 URL）\n        if (isdigit(line[0])) { // 如果首字符是数字，则认为该行是请求输出的数字\n            int n = atoi(line); // 将字符串转换为整数，表示请求输出的 URL 数量\n            sortURLs(cache, urlCount, n); // 调用排序并输出函数，输出前 n 个 URL\n        } else { // 否则认为该行是 URL\n            int found = 0; // 标志变量，记录当前 URL 是否已经存在\n            // 遍历当前已记录的 URL，检查是否已存在\n            for (int i = 0; i < urlCount; i++) {\n                if (strcmp(cache[i].url, line) == 0) { // 如果找到相同的 URL\n                    cache[i].count++; // 计数器加 1\n                    found = 1; // 标记为已找到\n                    break; // 跳出循环\n                }\n            }\n            // 如果未找到该 URL，说明是新 URL\n            if (!found) {\n                strcpy(cache[urlCount].url, line); // 将新的 URL 到缓存中\n                cache[urlCount].count = 1; // 初始化该 URL 的访问计数为 1\n                urlCount++; // 增加 URL 数量\n            }\n        }\n    }\n    return 0; // 程序结束\n}"
    }
  },
  {
    "id": "42",
    "title": "环中最长子串字符成环找偶数O",
    "examType": "A",
    "score": 100,
    "description": "给你一个字符串 s，字符串s首尾相连成一个环形 ，请你在环中找出 ‘o’ 字符出现了偶数次最长子字符串的长度。",
    "inputDesc": "输入是一串小写字母组成的字符串\n1 <= s.length <= 5 x 10^5 s 只包含小写英文字母",
    "outputDesc": "输出是一个整数",
    "examples": [
      {
        "input": "alolobo",
        "output": "",
        "explanation": "最长子字符串之一是 “alolob”，它包含’o’ 2个。"
      },
      {
        "input": "looxdolx",
        "output": "",
        "explanation": "最长子字符串是 “oxdolxl”，由于是首尾连接在一起的，所以最后一个 ‘x’ 和开头的 ‘l’是连接在一起的，此字符串包含 2 个’o’ 。"
      },
      {
        "input": "bcbcbc",
        "output": "",
        "explanation": "这个示例中，字符串 “bcbcbc” 本身就是最长的，因为 ‘o’ 都出现了 0 次。"
      }
    ],
    "solution": "1234567\n如果 ‘o’ 出现的次数为偶数，那么整个字符串就符合题目的要求：即包含偶数次的 ‘o’。如果 ‘o’ 出现的次数为奇数，则只能通过去掉一个字符（任意字符）来使得剩下的子字符串中的 ‘o’ 出现次数变为偶数。去掉一个字符后，最长的可能子字符串的长度就是 len - 1。\n偶数情况： 如果总共的 ‘o’ 个数已经是偶数，那么从字符串的任意位置开始到任意位置结束的子字符串，也一定能找到包含偶数次 ‘o’ 的最长子串，这个子串就是原字符串本身。 奇数情况： 如果 ‘o’ 的总数是奇数，那么无论如何，我们至少要移除一个字符才能使 ‘o’ 的数量变为偶数。因此，只需要输出 len - 1 即可。\n偶数情况：\n如果总共的 ‘o’ 个数已经是偶数，那么从字符串的任意位置开始到任意位置结束的子字符串，也一定能找到包含偶数次 ‘o’ 的最长子串，这个子串就是原字符串本身。\n奇数情况：\n如果 ‘o’ 的总数是奇数，那么无论如何，我们至少要移除一个字符才能使 ‘o’ 的数量变为偶数。因此，只需要输出 len - 1 即可。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个Scanner对象，用于读取用户输入\n        Scanner in = new Scanner(System.in);\n        // 读取用户输入的字符串\n        String input = in.nextLine();\n        // 将输入的字符串转换为字符数组\n        char[] chrs = input.toCharArray();\n        // 获取字符串的长度\n        int len = chrs.length;\n        // 初始化'o'字符的计数器\n        int num = 0;\n        // 遍历字符数组，统计'o'字符的数量\n        for (char chr : chrs) {\n            if (chr == 'o') {\n                num += 1;\n            }\n        }\n        // 如果'o'字符出现的次数是偶数，则输出字符串的长度\n        if (num % 2 == 0) {\n            System.out.println(len);\n        } else {\n            // 如果'o'字符出现的次数是奇数，则输出字符串长度减1\n            System.out.println(len - 1);\n        }\n    }\n}",
      "python": "# 读取用户输入的字符串\ninput_str = input(\"\")\n# 获取字符串的长度\nlen_str = len(input_str)\n# 初始化'o'字符的计数器\nnum = 0\n# 遍历字符串，统计'o'字符的数量\nfor chr in input_str:\n    if chr == 'o':\n        num += 1\n# 如果'o'字符出现的次数是偶数，则输出字符串的长度\nif num % 2 == 0:\n    print(len_str)\nelse:\n    # 如果'o'字符出现的次数是奇数，则输出字符串长度减1\n    print(len_str - 1)",
      "javascript": "// 引入readline模块，用于读取用户输入\nconst readline = require('readline').createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 询问用户输入字符串\nreadline.on('line', (input) => {\n  // 获取字符串的长度\n  const len = input.length;\n  // 初始化'o'字符的计数器\n  let num = 0;\n  // 遍历字符串，统计'o'字符的数量\n  for (let chr of input) {\n    if (chr === 'o') {\n      num += 1;\n    }\n  }\n  // 如果'o'字符出现的次数是偶数，则输出字符串的长度\n  if (num % 2 === 0) {\n    console.log(len);\n  } else {\n    // 如果'o'字符出现的次数是奇数，则输出字符串长度减1\n    console.log(len - 1);\n  }\n  readline.close();\n});",
      "cpp": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    // 创建一个字符串变量，用于存储用户输入\n    string input;\n    // 读取用户输入的字符串\n    getline(cin, input);\n    // 获取字符串的长度\n    int len = input.size();\n    // 初始化'o'字符的计数器\n    int num = 0;\n    // 遍历字符串，统计'o'字符的数量\n    for (char chr : input) {\n        if (chr == 'o') {\n            num += 1;\n        }\n    }\n    // 如果'o'字符出现的次数是偶数，则输出字符串的长度\n    if (num % 2 == 0) {\n        cout << len << endl;\n    } else {\n        // 如果'o'字符出现的次数是奇数，则输出字符串长度减1\n        cout << len - 1 << endl;\n    }\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char input[500001]; // 创建一个字符数组，用于存储用户输入的字符串，最大长度500000\n    scanf(\"%s\", input); // 读取用户输入的字符串\n\n    int len = strlen(input); // 获取字符串的长度\n    int num = 0; // 初始化'o'字符的计数器\n\n    // 遍历字符串，统计'o'字符的数量\n    for (int i = 0; i < len; i++) {\n        if (input[i] == 'o') {\n            num++;\n        }\n    }\n\n    // 如果'o'字符出现的次数是偶数，则输出字符串的长度\n    if (num % 2 == 0) {\n        printf(\"%d\\n\", len);\n    } else {\n        // 如果'o'字符出现的次数是奇数，则输出字符串长度减1\n        printf(\"%d\\n\", len - 1);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "43",
    "title": "生成哈夫曼树",
    "examType": "A",
    "score": 100,
    "description": "给定长度为 n nn 的无序的数字数组，每个数字代表二叉树的叶子节点的权值，数字数组的值均大于等于 1 11 。请完成一个函数，根据输入的数字数组，生成哈夫曼树，并将哈夫曼树按照中序遍历输出。\n为了保证输出的二叉树中序遍历结果统一，增加以下限制:又树节点中，左节点权值小于等于右节点权值，根节点权值为左右节点权值之和。当左右节点权值相同时，左子树高度高度小于等于右子树。\n注意: 所有用例保证有效，并能生成哈夫曼树提醒:哈夫曼树又称最优二叉树，是一种带权路径长度最短的一叉树。\n所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度(若根结点为 0 00 层，叶结点到根结点的路径长度为叶结点的层数)",
    "inputDesc": "例如：由叶子节点 5 15 40 30 10 生成的最优二叉树如下图所示，该树的最短带权路径长度为 40 * 1 + 30 * 2 +5 * 4 + 10 * 4 = 205 。",
    "outputDesc": "输出一个哈夫曼的中序遍历数组，数值间以空格分隔",
    "examples": [
      {
        "input": "15 40 30 10",
        "output": "100 30 60 15 30 5 15 10",
        "explanation": ""
      }
    ],
    "solution": "请结合上图阅读！ 计算过程如下：\n输入的5个数是：5, 15, 40, 30, 10。将这些数作为节点值创建节点，并将节点添加到优先队列中。构建哈夫曼树： 弹出两个最小的节点，值为5和10，合并为一个新节点值为15，将新节点添加回优先队列。弹出两个最小的节点，值为15（新合成的）和15（原始的），合并为一个新节点值为30，将新节点添加回优先队列。弹出两个最小的节点，值为30（新合成的）和30（原始的），合并为一个新节点值为60，将新节点添加回优先队列。弹出两个最小的节点，值为40和60，合并为一个新节点值为100，将新节点添加回优先队列。此时队列中只剩下一个节点，这就是树的根节点，值为100。 对哈夫曼树进行中序遍历： 访问左子树，值为40，它是一个叶子节点，输出40。访问根节点，值为100，输出100。访问右子树，值为60，它不是叶子节点，继续中序遍历： 访问左子树，值为30，它不是叶子节点，继续中序遍历： 访问左子树，值为15，它是一个叶子节点，输出15。访问根节点，值为30，输出30。访问右子树，值为15，它是一个叶子节点，输出15。 访问根节点，值为60，输出60。访问右子树，值为30，它不是叶子节点，继续中序遍历： 访问左子树，值为10，它是一个叶子节点，输出10。访问根节点，值为30，输出30。右子树为空，无输出。 最终输出的结果是：40 100 15 30 60 10 30。\n弹出两个最小的节点，值为5和10，合并为一个新节点值为15，将新节点添加回优先队列。弹出两个最小的节点，值为15（新合成的）和15（原始的），合并为一个新节点值为30，将新节点添加回优先队列。弹出两个最小的节点，值为30（新合成的）和30（原始的），合并为一个新节点值为60，将新节点添加回优先队列。弹出两个最小的节点，值为40和60，合并为一个新节点值为100，将新节点添加回优先队列。此时队列中只剩下一个节点，这就是树的根节点，值为100。\n访问左子树，值为40，它是一个叶子节点，输出40。访问根节点，值为100，输出100。访问右子树，值为60，它不是叶子节点，继续中序遍历： 访问左子树，值为30，它不是叶子节点，继续中序遍历： 访问左子树，值为15，它是一个叶子节点，输出15。访问根节点，值为30，输出30。访问右子树，值为15，它是一个叶子节点，输出15。 访问根节点，值为60，输出60。访问右子树，值为30，它不是叶子节点，继续中序遍历： 访问左子树，值为10，它是一个叶子节点，输出10。访问根节点，值为30，输出30。右子树为空，无输出。\n访问左子树，值为30，它不是叶子节点，继续中序遍历： 访问左子树，值为15，它是一个叶子节点，输出15。访问根节点，值为30，输出30。访问右子树，值为15，它是一个叶子节点，输出15。 访问根节点，值为60，输出60。访问右子树，值为30，它不是叶子节点，继续中序遍历： 访问左子树，值为10，它是一个叶子节点，输出10。访问根节点，值为30，输出30。右子树为空，无输出。\n访问左子树，值为15，它是一个叶子节点，输出15。访问根节点，值为30，输出30。访问右子树，值为15，它是一个叶子节点，输出15。\n访问左子树，值为10，它是一个叶子节点，输出10。访问根节点，值为30，输出30。右子树为空，无输出。\n小根堆（最小堆）：实现一个小根堆，用于在构建哈夫曼树的过程中维护节点的顺序，确保每次都能从中取出权值最小的节点。\n贪心算法：构建哈夫曼树的过程本身是一个贪心算法的应用，每次选择两个权值最小的节点合并，以确保最终树的带权路径长度最短。\nDFS（深度优先搜索）：在进行中序遍历时，使用了递归方法。",
    "codes": {
      "java": "import java.util.PriorityQueue;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\n// 定义一个节点类来表示哈夫曼树中的节点\nclass Node {\n    int value;       // 节点存储的权值\n    Node left;       // 指向左子节点的引用\n    Node right;      // 指向右子节点的引用\n    int height;      // 节点的高度，用于处理相等权值的情况\n\n    // 构造函数\n    public Node(int v) {\n        value = v;\n        left = null;\n        right = null;\n        height = 0;\n    }\n}\n\n// 实现比较器，用于优先队列的比较逻辑\nclass Compare implements Comparator<Node> {\n    @Override\n    public int compare(Node a, Node b) {\n        // 首先比较节点的权值，若权值相等则比较高度\n        if (a.value > b.value) return 1;\n        if (a.value < b.value) return -1;\n        if (a.height > b.height) return 1;\n        if (a.height < b.height) return -1;\n        return 0;\n    }\n}\n\npublic class Main {\n    // 构建哈夫曼树的函数\n    public static Node buildHuffmanTree(ArrayList<Integer> values) {\n        PriorityQueue<Node> pq = new PriorityQueue<>(new Compare());  // 使用优先队列存储节点\n        // 为每个权值创建一个节点并添加到优先队列中\n        for (int value : values) {\n            pq.add(new Node(value));\n        }\n\n        // 当队列中至少有两个节点时，执行循环\n        while (pq.size() > 1) {\n            Node left = pq.poll();  // 弹出最小的节点作为左子节点\n            Node right = pq.poll(); // 弹出次小的节点作为右子节点\n\n            // 创建一个新节点，其权值为左右子节点的权值之和\n            Node parent = new Node(left.value + right.value);\n            // 确保左子节点权值不大于右子节点权值，若相等则比较高度\n            if (left.value > right.value || (left.value == right.value && left.height > right.height)) {\n                Node temp = left;\n                left = right;\n                right = temp;  // 交换左右子节点\n            }\n            parent.left = left;\n            parent.right = right;\n            parent.height = Math.max(left.height, right.height) + 1;  // 计算新节点的高度\n            pq.add(parent);  // 将新节点加入优先队列\n        }\n        // 返回优先队列中剩余的最后一个节点，即哈夫曼树的根节点\n        return pq.peek();\n    }\n\n    // 中序遍历哈夫曼树，并将遍历结果保存为字符串\n    public static void inorderTraversal(Node root, StringBuilder result) {\n        if (root != null) {\n            inorderTraversal(root.left, result);  // 遍历左子树\n            result.append(root.value).append(\" \");  // 访问当前节点\n            inorderTraversal(root.right, result);  // 遍历右子树\n        }\n    }\n\n    // 主函数\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();  // 读取节点数量\n        ArrayList<Integer> values = new ArrayList<>();  // 存储所有节点的权值\n        for (int i = 0; i < n; i++) {\n            values.add(scanner.nextInt());  // 读取权值\n        }\n        Node root = buildHuffmanTree(values);  // 构建哈夫曼树\n        StringBuilder result = new StringBuilder();  // 用于存储中序遍历结果\n        inorderTraversal(root, result);  // 执行中序遍历\n        if (result.length() > 0) {\n            result.deleteCharAt(result.length() - 1);  // 移除最后的空格\n        }\n        System.out.println(result.toString());  // 输出中序遍历结果\n        scanner.close();\n    }\n}",
      "python": "import heapq\n\n# 定义Node类，用于构建哈夫曼树的节点\nclass Node:\n    def __init__(self, value):\n        self.value = value  # 节点存储的数值\n        self.left = None  # 节点的左子节点\n        self.right = None  # 节点的右子节点\n        self.height = 0  # 节点的高度\n\n    # 重载小于操作符，用于优先队列中比较Node对象\n    def __lt__(self, other):\n        # 首先比较节点的权值，如果权值相同，则比较高度\n        if self.value == other.value:\n            return self.height < other.height\n        return self.value < other.value\n\n# 构建哈夫曼树的函数\ndef build_huffman_tree(values):\n    pq = [Node(value) for value in values]  # 创建Node对象列表\n    heapq.heapify(pq)  # 将列表转换为最小堆\n    while len(pq) > 1:  # 当堆中有多于一个节点时\n        left = heapq.heappop(pq)  # 弹出两个数值最小的节点\n        right = heapq.heappop(pq)\n        parent = Node(left.value + right.value)  # 创建新节点，其数值为两个子节点数值之和\n        parent.left = left  # 设置新节点的左子节点\n        parent.right = right  # 设置新节点的右子节点\n        parent.height = max(left.height, right.height) + 1  # 更新节点的高度\n        heapq.heappush(pq, parent)  # 将新节点加入堆中\n    return pq[0]  # 返回堆中剩下的最后一个节点，即哈夫曼树的根节点\n\n# 中序遍历哈夫曼树的函数\ndef inorder_traversal(root):\n    if root is not None:  # 如果当前节点不为空\n        yield from inorder_traversal(root.left)  # 递归遍历左子树\n        yield root.value  # 返回当前节点的值\n        yield from inorder_traversal(root.right)  # 递归遍历右子树\n \nn = int(input())  # 从标准输入读取数字的个数\nvalues = list(map(int, input().split()))  # 从标准输入读取数字，并转换为整数列表\nroot = build_huffman_tree(values)  # 构建哈夫曼树，并获取根节点\nresult = ' '.join(map(str, inorder_traversal(root)))  # 对哈夫曼树进行中序遍历，并将结果转换为字符串\nprint(result)  # 打印中序遍历的结果",
      "javascript": "const readline = require('readline');\n\n// 创建命令行读取接口实例\nconst rl = readline.createInterface({\n    input: process.stdin,  // 标准输入流\n    output: process.stdout // 标准输出流\n});\n\n// 监听第一行输入事件，获取节点数量\nrl.on('line', (n) => {\n    // 监听第二行输入事件，获取节点权值列表\n    rl.on('line', (line) => {\n        const values = line.split(' ').map(Number);  // 将输入的行按空格分割，并将每个元素转换为数字\n        const root = buildHuffmanTree(values);  // 使用输入的值构建哈夫曼树，并获取根节点\n        const result = [];  // 初始化中序遍历结果数组\n        inorderTraversal(root, result);  // 对哈夫曼树进行中序遍历\n        console.log(result.join(' '));  // 将中序遍历的结果数组转换为字符串并打印\n        rl.close();  // 关闭读取接口\n    });\n});\n\n// 定义节点类，用于构建哈夫曼树\nclass Node {\n    constructor(value) {\n        this.value = value;  // 节点的值\n        this.left = null;    // 节点的左子节点\n        this.right = null;   // 节点的右子节点\n    }\n}\n\n// 定义最小优先队列类\nclass MinPriorityQueue {\n    constructor() {\n        this.elements = [];  // 存储队列元素的数组\n    }\n\n    // 入队操作\n    enqueue(element) {\n        this.elements.push(element);  // 将新元素添加到数组末尾\n        this.elements.sort((a, b) => a.value - b.value);  // 对数组进行排序，确保最小元素在数组开头\n    }\n\n    // 出队操作\n    dequeue() {\n        return this.elements.shift();  // 移除并返回数组第一个元素\n    }\n\n    // 检查队列是否为空\n    isEmpty() {\n        return this.elements.length === 0;  // 队列为空时数组长度为0\n    }\n}\n\n// 构建哈夫曼树的函数\nfunction buildHuffmanTree(values) {\n    const pq = new MinPriorityQueue();  // 创建最小优先队列实例\n    values.forEach(value => pq.enqueue(new Node(value)));  // 为每个权值创建一个节点并加入队列\n\n    while (pq.elements.length > 1) {\n        const left = pq.dequeue();  // 弹出最小的节点作为左子节点\n        const right = pq.dequeue();  // 弹出次小的节点作为右子节点\n\n        const parent = new Node(left.value + right.value);  // 创建新节点，其权值为左右子节点之和\n        parent.left = left;  // 设置新节点的左子节点\n        parent.right = right;  // 设置新节点的右子节点\n        pq.enqueue(parent);  // 将新节点加入优先队列\n    }\n    return pq.dequeue();  // 返回队列中的最后一个节点，即哈夫曼树的根节点\n}\n\n// 中序遍历函数\nfunction inorderTraversal(node, result) {\n    if (node) {\n        inorderTraversal(node.left, result);  // 遍历左子树\n        result.push(node.value);  // 访问当前节点，并加入结果数组\n        inorderTraversal(node.right, result);  // 遍历右子树\n    }\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\n// Node结构用于表示哈夫曼树中的节点\nstruct Node {\n    int value;       // 节点存储的权值\n    Node* left;      // 指向左子节点的指针\n    Node* right;     // 指向右子节点的指针\n    int height;      // 节点的高度，用于处理相等权值的情况\n    Node(int v) : value(v), left(nullptr), right(nullptr), height(0) {}\n};\n\n// Compare结构用于定义优先队列的比较方式\nstruct Compare {\n    // 重载()操作符，定义比较规则\n    bool operator()(Node* a, Node* b) {\n        // 首先比较节点的权值，若权值相等则比较高度\n        return a->value > b->value || (a->value == b->value && a->height > b->height);\n    }\n};\n\n// 构建哈夫曼树的函数\nNode* buildHuffmanTree(const vector<int>& values) {\n    priority_queue<Node*, vector<Node*>, Compare> pq;  // 定义优先队列存储节点\n    // 遍历所有权值，为每个权值创建一个节点\n    for (int value : values) {\n        pq.push(new Node(value));\n    }\n\n    // 当队列中至少有两个节点时，执行循环\n    while (pq.size() > 1) {\n        Node* left = pq.top(); pq.pop();  // 弹出最小的节点作为左子节点\n        Node* right = pq.top(); pq.pop(); // 弹出次小的节点作为右子节点\n\n        // 创建一个新节点，其权值为左右子节点的权值之和\n        Node* parent = new Node(left->value + right->value);\n        // 确保左子节点权值不大于右子节点权值，若相等则比较高度\n        if (left->value > right->value || (left->value == right->value && left->height > right->height)) {\n            swap(left, right);  // 若需要，交换左右子节点\n        }\n        parent->left = left;\n        parent->right = right;\n        parent->height = max(left->height, right->height) + 1;  // 计算新节点的高度\n        pq.push(parent);  // 将新节点加入优先队列\n    }\n    // 返回优先队列中剩余的最后一个节点，即哈夫曼树的根节点\n    return pq.top();\n}\n\n// 中序遍历哈夫曼树，并将遍历结果保存为字符串\nvoid inorderTraversal(Node* root, string& result) {\n    if (root) {\n        inorderTraversal(root->left, result);  // 遍历左子树\n        result += to_string(root->value) + \" \";  // 访问当前节点\n        inorderTraversal(root->right, result);  // 遍历右子树\n    }\n}\n\n// 主函数\nint main() {\n    int n;  // 存储节点数量\n    cin >> n;\n    vector<int> values(n);  // 存储所有节点的权值\n    for (int i = 0; i < n; ++i) {\n        cin >> values[i];  // 输入权值\n    }\n    Node* root = buildHuffmanTree(values);  // 构建哈夫曼树\n    string result;  // 用于存储中序遍历结果\n    inorderTraversal(root, result);  // 执行中序遍历\n    if (!result.empty()) {\n        result.pop_back();  // 移除最后的空格\n    }\n    cout << result << endl;  // 输出中序遍历结果\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 1000 // 定义最大节点数量，限制优先队列的容量\n\n// 哈夫曼树节点结构体定义\ntypedef struct Node {\n    int value;           // 节点存储的权值\n    struct Node *left;   // 指向左子节点的指针\n    struct Node *right;  // 指向右子节点的指针\n    int height;          // 节点的高度，用于处理权值相同的情况\n} Node;\n\n// 优先队列结构体定义\ntypedef struct {\n    Node *data[MAX_SIZE];  // 存储队列元素的数组\n    int size;              // 队列当前元素个数\n} PriorityQueue;\n\n// 初始化优先队列\nvoid initPriorityQueue(PriorityQueue *pq) {\n    pq->size = 0;\n}\n\n// 创建新节点\nNode *createNode(int value) {\n    Node *node = (Node *)malloc(sizeof(Node));\n    node->value = value;\n    node->left = NULL;\n    node->right = NULL;\n    node->height = 0;\n    return node;\n}\n\n// 向优先队列添加元素，维持最小堆性质\nvoid push(PriorityQueue *pq, Node *node) {\n    int i = pq->size++; // 插入新元素的位置\n    while (i > 0) {\n        int parent = (i - 1) / 2; // 计算父节点的位置\n        if (pq->data[parent]->value < node->value ||\n            (pq->data[parent]->value == node->value && pq->data[parent]->height <= node->height)) {\n            break; // 如果当前节点大于父节点，或权值相等但高度不低于父节点，停止调整\n        }\n        pq->data[i] = pq->data[parent]; // 否则，将父节点下移\n        i = parent;\n    }\n    pq->data[i] = node; // 插入新节点\n}\n\n// 从优先队列中弹出最小元素\nNode *pop(PriorityQueue *pq) {\n    Node *min = pq->data[0];\n    Node *last = pq->data[--pq->size];\n    int i = 0;\n    while (i * 2 + 1 < pq->size) {\n        int left = i * 2 + 1;\n        int right = i * 2 + 2;\n        int smallest = left;\n        if (right < pq->size && (pq->data[right]->value < pq->data[left]->value ||\n                                 (pq->data[right]->value == pq->data[left]->value && pq->data[right]->height < pq->data[left]->height))) {\n            smallest = right;\n        }\n        if (last->value < pq->data[smallest]->value ||\n            (last->value == pq->data[smallest]->value && last->height <= pq->data[smallest]->height)) {\n            break;\n        }\n        pq->data[i] = pq->data[smallest];\n        i = smallest;\n    }\n    pq->data[i] = last;\n    return min;\n}\n\n// 构建哈夫曼树\nNode *buildHuffmanTree(int values[], int n) {\n    PriorityQueue pq;\n    initPriorityQueue(&pq);\n    for (int i = 0; i < n; i++) {\n        push(&pq, createNode(values[i]));\n    }\n    while (pq.size > 1) {\n        Node *left = pop(&pq);\n        Node *right = pop(&pq);\n        Node *parent = createNode(left->value + right->value);\n        if (left->value > right->value || (left->value == right->value && left->height > right->height)) {\n            Node *temp = left;\n            left = right;\n            right = temp;\n        }\n        parent->left = left;\n        parent->right = right;\n        parent->height = (left->height > right->height ? left->height : right->height) + 1;\n        push(&pq, parent);\n    }\n    return pop(&pq);\n}\n\n// 中序遍历哈夫曼树\nvoid inorderTraversal(Node *root) {\n    if (root != NULL) {\n        inorderTraversal(root->left);\n        printf(\"%d \", root->value);\n        inorderTraversal(root->right);\n    }\n}\n\n// 主函数\nint main() {\n    int n, values[MAX_SIZE];\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &values[i]);\n    }\n    Node *root = buildHuffmanTree(values, n);\n    inorderTraversal(root);\n   \n    return 0;\n}"
    }
  },
  {
    "id": "44",
    "title": "矩形相交的面积",
    "examType": "A",
    "score": 100,
    "description": "给出3组点坐标(x, y, w, h)，-1000<x,y<1000，w,h为正整数。\n(x, y, w, h)表示平面直角坐标系中的一个矩形：\nx, y为矩形左上角坐标点，w, h向右w，向下h。\n(x, y, w, h)表示x轴(x, x+w)和y轴(y, y-h)围成的矩形区域；\n(0, 0, 2, 2)表示 x轴(0, 2)和y 轴(0, -2)围成的矩形区域；\n(3, 5, 4, 6)表示x轴(3, 7)和y轴(5, -1)围成的矩形区域；\n求3组坐标构成的矩形区域重合部分的面积。",
    "inputDesc": "3行输入分别为3个矩形的位置，分别代表“左上角x坐标”，“左上角y坐标”，“矩形宽”，“矩形高” -1000 <= x,y < 1000",
    "outputDesc": "输出3个矩形相交的面积，不相交的输出0。",
    "examples": [
      {
        "input": "6 4 4\n 5 3 4\n 3 7 3",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "三个矩形的左上角坐标 (x1, y1) 以及宽度 w 和高度 h。利用这些输入，计算出每个矩形的右下角坐标 (x2, y2)： x2 = x1 + w：右下角的 x 坐标是左上角 x 加上矩形的宽度。y2 = y1 - h：右下角的 y 坐标是左上角 y 减去矩形的高度（因为高度是向下的，所以用减法）。 这些计算结果存储在 x_coords 和 y_coords 两个列表中，分别保存所有的 x 和 y 坐标信息。 确定最小和最大坐标： 代码通过遍历 x_coords 和 y_coords 来确定x、y坐标的最小值和最大值。这些值用于构建包含所有矩形的二维数组，这样可以将坐标转换为一个可索引的数组形式，方便后续的重叠检测。 偏移量的计算： 为了确保坐标系可以从数组的索引 0 开始，代码计算了 x_offset 和 y_offset，这些偏移量用于将负数坐标平移到数组的有效范围内。 构建二维数组表示区域并进行重叠检测： 使用二维数组 intersection_area 来表示整个坐标系的矩形区域，每个位置（数组的元素）表示该位置被多少个矩形覆盖： 遍历每个矩形的左上角到右下角的范围，将这些区域的值在二维数组中加1，表示这些区域已被覆盖。如果某个二维数组的值是3，说明该位置被三个矩形同时覆盖。 计算重叠区域： 最后，遍历二维数组，统计值为3的区域数量，即为三个矩形重叠部分的面积。\n三个矩形的左上角坐标 (x1, y1) 以及宽度 w 和高度 h。利用这些输入，计算出每个矩形的右下角坐标 (x2, y2)：\nx2 = x1 + w：右下角的 x 坐标是左上角 x 加上矩形的宽度。y2 = y1 - h：右下角的 y 坐标是左上角 y 减去矩形的高度（因为高度是向下的，所以用减法）。\n这些计算结果存储在 x_coords 和 y_coords 两个列表中，分别保存所有的 x 和 y 坐标信息。\n确定最小和最大坐标： 代码通过遍历 x_coords 和 y_coords 来确定x、y坐标的最小值和最大值。这些值用于构建包含所有矩形的二维数组，这样可以将坐标转换为一个可索引的数组形式，方便后续的重叠检测。\n偏移量的计算： 为了确保坐标系可以从数组的索引 0 开始，代码计算了 x_offset 和 y_offset，这些偏移量用于将负数坐标平移到数组的有效范围内。\n构建二维数组表示区域并进行重叠检测： 使用二维数组 intersection_area 来表示整个坐标系的矩形区域，每个位置（数组的元素）表示该位置被多少个矩形覆盖：\n遍历每个矩形的左上角到右下角的范围，将这些区域的值在二维数组中加1，表示这些区域已被覆盖。如果某个二维数组的值是3，说明该位置被三个矩形同时覆盖。\n计算重叠区域： 最后，遍历二维数组，统计值为3的区域数量，即为三个矩形重叠部分的面积。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> x_coords = new ArrayList<>();  // 存储所有矩形的x坐标\n        List<Integer> y_coords = new ArrayList<>();  // 存储所有矩形的y坐标\n        List<int[]> rectangles = new ArrayList<>();  // 存储所有矩形的左上角和右下角坐标\n        Scanner scanner = new Scanner(System.in);\n        for (int i = 0; i < 3; i++) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int w = scanner.nextInt();\n            int h = scanner.nextInt();\n\n            int x2 = x1 + w;  // 计算矩形的右上角x坐标\n            int y2 = y1 - h;  // 计算矩形的右上角y坐标\n            x_coords.add(x1);\n            x_coords.add(x2);\n            y_coords.add(y1);\n            y_coords.add(y2);\n            rectangles.add(new int[]{x1, y1, x2, y2});\n        }\n\n        int min_x_coord = Integer.MAX_VALUE;\n        int max_x_coord = Integer.MIN_VALUE;\n        int min_y_coord = Integer.MAX_VALUE;\n        int max_y_coord = Integer.MIN_VALUE;\n        for (int x : x_coords) {\n            min_x_coord = Math.min(min_x_coord, x);\n            max_x_coord = Math.max(max_x_coord, x);\n        }\n        for (int y : y_coords) {\n            min_y_coord = Math.min(min_y_coord, y);\n            max_y_coord = Math.max(max_y_coord, y);\n        }\n\n        int x_offset = 0 - min_x_coord;  // 计算x坐标的偏移量\n        int y_offset = 0 - min_y_coord;  // 计算y坐标的偏移量\n\n        int[][] intersection_area = new int[Math.abs(max_x_coord - min_x_coord)][Math.abs(max_y_coord - min_y_coord)];  // 创建表示矩形区域的二维数组\n\n        for (int[] rectangle : rectangles) {\n            int x1 = rectangle[0];\n            int y1 = rectangle[1];\n            int x2 = rectangle[2];\n            int y2 = rectangle[3];\n            for (int i = Math.min(x2, x1) + x_offset; i < Math.max(x2, x1) + x_offset; i++) {\n                for (int j = Math.min(y2, y1) + y_offset; j < Math.max(y2, y1) + y_offset; j++) {\n                    intersection_area[i][j] += 1;  // 在相应的区域加1\n                }\n            }\n        }\n\n        int ret = 0;\n        for (int i = 0; i < intersection_area.length; i++) {\n            for (int j = 0; j < intersection_area[0].length; j++) {\n                if (intersection_area[i][j] == 3) {  // 统计值为3的区域的个数\n                    ret += 1;\n                }\n            }\n        }\n\n        System.out.println(ret);  // 输出相交的面积\n    }\n}",
      "python": "x_coords = []  # 存储所有矩形的x坐标\ny_coords = []  # 存储所有矩形的y坐标\nrectangles = []  # 存储所有矩形的左上角和右下角坐标\nfor _ in range(3):\n    x1, y1, w, h = list(map(int, input().split()))\n \n    x2 = x1 + w  # 计算矩形的右上角x坐标\n    y2 = y1 - h  # 计算矩形的右上角y坐标\n    x_coords += [x1, x2]\n    y_coords += [y1, y2]\n    rectangles.append((x1, y1, x2, y2))\n\nmin_x_coord, max_x_coord = min(x_coords), max(x_coords)  # 计算矩形区域的最小和最大x坐标\nmin_y_coord, max_y_coord = min(y_coords), max(y_coords)  # 计算矩形区域的最小和最大y坐标\nx_offset = 0 - min_x_coord  # 计算x坐标的偏移量\ny_offset = 0 - min_y_coord  # 计算y坐标的偏移量\n\nintersection_area = [[0] * abs(max_y_coord - min_y_coord) for _ in range(abs(max_x_coord - min_x_coord))]  # 创建表示矩形区域的二维数组\n\nfor x1, y1, x2, y2 in rectangles:\n    for i in range(min((x2, x1)) + x_offset, max((x2, x1)) + x_offset):\n        for j in range(min((y2, y1)) + y_offset, max((y2, y1)) + y_offset):\n            intersection_area[i][j] += 1  # 在相应的区域加1\n\nret = 0\nfor i in range(len(intersection_area)):\n    for j in range(len(intersection_area[0])):\n        if intersection_area[i][j] == 3:  #  区域值为3时表示3个矩形重合\n            ret += 1\n\nprint(ret)  # 输出相交的面积",
      "javascript": "var readline = require('readline');\n\n// 创建接口用于读取标准输入\nvar rl = readline.createInterface({\n  input: process.stdin, // 输入来自标准输入（键盘输入）\n  output: process.stdout // 输出到标准输出（控制台）\n});\n\nvar x_coords = []; // 用于存储所有矩形的x坐标\nvar y_coords = []; // 用于存储所有矩形的y坐标\nvar rectangles = []; // 用于存储每个矩形的左上角和右下角坐标\n\n// 监听每行输入的事件\nrl.on('line', function(line){\n  // 将输入的每一行按空格分割，并将其转换为数字数组\n  var inputs = line.split(' ').map(Number);\n  var x1 = inputs[0]; // 矩形左上角的x坐标\n  var y1 = inputs[1]; // 矩形左上角的y坐标\n  var w = inputs[2];  // 矩形的宽度\n  var h = inputs[3];  // 矩形的高度\n\n  var x2 = x1 + w;  // 计算矩形右下角的x坐标\n  var y2 = y1 - h;  // 计算矩形右下角的y坐标\n\n  // 将矩形的x坐标加入x_coords数组\n  x_coords.push(x1, x2);\n  // 将矩形的y坐标加入y_coords数组\n  y_coords.push(y1, y2);\n  // 将矩形的完整坐标（左上角和右下角）存入rectangles数组\n  rectangles.push([x1, y1, x2, y2]);\n\n  // 当已经读取到三个矩形时，结束输入\n  if(rectangles.length === 3){\n    rl.close(); // 关闭输入流\n  }\n});\n\n// 当输入结束时触发此事件\nrl.on('close', function(){\n  // 计算所有矩形的x坐标中的最小值和最大值\n  var min_x_coord = Math.min(...x_coords);\n  var max_x_coord = Math.max(...x_coords);\n  // 计算所有矩形的y坐标中的最小值和最大值\n  var min_y_coord = Math.min(...y_coords);\n  var max_y_coord = Math.max(...y_coords);\n\n  // 计算x坐标和y坐标的偏移量，将所有坐标平移到非负范围\n  var x_offset = 0 - min_x_coord;\n  var y_offset = 0 - min_y_coord;\n\n  // 创建一个二维数组 intersection_area，表示整个区域\n  // 数组的大小为矩形的最大x和最小x之间的差值，以及最大y和最小y之间的差值\n  var intersection_area = new Array(Math.abs(max_x_coord - min_x_coord))\n    .fill(0)\n    .map(() => new Array(Math.abs(max_y_coord - min_y_coord)).fill(0));\n\n  // 遍历每个矩形\n  for(var i = 0; i < rectangles.length; i++){\n    var x1 = rectangles[i][0]; // 矩形左上角的x坐标\n    var y1 = rectangles[i][1]; // 矩形左上角的y坐标\n    var x2 = rectangles[i][2]; // 矩形右下角的x坐标\n    var y2 = rectangles[i][3]; // 矩形右下角的y坐标\n\n    // 遍历矩形的x坐标范围，填充到二维数组中\n    for(var j = Math.min(x2, x1) + x_offset; j < Math.max(x2, x1) + x_offset; j++){\n      // 遍历矩形的y坐标范围，填充到二维数组中\n      for(var k = Math.min(y2, y1) + y_offset; k < Math.max(y2, y1) + y_offset; k++){\n        intersection_area[j][k]++; // 对应的二维数组位置计数加1，表示该区域被覆盖\n      }\n    }\n  }\n\n  var ret = 0; // 用于存储同时被三个矩形覆盖的区域的数量\n\n  // 遍历整个二维数组，统计被三个矩形同时覆盖的区域\n  for(var i = 0; i < intersection_area.length; i++){\n    for(var j = 0; j < intersection_area[0].length; j++){\n      if(intersection_area[i][j] === 3){ // 如果该区域被三个矩形覆盖\n        ret++; // 计数增加\n      }\n    }\n  }\n\n  // 输出最终结果，即重叠的面积\n  console.log(ret);\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    vector<int> x_coords;  // 存储所有矩形的x坐标\n    vector<int> y_coords;  // 存储所有矩形的y坐标\n    vector<vector<int>> rectangles;  // 存储所有矩形的左上角和右下角坐标\n    for (int i = 0; i < 3; i++) {\n        int x1, y1, w, h;\n        cin >> x1 >> y1 >> w >> h;\n\n        int x2 = x1 + w;  // 计算矩形的右上角x坐标\n        int y2 = y1 - h;  // 计算矩形的右上角y坐标\n        x_coords.push_back(x1);\n        x_coords.push_back(x2);\n        y_coords.push_back(y1);\n        y_coords.push_back(y2);\n        rectangles.push_back({x1, y1, x2, y2});\n    }\n\n    int min_x_coord = *min_element(x_coords.begin(), x_coords.end());  // 计算矩形区域的最小x坐标\n    int max_x_coord = *max_element(x_coords.begin(), x_coords.end());  // 计算矩形区域的最大x坐标\n    int min_y_coord = *min_element(y_coords.begin(), y_coords.end());  // 计算矩形区域的最小y坐标\n    int max_y_coord = *max_element(y_coords.begin(), y_coords.end());  // 计算矩形区域的最大y坐标\n    int x_offset = 0 - min_x_coord;  // 计算x坐标的偏移量\n    int y_offset = 0 - min_y_coord;  // 计算y坐标的偏移量\n\n    vector<vector<int>> intersection_area(abs(max_x_coord - min_x_coord), vector<int>(abs(max_y_coord - min_y_coord), 0));  // 创建表示矩形区域的二维数组\n\n    for (vector<int>& rectangle : rectangles) {\n        int x1 = rectangle[0];\n        int y1 = rectangle[1];\n        int x2 = rectangle[2];\n        int y2 = rectangle[3];\n        for (int i = min(x2, x1) + x_offset; i < max(x2, x1) + x_offset; i++) {\n            for (int j = min(y2, y1) + y_offset; j < max(y2, y1) + y_offset; j++) {\n                intersection_area[i][j] += 1;  // 在相应的区域加1\n            }\n        }\n    }\n\n    int ret = 0;\n    for (int i = 0; i < intersection_area.size(); i++) {\n        for (int j = 0; j < intersection_area[0].size(); j++) {\n            if (intersection_area[i][j] == 3) {  // 域值为3时表示3个矩形重合\n                ret += 1;\n            }\n        }\n    }\n\n    cout << ret << endl;  // 输出相交的面积\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>  // 用于定义最大和最小整数值\n\n#define MAX_RECTANGLES 3  // 矩形数量\n\nint main() {\n    int x_coords[MAX_RECTANGLES * 2];  // 存储所有矩形的x坐标（每个矩形有2个x坐标）\n    int y_coords[MAX_RECTANGLES * 2];  // 存储所有矩形的y坐标（每个矩形有2个y坐标）\n    int rectangles[MAX_RECTANGLES][4];  // 存储所有矩形的左上角和右下角坐标 (x1, y1, x2, y2)\n    int x1, y1, w, h;\n    int x2, y2;\n\n    // 输入三个矩形的信息\n    for (int i = 0; i < MAX_RECTANGLES; i++) {\n        scanf(\"%d %d %d %d\", &x1, &y1, &w, &h);  // 读取每个矩形的左上角坐标和宽高\n        x2 = x1 + w;  // 计算矩形的右下角x坐标\n        y2 = y1 - h;  // 计算矩形的右下角y坐标\n\n        // 存储矩形的x坐标\n        x_coords[i * 2] = x1;\n        x_coords[i * 2 + 1] = x2;\n\n        // 存储矩形的y坐标\n        y_coords[i * 2] = y1;\n        y_coords[i * 2 + 1] = y2;\n\n        // 存储矩形的坐标 (x1, y1, x2, y2)\n        rectangles[i][0] = x1;\n        rectangles[i][1] = y1;\n        rectangles[i][2] = x2;\n        rectangles[i][3] = y2;\n    }\n\n    // 初始化最小和最大坐标值\n    int min_x_coord = INT_MAX;\n    int max_x_coord = INT_MIN;\n    int min_y_coord = INT_MAX;\n    int max_y_coord = INT_MIN;\n\n    // 寻找x轴的最小值和最大值\n    for (int i = 0; i < MAX_RECTANGLES * 2; i++) {\n        if (x_coords[i] < min_x_coord) {\n            min_x_coord = x_coords[i];\n        }\n        if (x_coords[i] > max_x_coord) {\n            max_x_coord = x_coords[i];\n        }\n    }\n\n    // 寻找y轴的最小值和最大值\n    for (int i = 0; i < MAX_RECTANGLES * 2; i++) {\n        if (y_coords[i] < min_y_coord) {\n            min_y_coord = y_coords[i];\n        }\n        if (y_coords[i] > max_y_coord) {\n            max_y_coord = y_coords[i];\n        }\n    }\n\n    // 计算x和y的偏移量，将坐标平移至非负范围\n    int x_offset = 0 - min_x_coord;\n    int y_offset = 0 - min_y_coord;\n\n    // 计算二维数组的大小\n    int width = abs(max_x_coord - min_x_coord);\n    int height = abs(max_y_coord - min_y_coord);\n\n    // 动态分配用于表示矩形区域的二维数组\n    int** intersection_area = (int**)malloc(width * sizeof(int*));\n    for (int i = 0; i < width; i++) {\n        intersection_area[i] = (int*)calloc(height, sizeof(int));  // 初始化数组元素为0\n    }\n\n    // 遍历每个矩形，填充二维数组区域\n    for (int i = 0; i < MAX_RECTANGLES; i++) {\n        int rect_x1 = rectangles[i][0];\n        int rect_y1 = rectangles[i][1];\n        int rect_x2 = rectangles[i][2];\n        int rect_y2 = rectangles[i][3];\n\n        // 遍历每个矩形的区域，并在二维数组中标记被覆盖的区域\n        for (int x = (rect_x1 + x_offset); x < (rect_x2 + x_offset); x++) {\n            for (int y = (rect_y2 + y_offset); y < (rect_y1 + y_offset); y++) {\n                intersection_area[x][y] += 1;  // 增加覆盖计数\n            }\n        }\n    }\n\n    int ret = 0;  // 用于存储重叠的区域面积\n\n    // 遍历二维数组，统计同时被三个矩形覆盖的区域数\n    for (int i = 0; i < width; i++) {\n        for (int j = 0; j < height; j++) {\n            if (intersection_area[i][j] == 3) {  // 如果区域被三个矩形覆盖\n                ret += 1;  // 增加计数\n            }\n        }\n    }\n\n    // 输出结果\n    printf(\"%d\\n\", ret);\n\n    // 释放二维数组的内存\n    for (int i = 0; i < width; i++) {\n        free(intersection_area[i]);\n    }\n    free(intersection_area);\n\n    return 0;\n}"
    }
  },
  {
    "id": "45",
    "title": "磁盘容量排序",
    "examType": "A",
    "score": 100,
    "description": "磁盘的容量单位常用的有 M，G，T 这三个等级，它们之间的换算关系为：\n1T = 1024G1G = 1024M\n现在给定 n 块磁盘的容量，请对它们按从小到大的顺序进行稳定排序。\n例如给定5块盘的容量：\n1T，20M，3G，10G6T，3M12G9M\n排序后的结果为：\n20M，3G，3M12G9M，1T，10G6T\n注意单位可以重复出现，上述 3M12G9M 表示的容量即为：3M+12G+9M，和 12M12G 相等。",
    "inputDesc": "输入第一行包含一个整数 n，表示磁盘的个数\n2 ≤ n ≤ 100\n接下的 n 行，每行一个字符串（长度大于2，小于30），表示磁盘的容量，由一个或多个格式为mv的子串组成，其中 m 表示容量大小，v 表示容量单位，例如：20M，1T，30G，10G6T，3M12G9M。\n磁盘容量 m 的范围为 1 到 1024 的正整数容量单位 v 的范围只包含题目中提到的 M，G，T 三种，换算关系如题目描述",
    "outputDesc": "输出 n 行，表示 n 块磁盘容量排序后的结果。",
    "examples": [
      {
        "input": "G\nG\nM",
        "output": "G\nM\nG",
        "explanation": "1G和1024M容量相等，稳定排序要求保留它们原来的相对位置，故1G在1024M之前。"
      },
      {
        "input": "G4M\nM2G\nT",
        "output": "M2G\nG4M\nT",
        "explanation": "1T的容量大于2G4M，2G4M的容量大于3M2G。"
      }
    ],
    "solution": "题目描述要求对磁盘容量进行稳定排序，磁盘容量可以用M（兆）、G（千兆）、T（太字节）表示，它们之间的换算关系为：1T = 1024G，1G = 1024M。磁盘的容量以格式为mv的子串表示，其中m表示容量大小，v表示容量单位。\n换算规则： 1T = 1024G，1G = 1024M，所以所有磁盘容量可以统一转换为M单位来方便比较。例如： 1T = 1024 * 1024M = 1048576M1G = 1024M20M就是20M。 排序要求： 题目要求对这些磁盘容量从小到大排序。稳定排序：如果两个磁盘的容量大小相同，保持它们原输入中的顺序不变。例如，1G和1024M容量相等，但1G在输入时位于1024M之前，故在输出时1G仍应位于1024M之前。\n1T = 1024G，1G = 1024M，所以所有磁盘容量可以统一转换为M单位来方便比较。例如： 1T = 1024 * 1024M = 1048576M1G = 1024M20M就是20M。\n1T = 1024 * 1024M = 1048576M1G = 1024M20M就是20M。\n题目要求对这些磁盘容量从小到大排序。稳定排序：如果两个磁盘的容量大小相同，保持它们原输入中的顺序不变。例如，1G和1024M容量相等，但1G在输入时位于1024M之前，故在输出时1G仍应位于1024M之前。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = Integer.parseInt(scanner.nextLine());\n \n        List<Map.Entry<Integer, String>> res = new ArrayList<>();\n\n        // 处理n行磁盘容量\n        for (int i = 0; i < n; i++) {\n            String capacity = scanner.nextLine();\n            int sum = 0;\n            int left = 0;\n            int right = 1;\n\n            // 将磁盘容量转化为数值\n            while (right < capacity.length()) {\n                if (capacity.charAt(right) == 'M' || capacity.charAt(right) == 'G' || capacity.charAt(right) == 'T') {\n                    int val = Integer.parseInt(capacity.substring(left, right));\n                    switch (capacity.charAt(right)) {\n                        case 'M':\n                            sum += val;\n                            break;\n                        case 'G':\n                            sum += val * 1024;\n                            break;\n                        case 'T':\n                            sum += val * 1024 * 1024;\n                            break;\n                    }\n                    left = right + 1;  // 更新左指针\n                }\n                right++;  // 移动右指针\n            }\n\n            // 存储容量及其原始字符串\n            res.add(new AbstractMap.SimpleEntry<>(sum, capacity));\n        }\n\n        // 排序后输出结果\n        res.sort(Comparator.comparingInt(Map.Entry::getKey));  // 对容量值进行排序\n        for (Map.Entry<Integer, String> ele : res) {\n            System.out.println(ele.getValue());  // 输出原始字符串\n        }\n    }\n}",
      "python": "import sys\n\n# 读取磁盘数量\nn = int(input())\n\n# 存储处理后的磁盘容量及其原始字符串\nres = []\n\n# 处理n行磁盘容量\nfor _ in range(n):\n    capacity = input()\n    sum = 0\n    left = 0\n    right = 1\n\n    # 将磁盘容量转化为数值\n    while right < len(capacity):\n        if capacity[right] in ['M', 'G', 'T']:\n            val = int(capacity[left:right])\n            if capacity[right] == 'M':\n                sum += val  # M为基本单位\n            elif capacity[right] == 'G':\n                sum += val * 1024  # 1G = 1024M\n            elif capacity[right] == 'T':\n                sum += val * 1024 * 1024  # 1T = 1024G = 1024*1024M\n            left = right + 1  # 更新左指针\n        right += 1  # 移动右指针\n\n    # 存储容量及其原始字符串\n    res.append((sum, capacity))\n\n# 按容量排序后输出\nres.sort(key=lambda x: x[0])\nfor _, capacity in res:\n    print(capacity)",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet input = [];\nrl.on('line', function (line) {\n    input.push(line);\n    if (input.length === parseInt(input[0], 10) + 1) {\n        rl.close();\n    }\n});\n\nrl.on('close', function () {\n    const n = parseInt(input[0], 10);  // 读取磁盘数量\n    let res = [];\n\n    // 处理每一行磁盘容量\n    for (let i = 1; i <= n; i++) {\n        const capacity = input[i];\n        let sum = 0;\n        let left = 0;\n\n        // 将磁盘容量转换为数值\n        for (let right = 1; right < capacity.length; right++) {\n            if (['M', 'G', 'T'].includes(capacity[right])) {\n                const val = parseInt(capacity.slice(left, right), 10);\n                switch (capacity[right]) {\n                    case 'M':\n                        sum += val;\n                        break;\n                    case 'G':\n                        sum += val * 1024;\n                        break;\n                    case 'T':\n                        sum += val * 1024 * 1024;\n                        break;\n                }\n                left = right + 1;\n            }\n        }\n\n        // 存储容量及其原始字符串\n        res.push({ sum, capacity });\n    }\n\n    // 按容量排序后输出\n    res.sort((a, b) => a.sum - b.sum);\n    res.forEach(ele => console.log(ele.capacity));\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// 定义一个存储容量值和原始字符串的结构体\nstruct Capacity {\n    int sum;\n    string original;\n};\n\nint main() {\n    int n;\n    cin >> n;  // 读取磁盘数量\n    cin.ignore();  // 忽略换行符\n\n    vector<Capacity> res;\n\n    // 处理n行磁盘容量\n    for (int i = 0; i < n; ++i) {\n        string capacity;\n        getline(cin, capacity);\n        int sum = 0;\n        int left = 0;\n\n        // 将磁盘容量转换为数值\n        for (int right = 1; right < capacity.size(); ++right) {\n            if (capacity[right] == 'M' || capacity[right] == 'G' || capacity[right] == 'T') {\n                int val = stoi(capacity.substr(left, right - left));\n                if (capacity[right] == 'M') {\n                    sum += val;\n                } else if (capacity[right] == 'G') {\n                    sum += val * 1024;\n                } else if (capacity[right] == 'T') {\n                    sum += val * 1024 * 1024;\n                }\n                left = right + 1;\n            }\n        }\n\n        // 存储容量及其原始字符串\n        res.push_back({sum, capacity});\n    }\n\n    // 按容量排序后输出\n    sort(res.begin(), res.end(), [](const Capacity &a, const Capacity &b) {\n        return a.sum < b.sum;\n    });\n\n    for (const auto &ele : res) {\n        cout << ele.original << endl;\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LENGTH 100\n\n// 定义一个结构体存储容量值和原始字符串\ntypedef struct {\n    int sum;\n    char original[MAX_LENGTH];\n} Capacity;\n\n// 比较函数，用于qsort排序\nint compare(const void *a, const void *b) {\n    return ((Capacity *)a)->sum - ((Capacity *)b)->sum;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);  // 读取磁盘数量\n    getchar();  // 消费换行符\n\n    Capacity res[n];  // 定义结构体数组存储结果\n\n    // 处理n行磁盘容量\n    for (int i = 0; i < n; i++) {\n        char capacity[MAX_LENGTH];\n        fgets(capacity, MAX_LENGTH, stdin);\n\n        // 移除换行符\n        capacity[strcspn(capacity, \"\\n\")] = 0;\n\n        int sum = 0;\n        int left = 0;\n\n        // 将磁盘容量转换为数值\n        for (int right = 1; right < strlen(capacity); right++) {\n            if (capacity[right] == 'M' || capacity[right] == 'G' || capacity[right] == 'T') {\n                char temp[10];\n                strncpy(temp, &capacity[left], right - left);\n                temp[right - left] = '\\0';\n                int val = atoi(temp);\n                \n                if (capacity[right] == 'M') {\n                    sum += val;\n                } else if (capacity[right] == 'G') {\n                    sum += val * 1024;\n                } else if (capacity[right] == 'T') {\n                    sum += val * 1024 * 1024;\n                }\n                left = right + 1;\n            }\n        }\n\n        // 存储容量及其原始字符串\n        res[i].sum = sum;\n        strcpy(res[i].original, capacity);\n    }\n\n    // 使用qsort进行排序\n    qsort(res, n, sizeof(Capacity), compare);\n\n    // 输出排序后的结果\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", res[i].original);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "46",
    "title": "第k个排列",
    "examType": "A",
    "score": 100,
    "description": "给定参数n，从1到n会有n个整数：1,2,3,…,n,这n个数字共有n!种排列。\n按大小顺序升序列出所有排列的情况，并一一标记，\n当n=3时,所有排列如下:\n“123” “132” “213” “231” “312” “321”\n给定n和k，返回第k个排列。",
    "inputDesc": "输入两行，第一行为n，第二行为k，给定n的范围是[1,9],给定k的范围是[1,n!]。",
    "outputDesc": "输出排在第k位置的数字。",
    "examples": [],
    "solution": "理解排列的字典序：对于给定的整数 n 和 k，题目要求找到由 [1, 2, ..., n] 组成的所有排列中按字典序排列的第 k 个排列。字典序排列是将排列按数值大小进行排序。 分解问题：将排列问题分解为一系列位置选择的问题： 首先确定排列的第一个数字，然后确定剩下数字的排列。通过除以某个数字的阶乘，可以找到这一位上的数字索引，接着更新 k 值并继续进行下一位的选择。 计算阶乘：使用阶乘来计算某个位置上的数字有多少种可能性。 对于长度为 n 的数组，第一个数字确定后，剩下的 n-1 个数字有 (n-1)! 种排列方式。例如，对于 [1, 2, 3]，如果第一个数字是 1，那么剩余 [2, 3] 可以有 2! = 2 种排列。 确定每一位数字：通过计算 (k-1) / (n-1)! 来确定第一个数字的位置索引 index，然后从数字列表中删除已经选择的数字，并调整 k 为 k % (n-1)!，继续下一位的选择。 重复过程：这个过程从左到右一位一位确定，每一步都使用上述计算方法，直到所有位都确定。\n理解排列的字典序：对于给定的整数 n 和 k，题目要求找到由 [1, 2, ..., n] 组成的所有排列中按字典序排列的第 k 个排列。字典序排列是将排列按数值大小进行排序。\n分解问题：将排列问题分解为一系列位置选择的问题：\n首先确定排列的第一个数字，然后确定剩下数字的排列。通过除以某个数字的阶乘，可以找到这一位上的数字索引，接着更新 k 值并继续进行下一位的选择。\n计算阶乘：使用阶乘来计算某个位置上的数字有多少种可能性。\n对于长度为 n 的数组，第一个数字确定后，剩下的 n-1 个数字有 (n-1)! 种排列方式。例如，对于 [1, 2, 3]，如果第一个数字是 1，那么剩余 [2, 3] 可以有 2! = 2 种排列。\n确定每一位数字：通过计算 (k-1) / (n-1)! 来确定第一个数字的位置索引 index，然后从数字列表中删除已经选择的数字，并调整 k 为 k % (n-1)!，继续下一位的选择。\n重复过程：这个过程从左到右一位一位确定，每一步都使用上述计算方法，直到所有位都确定。\n以下通过一个例子详细讲解康托展开的原理：\n例子：判断数字2143在集合{1, 2, 3, 4}的全排列中是第几大的排列？\n集合{1, 2, 3, 4}共有4个元素，因此总共有 4 ! = 24 4! = 24 4!=24 种排列方式。要计算2143在这些排列中所处的具体位置，我们可以通过以下步骤进行：\n计算首位小于2的排列数： 比2小的数字只有1。剩余的三个数字有 3 ! = 6 3! = 6 3!=6 种排列方式。因此，这部分排列的数量为 1 × 3 ! = 6 1 \\times 3! = 6 1×3!=6。 计算首位为2、第二位小于1的排列数： 第二位比1小的数字不存在。因此，这部分排列的数量为 0 × 2 ! = 0 0 \\times 2! = 0 0×2!=0。 计算前两位为21、第三位小于4的排列数： 第三位比4小的数字只有3。剩余的一个数字有 1 ! = 1 1! = 1 1!=1 种排列方式。因此，这部分排列的数量为 1 × 1 ! = 1 1 \\times 1! = 1 1×1!=1。 计算前三位为214、第四位小于3的排列数： 第四位比3小的数字不存在。因此，这部分排列的数量为 0 × 0 ! = 0 0 \\times 0! = 0 0×0!=0。\n计算首位小于2的排列数：\n比2小的数字只有1。剩余的三个数字有 3 ! = 6 3! = 6 3!=6 种排列方式。因此，这部分排列的数量为 1 × 3 ! = 6 1 \\times 3! = 6 1×3!=6。\n计算首位为2、第二位小于1的排列数：\n第二位比1小的数字不存在。因此，这部分排列的数量为 0 × 2 ! = 0 0 \\times 2! = 0 0×2!=0。\n计算前两位为21、第三位小于4的排列数：\n第三位比4小的数字只有3。剩余的一个数字有 1 ! = 1 1! = 1 1!=1 种排列方式。因此，这部分排列的数量为 1 × 1 ! = 1 1 \\times 1! = 1 1×1!=1。\n计算前三位为214、第四位小于3的排列数：\n第四位比3小的数字不存在。因此，这部分排列的数量为 0 × 0 ! = 0 0 \\times 0! = 0 0×0!=0。\n将以上各部分的结果相加，即可得到2143在全排列中的位置：\n1 × 3 ! + 0 × 2 ! + 1 × 1 ! + 0 × 0 ! = 7 1 \\times 3! + 0 \\times 2! + 1 \\times 1! + 0 \\times 0! = 7 1×3!+0×2!+1×1!+0×0!=7\n所以2143是第8大的排列。\n通过上述例子，我们可以推导出康托展开的通用公式：\nX = a [ n ] × ( n − 1 ) ! + a [ n − 1 ] × ( n − 2 ) ! + ⋯ + a [ i ] × ( i − 1 ) ! + ⋯ + a [ 2 ] × 1 ! + a [ 1 ] × 0 ! X = a[n] \\times (n-1)! + a[n-1] \\times (n-2)! + \\dots + a[i] \\times (i-1)! + \\dots + a[2] \\times 1! + a[1] \\times 0! X=a[n]×(n−1)!+a[n−1]×(n−2)!+⋯+a[i]×(i−1)!+⋯+a[2]×1!+a[1]×0!\n其中， a [ i ] a[i] a[i]表示原数第 i i i 位在当前未出现的元素中排在第几位（从0开始计数），并且满足 0 ≤ a [ i ] < i 0 \\leq a[i] < i 0≤a[i]<i（ 1 ≤ i ≤ n 1 \\leq i \\leq n 1≤i≤n）。\n康托展开的逆过程称为康托逆展开，即对于某个集合的全排列，输入一个数字 k k k，返回对应的第 k k k 大排列。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int n, k;\n        Vector<String> lines = new Vector<String>();\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取 n 和 k\n        n = scanner.nextInt();\n        k = scanner.nextInt();\n\n        // 如果 n 等于 1，则直接输出 1 并结束程序\n        if (n == 1) {\n            System.out.println(\"1\");\n            return;\n        }\n\n        // 初始化 nums 数组，存储 1 到 n 的整数\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = i + 1;\n        }\n\n        // 初始化结果列表\n        List<String> result = new ArrayList<>();\n\n        // 递归函数，用于生成所有排列\n        generatePermutations(nums, \"\", result, k);\n\n        // 对结果列表进行排序\n        Collections.sort(result);\n\n        // 输出第k个排列\n        System.out.println(result.get(k - 1));\n    }\n\n    public static void generatePermutations(int[] nums, String current, List<String> result, int k) {\n        // 如果数字数组为空，将当前结果添加到结果列表中\n        if (nums.length == 0) {\n            result.add(current);\n            return;\n        }\n\n        // 遍历当前数字数组\n        for (int i = 0; i < nums.length; i++) {\n            // 取出一个数字\n            int num = nums[i];\n\n            // 创建新的数字数组，删除当前数字\n            int[] newNums = new int[nums.length - 1];\n            for (int j = 0; j < i; j++) {\n                newNums[j] = nums[j];\n            }\n            for (int j = i + 1; j < nums.length; j++) {\n                newNums[j - 1] = nums[j];\n            }\n\n            // 递归调用函数，传递更新后的数字数组和结果字符串\n            generatePermutations(newNums, current + num, result, k);\n\n            // 如果结果列表长度等于k，直接返回\n            if (result.size() == k) {\n                return;\n            }\n        }\n    }\n}",
      "python": "n = int(input())\nk = int(input())\n\n\nif n == 1:\n    print(\"1\")\n    exit()\n\nnums = [i+1 for i in range(n)]\nresult = []\n\ndef generatePermutations(nums, current, result, k):\n    if len(nums) == 0:\n        result.append(current)\n        return\n\n    for i in range(len(nums)):\n        num = nums[i]\n        newNums = nums[:i] + nums[i+1:]\n        generatePermutations(newNums, current + str(num), result, k)\n\n        if len(result) == k:\n            return\n\ngeneratePermutations(nums, \"\", result, k)\n\nresult.sort()\nprint(result[k-1])",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (n) => {\n  rl.on('line', (k) => {\n    // 如果 n 等于 1，则直接输出 1 并结束程序\n    if (n == 1) {\n      console.log(\"1\");\n      rl.close();\n      return;\n    }\n\n    // 初始化 nums 数组，存储 1 到 n 的整数\n    let nums = [];\n    for (let i = 0; i < n; i++) {\n      nums.push(i + 1);\n    }\n\n    // 初始化结果列表\n    let result = [];\n\n    // 递归函数，用于生成所有排列\n    generatePermutations(nums, \"\", result, k);\n\n    // 对结果列表进行排序\n    result.sort();\n\n    // 输出第k个排列\n    console.log(result[k - 1]);\n\n    rl.close();\n  });\n});\n\nfunction generatePermutations(nums, current, result, k) {\n  // 如果数字数组为空，将当前结果添加到结果列表中\n  if (nums.length === 0) {\n    result.push(current);\n    return;\n  }\n\n  // 遍历当前数字数组\n  for (let i = 0; i < nums.length; i++) {\n    // 取出一个数字\n    let num = nums[i];\n\n    // 创建新的数字数组，删除当前数字\n    let newNums = nums.slice(0, i).concat(nums.slice(i + 1));\n\n    // 递归调用函数，传递更新后的数字数组和结果字符串\n    generatePermutations(newNums, current + num, result, k);\n\n    // 如果结果列表长度等于k，直接返回\n    if (result.length === k) {\n      return;\n    }\n  }\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid generatePermutations(vector<int>& nums, string current, vector<string>& result, int k);\n\nint main() {\n    int n, k;\n    vector<string> lines;\n    cin >> n >> k;\n\n    if (n == 1) {\n        cout << \"1\" << endl;\n        return 0;\n    }\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        nums[i] = i + 1;\n    }\n\n    vector<string> result;\n    generatePermutations(nums, \"\", result, k);\n\n    sort(result.begin(), result.end());\n\n    cout << result[k - 1] << endl;\n\n    return 0;\n}\n\nvoid generatePermutations(vector<int>& nums, string current, vector<string>& result, int k) {\n    if (nums.empty()) {\n        result.push_back(current);\n        return;\n    }\n\n    for (int i = 0; i < nums.size(); i++) {\n        int num = nums[i];\n        vector<int> newNums(nums.size() - 1);\n        copy(nums.begin(), nums.begin() + i, newNums.begin());\n        copy(nums.begin() + i + 1, nums.end(), newNums.begin() + i);\n\n        generatePermutations(newNums, current + to_string(num), result, k);\n\n        if (result.size() == k) {\n            return;\n        }\n    }\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 生成排列的递归函数\nvoid generatePermutations(int* nums, int numsSize, char* current, char** result, int* resultSize, int k) {\n    // 如果数字数组为空，将当前结果添加到结果列表中\n    if (numsSize == 0) {\n        result[*resultSize] = (char*)malloc(strlen(current) + 1);\n        strcpy(result[*resultSize], current);\n        (*resultSize)++;\n        return;\n    }\n\n    // 遍历当前数字数组\n    for (int i = 0; i < numsSize; i++) {\n        // 取出一个数字\n        int num = nums[i];\n\n        // 创建新的数字数组，删除当前数字\n        int* newNums = (int*)malloc((numsSize - 1) * sizeof(int));\n        for (int j = 0; j < i; j++) {\n            newNums[j] = nums[j];\n        }\n        for (int j = i + 1; j < numsSize; j++) {\n            newNums[j - 1] = nums[j];\n        }\n\n        // 更新结果字符串\n        int newCurrentLen = strlen(current) + 10; // 分配足够大的空间\n        char *newCurrent = (char*)malloc(newCurrentLen * sizeof(char));\n        snprintf(newCurrent, newCurrentLen, \"%s%d\", current, num);\n\n        // 递归调用函数，传递更新后的数字数组和结果字符串\n        generatePermutations(newNums, numsSize - 1, newCurrent, result, resultSize, k);\n\n        // 如果结果列表长度等于k，直接返回\n        if (*resultSize == k) {\n            free(newNums);\n            free(newCurrent); // 避免内存泄漏\n            return;\n        }\n\n        // 释放内存\n        free(newNums);\n        free(newCurrent); // 每次循环后释放newCurrent\n    }\n}\n\nint compareStrings(const void* a, const void* b) {\n    return strcmp(*(const char**)a, *(const char**)b);\n}\n\nint main() {\n    int n, k;\n\n    // 读取 n 和 k\n    scanf(\"%d %d\", &n, &k);\n\n    // 如果 n 等于 1，则直接输出 1 并结束程序\n    if (n == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    // 初始化 nums 数组，存储 1 到 n 的整数\n    int* nums = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        nums[i] = i + 1;\n    }\n\n    // 初始化结果列表\n    char** result = (char**)malloc(100000000 * sizeof(char*));   \n    int resultSize = 0;\n\n    // 调用递归函数生成所有排列\n    char current[100] = \"\";  // 初始的结果字符串为空\n    generatePermutations(nums, n, current, result, &resultSize, k);\n\n    // 对结果列表进行排序\n    qsort(result, resultSize, sizeof(char*), compareStrings);\n\n    // 输出第 k 个排列\n    printf(\"%s\\n\", result[k - 1]);\n\n    // 释放内存\n    for (int i = 0; i < resultSize; i++) {\n        free(result[i]);\n    }\n    free(result);\n    free(nums);\n\n    return 0;\n}"
    }
  },
  {
    "id": "47",
    "title": "简单的自动曝光平均像素值",
    "examType": "A",
    "score": 100,
    "description": "一个图像有n个像素点，存储在一个长度为n的数组img里，每个像素点的取值范围[0,255]的正整数。\n请你给图像每个像素点值加上一个整数k（可以是负数），得到新图newImg，使得新图newImg的所有像素平均值最接近中位值128。\n请输出这个整数k。",
    "inputDesc": "n个整数，中间用空格分开\n• 1 <= n <= 100 • 如有多个整数k都满足，输出小的那个k； • 新图的像素值会自动截取到[0,255]范围。当新像素值<0，其值会更改为0；当新像素值>255，其值会更改为255；\n例如newImg=”-1 -2 256″,会自动更改为”0 0 255″",
    "outputDesc": "一个整数k",
    "examples": [
      {
        "input": "130 129 130",
        "output": "-2",
        "explanation": "-1的均值128.5，-2的均值为127.5，输出较小的数-2"
      },
      {
        "input": "0 0 0",
        "output": "",
        "explanation": "四个像素值都为0"
      }
    ],
    "solution": "本题的解题思路是通过枚举每一个可能的 k值，计算新图像的每个像素点的值，并找出使得新图像的平均值与中位值 128 的差的绝对值最小的 k 值。\n具体实现步骤如下：\n枚举每一个可能的 k k k 值： 计算新图像的每个像素点的值。将这些像素点的值累加起来，得到新图像的所有像素点值的和 sum。 计算平均值和差的绝对值： 计算新图像的平均值 sum / len。计算新图像的平均值与中位值 128 之间的差的绝对值 diff。 更新最优解： 如果 diff 小于 min_diff，更新 min_diff 为当前的 diff，并更新 k_ans 为当前的 k 值。如果 diff 等于 min_diff 且 k_ans 不等于 0，则更新 k_ans 为 k 和 k_ans 中的较小值。\n枚举每一个可能的 k k k 值：\n计算新图像的每个像素点的值。将这些像素点的值累加起来，得到新图像的所有像素点值的和 sum。\n计算平均值和差的绝对值：\n计算新图像的平均值 sum / len。计算新图像的平均值与中位值 128 之间的差的绝对值 diff。\n更新最优解：\n如果 diff 小于 min_diff，更新 min_diff 为当前的 diff，并更新 k_ans 为当前的 k 值。如果 diff 等于 min_diff 且 k_ans 不等于 0，则更新 k_ans 为 k 和 k_ans 中的较小值。\n对于每一个像素点的新值，需要确保其在 [0, 255] 的范围内：\n如果新值小于 0，则将其设为 0。如果新值大于 255，则将其设为 255。如果有多个整数 k 满足条件，输出较小的那个 k。",
    "codes": {
      "java": "import java.util.Scanner; // 导入Scanner类\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in); // 创建Scanner对象\n        String input_str = sc.nextLine(); // 读取一行输入\n        Scanner ss = new Scanner(input_str); // 将输入转换为Scanner对象\n        int val, len = 0;\n        int[] img = new int[110];\n        while (ss.hasNextInt()) { // 判断Scanner对象中是否还有整数\n            val = ss.nextInt(); // 读取下一个整数\n            img[len++] = val;\n        }\n        double min_diff = Integer.MAX_VALUE; // 定义双精度浮点型变量min_diff，并初始化为整型最大值\n        int k_ans = 0; // 定义整型变量k_ans，并初始化为0\n\n        for (int k = -127; k <= 128; k++) { // 循环k的值从-127到128\n            double sum = 0; // 定义双精度浮点型变量sum，并初始化为0\n            for (int i = 0; i < len; i++) { // 循环i的值从0到len-1\n                int new_val = img[i] + k; // 定义整型变量new_val，值为img[i]+k\n                new_val = Math.max(0, Math.min(new_val, 255)); // 将new_val的值限制在0到255之间\n                sum += new_val; // 将new_val的值加入sum中\n            }\n\n            double diff = Math.abs(sum / len - 128); // 计算sum/len-128的绝对值\n\n            if (diff < min_diff) { // 如果diff小于min_diff\n                min_diff = diff; // 将min_diff的值更新为diff\n                k_ans = k; // 将k_ans的值更新为k\n            } else if (diff == min_diff && k_ans != 0) { // 如果diff等于min_diff且k_ans不等于0\n                k_ans = Math.min(k_ans, k); // 将k_ans的值更新为k和k_ans中的最小值\n            }\n        }\n\n        System.out.println(k_ans); // 输出k_ans的值，并换行\n    }\n}",
      "python": "import sys\ninput_str = sys.stdin.readline().strip()\nimg = list(map(int, input_str.split()))\nlen = len(img)\nmin_diff = sys.maxsize\nk_ans = 0\n\nfor k in range(-127, 129):\n    sum = 0\n    for i in range(len):\n        new_val = img[i] + k\n        new_val = max(0, min(new_val, 255))\n        sum += new_val\n    diff = abs(sum / len - 128)\n    if diff < min_diff:\n        min_diff = diff\n        k_ans = k\n    elif diff == min_diff and k_ans != 0:\n        k_ans = min(k_ans, k)\n\nprint(k_ans)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet input_str = '';\n\n// 监听输入，将输入存入input_str中\nrl.on('line', (line) => {\n  input_str += line + ' ';\n}).on('close', () => {\n  const img = [];\n  const input_arr = input_str.trim().split(' ');\n  const len = input_arr.length;\n\n  // 将输入的字符串转为数字并存入数组img中\n  for (let i = 0; i < len; i++) {\n    img.push(parseInt(input_arr[i]));\n  }\n\n  // 初始化最小差值和答案k\n  let min_diff = Number.MAX_SAFE_INTEGER;\n  let k_ans = 0;\n\n  // 枚举k的取值范围\n  for (let k = -127; k <= 128; k++) {\n    let sum = 0;\n\n    // 计算新图的所有像素点的值之和\n    for (let i = 0; i < len; i++) {\n      let new_val = img[i] + k;\n      // 将新像素值截取到[0,255]范围\n      new_val = Math.max(0, Math.min(new_val, 255));\n      sum += new_val;\n    }\n\n    // 计算新图的所有像素点的平均值与中位值128的差值\n    const diff = Math.abs(sum / len - 128);\n\n    // 更新最小差值和答案k\n    if (diff < min_diff) {\n      min_diff = diff;\n      k_ans = k;\n    } else if (diff === min_diff && k_ans !== 0) {\n      k_ans = Math.min(k_ans, k);\n    }\n  }\n\n  // 输出答案k\n  console.log(k_ans);\n});",
      "cpp": "#include <iostream> // 标准输入输出流\n#include <algorithm> \n#include <string> \n#include <sstream> \n#include <cmath> \n#include <climits> \n\nusing namespace std;\n\nint main() {\n    string input_str; \n    getline(cin, input_str); \n    stringstream ss(input_str); \n    int val, len = 0; \n    int img[110]; \n    while (ss >> val) {\n        img[len++] = val; \n    }\n    double min_diff = INT_MAX; // 定义双精度浮点型变量min_diff，并初始化为整型最大值\n    int k_ans = 0; // 定义整型变量k_ans，并初始化为0\n\n    for (int k = -127; k <= 128; k++) { // 循环k的值从-127到128\n        double sum = 0; // 定义双精度浮点型变量sum，并初始化为0\n        for (int i = 0; i < len; i++) { // 循环i的值从0到len-1\n            int new_val = img[i] + k; // 定义整型变量new_val，值为img[i]+k\n            new_val = max(0, min(new_val, 255)); // 将new_val的值限制在0到255之间\n            sum += new_val; // 将new_val的值加入sum中\n        }\n\n        double diff = abs(sum / len - 128); // 计算sum/len-128的绝对值\n\n        if (diff < min_diff) { // 如果diff小于min_diff\n            min_diff = diff; // 将min_diff的值更新为diff\n            k_ans = k; // 将k_ans的值更新为k\n        }\n        else if (diff == min_diff && k_ans != 0) { // 如果diff等于min_diff且k_ans不等于0\n            k_ans = min(k_ans, k); // 将k_ans的值更新为k和k_ans中的最小值\n        }\n    }\n\n    cout << k_ans << endl; // 输出k_ans的值，并换行\n\n    return 0; // 返回0，表示程序正常结束\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <math.h>\n\nint main() {\n    char input_str[1000]; // 定义字符数组用于存储输入的字符串\n    fgets(input_str, 1000, stdin); // 读取一行输入并存储在input_str中\n\n    int val, len = 0; // 定义整型变量val和len，len用于记录数组长度\n    int img[110]; // 定义整型数组img，用于存储输入的像素值\n\n    // 用于解析输入字符串中的整数\n    char *token = strtok(input_str, \" \");\n    while (token != NULL) { // 当token不为NULL时继续循环\n        val = atoi(token); // 将token转换为整数\n        img[len++] = val; // 将整数存入数组img中，并增加数组长度len\n        token = strtok(NULL, \" \"); // 获取下一个token\n    }\n\n    double min_diff = INT_MAX; // 定义双精度浮点型变量min_diff，并初始化为整型最大值\n    int k_ans = 0; // 定义整型变量k_ans，并初始化为0\n\n    // 枚举k值从-127到128\n    for (int k = -127; k <= 128; k++) {\n        double sum = 0; // 定义双精度浮点型变量sum，并初始化为0\n\n        // 遍历img数组中的每一个像素值\n        for (int i = 0; i < len; i++) {\n            int new_val = img[i] + k; // 定义整型变量new_val，值为img[i]+k\n\n            // 将new_val的值限制在0到255之间\n            if (new_val < 0) {\n                new_val = 0; // 如果new_val小于0，则将new_val设为0\n            } else if (new_val > 255) {\n                new_val = 255; // 如果new_val大于255，则将new_val设为255\n            }\n\n            sum += new_val; // 将new_val的值加入sum中\n        }\n\n        // 计算新图像的平均值与中位值128的差的绝对值\n        double diff = fabs(sum / len - 128);\n\n        // 如果当前diff小于min_diff，更新min_diff和k_ans\n        if (diff < min_diff) {\n            min_diff = diff;\n            k_ans = k;\n        } \n        // 如果当前diff等于min_diff且k_ans不等于0，更新k_ans为k和k_ans中的较小值\n        else if (diff == min_diff && k_ans != 0) {\n            k_ans = (k_ans < k) ? k_ans : k;\n        }\n    }\n\n    // 输出最终的k_ans值\n    printf(\"%d\\n\", k_ans);\n\n    return 0;\n}"
    }
  },
  {
    "id": "48",
    "title": "简易压缩算法一种字符串压缩表示的解压",
    "examType": "A",
    "score": 100,
    "description": "有一种简易压缩算法：针对全部为小写英文字母组成的字符串， 将其中连续超过两个相同字母的部分压缩为连续个数加该字母 其他部分保持原样不变.\n例如字符串aaabbccccd 经过压缩变成字符串 3abb4cd\n请您编写解压函数,根据输入的字符串,判断其是否为合法压缩过的字符串\n若输入合法则输出解压缩后的字符串否则输出字符串!error来报告错误",
    "inputDesc": "输入一行，为一个 ASCII 字符串\n长度不超过100字符\n用例保证输出的字符串长度也不会超过100字符串",
    "outputDesc": "若判断输入为合法的经过压缩后的字符串\n则输出压缩前的字符串\n若输入不合法 则输出字符串!error",
    "examples": [
      {
        "input": "dff",
        "output": "ddddff",
        "explanation": "4d 扩展为 4 个 d ，故解压后的字符串为 ddddff"
      },
      {
        "input": "dff",
        "output": "!error",
        "explanation": "2 个 d 不需要压缩 故输入不合法"
      },
      {
        "input": "d@A",
        "output": "!error",
        "explanation": "全部由小写英文字母做成的字符串，压缩后不会出现特殊字符@和大写字母 A 故输入不合法"
      }
    ],
    "solution": "题目要求我们编写一个函数来判断一个字符串是否是经过合法压缩后的字符串，并且能够解压缩这个字符串。如果字符串不合法，则返回!error。\n连续超过两个相同的字母，将它们压缩为数字 + 字母的形式。例如，aaa压缩为3a，cccc压缩为4c。字符串中的其他部分保持原样。\n字符串中只允许包含小写字母和数字，不允许出现其他字符。数字必须大于2，因为两个或更少个相同字母不应该压缩。数字后面必须跟随一个小写字母，且该数字应扩展为对应数量的字母。",
    "codes": {
      "java": "import java.util.Scanner;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // 读取输入字符串\n        String s = scanner.nextLine();\n        \n        // 定义匹配非法字符的正则表达式（非数字和小写字母的字符）\n        String pat = \"[^0-9a-z]\";\n        \n        // 用于存储数字部分的字符串\n        String num = \"\";\n        \n        // 用于存储最终解压缩的结果\n        String res = \"\";\n        \n        // 编译正则表达式\n        Pattern pattern = Pattern.compile(pat);\n        Matcher matcher = pattern.matcher(s);\n        \n        // 如果找到非法字符，则直接输出 \"!error\"\n        if (matcher.find()) {\n            res = \"!error\";\n        } else {\n            // 遍历输入字符串的每一个字符\n            for (int i = 0; i < s.length(); i++) {\n                char c = s.charAt(i);\n                \n                // 如果当前字符是数字，则将其追加到 num 中\n                if (Character.isDigit(c)) {\n                    num += c;\n                } \n                // 如果 num 不为空，表示之前有数字，需要进行解压操作\n                else if (!num.equals(\"\")) {\n                    // 判断数字是否小于等于2，如果是则输入不合法\n                    if (Integer.parseInt(num) <= 2) {\n                        res = \"!error\";\n                        break;\n                    } else {\n                        // 将对应数量的字母添加到结果中\n                        for (int j = 0; j < Integer.parseInt(num); j++) {\n                            res += c;\n                        }\n                        // 重置 num 为空\n                        num = \"\";\n                    }\n                } \n                // 如果当前字符是字母，且前面没有数字，则直接添加到结果中\n                else {\n                    res += c;\n                }\n            }\n        }\n        \n        // 输出最终结果\n        System.out.println(res);\n    }\n}",
      "python": "import re\n\n# 读取输入字符串\ns = input()\n\n# 定义匹配非法字符的正则表达式（非数字和小写字母的字符）\npat = \"[^0-9a-z]\"\n\n# 用于存储数字部分的字符串\nnum = \"\"\n\n# 用于存储最终解压缩的结果\nres = \"\"\n\n# 编译正则表达式并查找非法字符\npattern = re.compile(pat)\nmatcher = pattern.search(s)\n\n# 如果找到非法字符，则直接输出 \"!error\"\nif matcher:\n    res = \"!error\"\nelse:\n    # 遍历输入字符串的每一个字符\n    for i in range(len(s)):\n        c = s[i]\n        \n        # 如果当前字符是数字，则将其追加到 num 中\n        if c.isdigit():\n            num += c\n        # 如果 num 不为空，表示之前有数字，需要进行解压操作\n        elif num != \"\":\n            # 判断数字是否小于等于2，如果是则输入不合法\n            if int(num) <= 2:\n                res = \"!error\"\n                break\n            else:\n                # 将对应数量的字母添加到结果中\n                for j in range(int(num)):\n                    res += c\n                # 重置 num 为空\n                num = \"\"\n        # 如果当前字符是字母，且前面没有数字，则直接添加到结果中\n        else:\n            res += c\n\n# 输出最终结果\nprint(res)",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (s) => {\n  // 定义匹配非法字符的正则表达式（非数字和小写字母的字符）\n  const pat = '[^0-9a-z]';\n  \n  // 用于存储数字部分的字符串\n  let num = \"\";\n  \n  // 用于存储最终解压缩的结果\n  let res = \"\";\n\n  // 如果字符串包含非法字符，则输出 \"!error\"\n  if (s.match(pat) !== null) {\n    res = \"!error\";\n  } else {\n    // 遍历输入字符串的每一个字符\n    for (let i = 0; i < s.length; i++) {\n      const c = s[i];\n      \n      // 如果当前字符是数字，则将其追加到 num 中\n      if (c.match(/[0-9]/)) {\n        num += c;\n      } \n      // 如果 num 不为空，表示之前有数字，需要进行解压操作\n      else if (num !== \"\") {\n        // 判断数字是否小于等于2，如果是则输入不合法\n        if (parseInt(num) <= 2) {\n          res = \"!error\";\n          break;\n        } else {\n          // 将对应数量的字母添加到结果中\n          res += c.repeat(parseInt(num));\n          // 重置 num 为空\n          num = \"\";\n        }\n      } \n      // 如果当前字符是字母，且前面没有数字，则直接添加到结果中\n      else {\n        res += c;\n      }\n    }\n  }\n  \n  // 输出最终结果\n  console.log(res);\n  rl.close();\n});",
      "cpp": "#include <iostream>\n#include <regex>\nusing namespace std;\n\nint main() {\n    // 读取输入字符串\n    string s;\n    cin >> s;\n\n    // 定义匹配非法字符的正则表达式（非数字和小写字母的字符）\n    string pat = \"[^0-9a-z]\";\n    \n    // 用于存储数字部分的字符串\n    string num = \"\";\n    \n    // 用于存储最终解压缩的结果\n    string res = \"\";\n    \n    // 如果字符串包含非法字符，则输出 \"!error\"\n    if (regex_search(s, regex(pat))) {\n        res = \"!error\";\n    } else {\n        // 遍历输入字符串的每一个字符\n        for (char c : s) {\n            // 如果当前字符是数字，则将其追加到 num 中\n            if (isdigit(c)) {\n                num += c;\n            } \n            // 如果 num 不为空，表示之前有数字，需要进行解压操作\n            else if (num != \"\") {\n                // 判断数字是否小于等于2，如果是则输入不合法\n                if (stoi(num) <= 2) {\n                    res = \"!error\";\n                    break;\n                } else {\n                    // 将对应数量的字母添加到结果中\n                    res += string(stoi(num), c);\n                    // 重置 num 为空\n                    num = \"\";\n                }\n            } \n            // 如果当前字符是字母，且前面没有数字，则直接添加到结果中\n            else {\n                res += c;\n            }\n        }\n    }\n\n    // 输出最终结果\n    cout << res << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n// 定义一个函数，用于检查字符串中是否包含非法字符\nbool contains_invalid_characters(const char *s) {\n    while (*s) {\n        // 如果字符不是数字或小写字母，则认为是非法字符\n        if (!isdigit(*s) && !islower(*s)) {\n            return true;\n        }\n        s++;\n    }\n    return false;\n}\n\nint main() {\n    // 定义存储输入字符串的数组\n    char s[1000];\n    \n    // 读取输入字符串\n    scanf(\"%s\", s);\n\n    // 用于存储数字部分的字符串\n    char num[100] = \"\";\n    \n    // 用于存储最终解压缩的结果\n    char res[1000] = \"\";\n    \n    // 如果字符串包含非法字符，则输出 \"!error\"\n    if (contains_invalid_characters(s)) {\n        strcpy(res, \"!error\");\n    } else {\n        // 遍历输入字符串的每一个字符\n        for (int i = 0; s[i] != '\\0'; i++) {\n            char c = s[i];\n            \n            // 如果当前字符是数字，则将其追加到 num 中\n            if (isdigit(c)) {\n                strncat(num, &c, 1);\n            } \n            // 如果 num 不为空，表示之前有数字，需要进行解压操作\n            else if (strlen(num) > 0) {\n                // 判断数字是否小于等于2，如果是则输入不合法\n                int repeat_count = atoi(num);\n                if (repeat_count <= 2) {\n                    strcpy(res, \"!error\");\n                    break;\n                } else {\n                    // 将对应数量的字母添加到结果中\n                    for (int j = 0; j < repeat_count; j++) {\n                        strncat(res, &c, 1);\n                    }\n                    // 重置 num 为空\n                    num[0] = '\\0';\n                }\n            } \n            // 如果当前字符是字母，且前面没有数字，则直接添加到结果中\n            else {\n                strncat(res, &c, 1);\n            }\n        }\n    }\n\n    // 输出最终结果\n    printf(\"%s\\n\", res);\n    return 0;\n}"
    }
  },
  {
    "id": "49",
    "title": "素数之积RSA加密算法",
    "examType": "A",
    "score": 100,
    "description": "RSA加密算法在网络安全世界中无处不在，它利用了极大整数因数分解的困难度，数据越大，安全系数越高，给定一个32位正整数，请对其进行因数分解，找出是哪两个素数的乘积。",
    "inputDesc": "一个正整数num，0 < num <= 2147483647",
    "outputDesc": "如果成功找到，以单个空格分割，从小到大输出两个素数，分解失败，请输出-1, -1",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static boolean isPrime(int num) {\n        if (num <= 3) {\n            return num > 1;\n        }\n        if (num % 6 != 1 && num % 6 != 5) {\n            return false;\n        }\n        for (int i = 5; i <= Math.sqrt(num); i += 6) {\n            if (num % i == 0 || num % (i + 2) == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int num = scanner.nextInt();\n        // 如果输入的数本身就是素数，无法进行因数分解\n        if (isPrime(num)) {\n            System.out.println(\"-1 -1\");\n            return;\n        }\n        // 因数分解\n        for (int i = 2; i <= Math.sqrt(num); i++) {\n            if (num % i == 0) {\n                int j = num / i;\n                // 判断 i 和 j 是否都是素数\n                if (isPrime(i) && isPrime(j)) {\n                    System.out.println(i < j ? i + \" \" + j : j + \" \" + i);\n                    return;\n                }\n            }\n        }\n        System.out.println(\"-1 -1\");\n    }\n}",
      "python": "import math\n\n# 函数：检查一个数是否为素数\ndef is_prime(num):\n    if num <= 3:\n        return num > 1\n    if num % 6 != 1 and num % 6 != 5:\n        return False\n    for i in range(5, int(math.sqrt(num)) + 1, 6):\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n    return True\n\nnum = int(input())\n\n# 如果数字本身就是素数，那么它不能被分解\nif is_prime(num):\n    print(\"-1 -1\")\nelse:\n    # 分解数字\n    for i in range(2, int(math.sqrt(num)) + 1):\n        if num % i == 0:\n            j = num // i\n            # 检查 i 和 j 是否都是素数\n            if is_prime(i) and is_prime(j):\n                print(f\"{min(i, j)} {max(i, j)}\")\n                break\n    else:\n        print(\"-1 -1\")",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <cmath>\n\n// 函数：检查一个数是否为素数\nbool isPrime(int num) {\n    if (num <= 3) {\n        return num > 1;\n    }\n    if (num % 6 != 1 && num % 6 != 5) {\n        return false;\n    }\n    for (int i = 5; i <= sqrt(num); i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int num;\n    std::cin >> num; // 读取输入\n\n    // 如果数字本身就是素数，那么它不能被分解\n    if (isPrime(num)) {\n        std::cout << \"-1 -1\" << std::endl;\n        return 0;\n    }\n\n    // 分解数字\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) {\n            int j = num / i;\n            // 检查 i 和 j 是否都是素数\n            if (isPrime(i) && isPrime(j)) {\n                std::cout << (i < j ? std::to_string(i) + \" \" + std::to_string(j) : std::to_string(j) + \" \" + std::to_string(i)) << std::endl;\n                return 0;\n            }\n        }\n    }\n    std::cout << \"-1 -1\" << std::endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <math.h>\n\n// 函数：检查一个数是否为素数\nint isPrime(int num) {\n    if (num <= 3) {\n        return num > 1;\n    }\n    if (num % 6 != 1 && num % 6 != 5) {\n        return 0;\n    }\n    for (int i = 5; i <= sqrt(num); i += 6) {\n        if (num % i == 0 || num % (i + 2) == 0) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int num;\n    scanf(\"%d\", &num); // 读取输入\n\n    // 如果数字本身就是素数，那么它不能被分解\n    if (isPrime(num)) {\n        printf(\"-1 -1\\n\");\n        return 0;\n    }\n\n    // 分解数字\n    for (int i = 2; i <= sqrt(num); i++) {\n        if (num % i == 0) {\n            int j = num / i;\n            // 检查 i 和 j 是否都是素数\n            if (isPrime(i) && isPrime(j)) {\n                printf(\"%d %d\\n\", i < j ? i : j, i < j ? j : i);\n                return 0;\n            }\n        }\n    }\n    printf(\"-1 -1\\n\");\n    return 0;\n}"
    }
  },
  {
    "id": "50",
    "title": "考勤信息",
    "examType": "A",
    "score": 100,
    "description": "公司用一个字符串来表示员工的出勤信息\nabsent：缺勤late：迟到leaveearly：早退present：正常上班\n现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下：\n缺勤不超过一次；没有连续的迟到/早退；任意连续7次考勤，缺勤/迟到/早退不超过3次。",
    "inputDesc": "用户的考勤数据字符串\n记录条数 >= 1；输入字符串长度 < 10000；不存在非法输入；\n如：\n2 present present absent present present leaveearly present absent",
    "outputDesc": "根据考勤数据字符串，如果能得到考勤奖，输出”true”；否则输出”false”， 对于输入示例的结果应为：\ntrue false",
    "examples": [
      {
        "input": "present\npresent present",
        "output": "true true",
        "explanation": "无"
      },
      {
        "input": "present\npresent absent present present leaveearly present absent",
        "output": "true false",
        "explanation": ""
      }
    ],
    "solution": "这个题目要求我们根据员工的出勤信息字符串来判断员工是否可以获得出勤奖。根据题目的描述，有三个条件来判断员工是否能够获得出勤奖。、\n员工要获得出勤奖，必须满足以下三个条件：\n缺勤不超过一次：即字符串中 absent 出现的次数不能超过1次。没有连续的迟到/早退：即字符串中不能有 late 和 leaveearly 这两种情况连续出现。任意连续7次考勤中，缺勤/迟到/早退不超过3次：在任何7次连续考勤记录中，absent、late 和 leaveearly 的总次数不能超过3次。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建Scanner对象读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取测试用例数量\n        int testCases = Integer.parseInt(scanner.nextLine().trim());\n        // 使用StringBuilder来构建所有测试用例的输出结果\n        StringBuilder results = new StringBuilder();\n        // 遍历处理每个测试用例\n        while (testCases-- > 0) {\n            // 读取并分割每个测试用例的考勤记录\n            String[] attendanceRecords = scanner.nextLine().trim().split(\" \");\n            // 判断是否能获得考勤奖，并追加结果到results\n            results.append(canReceiveAward(attendanceRecords) ? \"true\" : \"false\");\n            // 如果还有剩余测试用例，追加一个空格分隔\n            if (testCases > 0) {\n                results.append(\" \");\n            }\n        }\n        // 输出所有测试用例的结果\n        System.out.println(results.toString());\n        // 关闭Scanner\n        scanner.close();\n    }\n\n    // 判断是否能获得考勤奖的方法\n    private static boolean canReceiveAward(String[] records) {\n        // 缺勤次数计数器\n        int absentCount = 0;\n        // 遍历考勤记录\n        for (int i = 0; i < records.length; i++) {\n            // 如果记录为缺勤，增加缺勤计数\n            if (\"absent\".equals(records[i])) {\n                absentCount++;\n                // 如果缺勤超过1次，返回false\n                if (absentCount > 1) return false;\n            }\n            // 如果记录为迟到或早退，且前一天也是迟到或早退，返回false\n            if (\"late\".equals(records[i]) || \"leaveearly\".equals(records[i])) {\n                if (i > 0 && (\"late\".equals(records[i - 1]) || \"leaveearly\".equals(records[i - 1]))) {\n                    return false;\n                }\n            }\n            // 检查任意连续7天的考勤记录\n            if (i >= 6) {\n                int countIn7Days = 0;\n                // 计算连续7天内非正常上班的天数\n                for (int j = i - 6; j <= i; j++) {\n                    if (!\"present\".equals(records[j])) {\n                        countIn7Days++;\n                    }\n                }\n                // 如果连续7天内非正常上班超过3天，返回false\n                if (countIn7Days > 3) return false;\n            }\n        }\n        // 如果所有条件都满足，返回true\n        return true;\n    }\n}",
      "python": "def can_receive_award(records):\n    absent_count = 0  # 用于记录缺勤的次数\n    for i in range(len(records)):  # 遍历考勤记录\n        if records[i] == \"absent\":  # 如果记录为缺勤\n            absent_count += 1  # 缺勤次数加1\n            if absent_count > 1:  # 如果缺勤超过1次\n                return False  # 返回False，表示不能获得考勤奖\n        if records[i] in [\"late\", \"leaveearly\"]:  # 如果记录为迟到或早退\n            # 如果前一天也是迟到或早退，则不能获得考勤奖\n            if i > 0 and records[i - 1] in [\"late\", \"leaveearly\"]:\n                return False\n        if i >= 6:  # 如果记录长度大于等于7，检查任意连续7天的考勤记录\n            # 计算连续7天内非出勤的天数\n            count_in_7_days = sum(1 for j in range(i - 6, i + 1) if records[j] != \"present\")\n            if count_in_7_days > 3:  # 如果连续7天内非出勤天数超过3天\n                return False  # 返回False，表示不能获得考勤奖\n    return True  # 所有条件都满足，返回True，表示可以获得考勤奖\n\n# 读取测试用例的数量\ntest_cases = int(input().strip())\nresults = []  # 用于存储每个测试用例的结果\nfor _ in range(test_cases):  # 遍历每个测试用例\n    # 读取并分割每个测试用例的考勤记录\n    attendance_records = input().strip().split()\n    # 判断是否能获得考勤奖，并将结果添加到results列表中\n    results.append(\"true\" if can_receive_award(attendance_records) else \"false\")\n# 输出所有测试用例的结果，结果之间用空格分隔\nprint(\" \".join(results))",
      "javascript": "// 引入readline模块用于读取命令行输入\nconst readline = require('readline');\n\n// 创建readline接口实例\nconst rl = readline.createInterface({\n    input: process.stdin, // 标准输入流\n    output: process.stdout // 标准输出流\n});\n\n// 定义函数判断是否能获得考勤奖\nconst canReceiveAward = (records) => {\n    let absentCount = 0; // 缺勤次数计数器\n    for (let i = 0; i < records.length; i++) {\n        if (records[i] === 'absent') { // 如果记录为缺勤\n            absentCount++; // 缺勤次数加1\n            if (absentCount > 1) return false; // 缺勤超过1次，返回false\n        }\n        if (records[i] === 'late' || records[i] === 'leaveearly') { // 如果记录为迟到或早退\n            // 如果前一天也是迟到或早退，返回false\n            if (i > 0 && (records[i - 1] === 'late' || records[i - 1] === 'leaveearly')) {\n                return false;\n            }\n        }\n        if (i >= 6) { // 检查任意连续7天的考勤记录\n            let countIn7Days = 0; // 连续7天内非正常上班的天数\n            for (let j = i - 6; j <= i; j++) {\n                if (records[j] !== 'present') { // 如果这7天内有非出勤记录\n                    countIn7Days++;\n                }\n            }\n            if (countIn7Days > 3) return false; // 如果连续7天内非正常上班超过3天，返回false\n        }\n    }\n    return true; // 所有条件都满足，返回true\n};\n\nlet lines = []; // 存储输入行的数组\n\n// 监听命令行输入\nrl.on('line', (line) => {\n    lines.push(line); // 将每行输入存储到lines数组中\n}).on('close', () => { // 输入结束时触发\n    const testCases = parseInt(lines[0], 10); // 解析测试用例数量\n    for (let i = 1; i <= testCases; i++) { // 遍历每个测试用例\n        const attendanceRecords = lines[i].trim().split(\" \"); // 分割考勤记录\n        // 输出每个测试用例的结果，并根据条件添加空格分隔\n        process.stdout.write(canReceiveAward(attendanceRecords) ? \"true\" : \"false\");\n        if (i < testCases) {\n            process.stdout.write(\" \");\n        }\n    }\n    process.exit(0); // 执行完毕后退出程序\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// 定义一个函数用于判断是否能获得考勤奖\nbool can_receive_award(const vector<string>& records) {\n    int absent_count = 0; // 用于记录缺勤的次数\n    for (size_t i = 0; i < records.size(); ++i) { // 遍历考勤记录\n        if (records[i] == \"absent\") { // 如果记录为缺勤\n            ++absent_count; // 缺勤次数加1\n            if (absent_count > 1) return false; // 如果缺勤超过1次，返回false\n        }\n        if (records[i] == \"late\" || records[i] == \"leaveearly\") { // 如果记录为迟到或早退\n            // 如果前一天也是迟到或早退，则不能获得考勤奖\n            if (i > 0 && (records[i - 1] == \"late\" || records[i - 1] == \"leaveearly\")) {\n                return false;\n            }\n        }\n        if (i >= 6) { // 如果记录长度大于等于7，检查任意连续7天的考勤记录\n            int count_in_7_days = 0; // 计算连续7天内非出勤的天数\n            for (int j = i - 6; j <= i; ++j) {\n                if (records[j] != \"present\") ++count_in_7_days;\n            }\n            if (count_in_7_days > 3) return false; // 如果连续7天内非出勤天数超过3天，返回false\n        }\n    }\n    return true; // 所有条件都满足，返回true\n}\n\nint main() {\n    int test_cases;\n    cin >> test_cases; // 读取测试用例的数量\n    cin.ignore(); // 忽略换行符\n    for (int i = 0; i < test_cases; ++i) {\n        string line;\n        getline(cin, line); // 读取一行考勤记录\n        vector<string> records;\n        size_t pos = 0;\n        while ((pos = line.find(' ')) != string::npos) {\n            records.push_back(line.substr(0, pos));\n            line.erase(0, pos + 1);\n        }\n        records.push_back(line); // 添加最后一个记录\n        cout << (can_receive_award(records) ? \"true\" : \"false\") << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_RECORDS 100 // 定义最大记录数\n#define MAX_LENGTH 100  // 定义每条记录的最大长度\n\n// 检查是否可以根据出勤记录获得奖励的函数\nint can_receive_award(char records[][MAX_LENGTH], int count) {\n    int absent_count = 0; // 缺席计数\n    for (int i = 0; i < count; ++i) {\n        // 如果记录为\"absent\"，增加缺席计数\n        if (strcmp(records[i], \"absent\") == 0) {\n            ++absent_count;\n            // 如果缺席超过一次，则不符合条件\n            if (absent_count > 1) return 0; // false\n        }\n        // 如果记录为\"late\"或\"leaveearly\"，检查前一天是否也为\"late\"或\"leaveearly\"\n        if (strcmp(records[i], \"late\") == 0 || strcmp(records[i], \"leaveearly\") == 0) {\n            if (i > 0 && (strcmp(records[i - 1], \"late\") == 0 || strcmp(records[i - 1], \"leaveearly\") == 0)) {\n                return 0; // false\n            }\n        }\n        // 检查连续7天内，非\"present\"的记录是否超过3次\n        if (i >= 6) {\n            int count_in_7_days = 0;\n            for (int j = i - 6; j <= i; ++j) {\n                if (strcmp(records[j], \"present\") != 0) ++count_in_7_days;\n            }\n            if (count_in_7_days > 3) return 0; // false\n        }\n    }\n    return 1; // true，符合条件\n}\n\nint main() {\n    int test_cases;\n    scanf(\"%d\", &test_cases); // 读取测试用例的数量\n\n    for (int t = 0; t < test_cases; ++t) {\n        char records[MAX_RECORDS][MAX_LENGTH]; // 存储记录的数组\n        int records_size = 0; // 记录的实际数量\n\n        // 循环读取每条记录，直到检测到换行符\n        while (scanf(\"%s\", records[records_size]) == 1) {\n            records_size++;\n            if (getchar() == '\\n') break; // 如果检测到换行符，跳出循环\n        }\n\n        // 输出结果，如果符合条件输出\"true\"，否则输出\"false\"\n        printf(\"%s \", can_receive_award(records, records_size) ? \"true\" : \"false\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"
    }
  },
  {
    "id": "51",
    "title": "英文输入法",
    "examType": "A",
    "score": 100,
    "description": "主管期望你来实现英文输入法单词联想功能。 需求如下：\n依据用户输入的单词前缀，从已输入的英文语句中联想出用户想输入的单词，按字典序输出联想到的单词序列，如果联想不到，请输出用户输入的单词前缀。\n注意：\n英文单词联想时，区分大小写缩略形式如”don’t”，判定为两个单词，”don”和”t”输出的单词序列，不能有重复单词，且只能是英文单词，不能有标点符号",
    "inputDesc": "输入为两行。\n首行输入一段由英文单词word和标点符号组成的语句str；\n接下来一行为一个英文单词前缀pre。\n0 < word.length() <= 200 < str.length <= 100000 < pre <= 20",
    "outputDesc": "输出符合要求的单词序列或单词前缀，存在多个时，单词之间以单个空格分割",
    "examples": [
      {
        "input": "I love you\nHe",
        "output": "He",
        "explanation": "从用户已输入英文语句”I love you”中提炼出“I”、“love”、“you”三个单词，接下来用户输入“He”，从已输入信息中无法联想到任何符合要求的单词，因此输出用户输入的单词前缀。"
      },
      {
        "input": "The furthest distance in the world, Is not between life and death, But when I stand in front of you, Yet you don’t know that I love you.\nf",
        "output": "front furthest",
        "explanation": "从用户已输入英文语句”The furthestdistance in the world, Is not between life and death, But when I stand in frontof you, Yet you dont know that I love you.”中提炼出的单词，符合“f”作为前缀的，有“furthest”和“front”，按字典序排序并在单词间添加空格后输出，结果为“front furthest”。"
      }
    ],
    "solution": "简单题",
    "codes": {
      "java": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String sentence = br.readLine(); // 输入一段由英文单词word和标点符号组成的语句\n        String prefix = br.readLine(); // 输入一个英文单词前缀\n        sentence = sentence.replaceAll(\"[^a-zA-Z]\", \" \"); // 将标点符号替换为空格\n        Set<String> wordSet = new TreeSet<>(); // 存储单词的集合，自动去重且按照字典序排序\n        String[] words = sentence.split(\"\\\\s+\");\n        for (String word : words) {\n            wordSet.add(word);\n        }\n        StringBuilder ans = new StringBuilder();\n        for (String s : wordSet) { // 遍历单词集合\n            if (s.startsWith(prefix)) { // 如果单词以前缀开头\n                ans.append(s).append(\" \"); // 将单词加入答案字符串\n            }\n        }\n        if (ans.length() > 0) { // 如果答案字符串不为空\n            System.out.println(ans.toString().trim()); // 输出单词序列\n        } else {\n            System.out.println(prefix); // 否则输出前缀\n        }\n    }\n}",
      "python": "import string\n\nsentence = input() # 输入一段由英文单词word和标点符号组成的语句\nprefix = input() # 输入一个英文单词前缀\nsentence = sentence.translate(str.maketrans(string.punctuation, ' ' * len(string.punctuation))) # 将标点符号替换为空格\nword_set = set(sentence.split()) # 存储单词的集合，自动去重且按照字典序排序\nans = ''\nfor s in sorted(word_set): # 遍历单词集合\n    if s.startswith(prefix): # 如果单词以前缀开头\n        ans += s + ' ' # 将单词加入答案字符串\nif ans: # 如果答案字符串不为空\n    print(ans) # 输出单词序列\nelse:\n    print(prefix) # 否则输出前缀",
      "javascript": "const readline = require('readline');\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (sentence) => {\n  rl.on('line', (prefix) => {\n  sentence = sentence.replace(/[^\\w\\s]/g, ' '); // 将标点符号替换为空格\n    const wordSet = new Set(sentence.split(' ')); // 存储单词的集合，自动去重且按照字典序排序\n    let ans = '';\n    for (const word of Array.from(wordSet).sort()) { // 遍历单词集合\n      if (word.startsWith(prefix)) { // 如果单词以前缀开头\n        ans += word + ' '; // 将单词加入答案字符串\n      }\n    }\n    if (ans) { // 如果答案字符串不为空\n      console.log(ans); // 输出单词序列\n    } else {\n      console.log(prefix); // 否则输出前缀\n    }\n    rl.close();\n  });\n});",
      "cpp": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    string sentence, prefix;\n    getline(cin, sentence); // 输入一段由英文单词word和标点符号组成的语句\n    getline(cin, prefix); // 输入一个英文单词前缀\n    replace_if(sentence.begin(), sentence.end(), [](char c){return !isalpha(c);}, ' '); // 将标点符号替换为空格\n    stringstream ss(sentence);\n    set<string> word_set; // 存储单词的集合，自动去重且按照字典序排序\n    string word;\n    while (ss >> word) {\n        word_set.insert(word);\n    }\n    string ans;\n    for (auto s : word_set) { // 遍历单词集合\n        if (s.substr(0, prefix.length()) == prefix) { // 如果单词以前缀开头\n            ans += s + \" \"; // 将单词加入答案字符串\n        }\n    }\n    if (ans.length() > 0) { // 如果答案字符串不为空\n        cout << ans << endl; // 输出单词序列\n    } else {\n        cout << prefix << endl; // 否则输出前缀\n    }\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#define MAX_WORDS 1000\n#define MAX_WORD_LENGTH 21\n#define MAX_SENTENCE_LENGTH 10001\n\nint compare(const void *a, const void *b) {\n    return strcmp(*(const char **)a, *(const char **)b);\n}\n\nint main() {\n    char sentence[MAX_SENTENCE_LENGTH], prefix[MAX_WORD_LENGTH];\n    fgets(sentence, MAX_SENTENCE_LENGTH, stdin); // 输入一段由英文单词和标点符号组成的语句\n    fgets(prefix, MAX_WORD_LENGTH, stdin);       // 输入一个英文单词前缀\n\n    // 去除前缀字符串末尾的换行符\n    size_t prefix_len = strlen(prefix);\n    if (prefix[prefix_len - 1] == '\\n') {\n        prefix[prefix_len - 1] = '\\0';\n        prefix_len--;\n    }\n\n    // 将标点符号替换为空格\n    for (int i = 0; sentence[i] != '\\0'; i++) {\n        if (!isalpha(sentence[i])) {\n            sentence[i] = ' ';\n        }\n    }\n\n    // 存储单词的数组\n    char *words[MAX_WORDS];\n    int word_count = 0;\n    char *word = strtok(sentence, \" \");\n\n    // 分割单词并存储\n    while (word != NULL) {\n        words[word_count] = (char *)malloc(strlen(word) + 1);\n        strcpy(words[word_count], word);\n        word_count++;\n        word = strtok(NULL, \" \");\n    }\n\n    // 对单词数组进行排序\n    qsort(words, word_count, sizeof(char *), compare);\n\n    // 输出结果\n    int found = 0;\n    for (int i = 0; i < word_count; i++) {\n        if (strncmp(words[i], prefix, prefix_len) == 0) {\n            printf(\"%s \", words[i]);\n            found = 1;\n        }\n        free(words[i]); // 释放分配的内存\n    }\n\n    // 如果没有找到任何匹配的单词，输出前缀\n    if (!found) {\n        printf(\"%s\", prefix);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "52",
    "title": "螺旋数字矩阵",
    "examType": "A",
    "score": 100,
    "description": "疫情期间，小明隔离在家，百无聊赖，在纸上写数字玩。他发明了一种写法： 给出数字个数n和行数m（0 < n ≤ 999，0 < m ≤ 999），从左上角的1开始，按照顺时针螺旋向内写方式，依次写出2,3…n，最终形成一个m行矩阵。 小明对这个矩阵有些要求：\n每行数字的个数一样多列的数量尽可能少填充数字时优先填充外部数字不够时，使用单个*号占位",
    "inputDesc": "输入一行，两个整数，空格隔开，依次表示n、m",
    "outputDesc": "符合要求的唯一矩阵\n输入：\n输出：\n说明：\n9个数字写成4行，最少需要3列\n输入：\n3 5 输出：\n说明：\n3个数字写5行，只有一列，数字不够用*号填充\n输入：\n输出：",
    "examples": [],
    "solution": "本题不难，主要就是模拟。按照题目的要求填充矩阵就可以了。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // 读取要填充的数字个数n\n        int m = scanner.nextInt(); // 读取矩阵的行数m\n        scanner.close(); // 输入完毕后关闭scanner\n\n        int cols = (int) Math.ceil(n / (double) m); // 计算矩阵的列数\n        int[][] matrix = new int[m][cols]; // 创建一个整型矩阵，默认初始化为0\n\n        int num = 1; // 用于填充的数字从1开始\n        int top = 0, bottom = m - 1, left = 0, right = cols - 1;\n        while (num <= n) {\n            for (int i = left; i <= right && num <= n; i++) { // 从左到右填充上边界\n                matrix[top][i] = num++;\n            }\n            top++; // 上边界下移\n            for (int i = top; i <= bottom && num <= n; i++) { // 从上到下填充右边界\n                matrix[i][right] = num++;\n            }\n            right--; // 右边界左移\n            for (int i = right; i >= left && num <= n; i--) { // 从右到左填充下边界\n                matrix[bottom][i] = num++;\n            }\n            bottom--; // 下边界上移\n            for (int i = bottom; i >= top && num <= n; i--) { // 从下到上填充左边界\n                matrix[i][left] = num++;\n            }\n            left++; // 左边界右移\n        }\n\n        for (int i = 0; i < m; i++) { // 遍历矩阵的每一行\n            for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n                if (matrix[i][j] == 0) { // 如果当前位置是0，则输出'*'\n                    System.out.print('*');\n                } else { // 否则输出当前位置的数字\n                    System.out.print(matrix[i][j]);\n                }\n                if (j < cols - 1) { // 在同一行的数字之间打印空格\n                    System.out.print(\" \");\n                }\n            }\n            System.out.println(); // 每打印完一行后换行\n        }\n    }\n}",
      "python": "import math\n\nn, m = map(int, input().split()) # 读取要填充的数字个数n和矩阵的行数m\ncols = math.ceil(n / m) # 计算矩阵的列数\nmatrix = [[0 for _ in range(cols)] for _ in range(m)] # 创建一个整型矩阵，默认初始化为0\n\nnum = 1 # 用于填充的数字从1开始\ntop, bottom, left, right = 0, m - 1, 0, cols - 1\nwhile num <= n:\n    for i in range(left, right + 1): # 从左到右填充上边界\n        if num <= n:\n            matrix[top][i] = num\n            num += 1\n    top += 1 # 上边界下移\n    for i in range(top, bottom + 1): # 从上到下填充右边界\n        if num <= n:\n            matrix[i][right] = num\n            num += 1\n    right -= 1 # 右边界左移\n    for i in range(right, left - 1, -1): # 从右到左填充下边界\n        if num <= n:\n            matrix[bottom][i] = num\n            num += 1\n    bottom -= 1 # 下边界上移\n    for i in range(bottom, top - 1, -1): # 从下到上填充左边界\n        if num <= n:\n            matrix[i][left] = num\n            num += 1\n    left += 1 # 左边界右移\n\nfor row in matrix: # 遍历矩阵的每一行\n    print(' '.join('*' if val == 0 else str(val) for val in row)) # 如果当前位置是0，则输出'*'，否则输出当前位置的数字",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nint main() {\n    int n, m;\n    std::cin >> n >> m; // 读取要填充的数字个数n和矩阵的行数m\n\n    int cols = std::ceil(static_cast<double>(n) / m); // 计算矩阵的列数\n    std::vector<std::vector<int>> matrix(m, std::vector<int>(cols, 0)); // 创建一个整型矩阵，默认初始化为0\n\n    int num = 1; // 用于填充的数字从1开始\n    int top = 0, bottom = m - 1, left = 0, right = cols - 1;\n    while (num <= n) {\n        for (int i = left; i <= right && num <= n; i++) { // 从左到右填充上边界\n            matrix[top][i] = num++;\n        }\n        top++; // 上边界下移\n        for (int i = top; i <= bottom && num <= n; i++) { // 从上到下填充右边界\n            matrix[i][right] = num++;\n        }\n        right--; // 右边界左移\n        for (int i = right; i >= left && num <= n; i--) { // 从右到左填充下边界\n            matrix[bottom][i] = num++;\n        }\n        bottom--; // 下边界上移\n        for (int i = bottom; i >= top && num <= n; i--) { // 从下到上填充左边界\n            matrix[i][left] = num++;\n        }\n        left++; // 左边界右移\n    }\n\n    for (int i = 0; i < m; i++) { // 遍历矩阵的每一行\n        for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n            if (matrix[i][j] == 0) { // 如果当前位置是0，则输出'*'\n                std::cout << '*';\n            } else { // 否则输出当前位置的数字\n                std::cout << matrix[i][j];\n            }\n            if (j < cols - 1) { // 在同一行的数字之间打印空格\n                std::cout << \" \";\n            }\n        }\n        std::cout << std::endl; // 每打印完一行后换行\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m); // 读取要填充的数字个数n和矩阵的行数m\n\n    int cols = (int)ceil((double)n / m); // 计算矩阵的列数\n    int matrix[m][cols]; // 创建一个整型矩阵，默认初始化为0\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = 0;\n        }\n    }\n\n    int num = 1; // 用于填充的数字从1开始\n    int top = 0, bottom = m - 1, left = 0, right = cols - 1;\n    while (num <= n) {\n        for (int i = left; i <= right && num <= n; i++) { // 从左到右填充上边界\n            matrix[top][i] = num++;\n        }\n        top++; // 上边界下移\n        for (int i = top; i <= bottom && num <= n; i++) { // 从上到下填充右边界\n            matrix[i][right] = num++;\n        }\n        right--; // 右边界左移\n        for (int i = right; i >= left && num <= n; i--) { // 从右到左填充下边界\n            matrix[bottom][i] = num++;\n        }\n        bottom--; // 下边界上移\n        for (int i = bottom; i >= top && num <= n; i--) { // 从下到上填充左边界\n            matrix[i][left] = num++;\n        }\n        left++; // 左边界右移\n    }\n\n    for (int i = 0; i < m; i++) { // 遍历矩阵的每一行\n        for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n            if (matrix[i][j] == 0) { // 如果当前位置是0，则输出'*'\n                printf(\"* \");\n            } else { // 否则输出当前位置的数字\n                printf(\"%d \", matrix[i][j]);\n            }\n        }\n        printf(\"\\n\"); // 每打印完一行后换行\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "53",
    "title": "补种未成活胡杨",
    "examType": "A",
    "score": 100,
    "description": "近些年来，我国防沙治沙取得显著成果。某沙漠新种植N棵胡杨（编号1-N），排成一排。\n一个月后，有M棵胡杨未能成活。\n现可补种胡杨K棵，请问如何补种（只能补种，不能新种），可以得到最多的连续胡杨树？",
    "inputDesc": "N 总种植数量，1 <= N <= 100000\nM 未成活胡杨数量，M 个空格分隔的数，按编号从小到大排列，1 <= M <= N\nK 最多可以补种的数量，0 <= K <= M",
    "outputDesc": "最多的连续胡杨棵树",
    "examples": [
      {
        "input": "4",
        "output": "",
        "explanation": "补种到2或4结果一样，最多的连续胡杨棵树都是3。"
      },
      {
        "input": "4 7",
        "output": "",
        "explanation": "种第7棵树，最多连续胡杨树棵数位6（5，6，7，8，9，10）"
      },
      {
        "input": "4 7",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "这道题目主要是考察如何通过补种胡杨树，使得胡杨树形成【最长的连续序列】。\n基本与下题一致：\n1004. 最大连续1的个数 III\n参考题解：https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/608931/zui-da-lian-xu-1de-ge-shu-iii-by-leetcod-hw12/",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个扫描器对象，用于读取输入\n        Scanner scanner = new Scanner(System.in);\n        \n        // 读取总共的胡杨树数量\n        int total = scanner.nextInt();\n        \n        // 读取未成活的胡杨树数量\n        int deadCount = scanner.nextInt();\n        \n        // 创建一个数组来表示每棵树是否成活，0表示成活，1表示未成活\n        int[] nums = new int[total];\n        \n        // 初始化数组，所有元素设为0，表示所有树最初都是成活的\n        Arrays.fill(nums, 0);\n \n        // 根据输入，将未成活的树的位置标记为1\n        for (int i = 0; i < deadCount; i++) {\n            int num = scanner.nextInt();\n            nums[num - 1] = 1; // 树的编号从1开始，因此需要减1\n        }\n        \n        // 读取可以补种的树的数量\n        int supplementCount = scanner.nextInt();\n        \n        // 初始化滑动窗口的左右边界\n        int left = 0;\n        int maxLen = 0; // 用于存储最大连续成活区域的长度\n        int sumLeft = 0; // 滑动窗口左边界的未成活树数量\n        int sumRight = 0; // 滑动窗口右边界的未成活树数量\n        \n        // 遍历所有的树，right代表滑动窗口的右边界\n        for (int right = 0; right < total; right++) {\n            sumRight += nums[right]; // 更新右边界的未成活树数量\n            \n            // 如果窗口内的未成活树数量大于可以补种的数量\n            while (sumRight - sumLeft > supplementCount) {\n                sumLeft += nums[left]; // 缩小窗口，左边界右移\n                left++;\n            }\n            \n            // 更新最大成活区域的长度\n            maxLen = Math.max(maxLen, right - left + 1);\n        }\n        \n        // 输出最大连续成活区域的长度\n        System.out.println(maxLen);\n    }\n}",
      "python": "# 读取胡杨树的总数N\ntotal = int(input())\n\n# 读取未成活胡杨树的数量M\ndead_count = int(input())\n\n# 读取未成活胡杨树的编号列表\ndead_list = list(map(int, input().split()))\n\n# 读取可以补种的胡杨树数量K\nsupplement_count = int(input())\n\n# 初始化数组，所有树最初都是成活的，0表示成活，1表示未成活\nnums = [0] * total\n\n# 根据输入，将未成活的树的位置标记为1\nfor num in dead_list:\n    nums[num - 1] = 1  # 树的编号从1开始，因此需要减1\n\n# 初始化滑动窗口的左右边界\nleft = 0\nmax_len = 0  # 用于存储最大连续成活区域的长度\nsum_left = 0  # 滑动窗口左边界的未成活树数量\nsum_right = 0  # 滑动窗口右边界的未成活树数量\n\n# 遍历所有的树，right代表滑动窗口的右边界\nfor right in range(total):\n    sum_right += nums[right]  # 更新右边界的未成活树数量\n    \n    # 如果窗口内的未成活树数量大于可以补种的数量\n    while sum_right - sum_left > supplement_count:\n        sum_left += nums[left]  # 缩小窗口，左边界右移\n        left += 1\n    \n    # 更新最大成活区域的长度\n    max_len = max(max_len, right - left + 1)\n\n# 输出最大连续成活区域的长度\nprint(max_len)",
      "javascript": "const readline = require('readline');\n\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst inputLines = [];\nrl.on('line', (input) => {\n    inputLines.push(input);\n});\n\nrl.on('close', () => {\n    // 读取胡杨树的总数N\n    const total = parseInt(inputLines[0]);\n\n    // 读取未成活胡杨树的数量M\n    const deadCount = parseInt(inputLines[1]);\n\n    // 读取未成活胡杨树的编号列表\n    const deadList = inputLines[2].split(' ').map(Number);\n\n    // 读取可以补种的胡杨树数量K\n    const supplementCount = parseInt(inputLines[3]);\n\n    // 初始化数组，所有树最初都是成活的，0表示成活，1表示未成活\n    const nums = new Array(total).fill(0);\n\n    // 根据输入，将未成活的树的位置标记为1\n    deadList.forEach(num => {\n        nums[num - 1] = 1; // 树的编号从1开始，因此需要减1\n    });\n\n    // 初始化滑动窗口的左右边界\n    let left = 0;\n    let maxLen = 0; // 用于存储最大连续成活区域的长度\n    let sumLeft = 0; // 滑动窗口左边界的未成活树数量\n    let sumRight = 0; // 滑动窗口右边界的未成活树数量\n\n    // 遍历所有的树，right代表滑动窗口的右边界\n    for (let right = 0; right < total; right++) {\n        sumRight += nums[right]; // 更新右边界的未成活树数量\n        \n        // 如果窗口内的未成活树数量大于可以补种的数量\n        while (sumRight - sumLeft > supplementCount) {\n            sumLeft += nums[left]; // 缩小窗口，左边界右移\n            left++;\n        }\n        \n        // 更新最大成活区域的长度\n        maxLen = Math.max(maxLen, right - left + 1);\n    }\n\n    // 输出最大连续成活区域的长度\n    console.log(maxLen);\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm> \n\nusing namespace std;\n\nint main() {\n    int total, deadCount;\n    cin >> total >> deadCount;\n\n    // 初始化数组，所有树最初都是成活的，0表示成活，1表示未成活\n    vector<int> nums(total, 0);\n\n    // 根据输入，将未成活的树的位置标记为1\n    for (int i = 0; i < deadCount; i++) {\n        int num;\n        cin >> num;\n        nums[num - 1] = 1; // 树的编号从1开始，因此需要减1\n    }\n\n    // 读取可以补种的树的数量\n    int supplementCount;\n    cin >> supplementCount;\n\n    // 初始化滑动窗口的左右边界\n    int left = 0, maxLen = 0, sumLeft = 0, sumRight = 0;\n\n    // 遍历所有的树，right代表滑动窗口的右边界\n    for (int right = 0; right < total; right++) {\n        sumRight += nums[right]; // 更新右边界的未成活树数量\n\n        // 如果窗口内的未成活树数量大于可以补种的数量\n        while (sumRight - sumLeft > supplementCount) {\n            sumLeft += nums[left]; // 缩小窗口，左边界右移\n            left++;\n        }\n\n        // 更新最大成活区域的长度\n        maxLen = max(maxLen, right - left + 1);\n    }\n\n    // 输出最大连续成活区域的长度\n    cout << maxLen << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 定义一个max函数，用于求两个数中的最大值\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint main() {\n    int total, deadCount;\n\n    scanf(\"%d %d\", &total, &deadCount);\n\n    // 初始化数组，所有树最初都是成活的，0表示成活，1表示未成活\n    int *nums = (int *)calloc(total, sizeof(int));\n\n    // 根据输入，将未成活的树的位置标记为1\n    for (int i = 0; i < deadCount; i++) {\n        int num;\n        scanf(\"%d\", &num);\n        nums[num - 1] = 1; // 树的编号从1开始，因此需要减1\n    }\n\n    // 读取可以补种的树的数量\n    int supplementCount;\n    scanf(\"%d\", &supplementCount);\n\n    // 初始化滑动窗口的左右边界\n    int left = 0, maxLen = 0, sumLeft = 0, sumRight = 0;\n\n    // 遍历所有的树，right代表滑动窗口的右边界\n    for (int right = 0; right < total; right++) {\n        sumRight += nums[right]; // 更新右边界的未成活树数量\n\n        // 如果窗口内的未成活树数量大于可以补种的数量\n        while (sumRight - sumLeft > supplementCount) {\n            sumLeft += nums[left]; // 缩小窗口，左边界右移\n            left++;\n        }\n\n        // 更新最大成活区域的长度\n        maxLen = max(maxLen, right - left + 1);\n    }\n\n    // 输出最大连续成活区域的长度\n    printf(\"%d\\n\", maxLen);\n\n    // 释放动态分配的内存\n    free(nums);\n\n    return 0;\n}"
    }
  },
  {
    "id": "54",
    "title": "计算三叉搜索树的高度",
    "examType": "A",
    "score": 100,
    "description": "定义构造三叉搜索树规则如下：\n每个节点都存有一个数，当插入一个新的数时，从根节点向下寻找，直到找到一个合适的空节点插入。查找的规则是：\n如果数小于节点的数减去500，则将数插入节点的左子树 如果数大于节点的数加上500，则将数插入节点的右子树 否则，将数插入节点的中子树\n如果数小于节点的数减去500，则将数插入节点的左子树\n如果数大于节点的数加上500，则将数插入节点的右子树\n否则，将数插入节点的中子树\n给你一系列数，请按以上规则，按顺序将数插入树中，构建出一棵三叉搜索树，最后输出树的高度。",
    "inputDesc": "第一行为一个数 N，表示有 N 个数，1 ≤ N ≤ 10000\n第二行为 N 个空格分隔的整数，每个数的范围为[1,10000]",
    "outputDesc": "输出树的高度（根节点的高度为1）",
    "examples": [
      {
        "input": "2000 5000 8000 1800",
        "output": "",
        "explanation": ""
      },
      {
        "input": "4000 3000",
        "output": "",
        "explanation": ""
      },
      {
        "input": "2000 5000 8000 1800 7500 4500 1400 8100",
        "output": "",
        "explanation": ""
      },
      {
        "input": "2000 5000 8000 1800 7500 4500 1400 8100",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "这道题目要求构造一棵 三叉搜索树，并计算这棵树的高度。所谓三叉搜索树，就是每个节点可以有最多三个子节点：左子树、中子树和右子树。每当插入一个新数时，按照一定的规则决定它应该插入到哪个子树中。\n左子树：如果新数小于当前节点的值减去500，则新数应该插入到当前节点的左子树中。右子树：如果新数大于当前节点的值加上500，则新数应该插入到当前节点的右子树中。中子树：如果新数介于当前节点的值减去500和加上500之间（包括边界），则新数应该插入到当前节点的中子树中。",
    "codes": {
      "java": "import java.util.Scanner;\n\n// 主类\npublic class Main {\n  \n    // 静态内部类：树\n    static class Tree {\n        // 插入方法：向树中插入值\n        public TreeNode insert(TreeNode root, int val) {\n            if (root == null) {\n                return new TreeNode(val); // 如果根节点为空，创建新节点作为根节点\n            }\n            if (val < root.val - 500) {\n                root.left = insert(root.left, val); // 如果值小于根节点值减500，插入到左子树\n            } else if (val > root.val + 500) {\n                root.right = insert(root.right, val); // 如果值大于根节点值加500，插入到右子树\n            } else {\n                root.mid = insert(root.mid, val); // 如果值在根节点值加减500范围内，插入到中间子树\n            }\n            return root; // 返回根节点\n        }\n\n        // 获取树的高度\n        public int getHeight(TreeNode root) {\n            if (root == null) {\n                return 0; // 如果根节点为空，高度为0\n            }\n            int leftHeight = getHeight(root.left); // 计算左子树的高度\n            int midHeight = getHeight(root.mid); // 计算中间子树的高度\n            int rightHeight = getHeight(root.right); // 计算右子树的高度\n            return Math.max(Math.max(leftHeight, midHeight), rightHeight) + 1; // 返回三者中最大的高度加1\n        }\n    }\n\n    // 静态内部类：树节点\n    static class TreeNode {\n        int val; // 节点值\n        TreeNode left, mid, right; // 左子节点、中间子节点、右子节点\n        TreeNode(int x) { val = x; } // 构造方法，初始化节点值\n    }\n\n     \n    public static void main(String[] args) {\n        Tree tree = new Tree(); // 创建树对象\n        Scanner scanner = new Scanner(System.in); // 创建扫描器读取输入\n        int N = scanner.nextInt();  // 读取第一个整数作为后续要输入的节点数量\n        TreeNode root = null; // 初始化根节点为null\n        for (int i = 0; i < N; i++) {\n            int num = scanner.nextInt();  // 循环读取N个整数作为节点值\n            root = tree.insert(root, num);  // 将每个整数插入树中\n        }\n        scanner.close(); // 关闭扫描器\n        int height = tree.getHeight(root);  // 获取树的高度\n        System.out.println(height);  // 输出树的高度\n    }\n}",
      "python": "class TreeNode:\n    def __init__(self, val):\n        self.val = val  # 节点值\n        self.left = self.mid = self.right = None  # 左、中、右子节点\n\nclass Tree:\n    # 插入方法：向树中插入值\n    def insert(self, root, val):\n        if root is None:\n            return TreeNode(val)  # 如果根节点为空，创建新节点作为根节点\n        if val < root.val - 500:\n            root.left = self.insert(root.left, val)  # 如果值小于根节点值减500，插入到左子树\n        elif val > root.val + 500:\n            root.right = self.insert(root.right, val)  # 如果值大于根节点值加500，插入到右子树\n        else:\n            root.mid = self.insert(root.mid, val)  # 如果值在根节点值加减500范围内，插入到中间子树\n        return root  # 返回根节点\n\n    # 获取树的高度\n    def get_height(self, root):\n        if root is None:\n            return 0  # 如果根节点为空，高度为0\n        left_height = self.get_height(root.left)  # 计算左子树的高度\n        mid_height = self.get_height(root.mid)  # 计算中间子树的高度\n        right_height = self.get_height(root.right)  # 计算右子树的高度\n        return max(left_height, mid_height, right_height) + 1  # 返回三者中最大的高度加1\n\nif __name__ == '__main__':\n    tree = Tree()  # 创建树对象\n    N = int(input())  # 读取节点数量\n    root = None  # 初始化根节点为None\n    nums = list(map(int, input().split()))\n    for num in nums:\n        root = tree.insert(root, num)  # 将每个整数插入树中     \n    height = tree.get_height(root)  # 获取树的高度\n    print(height)  # 输出树的高度",
      "javascript": "class TreeNode {\n    // 构造函数：创建树节点\n    constructor(val) {\n        this.val = val; // 节点值\n        this.left = this.mid = this.right = null; // 初始化左、中、右子节点为null\n    }\n}\n\nclass Tree {\n    // 插入方法：向树中插入值\n    insert(root, val) {\n        if (root === null) {\n            return new TreeNode(val); // 如果根节点为空，创建新节点作为根节点\n        }\n        if (val < root.val - 500) {\n            root.left = this.insert(root.left, val); // 如果值小于根节点值减500，插入到左子树\n        } else if (val > root.val + 500) {\n            root.right = this.insert(root.right, val); // 如果值大于根节点值加500，插入到右子树\n        } else {\n            root.mid = this.insert(root.mid, val); // 如果值在根节点值加减500范围内，插入到中间子树\n        }\n        return root; // 返回根节点\n    }\n\n    // 获取树的高度\n    getHeight(root) {\n        if (root === null) {\n            return 0; // 如果根节点为空，高度为0\n        }\n        let leftHeight = this.getHeight(root.left); // 计算左子树的高度\n        let midHeight = this.getHeight(root.mid); // 计算中间子树的高度\n        let rightHeight = this.getHeight(root.right); // 计算右子树的高度\n        return Math.max(leftHeight, midHeight, rightHeight) + 1; // 返回三者中最大的高度加1\n    }\n}\n\n// 主程序\nconst readline = require('readline').createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst tree = new Tree();\nlet root = null;\n\nreadline.on('line', N => {\n    N = parseInt(N);\n    readline.on('line', nums => {\n        nums.split(' ').forEach(num => {\n            root = tree.insert(root, parseInt(num)); // 将每个整数插入树中\n        });\n        const height = tree.getHeight(root); // 获取树的高度\n        console.log(height); // 输出树的高度\n        readline.close();\n    });\n});",
      "cpp": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n// 树节点结构体\nstruct TreeNode {\n    int val; // 节点值\n    TreeNode *left, *mid, *right; // 左、中、右子节点指针\n    TreeNode(int x) : val(x), left(nullptr), mid(nullptr), right(nullptr) {} // 构造函数\n};\n\n// 树类\nclass Tree {\npublic:\n    // 插入方法：向树中插入值\n    TreeNode* insert(TreeNode* root, int val) {\n        if (root == nullptr) {\n            return new TreeNode(val); // 如果根节点为空，创建新节点作为根节点\n        }\n        if (val < root->val - 500) {\n            root->left = insert(root->left, val); // 如果值小于根节点值减500，插入到左子树\n        } else if (val > root->val + 500) {\n            root->right = insert(root->right, val); // 如果值大于根节点值加500，插入到右子树\n        } else {\n            root->mid = insert(root->mid, val); // 如果值在根节点值加减500范围内，插入到中间子树\n        }\n        return root; // 返回根节点\n    }\n\n    // 获取树的高度\n    int getHeight(TreeNode* root) {\n        if (root == nullptr) {\n            return 0; // 如果根节点为空，高度为0\n        }\n        int leftHeight = getHeight(root->left); // 计算左子树的高度\n        int midHeight = getHeight(root->mid); // 计算中间子树的高度\n        int rightHeight = getHeight(root->right); // 计算右子树的高度\n        return max({leftHeight, midHeight, rightHeight}) + 1; // 返回三者中最大的高度加1\n    }\n};\n\nint main() {\n    Tree tree; // 创建树对象\n    int N;\n    cin >> N; // 读取节点数量\n    TreeNode* root = nullptr; // 初始化根节点为null\n    for (int i = 0; i < N; ++i) {\n        int num;\n        cin >> num; // 循环读取节点值\n        root = tree.insert(root, num); // 将每个整数插入树中\n    }\n    int height = tree.getHeight(root); // 获取树的高度\n    cout << height << endl; // 输出树的高度\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 树节点结构体\ntypedef struct TreeNode {\n    int val; // 节点值\n    struct TreeNode *left, *mid, *right; // 左、中、右子节点指针\n} TreeNode;\n\n// 创建新节点\nTreeNode* createNode(int val) {\n    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode)); // 分配内存\n    node->val = val; // 设置节点值\n    node->left = node->mid = node->right = NULL; // 初始化子节点为NULL\n    return node; // 返回新创建的节点\n}\n\n// 向树中插入值\nTreeNode* insert(TreeNode* root, int val) {\n    if (root == NULL) {\n        return createNode(val); // 如果根节点为空，创建新节点作为根节点\n    }\n    if (val < root->val - 500) {\n        root->left = insert(root->left, val); // 如果值小于根节点值减500，插入到左子树\n    } else if (val > root->val + 500) {\n        root->right = insert(root->right, val); // 如果值大于根节点值加500，插入到右子树\n    } else {\n        root->mid = insert(root->mid, val); // 如果值在根节点值加减500范围内，插入到中间子树\n    }\n    return root; // 返回根节点\n}\n\n// 获取树的高度\nint getHeight(TreeNode* root) {\n    if (root == NULL) {\n        return 0; // 如果根节点为空，高度为0\n    }\n    int leftHeight = getHeight(root->left); // 计算左子树的高度\n    int midHeight = getHeight(root->mid); // 计算中间子树的高度\n    int rightHeight = getHeight(root->right); // 计算右子树的高度\n    int maxHeight = leftHeight > midHeight ? leftHeight : midHeight; // 计算左子树和中间子树的最大高度\n    maxHeight = maxHeight > rightHeight ? maxHeight : rightHeight; // 计算最大高度\n    return maxHeight + 1; // 返回最大高度加1\n}\n\nint main() {\n    int N, num;\n    scanf(\"%d\", &N); // 读取节点数量\n    TreeNode* root = NULL; // 初始化根节点为NULL\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d\", &num); // 循环读取节点值\n        root = insert(root, num); // 将每个整数插入树中\n    }\n    int height = getHeight(root); // 获取树的高度\n    printf(\"%d\\n\", height); // 输出树的高度\n    return 0;\n}"
    }
  },
  {
    "id": "55",
    "title": "转盘寿司",
    "examType": "A",
    "score": 100,
    "description": "寿司店周年庆，正在举办优惠活动回馈新老客户。\n寿司转盘上总共有 n 盘寿司，prices[i] 是第 i 盘寿司的价格，\n如果客户选择了第 i 盘寿司，寿司店免费赠送客户距离第 i 盘寿司最近的下一盘寿司 j，前提是 prices[j] < prices[i]，如果没有满足条件的 j，则不赠送寿司。\n每个价格的寿司都可无限供应。",
    "inputDesc": "输入的每一个数字代表每盘寿司的价格，每盘寿司的价格之间使用空格分隔，例如:\n3 15 6 14\n表示：\n第 0 盘寿司价格 prices[0] 为 3第 1 盘寿司价格 prices[1] 为 15第 2 盘寿司价格 prices[2] 为 6第 3 盘寿司价格 prices[3] 为 14寿司的盘数 n 范围为：1 ≤ n ≤ 500\n每盘寿司的价格 price 范围为：1 ≤ price ≤ 1000",
    "outputDesc": "输出享受优惠后的一组数据，每个值表示客户选择第 i 盘寿司时实际得到的寿司的总价格。使用空格进行分隔，例如：\n3 21 9 17\n根据题目的描述，客户选择了第 i 盘寿司，寿司店免费赠送距离第 i 盘寿司最近的下一盘寿司 j，且 prices[j] < prices[i]。如果没有满足条件的 j，则不赠送寿司。因此，对于每一盘寿司，我们需要找到其价格右侧第一个比它小的寿司的价格，并将其加到当前寿司的价格上。\n给定输入 3 15 6 14，我们来逐个分析：\n综合以上，输出结果为 3 21 9 17。\n通过这个用例，可以得出数组是可以循环到头部继续寻找",
    "examples": [],
    "solution": "优惠规则是每个寿司盘可以用它右边第一个比它便宜的寿司盘的价格来享受优惠。如果右边没有更便宜的寿司盘，则保持原价。寿司盘是循环的，即最后一个寿司盘的右边是第一个寿司盘。\n解题思路如下：\n数据处理：将读取的字符串按空格分割，转换成整数数组prices，这个数组包含了所有寿司盘的价格。同时，获取数组的长度n，代表寿司盘的总数。 初始化数据结构：创建一个与价格数组等长的结果数组res来存储每个寿司盘享受优惠后的价格，并初始化一个双端队列stack作为栈，用来跟踪价格的索引。 遍历价格数组：由于寿司盘是循环的，需要遍历2 * n - 1次来确保每个寿司盘都能找到它右边的第一个更便宜的寿司盘。使用模运算来处理循环数组的索引。 处理栈：在遍历过程中，对于每个价格，检查栈顶元素（即之前遍历过的价格）是否大于当前价格。如果是，则说明找到了一个更便宜的寿司盘，计算栈顶元素对应寿司盘的优惠价格并更新到结果数组res中，然后将该元素出栈。重复此过程直到栈为空或栈顶元素小于当前价格。第一轮遍历（即j < n时）将每个索引加入栈中。 处理剩余元素：遍历结束后，栈中可能还有元素，这些元素代表它们右侧没有更小的价格，因此直接将它们的价格作为结果。\n数据处理：将读取的字符串按空格分割，转换成整数数组prices，这个数组包含了所有寿司盘的价格。同时，获取数组的长度n，代表寿司盘的总数。\n初始化数据结构：创建一个与价格数组等长的结果数组res来存储每个寿司盘享受优惠后的价格，并初始化一个双端队列stack作为栈，用来跟踪价格的索引。\n遍历价格数组：由于寿司盘是循环的，需要遍历2 * n - 1次来确保每个寿司盘都能找到它右边的第一个更便宜的寿司盘。使用模运算来处理循环数组的索引。\n处理栈：在遍历过程中，对于每个价格，检查栈顶元素（即之前遍历过的价格）是否大于当前价格。如果是，则说明找到了一个更便宜的寿司盘，计算栈顶元素对应寿司盘的优惠价格并更新到结果数组res中，然后将该元素出栈。重复此过程直到栈为空或栈顶元素小于当前价格。第一轮遍历（即j < n时）将每个索引加入栈中。\n处理剩余元素：遍历结束后，栈中可能还有元素，这些元素代表它们右侧没有更小的价格，因此直接将它们的价格作为结果。\n整个解题思路利用了栈这一数据结构来有效地跟踪和更新每个寿司盘的优惠价格，通过一次遍历来优化算法的时间复杂度。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 使用Scanner从控制台读取输入\n        Scanner sc = new Scanner(System.in);\n        // 读取一行输入，按空格分割，然后将每个数字字符串转换为整数，并收集到数组中\n        int[] prices = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 获取寿司价格数组的长度，代表寿司盘数\n        int n = prices.length;\n        \n        // 创建一个数组来存储结果，即每个寿司盘享受优惠后的总价格\n        int[] res = new int[n];\n        // 创建一个双端队列作为栈使用，用于跟踪寿司价格的索引\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        // 遍历每个寿司盘的价格，由于寿司盘是循环的，需要遍历两倍长度减一次\n        for (int j = 0; j < n * 2 - 1; j++) {\n            // 计算当前索引，由于数组是循环的，使用模运算得到实际索引\n            int index = j % n;\n            // 当栈不为空且栈顶元素的价格大于当前索引对应的价格时\n            while (!stack.isEmpty() && prices[stack.peek()] > prices[index]) {\n                // 弹出栈顶元素的索引\n                int topIndex = stack.pop();\n                // 计算栈顶元素享受优惠后的价格，并更新结果数组\n                res[topIndex] = prices[topIndex] + prices[index];\n            }\n            // 第一轮遍历时，将索引压入栈中\n            if (j < n) {\n                stack.push(index);\n            }\n        }\n \n        // 遍历完成后，栈中剩余的元素代表它们右侧没有更小的价格\n        // 直接将它们自身的价格作为结果\n        while (!stack.isEmpty()) {\n            int topIndex = stack.pop();\n            res[topIndex] = prices[topIndex];\n        }\n\n        // 使用StringBuilder构建输出结果\n        StringBuilder sb = new StringBuilder();\n        for (int num : res) {\n            // 将每个价格添加到StringBuilder中，并加上空格\n            sb.append(num).append(\" \");\n        }\n        // 输出结果，并去除末尾的空格\n        System.out.println(sb.toString().trim());\n    }\n}",
      "python": "# 读取一行输入，按空格分割，然后将每个数字字符串转换为整数，并收集到列表中\nprices = list(map(int, input().split()))\n# 获取寿司价格列表的长度，代表寿司盘数\nn = len(prices)\n\n# 创建一个列表来存储结果，即每个寿司盘享受优惠后的总价格\nres = [0] * n\n# 创建一个列表作为栈使用，用于跟踪寿司价格的索引\nstack = []\n\n# 遍历每个寿司盘的价格，由于寿司盘是循环的，需要遍历两倍长度减一次\nfor j in range(n * 2 - 1):\n    # 计算当前索引，由于列表是循环的，使用模运算得到实际索引\n    index = j % n\n    # 当栈不为空且栈顶元素的价格大于当前索引对应的价格时\n    while stack and prices[stack[-1]] > prices[index]:\n        # 弹出栈顶元素的索引\n        top_index = stack.pop()\n        # 计算栈顶元素享受优惠后的价格，并更新结果列表\n        res[top_index] = prices[top_index] + prices[index]\n    # 第一轮遍历时，将索引压入栈中\n    if j < n:\n        stack.append(index)\n\n# 遍历完成后，栈中剩余的元素代表它们右侧没有更小的价格\n# 直接将它们自身的价格作为结果\nwhile stack:\n    top_index = stack.pop()\n    res[top_index] = prices[top_index]\n\n# 输出结果，每个价格后加上空格\nprint(' '.join(map(str, res)))",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <sstream>\n\nint main() {\n    // 使用iostream从控制台读取输入\n    std::string line;\n    std::getline(std::cin, line);\n    std::istringstream iss(line);\n\n    // 读取一行输入，按空格分割，然后将每个数字字符串转换为整数，并收集到vector中\n    std::vector<int> prices;\n    int price;\n    while (iss >> price) {\n        prices.push_back(price);\n    }\n\n    // 获取寿司价格数组的长度，代表寿司盘数\n    int n = prices.size();\n    \n    // 创建一个数组来存储结果，即每个寿司盘享受优惠后的总价格\n    std::vector<int> res(n, 0);\n    // 创建一个栈来跟踪寿司价格的索引\n    std::stack<int> stack;\n\n    // 遍历每个寿司盘的价格，由于寿司盘是循环的，需要遍历两倍长度减一次\n    for (int j = 0; j < n * 2 - 1; ++j) {\n        // 计算当前索引，由于数组是循环的，使用模运算得到实际索引\n        int index = j % n;\n        // 当栈不为空且栈顶元素的价格大于当前索引对应的价格时\n        while (!stack.empty() && prices[stack.top()] > prices[index]) {\n            // 弹出栈顶元素的索引\n            int topIndex = stack.top();\n            stack.pop();\n            // 计算栈顶元素享受优惠后的价格，并更新结果数组\n            res[topIndex] = prices[topIndex] + prices[index];\n        }\n        // 第一轮遍历时，将索引压入栈中\n        if (j < n) {\n            stack.push(index);\n        }\n    }\n\n    // 遍历完成后，栈中剩余的元素代表它们右侧没有更小的价格\n    // 直接将它们自身的价格作为结果\n    while (!stack.empty()) {\n        int topIndex = stack.top();\n        stack.pop();\n        res[topIndex] = prices[topIndex];\n    }\n\n    // 输出结果，每个价格后加上空格\n    for (int num : res) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n\n#define MAX_N 500\n\nint main() {\n    int prices[MAX_N]; // 创建一个数组，用于存储每盘寿司的价格\n    int n = 0; // 初始化寿司盘数为0\n\n    // 从控制台读取每盘寿司的价格，直到读取到换行符\n    while (scanf(\"%d\", &prices[n]) == 1) {\n        n++; // 每读取一个价格，寿司盘数加1\n    }\n\n    int res[MAX_N]; // 创建一个数组，用于存储每个寿司盘享受优惠后的总价格\n    int stack[MAX_N]; // 创建一个数组作为栈使用，用于跟踪寿司价格的索引\n    int top = -1; // 初始化栈顶指针为-1，表示栈为空\n\n    // 遍历每个寿司盘的价格，由于寿司盘是循环的，需要遍历两倍长度减一次\n    for (int j = 0; j < n * 2 - 1; j++) {\n        // 计算当前索引，由于数组是循环的，使用模运算得到实际索引\n        int index = j % n;\n        // 当栈不为空且栈顶元素的价格大于当前索引对应的价格时\n        while (top >= 0 && prices[stack[top]] > prices[index]) {\n            // 弹出栈顶元素的索引\n            int topIndex = stack[top--];\n            // 计算栈顶元素享受优惠后的价格，并更新结果数组\n            res[topIndex] = prices[topIndex] + prices[index];\n        }\n        // 第一轮遍历时，将索引压入栈中\n        if (j < n) {\n            stack[++top] = index;\n        }\n    }\n\n    // 遍历完成后，栈中剩余的元素代表它们右侧没有更小的价格\n    // 直接将它们自身的价格作为结果\n    while (top >= 0) {\n        int topIndex = stack[top--];\n        res[topIndex] = prices[topIndex];\n    }\n\n    // 输出每个寿司盘享受优惠后的总价格\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", res[i]);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "56",
    "title": "运维日志排序",
    "examType": "A",
    "score": 100,
    "description": "[运维工程师]采集到某产品线网运行一天产生的日志n条，现需根据日志时间先后顺序对日志进行排序，日志时间格式为H:M:S.N。\nH表示小时(0~23)M表示分钟(0~59)S表示秒(0~59)N表示毫秒(0~999)\n时间可能并没有补全，也就是说，01:01:01.001也可能表示为1:1:1.1。",
    "inputDesc": "第一行输入一个整数n表示日志条数，1<=n<=100000，接下来n行输入n个时间。",
    "outputDesc": "按时间升序排序之后的时间，如果有两个时间表示的时间相同，则保持输入顺序。",
    "examples": [
      {
        "input": ":41:8.9\n:1:09.211",
        "output": ":1:09.211\n:41:8.9",
        "explanation": ""
      },
      {
        "input": ":41:08.023\n:1:09.211\n:01:22.0",
        "output": ":1:09.211\n:01:22.0\n:41:08.023",
        "explanation": ""
      },
      {
        "input": ":41:08.023\n:41:08.23",
        "output": ":41:08.023\n:41:08.23",
        "explanation": "说明 两个时间表示的时间相同，保持输入顺序"
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\nimport java.util.regex.*;\n\npublic class Main {\n    \n    /* 将时间字符串转换为毫秒数 */\npublic static int convertToMillisecond(String timeStr) {\n    Pattern pattern = Pattern.compile(\"(\\\\d+):(\\\\d+):(\\\\d+).(\\\\d+)\");\n    Matcher matcher = pattern.matcher(timeStr);\n    return matcher.find() ? ((Integer.parseInt(matcher.group(1)) * 60 + Integer.parseInt(matcher.group(2))) * 60 + Integer.parseInt(matcher.group(3))) * 1000 + Integer.parseInt(matcher.group(4)) : 0;\n}\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<String> logs = new ArrayList<>();\n        int n = scanner.nextInt();\n        scanner.nextLine(); // 忽略换行符\n        for (int i = 0; i < n; i++) {\n            String log = scanner.nextLine();\n            logs.add(log);\n        }\n        /* 日志排序 */\n        Collections.sort(logs, new Comparator<String>() {\n            public int compare(String log1, String log2) {\n                int time1 = convertToMillisecond(log1);\n                int time2 = convertToMillisecond(log2);\n                return time1 - time2;\n            }\n        });\n        for (String log : logs) {\n            System.out.println(log);\n        }\n    }\n}",
      "python": "import re\n\ndef convertToMillisecond(timeStr):\n    hour, minute, second, millisecond = map(int, re.findall(r'\\d+', timeStr))\n    return hour * 60 * 60 * 1000 + minute * 60 * 1000 + second * 1000 + millisecond\nlogs = []\nn = int(input())\n\nfor i in range(n):\n    log = input()\n    logs.append(log)\n\n# 日志排序\nlogs.sort(key=lambda log: convertToMillisecond(log))\n\nfor log in logs:\n    print(log)",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst logs = [];\nlet n;\n\nrl.on('line', (input) => {\n  if (!n) {\n    n = parseInt(input);\n  } else {\n    logs.push(input);\n  }\n\n  if (logs.length === n) {\n    /* 日志排序 */\n    logs.sort((log1, log2) => {\n      const time1 = convertToMillisecond(log1);\n      const time2 = convertToMillisecond(log2);\n      return time1 < time2 ? -1 : 1;\n    });\n\n    for (const log of logs) {\n      console.log(log);\n    }\n\n    rl.close();\n  }\n});\n\nfunction convertToMillisecond(timeStr) {\n  const match = timeStr.match(/(\\d+):(\\d+):(\\d+).(\\d+)/);\n  return (parseInt(match[1]) * 3600000) + (parseInt(match[2]) * 60000) + (parseInt(match[3]) * 1000) + parseInt(match[4]);\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <regex>\n#include <algorithm>\n\nusing namespace std;\n\nint convertToMillisecond(string timeStr) {\n    regex pattern(\"(\\\\d+):(\\\\d+):(\\\\d+).(\\\\d+)\");\n    smatch matcher;\n    return regex_search(timeStr, matcher, pattern) ? ((stoi(matcher[1]) * 60 + stoi(matcher[2])) * 60 + stoi(matcher[3])) * 1000 + stoi(matcher[4]) : 0;\n}\nint main() {\n    vector<string> logs;\n    int n;\n    cin >> n;\n    cin.ignore(); // 忽略换行符\n    for (int i = 0; i < n; i++) {\n        string log;\n        getline(cin, log);\n        logs.push_back(log);\n    }\n    /* 日志排序 */\n    sort(logs.begin(), logs.end(), [](const string& log1, const string& log2) {\n        int time1 = convertToMillisecond(log1);\n        int time2 = convertToMillisecond(log2);\n        return time1 < time2;\n    });\n    for (const string& log : logs) {\n        cout << log << endl;\n    }\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* 将时间字符串转换为毫秒数 */\nint convertToMillisecond(const char *timeStr) {\n    int hours = 0, minutes = 0, seconds = 0, milliseconds = 0;\n    sscanf(timeStr, \"%d:%d:%d.%d\", &hours, &minutes, &seconds, &milliseconds);\n    return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;\n}\n\n/* 比较函数，用于qsort */\nint compare(const void *a, const void *b) {\n    const char **log1 = (const char **)a;\n    const char **log2 = (const char **)b;\n    \n    int time1 = convertToMillisecond(*log1);\n    int time2 = convertToMillisecond(*log2);\n    \n    return time1 - time2;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar(); // 忽略换行符\n\n    char **logs = (char **)malloc(n * sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        logs[i] = (char *)malloc(50 * sizeof(char)); // 假设每个时间字符串长度不超过50\n        fgets(logs[i], 50, stdin);\n        \n        // 去除fgets输入中的换行符\n        logs[i][strcspn(logs[i], \"\\n\")] = '\\0';\n    }\n\n    /* 对日志进行排序 */\n    qsort(logs, n, sizeof(char *), compare);\n\n    /* 输出排序后的日志 */\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", logs[i]);\n        free(logs[i]); // 释放每个日志字符串的内存\n    }\n    free(logs); // 释放日志指针数组的内存\n\n    return 0;\n}"
    }
  },
  {
    "id": "57",
    "title": "选修课",
    "examType": "A",
    "score": 100,
    "description": "现有两门选修课，每门选修课都有一部分学生选修，每个学生都有选修课的成绩，需要你找出同时选修了两门选修课的学生，先按照班级进行划分，班级编号小的先输出，每个班级按照两门选修课成绩和的降序排序，成绩相同时按照学生的学号升序排序。",
    "inputDesc": "第一行为第一门选修课学生的成绩，\n第二行为第二门选修课学生的成绩，每行数据中学生之间以英文分号分隔，每个学生的学号和成绩以英文逗号分隔，\n学生学号的格式为8位数字(2位院系编号+入学年份后2位+院系内部1位专业编号+所在班级3位学号)，\n学生成绩的取值范围为[0,100]之间的整数，\n两门选修课选修学生数的取值范围为[1-2000]之间的整数。",
    "outputDesc": "同时选修了两门选修课的学生的学号，如果没有同时选修两门选修课的学生输出NULL，\n否则，先按照班级划分，班级编号小的先输出，每个班级先输出班级编号(学号前五位)，然后另起一行输出这个班级同时选修两门选修课的学生学号，学号按照要求排序(按照两门选修课成绩和的降序，成绩和相同时按照学号升序)，学生之间以英文分号分隔。",
    "examples": [
      {
        "input": ",75;01201033,95;01202008,80;01203006,90;01203088,100\n,70;01203088,85;01202111,80;01202021,75;01201100,88",
        "output": ";01202021",
        "explanation": "同时选修了两门选修课的学生01202021、01202008、01203088，这三个学生两门选修课的成绩和分别为150、150、185，01202021、01202008属于01202班的学生，按照成绩和降序，成绩相同时按学号升序输出的结果为01202008;01202021,01203088属于01203班的学生，按照成绩和降序，成绩相同时按学号升序输出的结果为01203088，01202的班级编号小于01203的班级编号，需要先输出。"
      },
      {
        "input": ",75;01202033,95;01202018,80;01203006,90;01202066,100\n,70;01203102,85;01202111,80;01201021,75;01201100,88",
        "output": "NULL",
        "explanation": "没有同时选修了两门选修课的学生，输出NULL。"
      }
    ],
    "solution": "题目要求我们处理两个选修课的学生成绩数据，并找出同时选修了两门选修课的学生。然后按照以下规则输出结果：\n班级划分：学生学号的前五位代表班级编号，需要先按班级进行划分，班级编号小的先输出。排序规则：每个班级内部按照两门选修课成绩之和的降序排序。如果成绩和相同，则按照学号升序排序。\n第一行是第一门选修课的学生成绩，每个学生的学号和成绩用英文逗号分隔，学生之间用英文分号分隔。第二行是第二门选修课的学生成绩，格式同上。学生的学号是8位数字，表示： 前两位是院系编号，第3和第4位是入学年份，第5位是院系内部的专业编号，第6到第8位是班级学号。\n前两位是院系编号，第3和第4位是入学年份，第5位是院系内部的专业编号，第6到第8位是班级学号。\n本题题目不难，就是拆解用例比较烦！",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n    static class Student {\n        String studentId; // 学生学号\n        String classId; // 班级编号\n        int score1 = -1; // 第一门选修课成绩\n        int score2 = -1; // 第二门选修课成绩\n\n        public int getSumScore() { // 计算两门选修课成绩和\n            return this.score1 + this.score2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String scores1 = sc.nextLine(); // 第一门选修课学生的成绩\n        String scores2 = sc.nextLine(); // 第二门选修课学生的成绩\n        HashMap<String, Student> students = new HashMap<>(); // 存储学生信息的HashMap\n        divide(scores1, 1, students); // 将第一门选修课学生成绩划分到HashMap中\n        divide(scores2, 2, students); // 将第二门选修课学生成绩划分到HashMap中\n        Student[] selectedStudents = students.values().stream().filter(stu -> stu.score1 != -1 && stu.score2 != -1)\n                .toArray(Student[]::new); // 选取同时选修了两门选修课的学生\n        if (selectedStudents.length == 0) {\n            System.out.println(\"NULL\"); // 如果没有同时选修两门选修课的学生，则输出NULL\n            return;\n        }\n        HashMap<String, ArrayList<Student>> ans = new HashMap<>(); // 存储按班级划分的学生信息的HashMap\n        for (Student stu : selectedStudents) {\n            ans.putIfAbsent(stu.classId, new ArrayList<>()); // 如果班级还没有被加入HashMap中，则加入\n            ans.get(stu.classId).add(stu); // 将学生加入对应班级的ArrayList中\n        }\n        ans.keySet().stream().sorted(String::compareTo).forEach(classId -> {\n            System.out.println(classId); // 先输出班级编号\n            ArrayList<Student> studentsInClass = ans.get(classId);\n            studentsInClass.sort((a, b) -> a.getSumScore() != b.getSumScore() ? b.getSumScore() - a.getSumScore()\n                    : a.studentId.compareTo(b.studentId)); // 按照成绩和的降序和学号的升序排序\n            StringJoiner sj = new StringJoiner(\";\"); // 用于拼接学生学号的StringJoiner\n            for (Student student : studentsInClass)\n                sj.add(student.studentId); // 将学生学号加入StringJoiner中\n            System.out.println(sj); // 输出学生学号\n        });\n    }\n\n    public static void divide(String str, int courseId, HashMap<String, Student> students) {\n        for (String sub : str.split(\";\")) {\n            String[] tmp = sub.split(\",\");\n            String studentId = tmp[0]; // 学生学号\n            String classId = studentId.substring(0, 5); // 班级编号\n            int score = Integer.parseInt(tmp[1]); // 选修课成绩\n            students.putIfAbsent(studentId, new Student()); // 如果学生还没有被加入HashMap中，则加入\n            Student stu = students.get(studentId);\n            stu.studentId = studentId;\n            stu.classId = classId;\n            if (courseId == 1)\n                stu.score1 = score; // 将第一门选修课成绩加入学生对象中\n            else\n                stu.score2 = score; // 将第二门选修课成绩加入学生对象中\n        }\n    }\n}",
      "python": "class Student:\n    def __init__(self):\n        self.studentId = \"\"  # 学生学号\n        self.classId = \"\"  # 班级编号\n        self.score1 = -1  # 第一门选修课成绩\n        self.score2 = -1  # 第二门选修课成绩\n\n    def getSumScore(self):  # 计算两门选修课成绩和\n        return self.score1 + self.score2\n\n\ndef divide(str, courseId, students):\n    for sub in str.split(\";\"):\n        tmp = sub.split(\",\")\n        studentId = tmp[0]  # 学生学号\n        classId = studentId[:5]  # 班级编号\n        score = int(tmp[1])  # 选修课成绩\n        if studentId not in students:\n            students[studentId] = Student()  # 如果学生还没有被加入HashMap中，则加入\n        stu = students[studentId]\n        stu.studentId = studentId\n        stu.classId = classId\n        if courseId == 1:\n            stu.score1 = score  # 将第一门选修课成绩加入学生对象中\n        else:\n            stu.score2 = score  # 将第二门选修课成绩加入学生对象中\n\n\nscores1 = input()  # 第一门选修课学生的成绩\nscores2 = input()  # 第二门选修课学生的成绩\nstudents = {}  # 存储学生信息的字典\ndivide(scores1, 1, students)  # 将第一门选修课学生成绩划分到字典中\ndivide(scores2, 2, students)  # 将第二门选修课学生成绩划分到字典中\nselectedStudents = [stu for stu in students.values() if stu.score1 != -1 and stu.score2 != -1]  # 选取同时选修了两门选修课的学生\nif len(selectedStudents) == 0:\n    print(\"NULL\")  # 如果没有同时选修两门选修课的学生，则输出NULL\nelse:\n    ans = {}  # 存储按班级划分的学生信息的字典\n    for stu in selectedStudents:\n        if stu.classId not in ans:\n            ans[stu.classId] = []  # 如果班级还没有被加入字典中，则加入\n        ans[stu.classId].append(stu)  # 将学生加入对应班级的列表中\n    for classId in sorted(ans.keys()):\n        print(classId)  # 先输出班级编号\n        studentsInClass = ans[classId]\n        studentsInClass.sort(key=lambda stu: (-stu.getSumScore(), stu.studentId))  # 按照成绩和的降序和学号的升序排序\n        studentIds = [stu.studentId for stu in studentsInClass]  # 学生学号列表\n        print(\";\".join(studentIds))  # 输出学生学号",
      "javascript": "const readline = require('readline');\n\nclass Student {\n  constructor() {\n    this.studentId = \"\"; // 学生学号\n    this.classId = \"\"; // 班级编号\n    this.score1 = -1; // 第一门选修课成绩\n    this.score2 = -1; // 第二门选修课成绩\n  }\n\n  getSumScore() { // 计算两门选修课成绩和\n    return this.score1 + this.score2;\n  }\n}\n\nfunction divide(str, courseId, students) {\n  for (let sub of str.split(\";\")) {\n    let tmp = sub.split(\",\");\n    let studentId = tmp[0]; // 学生学号\n    let classId = studentId.slice(0, 5); // 班级编号\n    let score = parseInt(tmp[1]); // 选修课成绩\n    if (!(studentId in students)) {\n      students[studentId] = new Student(); // 如果学生还没有被加入HashMap中，则加入\n    }\n    let stu = students[studentId];\n    stu.studentId = studentId;\n    stu.classId = classId;\n    if (courseId === 1) {\n      stu.score1 = score; // 将第一门选修课成绩加入学生对象中\n    } else {\n      stu.score2 = score; // 将第二门选修课成绩加入学生对象中\n    }\n  }\n}\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (scores1) => {\n  rl.on('line', (scores2) => {\n    let students = {}; // 存储学生信息的字典\n    divide(scores1, 1, students); // 将第一门选修课学生成绩划分到字典中\n    divide(scores2, 2, students); // 将第二门选修课学生成绩划分到字典中\n    let selectedStudents = Object.values(students).filter(stu => stu.score1 !== -1 && stu.score2 !== -1); // 选取同时选修了两门选修课的学生\n    if (selectedStudents.length === 0) {\n      console.log(\"NULL\"); // 如果没有同时选修两门选修课的学生，则输出NULL\n    } else {\n      let ans = {}; // 存储按班级划分的学生信息的字典\n      for (let stu of selectedStudents) {\n        if (!(stu.classId in ans)) {\n          ans[stu.classId] = []; // 如果班级还没有被加入字典中，则加入\n        }\n        ans[stu.classId].push(stu); // 将学生加入对应班级的列表中\n      }\n      for (let classId of Object.keys(ans).sort()) {\n        console.log(classId); // 先输出班级编号\n        let studentsInClass = ans[classId];\n        studentsInClass.sort((a, b) => (b.getSumScore() - a.getSumScore()) || (a.studentId.localeCompare(b.studentId))); // 按照成绩和的降序和学号的升序排序\n        let studentIds = studentsInClass.map(stu => stu.studentId); // 学生学号列表\n        console.log(studentIds.join(\";\")); // 输出学生学号\n      }\n    }\n    rl.close();\n  });\n});",
      "cpp": "#include <iostream>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct Student {\n    string id;\n    int score;\n    Student(const string& id, int score) : id(id), score(score) {}\n    bool operator<(const Student& other) const {\n        return score != other.score ? score > other.score : id < other.id;\n    }\n};\n\nint main() {\n    string line_one, line_two;\n    getline(cin, line_one);\n    getline(cin, line_two);\n\n    map<string, int> tIds;\n    stringstream ss(line_two);\n    string token;\n    while (getline(ss, token, ';')) {\n        vector<string> tStu;\n        stringstream ss2(token);\n        while (getline(ss2, token, ',')) {\n            tStu.push_back(token);\n        }\n        tIds[tStu[0]] = stoi(tStu[1]);\n    }\n\n    map<string, set<Student>> map;\n    stringstream ss3(line_one);\n    while (getline(ss3, token, ';')) {\n        vector<string> sStu;\n        stringstream ss4(token);\n        while (getline(ss4, token, ',')) {\n            sStu.push_back(token);\n        }\n        const string& sId = sStu[0];\n        if (tIds.count(sId)) {\n            const int totalScore = stoi(sStu[1]) + tIds[sId];\n            const string cls = sId.substr(0, 5);\n            map[cls].emplace(sId, totalScore);\n        }\n    }\n\n    if (map.empty()) {\n        cout << \"NULL\\n\";\n    } else {\n        for (const auto& [key, value] : map) {\n            cout << key << \"\\n\";\n            string res;\n            for (const auto& student : value) {\n                res += student.id + \";\";\n            }\n            res.pop_back(); \n            cout << res << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_STUDENTS 2000\n#define ID_LEN 10\n#define CLASS_ID_LEN 6\n\n// 学生结构体，包含学生学号、班级编号、两门选修课的成绩\ntypedef struct {\n    char studentId[ID_LEN]; // 学生学号\n    char classId[CLASS_ID_LEN]; // 班级编号\n    int score1; // 第一门选修课成绩\n    int score2; // 第二门选修课成绩\n} Student;\n\n// 用于存储学生信息的全局数组\nStudent students[MAX_STUDENTS];\nint student_count = 0; // 学生数量\n\n// 按照总成绩降序，学号升序比较函数\nint compare_students(const void* a, const void* b) {\n    Student* s1 = (Student*)a;\n    Student* s2 = (Student*)b;\n    int sum1 = s1->score1 + s1->score2;\n    int sum2 = s2->score1 + s2->score2;\n    if (sum1 != sum2) {\n        return sum2 - sum1; // 按照总成绩降序排列\n    } else {\n        return strcmp(s1->studentId, s2->studentId); // 如果成绩相同则按照学号升序排列\n    }\n}\n\n// 通过分割字符串，将学生成绩导入到结构体中\nvoid divide(const char* str, int courseId) {\n    char buffer[10000];\n    strcpy(buffer, str); // 输入字符串以便修改\n    char* token = strtok(buffer, \";\"); // 按分号分割字符串\n\n    while (token != NULL) {\n        char studentId[ID_LEN];\n        int score;\n        sscanf(token, \"%[^,],%d\", studentId, &score); // 解析学号和成绩\n\n        // 查找是否已存在该学生\n        int found = 0;\n        for (int i = 0; i < student_count; i++) {\n            if (strcmp(students[i].studentId, studentId) == 0) {\n                found = 1;\n                if (courseId == 1) {\n                    students[i].score1 = score; // 记录第一门课程成绩\n                } else {\n                    students[i].score2 = score; // 记录第二门课程成绩\n                }\n                break;\n            }\n        }\n\n        // 如果没有找到该学生，则新建学生\n        if (!found) {\n            strcpy(students[student_count].studentId, studentId);\n            strncpy(students[student_count].classId, studentId, 5); // 班级编号为学号前五位\n            students[student_count].classId[5] = '\\0'; // 确保字符串正确结束\n            if (courseId == 1) {\n                students[student_count].score1 = score; // 设置第一门课成绩\n                students[student_count].score2 = -1;    // 第二门课成绩未设定\n            } else {\n                students[student_count].score1 = -1;    // 第一门课成绩未设定\n                students[student_count].score2 = score; // 设置第二门课成绩\n            }\n            student_count++;\n        }\n\n        token = strtok(NULL, \";\"); // 继续分割下一个学生记录\n    }\n}\n\nint main() {\n    char line_one[10000], line_two[10000];\n\n    // 读取两行输入，第一行是第一门选修课成绩，第二行是第二门选修课成绩\n    fgets(line_one, sizeof(line_one), stdin);\n    fgets(line_two, sizeof(line_two), stdin);\n\n    // 处理第一门和第二门课程的学生成绩\n    divide(line_one, 1);\n    divide(line_two, 2);\n\n    // 创建按班级分类的数组\n    Student selectedStudents[MAX_STUDENTS];\n    int selected_count = 0;\n\n    // 筛选出同时选修了两门课程的学生\n    for (int i = 0; i < student_count; i++) {\n        if (students[i].score1 != -1 && students[i].score2 != -1) {\n            selectedStudents[selected_count++] = students[i];\n        }\n    }\n\n    // 如果没有找到符合条件的学生，则输出 \"NULL\"\n    if (selected_count == 0) {\n        printf(\"NULL\\n\");\n        return 0;\n    }\n\n    // 对筛选出的学生按照班级编号和成绩进行分类和排序\n    qsort(selectedStudents, selected_count, sizeof(Student), compare_students);\n\n    // 输出学生信息，按班级分组\n    char current_class[CLASS_ID_LEN] = \"\";\n    for (int i = 0; i < selected_count; i++) {\n        // 如果当前学生的班级不同于上一个，则输出班级编号\n        if (strcmp(current_class, selectedStudents[i].classId) != 0) {\n            if (i > 0) printf(\"\\n\"); // 换行符\n            strcpy(current_class, selectedStudents[i].classId);\n            printf(\"%s\\n\", current_class); // 输出班级编号\n        }\n\n        // 输出学生学号\n        if (i > 0 && strcmp(current_class, selectedStudents[i - 1].classId) == 0) {\n            printf(\";\"); // 同一班级中的学号之间使用分号隔开\n        }\n        printf(\"%s\", selectedStudents[i].studentId);\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
    }
  },
  {
    "id": "58",
    "title": "预订酒店",
    "examType": "A",
    "score": 100,
    "description": "放暑假了，小明决定到某旅游景点游玩，他在网上搜索到了各种价位的酒店（长度为n的数组A），他的心理价位是x元，请帮他筛选出k个最接近x元的酒店（n>=k>0）,并由低到高打印酒店的价格。",
    "inputDesc": "第一行：n, k, x 第二行：A[0] A[1] A[2]…A[n-1]",
    "outputDesc": "从低到高打印筛选出的酒店价格",
    "examples": [
      {
        "input": "5 6\n 2 3 4 5 6 7 8 9 10",
        "output": "5 6 7 8",
        "explanation": ""
      },
      {
        "input": "3 1000\n 30 200 500 70 300",
        "output": "300 500",
        "explanation": ""
      }
    ],
    "solution": "第一行包含三个整数 n、k 和 x： n：酒店价格数组的长度，即有 n 个酒店。k：需要选择的最接近心理价位 x 的酒店数量。x：用户的心理价位。 第二行是酒店价格数组 A，其中 A[0] 到 A[n-1] 代表不同酒店的价格。\nn：酒店价格数组的长度，即有 n 个酒店。k：需要选择的最接近心理价位 x 的酒店数量。x：用户的心理价位。\n\n示例 1 输入： 10 5 6 1 2 3 4 5 6 7 8 9 10 12 解释： 用户心理价位是 6。每个价格与 6 的差距分别是：5，4，3，2，1，0，1，2，3，4。按差距排序后，最接近的 5 个价格为：4，5，6，7，8。最终输出为：4 5 6 7 8。 示例 2 输入： 10 4 6 10 9 8 7 6 5 4 3 2 1 12 解释： 用户心理价位是 6。每个价格与 6 的差距分别是：4，3，2，1，0，1，2，3，4，5。按差距排序后，最接近的 4 个价格为：4，5，6，7。最终输出为：4 5 6 7。 示例 3 输入： 6 3 1000 30 30 200 500 70 300 12 解释： 用户心理价位是 1000。每个价格与 1000 的差距分别是：970，970，800，500，930，700。按差距排序后，最接近的 3 个价格为：200，300，500。最终输出为：200 300 500。\n示例 1 输入：\n12\n解释：\n用户心理价位是 6。每个价格与 6 的差距分别是：5，4，3，2，1，0，1，2，3，4。按差距排序后，最接近的 5 个价格为：4，5，6，7，8。最终输出为：4 5 6 7 8。\n示例 2 输入：\n12\n解释：\n用户心理价位是 6。每个价格与 6 的差距分别是：4，3，2，1，0，1，2，3，4，5。按差距排序后，最接近的 4 个价格为：4，5，6，7。最终输出为：4 5 6 7。\n示例 3 输入：\n12\n解释：\n用户心理价位是 1000。每个价格与 1000 的差距分别是：970，970，800，500，930，700。按差距排序后，最接近的 3 个价格为：200，300，500。最终输出为：200 300 500。\n优先选择价格最接近心理价位的酒店，若两家酒店和心理价位差价相同，则选择价格较低的酒店。(比如100元和300元距离心理价位200元同样接近，此时选择100元)酒店价格可能相同重复",
    "codes": {
      "java": "import java.util.Scanner;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.stream.Collectors;\n\nclass Main {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // 输入酒店数量、需要选择的酒店数量、心理价位\n        int n = scanner.nextInt(); // 酒店的数量\n        int k = scanner.nextInt(); // 需要选择的最接近心理价位的酒店数量\n        int x = scanner.nextInt(); // 心理价位\n        \n        // 输入酒店价格并存入数组\n        int[] A = new int[n]; // 酒店价格数组\n        for (int i = 0; i < n; i++) {\n            A[i] = scanner.nextInt(); // 读取每一个酒店价格\n        }\n        \n        // 将酒店价格数组从小到大排序\n        Arrays.sort(A);\n \n        // 创建一个二维数组，存储每个酒店价格以及它与心理价位的差距\n        int[][] priceDiff = new int[n][2]; // 二维数组，第一列是酒店价格，第二列是与心理价位的差值\n        for (int i = 0; i < n; i++) {\n            int price = A[i]; // 获取当前酒店的价格\n            priceDiff[i][0] = price; // 存储酒店价格\n            priceDiff[i][1] = Math.abs(price - x); // 计算并存储酒店价格与心理价位的绝对差值\n        }\n \n        // 使用 Java 流进行排序，根据差值从小到大排序\n        List<int[]> sortedPrices = Arrays.stream(priceDiff)\n            .sorted(Comparator.comparingInt(h -> h[1])) // 按与心理价位的差值进行排序\n            .collect(Collectors.toList()); // 将排序结果转化为 List\n \n        // 创建一个列表，存储前 k 个最接近心理价位的酒店价格\n        List<Integer> selectedPrices = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            selectedPrices.add(sortedPrices.get(i)[0]); // 选取排序后的前 k 个酒店价格\n        }\n \n        // 将挑选出的酒店价格从小到大排序\n        selectedPrices.sort(Integer::compareTo); // 按照酒店价格从小到大排序\n \n        // 按顺序打印 k 个酒店价格，并用空格分隔\n        for (int i = 0; i < selectedPrices.size(); i++) {\n            System.out.print(selectedPrices.get(i)); // 打印酒店价格\n            if (i != selectedPrices.size() - 1) { // 如果不是最后一个元素，则打印空格\n                System.out.print(\" \");\n            }\n        }\n    }\n}",
      "python": "n, k, x = map(int, input().split())\nprices = list(map(int, input().split()))\n\nsorted_prices = sorted(prices)\nprice_rating = sorted([(price, abs(price - x)) for price in sorted_prices], key=lambda item: item[1])\npicked_price = sorted(item[0] for item in price_rating[:k])\n\nprint(' '.join(map(str, picked_price)))",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (input) => {\n  const [n, k, x] = input.split(' ').map(Number);\n  let prices = [];\n  rl.on('line', (input) => {\n    prices = input.split(' ').map(Number);\n    const sortedPrices = prices.sort((a, b) => a - b);\n    const priceRating = sortedPrices.map(price => [price, Math.abs(price - x)]).sort((a, b) => a[1] - b[1]);\n    const pickedPrice = priceRating.slice(0, k).map(item => item[0]).sort((a, b) => a - b);\n    console.log(pickedPrice.join(' '));\n  });\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/* 自定义排序函数，按照酒店价格与目标价位的差值从小到大排序 */\nbool cmp(pair<int, int> x, pair<int, int> y)\n{\n    return x.second < y.second;\n}\n\nint main()\n{\n    int n, k, x;\n    cin >> n >> k >> x; // 输入酒店数量n、需要选择的酒店数量k和目标价位x\n    vector<int> prices(n);\n    for (int i = 0; i < n; i++)\n    {\n        cin >> prices[i]; // 输入每个酒店的价格\n    }\n    sort(prices.begin(), prices.end()); // 将酒店价格从小到大排序\n    vector<pair<int, int>> price_rating;\n    for (int i = 0; i < prices.size(); i++)\n    {\n        price_rating.push_back(make_pair(prices[i], abs(prices[i] - x))); // 计算每个酒店价格与目标价位的差值，并存入pair中\n    }\n    sort(price_rating.begin(), price_rating.end(), cmp); // 按照差值从小到大排序\n\n    vector<int> picked_price;\n    for (int i = 0; i < k; i++)\n    {\n        picked_price.push_back(price_rating[i].first); // 取出差值最小的k个酒店的价格\n    }\n    sort(picked_price.begin(), picked_price.end()); // 将选出的酒店价格从小到大排序\n\n    for (int i = 0; i < picked_price.size(); i++)\n    {\n        cout << picked_price[i]; // 输出选出的酒店价格\n        if (i != picked_price.size() - 1)\n        {\n            cout << \" \"; // 输出空格，除了最后一个酒店价格\n        }\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 1000 // 假设酒店数量的最大值为1000\n\n// 定义结构体来存储酒店价格与目标价位差值\ntypedef struct {\n    int price;   // 酒店价格\n    int diff;    // 酒店价格与目标价位的差值\n} Hotel;\n\n// 自定义排序函数，按照酒店价格与目标价位的差值从小到大排序\nint cmp(const void* a, const void* b) {\n    Hotel* hotelA = (Hotel*)a;\n    Hotel* hotelB = (Hotel*)b;\n    return hotelA->diff - hotelB->diff;\n}\n\n// 比较函数，用于排序酒店价格从小到大\nint cmp_price(const void* a, const void* b) {\n    return (*(int*)a) - (*(int*)b);\n}\n\nint main() {\n    int n, k, x;\n    scanf(\"%d %d %d\", &n, &k, &x); // 输入酒店数量n、需要选择的酒店数量k和目标价位x\n\n    int prices[MAX_N]; // 酒店价格数组\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &prices[i]); // 输入每个酒店的价格\n    }\n\n    // 对酒店价格从小到大排序\n    qsort(prices, n, sizeof(int), cmp_price);\n\n    Hotel price_rating[MAX_N]; // 存储酒店价格和与目标价位的差值的数组\n    for (int i = 0; i < n; i++) {\n        price_rating[i].price = prices[i]; // 存储酒店价格\n        price_rating[i].diff = abs(prices[i] - x); // 计算酒店价格与目标价位的差值\n    }\n\n    // 根据差值对酒店价格进行排序\n    qsort(price_rating, n, sizeof(Hotel), cmp);\n\n    int picked_price[MAX_N]; // 选出的k个酒店价格\n    for (int i = 0; i < k; i++) {\n        picked_price[i] = price_rating[i].price; // 取出差值最小的k个酒店的价格\n    }\n\n    // 将选出的k个酒店价格从小到大排序\n    qsort(picked_price, k, sizeof(int), cmp_price);\n\n    // 输出选出的酒店价格\n    for (int i = 0; i < k; i++) {\n        printf(\"%d\", picked_price[i]);\n        if (i != k - 1) {\n            printf(\" \"); // 输出空格，除了最后一个酒店价格\n        }\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "59",
    "title": "高矮个子排队",
    "examType": "A",
    "score": 100,
    "description": "现在有一队小朋友，他们高矮不同，我们以正整数数组表示这一队小朋友的身高，如数组{5,3,1,2,3}。\n我们现在希望小朋友排队，以“高”“矮”“高”“矮”顺序排列，每一个“高”位置的小朋友要比相邻的位置高或者相等；每一个“矮”位置的小朋友要比相邻的位置矮或者相等；\n要求小朋友们移动的距离和最小，第一个从“高”位开始排，输出最小移动距离即可。\n例如，在示范小队{5,3,1,2,3}中，{5, 1, 3, 2, 3}是排序结果。\n{5, 2, 3, 1, 3} 虽然也满足“高”“矮”“高”“矮”顺序排列，但小朋友们的移动距离大，所以不是最优结果。\n移动距离的定义如下所示：\n第二位小朋友移到第三位小朋友后面，移动距离为1，若移动到第四位小朋友后面，移动距离为2；",
    "inputDesc": "排序前的小朋友，以英文空格的正整数：\n4 3 5 7 8\n注：小朋友<100个",
    "outputDesc": "排序后的小朋友，以英文空格分割的正整数：4 3 7 5 8\n备注：4（高）3（矮）7（高）5（矮）8（高）， 输出结果为最小移动距离，只有5和7交换了位置，移动距离都是1。",
    "examples": [
      {
        "input": "1 3 5 2",
        "output": "4 1 5 2 3",
        "explanation": ""
      },
      {
        "input": "1 1 1 1",
        "output": "1 1 1 1",
        "explanation": "相邻位置可以相等"
      },
      {
        "input": "xxx",
        "output": "[ ]",
        "explanation": "出现非法参数情况， 返回空数组。"
      }
    ],
    "solution": "这道题看似简单，但看完题目可能会觉得不止这么简单。因为要保证移动距离最小，这意味着可能存在多种情况需要多次比较。不过，实际并没有那么复杂。\n比如在用例1中，乍一看好像有点问题：直接让5和2交换位置，得到的结果是：4 1 3 2 5，这样也符合题意，而且移动距离只有1，似乎更符合要求。\n然而，这样想的同学可能忽略了题目中的一句关键提示：“第一个从‘高’位开始排”。这句话的意思是，我们只需要从第一个小朋友开始排列，并在发现不符合要求的排队顺序时，就进行交换。这样大大降低了题目难度。\n为了实现将小朋友的身高按照“高矮交替”的顺序排列，代码中使用了以下判断条件：\n1\n这个条件可以分成两个部分来解释：\nheights[i] != heights[j]： 这个条件确保只在两个相邻的小朋友身高不相等的情况下才进行进一步的判断。如果两个小朋友的身高相等，那么无需交换位置，因为它们已经符合“高矮交替”的要求。 (heights[i] > heights[j]) != (i % 2 == 0)： 这个条件用于检查当前的排列是否符合“高矮交替”的要求。i % 2 == 0：判断当前索引 i 是否为偶数。根据题目的要求，如果 i 是偶数位置，那么我们期望 heights[i] > heights[j]，即当前小朋友的身高应该高于下一个小朋友的身高。如果 i 是奇数位置，我们期望 heights[i] < heights[j]。(heights[i] > heights[j]) != (i % 2 == 0)：这一部分的意思是： 如果 i 是偶数，那么期望 heights[i] > heights[j]。如果此时 heights[i] > heights[j] 为 true，与 i % 2 == 0 的结果相同，所以条件成立，说明不需要交换。如果 i 是奇数，那么期望 heights[i] < heights[j]。如果此时 heights[i] > heights[j] 为 false，与 i % 2 == 0 的结果相反，条件成立，说明不需要交换。如果实际情况与期望情况不符（即 heights[i] > heights[j] 和 i 的奇偶性不一致），那么 (heights[i] > heights[j]) != (i % 2 == 0) 结果为 true，表示当前排列不符合要求，需要交换 heights[i] 和 heights[j]。\nheights[i] != heights[j]：\n这个条件确保只在两个相邻的小朋友身高不相等的情况下才进行进一步的判断。如果两个小朋友的身高相等，那么无需交换位置，因为它们已经符合“高矮交替”的要求。\n(heights[i] > heights[j]) != (i % 2 == 0)：\n这个条件用于检查当前的排列是否符合“高矮交替”的要求。i % 2 == 0：判断当前索引 i 是否为偶数。根据题目的要求，如果 i 是偶数位置，那么我们期望 heights[i] > heights[j]，即当前小朋友的身高应该高于下一个小朋友的身高。如果 i 是奇数位置，我们期望 heights[i] < heights[j]。(heights[i] > heights[j]) != (i % 2 == 0)：这一部分的意思是： 如果 i 是偶数，那么期望 heights[i] > heights[j]。如果此时 heights[i] > heights[j] 为 true，与 i % 2 == 0 的结果相同，所以条件成立，说明不需要交换。如果 i 是奇数，那么期望 heights[i] < heights[j]。如果此时 heights[i] > heights[j] 为 false，与 i % 2 == 0 的结果相反，条件成立，说明不需要交换。如果实际情况与期望情况不符（即 heights[i] > heights[j] 和 i 的奇偶性不一致），那么 (heights[i] > heights[j]) != (i % 2 == 0) 结果为 true，表示当前排列不符合要求，需要交换 heights[i] 和 heights[j]。\n如果 i 是偶数，那么期望 heights[i] > heights[j]。如果此时 heights[i] > heights[j] 为 true，与 i % 2 == 0 的结果相同，所以条件成立，说明不需要交换。如果 i 是奇数，那么期望 heights[i] < heights[j]。如果此时 heights[i] > heights[j] 为 false，与 i % 2 == 0 的结果相反，条件成立，说明不需要交换。如果实际情况与期望情况不符（即 heights[i] > heights[j] 和 i 的奇偶性不一致），那么 (heights[i] > heights[j]) != (i % 2 == 0) 结果为 true，表示当前排列不符合要求，需要交换 heights[i] 和 heights[j]。",
    "codes": {
      "java": "import java.util.*;   \n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);   \n        String s = sc.nextLine();   \n\n        // 使用正则表达式检查输入字符串是否只包含数字和空格\n        // 如果字符串中包含非法字符（非数字或空格），则输出\"[]\"并退出程序\n        if (!s.matches(\"[0-9\\\\s]+\")) {\n            System.out.println(\"[]\");\n            return;\n        }\n\n        // 将输入字符串按空格分割，并将每个部分转换为整数，存储在数组heights中\n        int[] heights = Arrays.stream(s.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        // 初始化两个指针i和j，分别指向相邻的两个小朋友\n        int i = 0, j = 1;\n\n        // 遍历数组，调整相邻小朋友的身高顺序以满足\"高矮交替\"的要求\n        while (j < heights.length) {\n            // 判断当前两个相邻小朋友的身高是否满足要求\n            // 条件解释：如果heights[i] > heights[j]且i是偶数，或者heights[i] < heights[j]且i是奇数\n            // 则需要交换heights[i]和heights[j]的值，以符合\"高矮交替\"的规则\n            if (heights[i] != heights[j] && (heights[i] > heights[j]) != (i % 2 == 0)) {\n                // 交换heights[i]和heights[j]的值\n                int tmp = heights[i];\n                heights[i] = heights[j];\n                heights[j] = tmp;\n            }\n\n            // 移动指针，检查下一个相邻的小朋友\n            i++;\n            j++;\n        }\n\n        // 使用StringJoiner将排序后的身高数组转换为字符串，并以空格分隔\n        StringJoiner sj = new StringJoiner(\" \");\n        for (int h : heights) {  // 遍历heights数组中的每一个元素\n            sj.add(String.valueOf(h));  // 将元素转换为字符串并添加到StringJoiner中\n        }\n        // 输出最终排序结果\n        System.out.println(sj.toString());\n    }\n}",
      "python": "import re\n\ns = input()\nif not re.match(r\"[0-9\\s]+\", s):\n    print(\"[]\")\n    exit()\n\nheights = list(map(int, s.split()))\n\ni = 0\nj = 1\n\nwhile j < len(heights):\n    if heights[i] != heights[j] and (heights[i] > heights[j]) != (i % 2 == 0):\n        heights[i], heights[j] = heights[j], heights[i]\n        \n    i += 1\n    j += 1\n\nresult = \" \".join(map(str, heights))\nprint(result)",
      "javascript": "const readline = require('readline');\n\n \nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n \nrl.on('line', (s) => {\n    // 使用正则表达式检查输入字符串是否只包含数字和空格\n    // 如果字符串中包含非法字符（非数字或空格），则输出\"[]\"并退出程序\n    if (!/^[0-9\\s]+$/.test(s)) {\n        console.log(\"[]\");\n        rl.close();  // 关闭接口\n        return;\n    }\n\n    // 将输入字符串按空格分割，并将每个部分转换为整数，存储在数组heights中\n    let heights = s.split(' ').map(Number);\n\n    // 初始化两个指针i和j，分别指向相邻的两个小朋友\n    let i = 0, j = 1;\n\n    // 遍历数组，调整相邻小朋友的身高顺序以满足\"高矮交替\"的要求\n    while (j < heights.length) {\n        // 判断当前两个相邻小朋友的身高是否满足要求\n        // 条件解释：如果heights[i] > heights[j]且i是偶数，或者heights[i] < heights[j]且i是奇数\n        // 则需要交换heights[i]和heights[j]的值，以符合\"高矮交替\"的规则\n        if (heights[i] !== heights[j] && (heights[i] > heights[j]) !== (i % 2 === 0)) {\n            // 交换heights[i]和heights[j]的值\n            [heights[i], heights[j]] = [heights[j], heights[i]];\n        }\n\n        // 移动指针，检查下一个相邻的小朋友\n        i++;\n        j++;\n    }\n\n    // 将排序后的身高数组转换为字符串，并以空格分隔\n    console.log(heights.join(' '));\n\n    \n});",
      "cpp": "#include <iostream>    // 包含输入输出流库\n#include <sstream>     // 包含字符串流库，用于处理字符串\n#include <string>      // 包含字符串库\n#include <vector>      // 包含向量库，用于动态数组\nusing namespace std;\n\nint main() {\n    string s;\n    // 从标准输入读取一行字符串，存储在变量s中\n    getline(cin, s);\n\n    // 检查输入字符串中是否包含非数字或空格的字符\n    // 如果发现非法字符（非数字或空格），则输出\"[]\"并退出程序\n    if (s.find_first_not_of(\"0123456789 \") != string::npos) {\n        cout << \"[]\" << endl;\n        return 0;\n    }\n\n    // 使用字符串流将字符串s按空格分割，并依次转化为整数存入向量heights中\n    istringstream iss(s);\n    vector<int> heights;  // 定义一个整型向量用于存储小朋友的身高\n    int height;\n    while (iss >> height) {  // 从字符串流中读取一个整数，并存入heights向量\n        heights.push_back(height);\n    }\n\n    // 初始化两个索引i和j，分别指向相邻的两个小朋友\n    int i = 0, j = 1;\n    while (j < heights.size()) {  // 遍历向量，直到处理完所有元素\n        // 检查当前两个相邻位置是否满足\"高矮高矮\"的排列要求\n        // 如果heights[i] > heights[j] 且 i 是偶数，或者 heights[i] < heights[j] 且 i 是奇数\n        // 则说明当前排列不符合要求，需要交换两个元素的位置\n        if (heights[i] != heights[j] && (heights[i] > heights[j]) != (i % 2 == 0)) {\n            // 交换 heights[i] 和 heights[j] 的值\n            int tmp = heights[i];\n            heights[i] = heights[j];\n            heights[j] = tmp;\n        }\n        // 移动索引i和j，继续检查下一个相邻的元素对\n        i++;\n        j++;\n    }\n\n    // 将调整后的向量heights中的元素转换为字符串，准备输出\n    string result;\n    for (int h : heights) {  // 遍历向量中的每一个元素\n        result += to_string(h) + \" \";  // 将元素转换为字符串并拼接到result中，以空格分隔\n    }\n    result.pop_back();  // 移除最后一个多余的空格\n    cout << result << endl;  // 输出最终的排列结果\n\n    return 0;  // 程序结束\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n// 函数声明\nint is_valid_input(const char* s);\nint* split_and_convert(const char* s, int* size);\nvoid swap(int* a, int* b);\n\nint main() {\n    char s[1024];\n    fgets(s, sizeof(s), stdin);  // 读取用户输入\n\n    // 检查输入字符串是否只包含数字和空格\n    if (!is_valid_input(s)) {\n        printf(\"[]\\n\");\n        return 0;\n    }\n\n    int size;\n    int* heights = split_and_convert(s, &size);  // 将输入字符串分割并转换为整数数组\n\n    // 初始化两个指针i和j，分别指向相邻的两个小朋友\n    int i = 0, j = 1;\n\n    // 遍历数组，调整相邻小朋友的身高顺序以满足\"高矮交替\"的要求\n    while (j < size) {\n        // 判断当前两个相邻小朋友的身高是否满足要求\n        // 条件解释：如果heights[i] > heights[j]且i是偶数，或者heights[i] < heights[j]且i是奇数\n        // 则需要交换heights[i]和heights[j]的值，以符合\"高矮交替\"的规则\n        if (heights[i] != heights[j] && (heights[i] > heights[j]) != (i % 2 == 0)) {\n            // 交换heights[i]和heights[j]的值\n            swap(&heights[i], &heights[j]);\n        }\n\n        // 移动指针，检查下一个相邻的小朋友\n        i++;\n        j++;\n    }\n\n    // 输出最终排序结果\n    for (int k = 0; k < size; k++) {\n        if (k > 0) {\n            printf(\" \");\n        }\n        printf(\"%d\", heights[k]);\n    }\n    printf(\"\\n\");\n\n    free(heights);  // 释放动态分配的内存\n    return 0;\n}\n\n// 检查输入字符串是否只包含数字和空格\nint is_valid_input(const char* s) {\n    while (*s) {\n        if (!isdigit(*s) && !isspace(*s)) {\n            return 0;  // 非法字符\n        }\n        s++;\n    }\n    return 1;\n}\n\n// 将输入字符串按空格分割并转换为整数数组\nint* split_and_convert(const char* s, int* size) {\n    int* heights = malloc(1024 * sizeof(int));  // 假设数组最大长度为1024\n    *size = 0;\n\n    char* token = strtok(strdup(s), \" \");\n    while (token != NULL) {\n        heights[(*size)++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n    return heights;\n}\n\n// 交换两个整数的值\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}"
    }
  },
  {
    "id": "60",
    "title": "虚拟理财游戏",
    "examType": "A",
    "score": 100,
    "description": "在一款虚拟游戏中生活，你必须进行投资以增强在虚拟游戏中的资产以免被淘汰出局。\n现有一家Bank，它提供有若干理财产品 m 个，风险及投资回报不同，你有 N（元）进行投资，能接收的总风险值为X。\n你要在可接受范围内选择最优的投资方式获得最大回报。\n备注：\n在虚拟游戏中，每项投资风险值相加为总风险值；在虚拟游戏中，最多只能投资2个理财产品；在虚拟游戏中，最小单位为整数，不能拆分为小数；投资额*回报率=投资回报",
    "inputDesc": "第一行：\n产品数（取值范围[1,20]） 总投资额（整数，取值范围[1, 10000]） 可接受的总风险（整数，取值范围[1,200]）\n产品数（取值范围[1,20]）\n总投资额（整数，取值范围[1, 10000]）\n可接受的总风险（整数，取值范围[1,200]）\n第二行：产品投资回报率序列，输入为整数，取值范围[1,60]\n第三行：产品风险值序列，输入为整数，取值范围[1, 100]\n第四行：最大投资额度序列，输入为整数，取值范围[1, 10000]",
    "outputDesc": "每个产品的投资额序列",
    "examples": [
      {
        "input": "100 10\n 20 30 40 50\n 4 5 6 10\n 30 20 40 30",
        "output": "30 0 40 0",
        "explanation": "投资第二项30个单位，第四项40个单位，总的投资风险为两项相加为4+6=10"
      }
    ],
    "solution": "在满足总风险不超过容忍度和总投资额不超过预算的前提下，通过遍历选择单个或两个理财产品的组合来最大化投资回报。\n伪代码如下：\n初始化最大回报值为0。遍历所有理财产品： a. 如果单个产品的风险值和投资额均不超过限制，考虑其回报值。 b. 更新最大回报值。再次遍历所有理财产品组合（两两配对）： a. 如果两个产品的风险值之和和投资额之和均不超过限制，考虑这两个产品的回报值之和。 b. 更新最大回报值。返回最大回报值。",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建Scanner对象用于获取用户输入\n        Scanner sc = new Scanner(System.in);\n        // 读取一行输入并将其分割为字符串数组，然后转换为整数数组\n        int[] tmp = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 获取投资项目数量m、总投资额N和风险容忍度X\n        int m = tmp[0];\n        int N = tmp[1];\n        int X = tmp[2];\n        // 读取每个项目的预期回报率\n        int[] returns = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 读取每个项目的风险值\n        int[] risks = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 读取每个项目的最大投资额\n        int[] maxInvestments = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        // 初始化最大回报为0\n        int maxReturn = 0;\n        // 初始化最大回报对应的投资方案数组\n        int[] bestInvestments = new int[m];\n\n        // 遍历所有项目\n        for (int i = 0; i < m; i++) {\n            // 如果单个项目的风险在容忍度范围内\n            if (risks[i] <= X) {\n                // 计算对项目i的投资额，不超过总投资额N和项目i的最大投资额\n                int investmentForI = Math.min(N, maxInvestments[i]);\n                // 计算当前回报\n                int currentReturn = investmentForI * returns[i];\n                // 如果当前回报大于已知的最大回报\n                if (currentReturn > maxReturn) {\n                    // 更新最大回报\n                    maxReturn = currentReturn;\n                    // 重置最佳投资方案数组，并为项目i分配投资额\n                    bestInvestments = new int[m];\n                    bestInvestments[i] = investmentForI;\n                }\n            }\n\n            // 遍历项目i之后的项目，寻找两个项目的组合投资方案\n            for (int j = i + 1; j < m; j++) {\n                // 如果两个项目的风险总和在容忍度范围内\n                if (risks[i] + risks[j] <= X) {\n                    int investmentForI, investmentForJ;\n                    // 根据预期回报率决定投资额分配\n                    if (returns[i] > returns[j]) {\n                        // 如果项目i的回报率高于项目j，优先投资项目i\n                        investmentForI = Math.min(N, maxInvestments[i]);\n                        investmentForJ = Math.min(N - investmentForI, maxInvestments[j]);\n                    } else {\n                        // 如果项目j的回报率高于项目i，优先投资项目j\n                        investmentForJ = Math.min(N, maxInvestments[j]);\n                        investmentForI = Math.min(N - investmentForJ, maxInvestments[i]);\n                    }\n                    // 计算当前两个项目组合的回报\n                    int currentReturn = investmentForI * returns[i] + investmentForJ * returns[j];\n                    // 如果当前回报大于已知的最大回报\n                    if (currentReturn > maxReturn) {\n                        // 更新最大回报\n                        maxReturn = currentReturn;\n                        // 重置最佳投资方案数组，并为两个项目分配投资额\n                        bestInvestments = new int[m];\n                        bestInvestments[i] = investmentForI;\n                        bestInvestments[j] = investmentForJ;\n                    }\n                }\n            }\n        }\n\n        // 创建StringJoiner对象，用于构建输出格式\n        StringJoiner sj = new StringJoiner(\" \");\n        // 遍历最佳投资方案数组，将投资额添加到StringJoiner中\n        for (int investment : bestInvestments) {\n            sj.add(String.valueOf(investment));\n        }\n\n        // 输出最佳投资方案\n        System.out.println(sj.toString());\n        // 关闭Scanner对象\n        sc.close();\n    }\n}",
      "python": "import sys\n\n# 读取一行输入并将其转换为整数列表的函数\ndef read_int_array():\n    # 使用input()替换sys.stdin.readline()以适应在线编译器\n    return list(map(int, input().split()))\n\n# 读取投资项目数量m、总投资额N和风险容忍度X\nm, N, X = read_int_array()\n# 读取每个项目的预期回报率\nreturns = read_int_array()\n# 读取每个项目的风险值\nrisks = read_int_array()\n# 读取每个项目的最大投资额\nmax_investments = read_int_array()\n\n# 初始化最大回报为0\nmax_return = 0\n# 初始化最大回报对应的投资方案列表\nbest_investments = [0] * m\n\n# 遍历所有项目\nfor i in range(m):\n    # 检查项目i的风险是否在容忍度X以内\n    if risks[i] <= X:\n        # 计算项目i的投资额，不超过总投资额N和项目i的最大投资额\n        investment_for_i = min(N, max_investments[i])\n        # 计算当前项目的回报\n        current_return = investment_for_i * returns[i]\n        # 如果当前回报大于已知的最大回报\n        if current_return > max_return:\n            # 更新最大回报\n            max_return = current_return\n            # 重置最佳投资方案列表，并为项目i分配投资额\n            best_investments = [0] * m\n            best_investments[i] = investment_for_i\n\n    # 遍历项目i之后的项目，寻找两个项目的组合投资方案\n    for j in range(i + 1, m):\n        # 如果两个项目的风险总和在容忍度范围内\n        if risks[i] + risks[j] <= X:\n            # 根据预期回报率决定投资额分配\n            if returns[i] > returns[j]:\n                # 如果项目i的回报率高于项目j，优先投资项目i\n                investment_for_i = min(N, max_investments[i])\n                # 计算项目j的剩余可投资额\n                investment_for_j = min(N - investment_for_i, max_investments[j])\n            else:\n                # 如果项目j的回报率高于项目i，优先投资项目j\n                investment_for_j = min(N, max_investments[j])\n                # 计算项目i的剩余可投资额\n                investment_for_i = min(N - investment_for_j, max_investments[i])\n            # 计算两个项目组合的当前回报\n            current_return = investment_for_i * returns[i] + investment_for_j * returns[j]\n            # 如果当前回报大于已知的最大回报\n            if current_return > max_return:\n                # 更新最大回报\n                max_return = current_return\n                # 重置最佳投资方案列表，并为两个项目分配投资额\n                best_investments = [0] * m\n                best_investments[i] = investment_for_i\n                best_investments[j] = investment_for_j\n\n# 输出最佳投资方案\nprint(' '.join(map(str, best_investments)))",
      "javascript": "const readline = require('readline');\n\n// 创建readline接口实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 用于存储输入行的数组\nconst lines = [];\n\n// 读取输入行的事件监听\nrl.on('line', (line) => {\n  lines.push(line);\n}).on('close', () => {\n  // 当输入完成时，开始处理数据\n\n  // 读取一行输入并将其转换为整数数组的函数\n  const readIntArray = (line) => line.split(' ').map(Number);\n\n  // 读取投资项目数量m、总投资额N和风险容忍度X\n  const [m, N, X] = readIntArray(lines[0]);\n  // 读取每个项目的预期回报率\n  const returns = readIntArray(lines[1]);\n  // 读取每个项目的风险值\n  const risks = readIntArray(lines[2]);\n  // 读取每个项目的最大投资额\n  const maxInvestments = readIntArray(lines[3]);\n\n  // 初始化最大回报为0\n  let maxReturn = 0;\n  // 初始化最大回报对应的投资方案数组\n  let bestInvestments = new Array(m).fill(0);\n\n  // 遍历所有项目\n  for (let i = 0; i < m; i++) {\n    // 检查项目i的风险是否在容忍度X以内\n    if (risks[i] <= X) {\n      // 计算项目i的投资额，不超过总投资额N和项目i的最大投资额\n      const investmentForI = Math.min(N, maxInvestments[i]);\n      // 计算当前项目的回报\n      const currentReturn = investmentForI * returns[i];\n      // 如果当前回报大于已知的最大回报\n      if (currentReturn > maxReturn) {\n        // 更新最大回报\n        maxReturn = currentReturn;\n        // 重置最佳投资方案数组，并为项目i分配投资额\n        bestInvestments = new Array(m).fill(0);\n        bestInvestments[i] = investmentForI;\n      }\n    }\n\n    // 遍历项目i之后的项目，寻找两个项目的组合投资方案\n    for (let j = i + 1; j < m; j++) {\n      // 如果两个项目的风险总和在容忍度范围内\n      if (risks[i] + risks[j] <= X) {\n        let investmentForI, investmentForJ;\n        // 根据预期回报率决定投资额分配\n        if (returns[i] > returns[j]) {\n          // 如果项目i的回报率高于项目j，优先投资项目i\n          investmentForI = Math.min(N, maxInvestments[i]);\n          // 计算项目j的剩余可投资额\n          investmentForJ = Math.min(N - investmentForI, maxInvestments[j]);\n        } else {\n          // 如果项目j的回报率高于项目i，优先投资项目j\n          investmentForJ = Math.min(N, maxInvestments[j]);\n          // 计算项目i的剩余可投资额\n          investmentForI = Math.min(N - investmentForJ, maxInvestments[i]);\n        }\n        // 计算两个项目组合的当前回报\n        const currentReturn = investmentForI * returns[i] + investmentForJ * returns[j];\n        // 如果当前回报大于已知的最大回报\n        if (currentReturn > maxReturn) {\n          // 更新最大回报\n          maxReturn = currentReturn;\n          // 重置最佳投资方案数组，并为两个项目分配投资额\n          bestInvestments = new Array(m).fill(0);\n          bestInvestments[i] = investmentForI;\n          bestInvestments[j] = investmentForJ;\n        }\n      }\n    }\n  }\n\n  // 输出最佳投资方案\n  console.log(bestInvestments.join(' '));\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nvector<int> readIntArray() {\n    string line;\n    getline(cin, line); // 读取一行输入\n    istringstream iss(line);\n    vector<int> numbers;\n    int num;\n    while (iss >> num) { // 将字符串分割并转换为整数数组\n        numbers.push_back(num);\n    }\n    return numbers;\n}\n\nint main() {\n    // 读取投资项目数量m、总投资额N和风险容忍度X\n    vector<int> tmp = readIntArray();\n    int m = tmp[0], N = tmp[1], X = tmp[2];\n    // 读取每个项目的预期回报率\n    vector<int> returns = readIntArray();\n    // 读取每个项目的风险值\n    vector<int> risks = readIntArray();\n    // 读取每个项目的最大投资额\n    vector<int> maxInvestments = readIntArray();\n\n    // 初始化最大回报为0\n    int maxReturn = 0;\n    // 初始化最大回报对应的投资方案数组\n    vector<int> bestInvestments(m, 0);\n\n    // 遍历所有项目\n    for (int i = 0; i < m; i++) {\n        // 如果单个项目的风险在容忍度范围内\n        if (risks[i] <= X) {\n            // 计算对项目i的投资额，不超过总投资额N和项目i的最大投资额\n            int investmentForI = min(N, maxInvestments[i]);\n            // 计算当前回报\n            int currentReturn = investmentForI * returns[i];\n            // 如果当前回报大于已知的最大回报\n            if (currentReturn > maxReturn) {\n                // 更新最大回报\n                maxReturn = currentReturn;\n                // 重置最佳投资方案数组，并为项目i分配投资额\n                fill(bestInvestments.begin(), bestInvestments.end(), 0);\n                bestInvestments[i] = investmentForI;\n            }\n        }\n\n        // 遍历项目i之后的项目，寻找两个项目的组合投资方案\n        for (int j = i + 1; j < m; j++) {\n            // 如果两个项目的风险总和在容忍度范围内\n            if (risks[i] + risks[j] <= X) {\n                int investmentForI, investmentForJ;\n                // 根据预期回报率决定投资额分配\n                if (returns[i] > returns[j]) {\n                    // 如果项目i的回报率高于项目j，优先投资项目i\n                    investmentForI = min(N, maxInvestments[i]);\n                    investmentForJ = min(N - investmentForI, maxInvestments[j]);\n                } else {\n                    // 如果项目j的回报率高于项目i，优先投资项目j\n                    investmentForJ = min(N, maxInvestments[j]);\n                    investmentForI = min(N - investmentForJ, maxInvestments[i]);\n                }\n                // 计算当前两个项目组合的回报\n                int currentReturn = investmentForI * returns[i] + investmentForJ * returns[j];\n                // 如果当前回报大于已知的最大回报\n                if (currentReturn > maxReturn) {\n                    // 更新最大回报\n                    maxReturn = currentReturn;\n                    // 重置最佳投资方案数组，并为两个项目分配投资额\n                    fill(bestInvestments.begin(), bestInvestments.end(), 0);\n                    bestInvestments[i] = investmentForI;\n                    bestInvestments[j] = investmentForJ;\n                }\n            }\n        }\n    }\n\n    // 输出最佳投资方案\n    for (int investment : bestInvestments) {\n        cout << investment << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>  // 导入标准输入输出库，用于输入输出\n#include <string.h> // 导入字符串操作库，用于处理字符串\n\n#define MAX_PRODUCTS 20 // 定义最大产品数量常量\n\n// 用于读取整数数组的函数\nvoid readIntArray(int *arr, int size) {\n    for (int i = 0; i < size; i++) {\n        scanf(\"%d\", &arr[i]); // 循环读取输入的整数并存储到数组中\n    }\n}\n\nint min(int a, int b) {\n    return a < b ? a : b; // 返回两个整数中较小的一个\n}\n\nint main() {\n    int m, N, X; // 分别代表产品数、总投资额和可接受的总风险\n    scanf(\"%d %d %d\", &m, &N, &X); // 读取这三个值\n\n    int returns[MAX_PRODUCTS]; // 存储每个产品的投资回报率\n    readIntArray(returns, m); // 读取投资回报率\n\n    int risks[MAX_PRODUCTS]; // 存储每个产品的风险值\n    readIntArray(risks, m); // 读取风险值\n\n    int maxInvestments[MAX_PRODUCTS]; // 存储每个产品的最大投资额度\n    readIntArray(maxInvestments, m); // 读取最大投资额度\n\n    int maxReturn = 0; // 初始化最大回报为0\n    int bestInvestments[MAX_PRODUCTS] = {0}; // 初始化最佳投资方案数组，初始值全为0\n\n    // 遍历所有产品，尝试找到最佳的投资组合\n    for (int i = 0; i < m; i++) {\n        // 如果单个产品的风险在可接受范围内\n        if (risks[i] <= X) {\n            // 计算对产品i的投资额，不超过总投资额N和产品i的最大投资额\n            int investmentForI = min(N, maxInvestments[i]);\n            // 计算当前投资的回报\n            int currentReturn = investmentForI * returns[i];\n            // 如果当前回报大于已知的最大回报\n            if (currentReturn > maxReturn) {\n                maxReturn = currentReturn; // 更新最大回报\n                memset(bestInvestments, 0, sizeof(bestInvestments)); // 重置最佳投资方案数组\n                bestInvestments[i] = investmentForI; // 为产品i分配投资额\n            }\n        }\n\n        // 遍历产品i之后的产品，寻找两个产品的组合投资方案\n        for (int j = i + 1; j < m; j++) {\n            // 如果两个产品的风险总和在可接受范围内\n            if (risks[i] + risks[j] <= X) {\n                int investmentForI, investmentForJ;\n                // 根据回报率决定投资额分配\n                if (returns[i] > returns[j]) {\n                    // 如果产品i的回报率高于产品j，优先投资产品i\n                    investmentForI = min(N, maxInvestments[i]);\n                    investmentForJ = min(N - investmentForI, maxInvestments[j]);\n                } else {\n                    // 如果产品j的回报率高于产品i，优先投资产品j\n                    investmentForJ = min(N, maxInvestments[j]);\n                    investmentForI = min(N - investmentForJ, maxInvestments[i]);\n                }\n                // 计算当前两个产品组合的回报\n                int currentReturn = investmentForI * returns[i] + investmentForJ * returns[j];\n                // 如果当前回报大于已知的最大回报\n                if (currentReturn > maxReturn) {\n                    maxReturn = currentReturn; // 更新最大回报\n                    memset(bestInvestments, 0, sizeof(bestInvestments)); // 重置最佳投资方案数组\n                    bestInvestments[i] = investmentForI; // 为产品i分配投资额\n                    bestInvestments[j] = investmentForJ; // 为产品j分配投资额\n                }\n            }\n        }\n    }\n\n    // 输出最佳投资方案\n    for (int i = 0; i < m; i++) {\n        printf(\"%d \", bestInvestments[i]); // 打印每个产品的投资额\n    }\n    printf(\"\\n\"); // 打印换行符\n\n    return 0; // 程序结束\n}"
    }
  },
  {
    "id": "61",
    "title": "货币单位换算",
    "examType": "A",
    "score": 100,
    "description": "记账本上记录了若干条多国货币金额，需要转换成人民币分（fen），汇总后输出。 每行记录一条金额，金额带有货币单位，格式为数字+单位，可能是单独元，或者单独分，或者元与分的组合。 要求将这些货币全部换算成人民币分（fen）后进行汇总，汇总结果仅保留整数，小数部分舍弃。 元和分的换算关系都是1:100，如下：\n1CNY=100fen（1元=100分）1HKD=100cents（1港元=100港分）1JPY=100sen（1日元=100仙）1EUR=100eurocents（1欧元=100欧分）1GBP=100pence（1英镑=100便士）\n汇率表如下：\n即：100CNY = 1825JPY = 123HKD = 14EUR = 12GBP",
    "inputDesc": "第一行输入为N，N表示记录数。0<N<100\n之后N行，每行表示一条货币记录，且该行只会是一种货币。",
    "outputDesc": "将每行货币转换成人民币分（fen）后汇总求和，只保留整数部分。 输出格式只有整数数字，不带小数，不带单位。",
    "examples": [
      {
        "input": "CNY",
        "output": "",
        "explanation": "100CNY转换后是10000fen，所以输出结果为10000"
      },
      {
        "input": "fen",
        "output": "",
        "explanation": "3000fen，结果就是3000"
      },
      {
        "input": "HKD",
        "output": "",
        "explanation": "HKD与CNY的汇率关系是123:100，所以换算后，输出结果为10000"
      },
      {
        "input": "CNY53fen\nHKD87cents",
        "output": "",
        "explanation": "20元53分 + 53港元87港分，换算成人民币分后汇总，为6432"
      }
    ],
    "solution": "这题主要是拆解字符串，题目本身不难，按照题意写好分支判断即可。如果觉得代码复杂，可以考虑使用正则表达式来做。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class CurrencyConverter {\n\n    // 方法：根据货币单位返回其转换为人民币分的汇率\n    public static double exChange(String unit) {\n        switch (unit) {\n            case \"CNY\":\n                return 100.0; // 人民币\n            case \"JPY\":\n                return 100.0 / 1825 * 100; // 日元\n            case \"HKD\":\n                return 100.0 / 123 * 100; // 港元\n            case \"EUR\":\n                return 100.0 / 14 * 100; // 欧元\n            case \"GBP\":\n                return 100.0 / 12 * 100; // 英镑\n            case \"fen\":\n                return 1.0; // 人民币分\n            case \"cents\":\n                return 100.0 / 123; // 港元分\n            case \"sen\":\n                return 100.0 / 1825; // 日元分\n            case \"eurocents\":\n                return 100.0 / 14; // 欧元分\n            case \"pence\":\n                return 100.0 / 12; // 英镑分\n            default:\n                return 0.0; // 无效单位返回0\n        }\n    }\n \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in); // 创建Scanner对象用于读取输入\n        int n = Integer.parseInt(scanner.nextLine()); // 读取记录数\n       \n        \n        double totalFen = 0; // 汇总结果\n\n        // 处理每一条货币记录\n        for (int i = 0; i < n; i++) {\n            String record = scanner.nextLine(); // 读取每一行的记录\n            int amount = 0; // 用于保存金额\n            StringBuilder unit = new StringBuilder(); // 保存单位\n\n            // 遍历当前行，逐个提取金额和单位\n            for (int j = 0; j < record.length(); j++) {\n                char c = record.charAt(j);\n                if (Character.isDigit(c)) {\n                    amount = amount * 10 + (c - '0'); // 构建数字\n                } else {\n                    unit.append(c); // 构建货币单位\n                }\n\n                // 当遇到完整的金额+单位时进行换算\n                if (j == record.length() - 1 || Character.isDigit(record.charAt(j + 1)) && unit.length() > 0) {\n                    totalFen += amount * exChange(unit.toString()); // 计算并累加到总数\n                    amount = 0; // 重置金额\n                    unit.setLength(0); // 清空单位\n                }\n            }\n        }\n\n        // 输出汇总结果，只保留整数部分\n        System.out.println((int) totalFen);\n        scanner.close(); // 关闭Scanner对象\n    }\n}",
      "python": "def exChange(unit):\n    # 根据货币单位返回其转换为人民币分的汇率\n    if unit == \"CNY\":\n        return 100.0  # 人民币\n    elif unit == \"JPY\":\n        return 100.0 / 1825 * 100  # 日元\n    elif unit == \"HKD\":\n        return 100.0 / 123 * 100  # 港元\n    elif unit == \"EUR\":\n        return 100.0 / 14 * 100  # 欧元\n    elif unit == \"GBP\":\n        return 100.0 / 12 * 100  # 英镑\n    elif unit == \"fen\":\n        return 1.0  # 人民币分\n    elif unit == \"cents\":\n        return 100.0 / 123  # 港元分\n    elif unit == \"sen\":\n        return 100.0 / 1825  # 日元分\n    elif unit == \"eurocents\":\n        return 100.0 / 14  # 欧元分\n    elif unit == \"pence\":\n        return 100.0 / 12  # 英镑分\n    else:\n        return 0.0  # 无效单位返回0\n\n\ndef main():\n    n = int(input())  # 读取记录数\n    totalFen = 0.0  # 汇总结果\n\n    # 处理每一条货币记录\n    for _ in range(n):\n        record = input()  # 读取每一行的记录\n        amount = 0  # 用于保存金额\n        unit = \"\"  # 保存单位\n\n        # 遍历当前行，逐个提取金额和单位\n        for j, c in enumerate(record):\n            if c.isdigit():\n                amount = amount * 10 + int(c)  # 构建数字\n            else:\n                unit += c  # 构建货币单位\n\n            # 当遇到完整的金额+单位时进行换算\n            if j == len(record) - 1 or (j + 1 < len(record) and record[j + 1].isdigit() and unit):\n                totalFen += amount * exChange(unit)  # 计算并累加到总数\n                amount = 0  # 重置金额\n                unit = \"\"  # 清空单位\n\n    # 输出汇总结果，只保留整数部分\n    print(int(totalFen))\n\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "const readline = require('readline');\n\n// 根据货币单位返回其转换为人民币分的汇率\nfunction exChange(unit) {\n    switch (unit) {\n        case 'CNY':\n            return 100.0; // 人民币\n        case 'JPY':\n            return 100.0 / 1825 * 100; // 日元\n        case 'HKD':\n            return 100.0 / 123 * 100; // 港元\n        case 'EUR':\n            return 100.0 / 14 * 100; // 欧元\n        case 'GBP':\n            return 100.0 / 12 * 100; // 英镑\n        case 'fen':\n            return 1.0; // 人民币分\n        case 'cents':\n            return 100.0 / 123; // 港元分\n        case 'sen':\n            return 100.0 / 1825; // 日元分\n        case 'eurocents':\n            return 100.0 / 14; // 欧元分\n        case 'pence':\n            return 100.0 / 12; // 英镑分\n        default:\n            return 0.0; // 无效单位返回0\n    }\n}\n\n \nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n \nlet input = [];\nrl.on('line', (line) => {\n    input.push(line);\n}).on('close', () => {\n    const n = parseInt(input[0]); // 读取记录数\n    let totalFen = 0; // 汇总结果\n\n    // 处理每一条货币记录\n    for (let i = 1; i <= n; i++) {\n        const record = input[i];\n        let amount = 0; // 用于保存金额\n        let unit = ''; // 保存单位\n\n        // 遍历当前行，逐个提取金额和单位\n        for (let j = 0; j < record.length; j++) {\n            const c = record[j];\n            if (/\\d/.test(c)) {\n                amount = amount * 10 + parseInt(c); // 构建数字\n            } else {\n                unit += c; // 构建货币单位\n            }\n\n            // 当遇到完整的金额+单位时进行换算\n            if (j === record.length - 1 || (/\\d/.test(record[j + 1]) && unit.length > 0)) {\n                totalFen += amount * exChange(unit); // 计算并累加到总数\n                amount = 0; // 重置金额\n                unit = ''; // 清空单位\n            }\n        }\n    }\n\n    // 输出汇总结果，只保留整数部分\n    console.log(Math.floor(totalFen));\n});",
      "cpp": "#include <iostream>\n#include <string>\n#include <cctype> // 用于 isdigit 函数\n#include <sstream> // 用于 stringstream\n\nusing namespace std;\n\n// 根据货币单位返回其转换为人民币分的汇率\ndouble exChange(const string &unit) {\n    if (unit == \"CNY\") {\n        return 100.0; // 人民币\n    } else if (unit == \"JPY\") {\n        return 100.0 / 1825 * 100; // 日元\n    } else if (unit == \"HKD\") {\n        return 100.0 / 123 * 100; // 港元\n    } else if (unit == \"EUR\") {\n        return 100.0 / 14 * 100; // 欧元\n    } else if (unit == \"GBP\") {\n        return 100.0 / 12 * 100; // 英镑\n    } else if (unit == \"fen\") {\n        return 1.0; // 人民币分\n    } else if (unit == \"cents\") {\n        return 100.0 / 123; // 港元分\n    } else if (unit == \"sen\") {\n        return 100.0 / 1825; // 日元分\n    } else if (unit == \"eurocents\") {\n        return 100.0 / 14; // 欧元分\n    } else if (unit == \"pence\") {\n        return 100.0 / 12; // 英镑分\n    } else {\n        return 0.0; // 无效单位返回0\n    }\n}\n\nint main() {\n    int n;\n    cin >> n; // 读取记录数\n    cin.ignore(); // 忽略换行符\n\n    double totalFen = 0; // 汇总结果\n\n    // 处理每一条货币记录\n    for (int i = 0; i < n; i++) {\n        string record;\n        getline(cin, record); // 读取每一行的记录\n        int amount = 0; // 用于保存金额\n        string unit; // 保存单位\n\n        // 遍历当前行，逐个提取金额和单位\n        for (size_t j = 0; j < record.length(); j++) {\n            char c = record[j];\n            if (isdigit(c)) {\n                amount = amount * 10 + (c - '0'); // 构建数字\n            } else {\n                unit += c; // 构建货币单位\n            }\n\n            // 当遇到完整的金额+单位时进行换算\n            if (j == record.length() - 1 || (isdigit(record[j + 1]) && !unit.empty())) {\n                totalFen += amount * exChange(unit); // 计算并累加到总数\n                amount = 0; // 重置金额\n                unit.clear(); // 清空单位\n            }\n        }\n    }\n\n    // 输出汇总结果，只保留整数部分\n    cout << static_cast<int>(totalFen) << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n// 汇率转换函数，返回转换为人民币分的汇率\ndouble exChange(const char* unit) {\n    if (strcmp(unit, \"CNY\") == 0)\n        return 100.0; // 人民币元\n    else if (strcmp(unit, \"JPY\") == 0)\n        return 100.0 / 1825 * 100; // 日元\n    else if (strcmp(unit, \"HKD\") == 0)\n        return 100.0 / 123 * 100; // 港元\n    else if (strcmp(unit, \"EUR\") == 0)\n        return 100.0 / 14 * 100; // 欧元\n    else if (strcmp(unit, \"GBP\") == 0)\n        return 100.0 / 12 * 100; // 英镑\n    else if (strcmp(unit, \"fen\") == 0)\n        return 1.0; // 人民币分\n    else if (strcmp(unit, \"cents\") == 0)\n        return 100.0 / 123; // 港元分\n    else if (strcmp(unit, \"sen\") == 0)\n        return 100.0 / 1825; // 日元分\n    else if (strcmp(unit, \"eurocents\") == 0)\n        return 100.0 / 14; // 欧元分\n    else if (strcmp(unit, \"pence\") == 0)\n        return 100.0 / 12; // 英镑分\n    else\n        return 0.0; // 无效单位\n}\n\nint main() {\n    int n;  // 记录数\n    scanf(\"%d\", &n);  // 读取记录数\n    getchar();  // 读取换行符，避免影响后续输入\n\n    double totalFen = 0;  // 汇总结果（人民币分）\n\n    // 处理每一条货币记录\n    for (int i = 0; i < n; i++) {\n        char record[100];  // 保存输入的记录\n        fgets(record, 100, stdin);  // 读取整行记录\n\n        int amount = 0;  // 保存金额\n        char unit[20] = \"\";  // 保存货币单位\n        int len = strlen(record);\n\n        // 解析每一条记录\n        for (int j = 0; j < len; j++) {\n            char c = record[j];\n            if (isdigit(c)) {\n                amount = amount * 10 + (c - '0');  // 构建数字\n            } else if (isalpha(c)) {\n                int k = 0;\n                while (j < len && isalpha(record[j])) {\n                    unit[k++] = record[j++];  // 构建单位\n                }\n                unit[k] = '\\0';  // 添加字符串终止符\n                totalFen += amount * exChange(unit);  // 计算并累加\n                amount = 0;  // 重置金额\n                unit[0] = '\\0';  // 清空单位\n                j--;  // 回到当前字符（避免跳过字符）\n            }\n        }\n\n        \n    }\n\n    // 输出汇总结果，只保留整数部分\n    printf(\"%d\\n\", (int)totalFen);\n\n    return 0;\n}"
    }
  },
  {
    "id": "62",
    "title": "AI面板识别",
    "examType": "A",
    "score": 100,
    "description": "AI识别到面板上有N（1 ≤ N ≤ 100）个指示灯，灯大小一样，任意两个之间无重叠。\n由于AI识别误差，每次别到的指示灯位置可能有差异，以4个坐标值描述AI识别的指示灯的大小和位置(左上角x1,y1，右下角x2,y2)，\n请输出先行后列排序的指示灯的编号，排序规则：\n每次在尚未排序的灯中挑选最高的灯作为的基准灯，找出和基准灯属于同一行所有的灯进行排序。两个灯高低偏差不超过灯半径算同一行（即两个灯坐标的差 ≤ 灯高度的一半）。\n",
    "inputDesc": "第一行为N，表示灯的个数 接下来N行，每行为1个灯的坐标信息，格式为：\n编号 x1 y1 x2 y2\n编号全局唯一1 ≤ 编号 ≤ 1000 ≤ x1 < x2 ≤ 10000 ≤ y1 < y2 ≤ 1000\n",
    "outputDesc": "排序后的编号列表，编号之间以空格分隔\n\n\n\n题目给的图好像有问题，我画出来是\n\n按照题目意思，每次取出一个最高的灯（y坐标最小的），然后找出和最高灯坐标相差小于等于灯半径的，作为同一行，然后按照x轴坐标进行升序\n即存在如下用圈框住的三行，因此打印顺序是：1，2，3，4，5\n\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    Light[] lights = new Light[n];\n    for (int i = 0; i < n; i++) {\n      int id = sc.nextInt();\n      int x1 = sc.nextInt();\n      int y1 = sc.nextInt();\n      int x2 = sc.nextInt();\n      int y2 = sc.nextInt();\n      lights[i] = new Light(id, (x1 + x2) / 2, (y1 + y2) / 2, (x2 - x1) / 2);\n    }\n\n    System.out.println(getResult(lights));\n  }\n\n  public static String getResult(Light[] lights) {\n    // 按照圆心y坐标升序\n    Arrays.sort(lights, (a, b) -> a.y - b.y);\n\n    // ans记录题解\n    StringJoiner ans = new StringJoiner(\" \");\n\n    // sameRowLights记录同一行的灯\n    ArrayList<Light> sameRowLights = new ArrayList<>();\n    Light base = lights[0];\n    sameRowLights.add(base);\n\n    for (int i = 1; i < lights.length; i++) {\n      Light light = lights[i];\n\n      // 如果lights[i]的纵坐标和base的纵坐标相差不超过半径，则视为同一行\n      if (light.y - base.y <= base.r) {\n        sameRowLights.add(light);\n      } else {\n        // 否则，不是同一行\n        // 针对同一行的灯，再按照横坐标升序\n        sameRowLights.sort((a, b) -> a.x - b.x);\n        sameRowLights.forEach(a -> ans.add(a.id + \"\"));\n        sameRowLights.clear();\n\n        // 开始新的一行记录\n        base = light;\n        sameRowLights.add(base);\n      }\n    }\n\n    // 注意不要漏了最后一行\n    if (sameRowLights.size() > 0) {\n      sameRowLights.sort((a, b) -> a.x - b.x);\n      sameRowLights.forEach(a -> ans.add(a.id + \"\"));\n    }\n\n    return ans.toString();\n  }\n}\n\nclass Light {\n  int id; // 编号\n  int x; // 圆心横坐标\n  int y; // 圆心纵坐标\n  int r; // 圆半径\n\n  public Light(int id, int x, int y, int r) {\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n}",
      "python": "class Light:\n    def __init__(self, id, x, y, r):\n        self.id = id  # 编号\n        self.x = x  # 圆心横坐标\n        self.y = y  # 圆心纵坐标\n        self.r = r  # 圆半径\n\n\n# 输入获取\nn = int(input())\narr = [list(map(int, input().split())) for _ in range(n)]\nlights = list(map(lambda ele: Light(ele[0], (ele[1] + ele[3]) // 2, (ele[2] + ele[4]) // 2, (ele[3] - ele[1]) // 2), arr))\n\n\n# 算法入口\ndef getResult():\n    # 按照圆心y坐标升序\n    lights.sort(key=lambda l: l.y)\n\n    # ans记录题解\n    ans = []\n\n    # sameRowLights记录同一行的灯\n    sameRowLights = []\n    base = lights[0]\n    sameRowLights.append(base)\n\n    for i in range(1, len(lights)):\n        light = lights[i]\n\n        # 如果lights[i]的纵坐标和base的纵坐标相差不超过半径，则视为同一行\n        if light.y - base.y <= base.r:\n            sameRowLights.append(light)\n        else:\n            # 否则，不是同一行\n            # 针对同一行的灯，再按照横坐标升序\n            sameRowLights.sort(key=lambda l: l.x)\n            for l in sameRowLights:\n                ans.append(l.id)\n            sameRowLights.clear()\n\n            # 开始新的一行记录\n            base = light\n            sameRowLights.append(base)\n\n    # 注意不要漏了最后一行\n    if len(sameRowLights) > 0:\n        sameRowLights.sort(key=lambda l: l.x)\n        for l in sameRowLights:\n            ans.append(l.id)\n\n    return \" \".join(map(str, ans))\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "63",
    "title": "Linux发行版的数量",
    "examType": "A",
    "score": 100,
    "description": "Linux操作系统有多个发行版，distrowatch.com提供了各个发行版的资料。这些发行版互相存在关联，例如Ubuntu基于Debian开发，而Mint又基于Ubuntu开发，那么我们认为Mint同Debian也存在关联。\n发行版集是一个或多个相关存在关联的操作系统发行版，集合内不包含没有关联的发行版。\n给你一个 n * n 的矩阵 isConnected，其中 isConnected[i][j] = 1 表示第 i 个发行版和第 j 个发行版直接关联，而 isConnected[i][j] = 0 表示二者不直接相连。\n返回最大的发行版集中发行版的数量。\n",
    "inputDesc": "第一行输入发行版的总数量N，\n之后每行表示各发行版间是否直接相关\n",
    "outputDesc": "输出最大的发行版集中发行版的数量\n\n1 ≤ N ≤ 200\n\nDebian(1)和Unbuntu(2)相关\nMint(3)和Ubuntu(2)相关，\nEeulerOS(4)和另外三个都不相关，\n所以存在两个发行版集，发行版集中发行版的数量分别是3和1，所以输出3。\n\n本题可以利用并查集求解，本题要求的就是各个连通分量的节点数，并输出最大的连通分量的节点数。\n如果大家对并查集还不了解，可以看下这个入门视频：\n《算法训练营》进阶篇 01 并查集_哔哩哔哩_bilibili\n学会并查集数据结构后，本题的解题难度就很小了，本题题解可以参考\n华为OD机试 - 发广播_伏城之外的博客-CSDN博客_信道分配 华为od\n\n解决完本题，可以继续尝试2022.Q4题库的其他并查集算法题：\n华为OD机试 - 计算快递主站点_伏城之外的博客-CSDN博客\n华为OD机试 - 开心消消乐_伏城之外的博客-CSDN博客\n华为OD机试 - 机器人_伏城之外的博客-CSDN博客\n华为OD机试 - 快递业务站_伏城之外的博客-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    int[][] matrix = new int[n][n];\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    System.out.println(getResult(matrix, n));\n  }\n\n  public static int getResult(int[][] matrix, int n) {\n    UnionFindSet ufs = new UnionFindSet(n);\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) { // j从i+1开始，是因为矩阵是对称的\n        if (matrix[i][j] == 1) {\n          ufs.union(i, j);\n        }\n      }\n    }\n\n    // connected的key代表某个连通分量的顶级父节点，value代表该连通分量下的节点个数\n    HashMap<Integer, Integer> connected = new HashMap<>();\n\n    for (int i = 0; i < n; i++) {\n      Integer fa = ufs.find(ufs.fa[i]);\n      connected.put(fa, connected.getOrDefault(fa, 0) + 1);\n    }\n\n    // 返回最大节点数\n    return connected.values().stream().max((a, b) -> a - b).get();\n  }\n}\n\n// 并查集实现\nclass UnionFindSet {\n  int[] fa;\n  int count;\n\n  public UnionFindSet(int n) {\n    this.count = n;\n    this.fa = new int[n];\n    for (int i = 0; i < n; i++) this.fa[i] = i;\n  }\n\n  public int find(int x) {\n    if (x != this.fa[x]) {\n      return (this.fa[x] = this.find(this.fa[x]));\n    }\n    return x;\n  }\n\n  public void union(int x, int y) {\n    int x_fa = this.find(x);\n    int y_fa = this.find(y);\n\n    if (x_fa != y_fa) {\n      this.fa[y_fa] = x_fa;\n      this.count--;\n    }\n  }\n}",
      "python": "# 并查集\nclass UnionFindSet:\n    def __init__(self, n):\n        self.fa = [idx for idx in range(n)]\n        self.count = n\n\n    def find(self, x):\n        if x != self.fa[x]:\n            self.fa[x] = self.find(self.fa[x])\n            return self.fa[x]\n        return x\n\n    def union(self, x, y):\n        x_fa = self.find(x)\n        y_fa = self.find(y)\n\n        if x_fa != y_fa:\n            self.fa[y_fa] = x_fa\n            self.count -= 1\n\n\nn = int(input())\n\nmatrix = []\nfor i in range(n):\n    matrix.append(list(map(int, input().split())))\n\nufs = UnionFindSet(n)\n\nfor i in range(n):\n    for j in range(i + 1, n):  # 这里j从i+1开始，是因为矩阵是对称的\n        if matrix[i][j] == 1:\n            ufs.union(i, j)\n\n# connected字典的属性代表某个连通分量的顶级父节点，属性值代表该连通分量下的节点个数\nconnected = {}\n\nfor i in range(n):\n    fa = ufs.find(ufs.fa[i])\n    connected[fa] = connected.get(fa, 0) + 1\n\n# 返回最大节点数\nprint(max(connected.values()))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = lines[0] - 0;\n  }\n\n  if (n && lines.length === n + 1) {\n    lines.shift();\n    const matrix = lines.map((line) => line.split(\" \").map(Number));\n    console.log(getResult(matrix, n));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(matrix, n) {\n  const ufs = new UnionFindSet(n);\n\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) { // 这里j从i+1开始，是因为矩阵是对称的\n      if (matrix[i][j] === 1) {\n        ufs.union(i, j);\n      }\n    }\n  }\n\n  // connected对象的属性代表某个连通分量的顶级父节点，属性值代表该连通分量下的节点个数\n  const connected = {};\n\n  for (let i = 0; i < n; i++) {\n    const fa = ufs.find(ufs.fa[i]);\n    connected[fa] ? connected[fa]++ : (connected[fa] = 1);\n  }\n\n  // 返回最大节点数\n  return Math.max.apply(null, Object.values(connected));\n}\n\n// 并查集实现\nclass UnionFindSet {\n  constructor(n) {\n    this.fa = new Array(n).fill(0).map((_, i) => i);\n    this.count = n;\n  }\n\n  find(x) {\n    if (x !== this.fa[x]) {\n      return (this.fa[x] = this.find(this.fa[x]));\n    }\n    return x;\n  }\n\n  union(x, y) {\n    const x_fa = this.find(x);\n    const y_fa = this.find(y);\n\n    if (x_fa !== y_fa) {\n      this.fa[y_fa] = x_fa;\n      this.count--;\n    }\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "64",
    "title": "MVP争夺战",
    "examType": "A",
    "score": 100,
    "description": "在星球争霸篮球赛对抗赛中，最大的宇宙战队希望每个人都能拿到MVP，MVP的条件是单场最高分得分获得者。 可以并列所以宇宙战队决定在比赛中尽可能让更多队员上场，并且让所有得分的选手得分都相同， 然而比赛过程中的每1分钟的得分都只能由某一个人包揽。\n",
    "inputDesc": "输入第一行为一个数字 t ，表示为有得分的分钟数 1 ≤ t ≤ 50 第二行为 t 个数字，代表每一分钟的得分 p， 1 ≤ p ≤ 50\n",
    "outputDesc": "输出有得分的队员都是MVP时，最少得MVP得分。\n\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "xxxxxxxxxximport java.util.LinkedList;import java.util.Scanner;\npublic class Main {  public static void main(String[] args) {    Scanner sc = new Scanner(System.in);\n    int m = sc.nextInt();\n    LinkedList<Integer> link = new LinkedList<>();    for (int i = 0; i < m; i++) {      link.add(sc.nextInt());    }\n    System.out.println(getResult(link, m));  }\n  public static int getResult(LinkedList<Integer> link, int m) {    link.sort((a, b) -> b - a);\n    int sum = 0;    for (Integer ele : link) {      sum += ele;    }\n    while (m >= 1) {      // 根据网友指正，由于canPartition方法中会删除link元素，因此我们不能直接传递link过去，需要传递link备份，否则会影响下一次count判断      //      if (canPartitionMSubsets(link, sum, m)) return sum / m;      LinkedList<Integer> link_cp = new LinkedList<>(link);      if (canPartitionMSubsets(link_cp, sum, m)) return sum / m;      m--;    }\n    return sum;  }\n  public static boolean canPartitionMSubsets(LinkedList<Integer> link, int sum, int m) {    if (sum % m != 0) return false;\n    int subSum = sum / m;\n    if (subSum < link.get(0)) return false;\n    //    while (link.get(0) == subSum) { // 此段代码可能会出现越界    while (link.size() > 0 && link.get(0) == subSum) {      link.removeFirst();      m--;    }\n    int[] buckets = new int[m];    return partition(link, 0, buckets, subSum);  }\n  public static boolean partition(LinkedList<Integer> link, int index, int[] buckets, int subSum) {    if (index == link.size()) return true;\n    int select = link.get(index);\n    for (int i = 0; i < buckets.length; i++) {      if (i > 0 && buckets[i] == buckets[i - 1]) continue;      if (select + buckets[i] <= subSum) {        buckets[i] += select;        if (partition(link, index + 1, buckets, subSum)) return true;        buckets[i] -= select;      }    }\n    return false;  }}",
      "python": "xxxxxxxxxxdef dfs(arr, bucket, ind, ave):    if ind == len(arr):        return True    for i in range(len(bucket)):        if bucket[i] + arr[ind] <= ave:            bucket[i] += arr[ind]            if dfs(arr, bucket, ind + 1, ave):                return True            bucket[i] -= arr[ind]        # 如果当前桶为空且放不进去，就不要放入下一个空桶了        if bucket[i] == 0:            break    return False\nn = int(input())vec = input().split()arr = [int(i) for i in vec]total_sum = sum(arr)arr.sort(reverse=True)max_element = arr[0]\nfor target_sum in range(max_element, total_sum + 1):    if total_sum % target_sum == 0:        bucket_count = total_sum // target_sum        buckets = [0] * bucket_count        if dfs(arr, buckets, 0, target_sum):            print(target_sum)            break",
      "javascript": "​x/* JavaScript Node ACM模式 控制台输入获取 */const readline = require(\"readline\");\nconst rl = readline.createInterface({  input: process.stdin,  output: process.stdout,});\nconst lines = [];rl.on(\"line\", (line) => {  lines.push(line);\n  if (lines.length === 2) {    const n = lines[0] - 0;    const arr = lines[1].split(\" \").map(Number);\n    console.log(getResult(arr, n));    lines.length = 0;  }});\nfunction getResult(arr, n) {  const sum = arr.sort((a, b) => b - a).reduce((p, c) => p + c);\n  let count = n;  while (count >= 1) {    // 根据网友指正，由于canPartition方法中会删除arr元素，因此我们不能直接传递arr过去，需要传递arr备份，否则会影响下一次count判断    // if (canPartition(arr, sum, count)) {    if (canPartition([...arr], sum, count)) {      return sum / count;    } else {      count--;    }  }}\nfunction canPartition(arr, sum, count) {  if (sum % count) return false;\n  let subSum = sum / count;\n  if (subSum < arr[0]) return false;\n  while (arr[0] === subSum) {    arr.shift();    count--;  }\n  const buckets = new Array(count).fill(0);\n  return partition(0, arr, subSum, buckets);}\nfunction partition(index, arr, subSum, buckets) {  if (index === arr.length) {    return true;  }\n  const select = arr[index];\n  for (let i = 0; i < buckets.length; i++) {    if (i > 0 && buckets[i] === buckets[i - 1]) continue;    if (buckets[i] + select <= subSum) {      buckets[i] += select;      if (partition(index + 1, arr, subSum, buckets)) return true;      buckets[i] -= select;    }  }\n  return false;}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "65",
    "title": "判断一组不等式是否满足约束并输出最大差",
    "examType": "A",
    "score": 100,
    "description": "给定一组不等式，判断是否成立并输出不等式的最大差(输出浮点数的整数部分)\n要求:\n不等式系数为 double类型，是一个二维数组不等式的变量为 int类型，是一维数组;不等式的目标值为 double类型，是一维数组不等式约束为字符串数组，只能是:“>”,“>=”,“<”,“<=”,“=”，\n例如，不等式组:\na11x1+a12x2+a13x3+a14x4+a15x5<=b1;\na21x1+a22x2+a23x3+a24x4+a25x5<=b2;\na31x1+a32x2+a33x3+a34x4+a35x5<=b3;\n最大差 = max{(a11x1+a12x2+a13x3+a14x4+a15x5-b1),(a21x1+a22x2+a23x3+a24x4+ a25x5-b2),(a31x1+a32x2+a33x3+a34x4+a35x5-b3)},\n类型为整数(输出浮点数的整数部分)\n",
    "inputDesc": "a11,a12,a13,a14,a15,a21,a22,a23,a24,a25, a31,a32,a33,a34,a35,x1,x2,x3,x4,x5,b1,b2,b3,<=,<=,<=\n1)不等式组系数(double类型):\na11,a12,a13,a14,a15\na21,a22,a23,a24,a25\na31,a32,a33,a34,a35\n2)不等式变量(int类型):x1,x2,x3,x4,x5\n3)不等式目标值(double类型):b1,b2,b3\n4)不等式约束(字符串类型):<=,<=,<=\n",
    "outputDesc": "true或者 false，最大差\n\n\n这题是个纸老虎，大家不要怕。\n答案都在题目里。\n2023.06.09\n本题注意最大差输出的是：输出浮点数的整数部分\n这个不是向下取整，如果采用向下取整，负数最大差会有问题。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String[][] arr =\n        Arrays.stream(sc.nextLine().split(\";\")).map(s -> s.split(\",\")).toArray(String[][]::new);\n\n    double[] a1 = Arrays.stream(arr[0]).mapToDouble(Double::parseDouble).toArray();\n    double[] a2 = Arrays.stream(arr[1]).mapToDouble(Double::parseDouble).toArray();\n    double[] a3 = Arrays.stream(arr[2]).mapToDouble(Double::parseDouble).toArray();\n    double[] x = Arrays.stream(arr[3]).mapToDouble(Double::parseDouble).toArray();\n    double[] b = Arrays.stream(arr[4]).mapToDouble(Double::parseDouble).toArray();\n\n    String[] y = arr[5];\n\n    double diff1 = a1[0] * x[0] + a1[1] * x[1] + a1[2] * x[2] + a1[3] * x[3] + a1[4] * x[4] - b[0];\n    double diff2 = a2[0] * x[0] + a2[1] * x[1] + a2[2] * x[2] + a2[3] * x[3] + a2[4] * x[4] - b[1];\n    double diff3 = a3[0] * x[0] + a3[1] * x[1] + a3[2] * x[2] + a3[3] * x[3] + a3[4] * x[4] - b[2];\n\n    boolean flag =\n        compareWithZero(diff1, y[0])\n            && compareWithZero(diff2, y[1])\n            && compareWithZero(diff3, y[2]);\n\n    double maxDiff = Math.max(Math.max(diff1, diff2), diff3);\n\n    System.out.println(flag + \" \" + (int) maxDiff);\n  }\n\n  public static boolean compareWithZero(double val, String constraint) {\n    boolean flag = false;\n\n    switch (constraint) {\n      case \">\":\n        flag = val > 0;\n        break;\n      case \">=\":\n        flag = val >= 0;\n        break;\n      case \"<\":\n        flag = val < 0;\n        break;\n      case \"<=\":\n        flag = val <= 0;\n        break;\n      case \"=\":\n        flag = val == 0;\n        break;\n    }\n\n    return flag;\n  }\n}",
      "python": "# 输入获取\narr = list(map(lambda s: s.split(\",\"), input().split(\";\")))\n\n\ndef compareWithZero(val, constraint):\n    if constraint == \">\":\n        return val > 0\n    elif constraint == \">=\":\n        return val >= 0\n    elif constraint == \"<\":\n        return val < 0\n    elif constraint == \"<=\":\n        return val <= 0\n    elif constraint == \"=\":\n        return val == 0\n    else:\n        return False\n\n\n# 算法入口\ndef getResult(arr):\n    a11, a12, a13, a14, a15 = map(float, arr[0])\n    a21, a22, a23, a24, a25 = map(float, arr[1])\n    a31, a32, a33, a34, a35 = map(float, arr[2])\n    x1, x2, x3, x4, x5 = map(float, arr[3])\n    b1, b2, b3 = map(float, arr[4])\n    y1, y2, y3 = arr[5]\n\n    diff1 = a11 * x1 + a12 * x2 + a13 * x3 + a14 * x4 + a15 * x5 - b1\n    diff2 = a21 * x1 + a22 * x2 + a23 * x3 + a24 * x4 + a25 * x5 - b2\n    diff3 = a31 * x1 + a32 * x2 + a33 * x3 + a34 * x4 + a35 * x5 - b3\n\n    flag = compareWithZero(diff1, y1) and compareWithZero(diff2, y2) and compareWithZero(diff3, y3)\n\n    maxDiff = max(diff1, diff2, diff3)\n\n    print(f\"{flag} {int(maxDiff)}\".lower())\n\n\n# 算法调用\ngetResult(arr)",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const arr = line.split(\";\").map((str) => str.split(\",\"));\n\n  const [a11, a12, a13, a14, a15] = arr[0].map(Number);\n  const [a21, a22, a23, a24, a25] = arr[1].map(Number);\n  const [a31, a32, a33, a34, a35] = arr[2].map(Number);\n  const [x1, x2, x3, x4, x5] = arr[3].map(Number);\n  const [b1, b2, b3] = arr[4].map(Number);\n  const [y1, y2, y3] = arr[5];\n\n  let diff1 = a11 * x1 + a12 * x2 + a13 * x3 + a14 * x4 + a15 * x5 - b1;\n  let diff2 = a21 * x1 + a22 * x2 + a23 * x3 + a24 * x4 + a25 * x5 - b2;\n  let diff3 = a31 * x1 + a32 * x2 + a33 * x3 + a34 * x4 + a35 * x5 - b3;\n\n  const flag =\n    compareWithZero(diff1, y1) &&\n    compareWithZero(diff2, y2) &&\n    compareWithZero(diff3, y3);\n\n  const maxDiff = Math.max(diff1, diff2, diff3);\n\n  console.log(`${flag} ${parseInt(maxDiff)}`);\n});\n\nfunction compareWithZero(val, constraint) {\n  let flag;\n  switch (constraint) {\n    case \">\":\n      flag = val > 0;\n      break;\n    case \">=\":\n      flag = val >= 0;\n      break;\n    case \"<\":\n      flag = val < 0;\n      break;\n    case \"<=\":\n      flag = val <= 0;\n      break;\n    case \"=\":\n      flag = val === 0;\n      break;\n  }\n  return flag;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "66",
    "title": "勾股数元组",
    "examType": "A",
    "score": 100,
    "description": "如果3个正整数(a,b,c)满足a^2 + b^2 = c^2的关系，则称(a,b,c)为勾股数（著名的勾三股四弦五），\n为了探索勾股数的规律，我们定义如果勾股数(a,b,c)之间两两互质（即a与b，a与c，b与c之间均互质，没有公约数），则其为勾股数元组（例如(3,4,5)是勾股数元组，(6,8,10)则不是勾股数元组）。\n请求出给定范围[N,M]内，所有的勾股数元组。\n",
    "inputDesc": "起始范围N，1 <= N <= 10000\n结束范围M，N < M <= 10000\n",
    "outputDesc": "1. a,b,c请保证a < b < c,输出格式：a b c；\n2. 多组勾股数元组请按照a升序，b升序，最后c升序的方式排序输出；\n3. 给定范围中如果找不到勾股数元组时，输出”NA“。\n\n1\n20\n[1,20]范围内勾股数有：(3 4 5)，(5 12 13)，(6 8 10)，(8 15 17)，(9 12 15)，(12 16 20)；\n其中，满足(a,b,c)之间两两互质的勾股数元组有：(3 4 5)，(5 12 13)，(8 15 17);\n按输出描述中顺序要求输出结果。\n5\n10\n[5,10]范围内勾股数有：(6 8 10)；\n其中，没有满足(a,b,c)之间两两互质的勾股数元组；\n给定范围中找不到勾股数元组，输出”NA“\n本题首先需要找出给定区间内的所有勾股数，当找出勾股数后，继续判断勾股数两两之间是否互质，若否，则丢弃，若是，则保留。\n最终保留的就是勾股数元组。\n\n因此本题难点有二：1、如何找出所有勾股数； 2、如何判断两个数互质\n关于1，我们可以先求出区间[n,m]的所有数的平方，缓存到一个数组arr中，然后对该数组进行双重for遍历，外层遍历所有元素arr[i]，内层遍历i之后的每一个元素arr[j]，我们求arr[i]+arr[j]的和sum，看arr中是否包含sum元素，若是，则就得到一组勾股数sqrt(arr[i])、sqrt(arr[j])、sqrt(sum)。\n按照上面逻辑求得所有勾股数。\n之后，我们可以根据辗转相除法判断两个数是否互质，比如求9和12是否互质，以及求47和18是否互质。\n我们只需要用\na % b 得到一个 mod\n然后将\na <= b\nb <= mod\n如果进行到b===0时，则看此时a的值，若a===1，则说明初始时的a,b互质，否则就有最大公约数结束时的a。\n如下图所示：\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int m = sc.nextInt();\n\n    getResult(n, m);\n  }\n\n  public static void getResult(int n, int m) {\n    ArrayList<Integer> arr = new ArrayList<>();\n\n    for (int i = n; i <= m; i++) {\n      arr.add(i * i);\n    }\n\n    HashSet<Integer> set = new HashSet<>(arr);\n    ArrayList<Integer[]> res = new ArrayList<>();\n\n    for (int i = 0; i < arr.size(); i++) {\n      for (int j = i + 1; j < arr.size(); j++) {\n        // 判断勾股数 a^2 + b^2 = c^2\n        int sum = arr.get(i) + arr.get(j);\n        if (set.contains(sum)) {\n          res.add(\n              new Integer[] {\n                (int) Math.sqrt(arr.get(i)), (int) Math.sqrt(arr.get(j)), (int) Math.sqrt(sum)\n              });\n        }\n      }\n    }\n\n    List<Integer[]> collect =\n        res.stream()\n            .filter(\n                g ->\n                    isRelativePrime(g[0], g[1])\n                        && isRelativePrime(g[0], g[2])\n                        && isRelativePrime(g[1], g[2]))\n            .collect(Collectors.toList());\n\n    if (collect.size() == 0) {\n      System.out.println(\"NA\");\n    } else {\n      for (Integer[] g : collect) {\n        System.out.println(g[0] + \" \" + g[1] + \" \" + g[2]);\n      }\n    }\n  }\n\n  // 判断两个数是否互质，辗转相除\n  public static boolean isRelativePrime(int x, int y) {\n    while (y > 0) {\n      int mod = x % y;\n      x = y;\n      y = mod;\n    }\n\n    return x == 1;\n  }\n}",
      "python": "import math\n\n# 输入获取\nn = int(input())\nm = int(input())\n\n\n# 判断两个数是否互质，辗转相除\ndef isRelativePrime(x, y):\n    while y > 0:\n        mod = x % y\n        x = y\n        y = mod\n\n    return x == 1\n\n\n# 算法入口\ndef getResult():\n    arr = []\n\n    for i in range(n, m + 1):\n        arr.append(i * i)\n\n    setArr = set(arr)\n\n    res = []\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # 判断勾股数 a^2 + b^2 = c^2\n            sumV = arr[i] + arr[j]\n            if sumV in setArr:\n                res.append([int(math.sqrt(arr[i])), int(math.sqrt(arr[j])), int(math.sqrt(sumV))])\n\n    ans = list(\n        filter(lambda x: isRelativePrime(x[0], x[1]) and isRelativePrime(x[0], x[2]) and isRelativePrime(x[1], x[2]),\n               res))\n\n    if len(ans) == 0:\n        print(\"NA\")\n    else:\n        for g in ans:\n            print(\" \".join(map(str, g)))\n\n\n# 算法调用\ngetResult()",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const [n, m] = lines.map(Number);\n\n    getResult(n, m);\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(n, m) {\n  const arr = [];\n\n  for (let i = n; i <= m; i++) {\n    arr.push(i * i);\n  }\n\n  const set = new Set(arr);\n\n  const res = [];\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      /* 判断勾股数 a^2 + b^2 = c^2 */\n      const sum = arr[i] + arr[j];\n      if (set.has(sum)) {\n        res.push([Math.sqrt(arr[i]), Math.sqrt(arr[j]), Math.sqrt(sum)]);\n      }\n    }\n  }\n\n  const ans = res.filter((group) => {\n    const [a, b, c] = group;\n    return (\n      isRelativePrime(a, b) && isRelativePrime(a, c) && isRelativePrime(b, c)\n    );\n  });\n\n  if (!ans.length) return console.log(\"NA\");\n\n  ans.forEach((g) => console.log(g.join(\" \")));\n}\n\n/* 判断两个数是否互质，辗转相除 */\nfunction isRelativePrime(x, y) {\n  while (y > 0) {\n    let mod = x % y;\n    x = y;\n    y = mod;\n  }\n\n  return x === 1;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "67",
    "title": "堆栈中的剩余数字",
    "examType": "A",
    "score": 100,
    "description": "向一个空栈中依次存入正整数，假设入栈元素 n(1<=n<=2^31-1)按顺序依次为 nx…n4、 n3、n2、 n1, 每当元素入栈时，如果 n1=n2+…+ny(y 的范围[2,x]， 1<=x<=1000)，则 n1~ny 全部元素出栈，重新入栈新元素 m(m=2*n1)。\n如：依次向栈存入 6、 1、 2、 3, 当存入 6、 1、 2 时，栈底至栈顶依次为[6、 1、 2]；当存入 3时， 3=2+1， 3、 2、 1 全部出栈，重新入栈元素 6(6=2*3)，此时栈中有元素 6；\n因为 6=6，所以两个 6 全部出栈，存入 12，最终栈中只剩一个元素 12。\n",
    "inputDesc": "使用单个空格隔开的正整数的字符串，如”5 6 7 8″， 左边的数字先入栈，输入的正整数个数为 x， 1<=x<=1000。\n",
    "outputDesc": "最终栈中存留的元素值，元素值使用空格隔开，如”8 7 6 5″， 栈顶数字在左边。 6 1 2 3\n\n\n本题较为简单的解题思路是：\n每当有元素num将要入栈前，都尝试num去依次减去栈顶到栈底方向的栈中元素（注意这只是遍历栈的过程，而不是弹栈过程）：\n但是需要注意的是，对于情况1而言，我们需要注意题目描述中的这句话：\n每当元素入栈时，如果 n1=n2+…+ny(y 的范围[2,x]， 1<=x<=1000)，则 n1~ny 全部元素出栈，重新入栈新元素 m(m=2*n1)\n那么压栈 num * 2 是否也算新元素入栈呢？是否需要继续检查等价栈元素呢？\n我理解是需要的，即这个压栈num * 2 的过程是一个需要递归的过程。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int[] nums = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(getResult(nums));\n  }\n\n  public static String getResult(int[] nums) {\n    LinkedList<Integer> stack = new LinkedList<>();\n    stack.add(nums[0]);\n\n    for (int i = 1; i < nums.length; i++) {\n      push(nums[i], stack);\n    }\n\n    StringJoiner sj = new StringJoiner(\" \");\n    while (stack.size() > 0) {\n      sj.add(stack.removeLast() + \"\");\n    }\n    return sj.toString();\n  }\n\n  public static void push(int num, LinkedList<Integer> stack) {\n    int sum = num;\n\n    for (int i = stack.size() - 1; i >= 0; i--) {\n      sum -= stack.get(i);\n\n      if (sum == 0) {\n        stack.subList(i, stack.size()).clear();\n        push(num * 2, stack);\n        return;\n      } else if (sum < 0) {\n        break;\n      }\n    }\n\n    stack.add(num);\n  }\n}",
      "python": "# 输入获取\nnums = list(map(int, input().split()))\n\n\ndef push(num, stack):\n    total = num\n\n    for i in range(len(stack)-1, -1, -1):\n        total -= stack[i]\n\n        if total == 0:\n            del stack[i:]\n            push(num * 2, stack)\n            return\n        elif total < 0:\n            break\n\n    stack.append(num)\n\n\n# 算法入口\ndef getResult():\n    stack = [nums[0]]\n\n    for i in range(1, len(nums)):\n        push(nums[i], stack)\n\n    stack.reverse()\n\n    return \" \".join(map(str, stack))\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "68",
    "title": "字符串摘要",
    "examType": "A",
    "score": 100,
    "description": "给定一个字符串的摘要算法，请输出给定字符串的摘要值\n去除字符串中非字母的符号。如果出现连续字符(不区分大小写) ，则输出：该字符 (小写) + 连续出现的次数。如果是非连续的字符(不区分大小写)，则输出：该字符(小写) + 该字母之后字符串中出现的该字符的次数对按照以上方式表示后的字符串进行排序：字母和紧随的数字作为一组进行排序，数字大的在前，数字相同的，则按字母进行排序，字母小的在前。\n",
    "inputDesc": "一行字符串，长度为[1,200]\n",
    "outputDesc": "摘要字符串\n\nbAaAcBb: 第一个b非连续字母，该字母之后字符串中还出现了2次(最后的两个Bb) ，所以输出b2\na连续出现3次，输出a3， c非连续，该字母之后字符串再没有出现过c，输出c0\nBb连续2次，输出b2\n对b2a3c0b2进行排序，最终输出a3b2b2c0\n本题主要考察逻辑分析。\n\n本题主要难点在于：\n如果是非连续的字符(不区分大小写)，则输出：该字符(小写) + 该字母之后字符串中出现的该字符的次数\n如果当前位置的字母是一个非连续字符，那么我们需要统计当前位置之后的该字母出现次数。\n为了避免重复的扫描统计，我们可以一开始就统计好所有字母的出现次数到count中，每扫描一个位置，则对于位置的字母数量count[letter]--，表示该字母在后面还剩多少个。\n这样的话，碰到非连续字母letter时，我们只需要获取count[letter]即可知道其后续还有多少个letter字母。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n  // 字母数字类\n  static class Letter {\n    char letter;\n    int num;\n\n    public Letter(char letter, int num) {\n      this.letter = letter;\n      this.num = num;\n    }\n\n    @Override\n    public String toString() {\n      return this.letter + \"\" + this.num;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  public static String getResult(String s) {\n    // 不区分大小写\n    s = s.toLowerCase();\n\n    // 统计每个字母出现的次数\n    int[] count = new int[128];\n\n    // 去除字符串中的非字母\n    StringBuilder sb = new StringBuilder();\n\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      if (c >= 'a' && c <= 'z') {\n        count[c]++;\n        sb.append(c);\n      }\n    }\n\n    // 加空格是为了避免后续的收尾操作，如果有疑问可以移除下面加空格操作\n    s = sb + \" \";\n\n    // 记录连续字母和非连续字母\n    ArrayList<Letter> ans = new ArrayList<>();\n\n    // 上一个位置的字母\n    char pre = s.charAt(0);\n    // 该字母连续次数记为1\n    int repeat = 1;\n    // 后续该字母还有count[pre]-=1个\n    count[pre]--;\n\n    for (int i = 1; i < s.length(); i++) {\n      // 当前位置的字母\n      char cur = s.charAt(i);\n      // 后续该字母还有count[cur]-=1个\n      count[cur]--;\n\n      if (cur == pre) {\n        // 如果当前位置和上一个位置的字母相同，则产生连续\n        // 连续次数+1\n        repeat++;\n      } else {\n        // 如果当前位置和上一个位置的字母不同，则连续打断\n        // 如果pre字母连续次数>1，则是真连续，那么就是pre+repeat,否则就是假连续,是pre+count[pre]\n        ans.add(new Letter(pre, repeat > 1 ? repeat : count[pre]));\n        // 更新pre为cur\n        pre = cur;\n        // 更新pre连续次数为1\n        repeat = 1;\n      }\n    }\n\n    // 字母和紧随的数字作为一组进行排序，数字大的在前，数字相同的，则按字母进行排序，字母小的在前\n    ans.sort((a, b) -> a.num != b.num ? b.num - a.num : a.letter - b.letter);\n\n    StringBuilder res = new StringBuilder();\n    for (Letter an : ans) {\n      res.append(an.toString());\n    }\n    return res.toString();\n  }\n}",
      "python": "# 输入获取\ns = input()\n\n\n# 算法入口\ndef getResult():\n    global s\n\n    # 不区分大小写\n    s = s.lower()\n\n    # 统计每个字母出现的次数\n    count = {}\n    # 去除字符串中的非字母\n    letters = []\n\n    for c in s:\n        if 'z' >= c >= 'a':\n            count[c] = count.get(c, 0) + 1\n            letters.append(c)\n\n    # 加空格是为了避免后续的收尾操作，如果有疑问可以移除下面加空格操作\n    s = \"\".join(letters) + \" \"\n    count[' '] = 1\n\n    # 记录连续字母和非连续字母\n    ans = []\n\n    # 上一个位置的字母\n    pre = s[0]\n    # 该字母连续次数记为1\n    repeat = 1\n    # 后续该字母还有count[pre]-=1个\n    count[pre] -= 1\n\n    for i in range(1, len(s)):\n        # 当前位置的字母\n        cur = s[i]\n        # 后续该字母还有count[cur]-=1个\n        count[cur] -= 1\n\n        if cur == pre:\n            # 如果当前位置和上一个位置的字母相同，则产生连续\n            # 连续次数+1\n            repeat += 1\n        else:\n            # 如果当前位置和上一个位置的字母不同，则连续打断\n            # 如果pre字母连续次数>1，则是真连续，那么就是pre+repeat,否则就是假连续,是pre+count[pre]\n            ans.append([pre, repeat if repeat > 1 else count[pre]])\n            # 更新pre为cur\n            pre = cur\n            # 更新pre连续次数为1\n            repeat = 1\n\n    # 字母和紧随的数字作为一组进行排序，数字大的在前，数字相同的，则按字母进行排序，字母小的在前\n    ans.sort(key=lambda x: (-x[1], x[0]))\n\n    return \"\".join(map(lambda x: x[0]+str(x[1]), ans))\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "69",
    "title": "字符串重新排列、字符串重新排序",
    "examType": "A",
    "score": 100,
    "description": "给定一个字符串s，s包括以空格分隔的若干个单词，请对s进行如下处理后输出： 1、单词内部调整：对每个单词字母重新按字典序排序 2、单词间顺序调整： 1）统计每个单词出现的次数，并按次数降序排列 2）次数相同，按单词长度升序排列 3）次数和单词长度均相同，按字典升序排列\n请输出处理后的字符串，每个单词以一个空格分隔。\n",
    "inputDesc": "一行字符串，每个字符取值范围：[a-zA-z0-9]以及空格，字符串长度范围：[1，1000]\n",
    "outputDesc": "输出处理后的字符串，每个单词以一个空格分隔。\n\n本题需要注意的是，先进行单词内部调整，然后再进行单词间顺序。\n考察的是排序。\n\nPython解法的第16行排序原理，请看：\nPython3 - list sort方法实现多条件自定义排序_伏城之外的博客-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String[] arr = sc.nextLine().split(\" \");\n    System.out.println(getResult(arr));\n  }\n\n  public static String getResult(String[] arr) {\n    arr =\n        Arrays.stream(arr)\n            .map(\n                str -> {\n                  char[] cArr = str.toCharArray();\n                  Arrays.sort(cArr);\n                  return new String(cArr);\n                })\n            .toArray(String[]::new);\n\n    HashMap<String, Integer> count = new HashMap<>();\n    for (String s : arr) {\n      count.put(s, count.getOrDefault(s, 0) + 1);\n    }\n\n    Arrays.sort(\n        arr,\n        (a, b) ->\n            !count.get(a).equals(count.get(b))\n                ? count.get(b) - count.get(a)\n                : a.length() != b.length() ? a.length() - b.length() : a.compareTo(b));\n\n    StringJoiner sj = new StringJoiner(\" \", \"\", \"\");\n    for (String s : arr) {\n      sj.add(s);\n    }\n    return sj.toString();\n  }\n}",
      "python": "# 输入获取\narr = input().split()\n\n\n# 算法入口\ndef getResult(arr):\n    for i in range(len(arr)):\n        arr[i] = \"\".join(sorted(arr[i]))\n\n    count = {}\n    for c in arr:\n        if count.get(c) is None:\n            count[c] = 0\n        count[c] += 1\n\n    # arr.sort(key=lambda x: (-count[x], len(x), [ord(char) for char in x]))\n    arr.sort(key=lambda x: (-count[x], len(x), x))\n\n    # return \" \".join(map(str, arr))\n    return \" \".join(arr)\n\n\n# 算法调用\nprint(getResult(arr))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const arr = line.split(\" \");\n  console.log(getResult(arr));\n});\n\nfunction getResult(arr) {\n  arr = arr.map((str) => [...str].sort().join(\"\"));\n\n  const count = arr.reduce((p, c) => {\n    p[c] ? p[c]++ : (p[c] = 1);\n    return p;\n  }, {});\n\n  arr.sort((a, b) =>\n    count[a] !== count[b]\n      ? count[b] - count[a]\n      : a.length !== b.length\n      ? a.length - b.length\n      : a > b\n      ? 1\n      : -1\n  );\n\n  return arr.join(\" \");\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "70",
    "title": "完美走位",
    "examType": "A",
    "score": 100,
    "description": "在第一人称射击游戏中，玩家通过键盘的A、S、D、W四个按键控制游戏人物分别向左、向后、向右、向前进行移动，从而完成走位。\n假设玩家每按动一次键盘，游戏任务会向某个方向移动一步，如果玩家在操作一定次数的键盘并且各个方向的步数相同时，此时游戏任务必定会回到原点，则称此次走位为完美走位。\n现给定玩家的走位（例如：ASDA），请通过更换其中一段连续走位的方式使得原走位能够变成一个完美走位。其中待更换的连续走位可以是相同长度的任何走位。\n请返回待更换的连续走位的最小可能长度。\n如果原走位本身是一个完美走位，则返回0。\n",
    "inputDesc": "输入为由键盘字母表示的走位s，例如：ASDA\n",
    "outputDesc": "输出为待更换的连续走位的最小可能长度。\n\n题目要求，保持W,A,S,D字母个数平衡，即相等，如果不相等，可以从字符串中选取一段连续子串替换，来让字符串平衡。\n比如：WWWWAAAASSSS\n字符串长度12，W,A,S,D平衡的话，则每个字母个数应该是3个，而现在W,A,S各有4个，也就是说各超了1个。\n因此我们应该从字符串中，选取一段包含1个W，1个A，1个S的子串，来替换为D。\nWWWWAAAASSSS\nWWWWAAAASSSS\nWWWWAAAASSSS\n........\nWWWWAAAASSSS\n而符合这种要求的子串可能很多，我们需要找出其中最短的，即WAAAAS。\n本题其实就是求最小覆盖子串，同LeetCode - 76 最小覆盖子串_伏城之外的博客-CSDN博客\n题目解析请看上面链接博客。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.next()));\n  }\n\n  public static int getResult(String str) {\n    // count用于记录W,A,S,D字母的数量\n    HashMap<Character, Integer> count = new HashMap<>();\n\n    for (int i = 0; i < str.length(); i++) {\n      Character c = str.charAt(i);\n      count.put(c, count.getOrDefault(c, 0) + 1);\n    }\n\n    // 平衡状态时，W,A,S,D应该都是avg数量\n    int avg = str.length() / 4;\n\n    // total用于记录多余字母个数\n    int total = 0;\n\n    // flag表示当前是否为平衡状态，默认是\n    boolean flag = true;\n\n    for (Character c : count.keySet()) {\n      if (count.get(c) > avg) {\n        // 如果有一个字母数量超标，则平衡打破\n        flag = false;\n        // 此时count记录每个字母超过avg的数量\n        count.put(c, count.get(c) - avg);\n        total += count.get(c);\n      } else {\n        count.put(c, 0); // 此时count统计的其实是多余字母，如果没有超过avg,则表示没有多余字母\n      }\n    }\n\n    // 如果平衡，则输出0\n    if (flag) return 0;\n\n    int i = 0;\n    int j = 0;\n    int minLen = str.length() + 1;\n\n    while (j < str.length()) {\n      Character jc = str.charAt(j);\n\n      if (count.get(jc) > 0) {\n        total--;\n      }\n      count.put(jc, count.get(jc) - 1);\n\n      while (total == 0) {\n        minLen = Math.min(minLen, j - i + 1);\n\n        Character ic = str.charAt(i);\n        if (count.get(ic) >= 0) {\n          total++;\n        }\n        count.put(ic, count.get(ic) + 1);\n\n        i++;\n      }\n      j++;\n    }\n    return minLen;\n  }\n}",
      "python": "# 输入获取\ns = input()\n\n\n# 算法入口\ndef getResult(s):\n    # 此时count记录统计W,A,S,D字母的数量\n    count = {\n        \"W\": 0,\n        \"A\": 0,\n        \"S\": 0,\n        \"D\": 0\n    }\n\n    for c in s:\n        count[c] += 1\n\n    avg = len(s) / 4  # 平衡状态时，W,A,S,D应该都是avg数量\n    total = 0  # total用于记录多余字母个数\n    flag = True  # flag表示当前是否为平衡状态，默认是\n\n    for c in count.keys():\n        if count[c] > avg:\n            flag = False  # 如果有一个字母数量超标，则平衡打破\n            count[c] -= avg  # 此时count记录每个字母超过avg的数量\n            total += count[c]\n        else:\n            count[c] = 0\n\n    if flag:\n        return 0  # 如果平衡，则输出0\n\n    i = 0\n    j = 0\n    minLen = len(s) - 1\n\n    while j < len(s):\n        jc = s[j]\n\n        if count[jc] > 0:\n            total -= 1\n        count[jc] -= 1\n\n        while total == 0:\n            minLen = min(minLen, j - i + 1)\n\n            ic = s[i]\n            if count[ic] >= 0:\n                total += 1\n            count[ic] += 1\n\n            i += 1\n\n        j += 1\n\n    return minLen\n\n\nprint(getResult(s))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  console.log(getResult(line));\n});\n\nfunction getResult(str) {\n  // 此时count记录统计W,A,S,D字母的数量\n  const count = {\n    W: 0,\n    A: 0,\n    S: 0,\n    D: 0,\n  };\n\n  for (let c of str) count[c]++;\n\n  // 平衡状态时，W,A,S,D应该都是avg数量\n  const avg = str.length / 4;\n\n  let total = 0; // total用于记录多余字母个数\n\n  let flag = true; // flag表示当前是否为平衡状态，默认是\n  for (let c in count) {\n    if (count[c] > avg) {\n      flag = false; // 如果有一个字母数量超标，则平衡打破\n      count[c] -= avg; // 此时count记录每个字母超过avg的数量\n      total += count[c];\n    } else {\n      delete count[c];\n    }\n  }\n\n  if (flag) return 0; // 如果平衡，则输出0\n\n  let i = 0;\n  let j = 0;\n  let minLen = str.length + 1;\n\n  while (j < str.length) {\n    const jc = str[j];\n\n    if (count[jc]-- > 0) {\n      total--;\n    }\n\n    while (total === 0) {\n      minLen = Math.min(minLen, j - i + 1);\n\n      const ic = str[i];\n      if (count[ic]++ >= 0) {\n        total++;\n      }\n\n      i++;\n    }\n\n    j++;\n  }\n\n  return minLen;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "71",
    "title": "工号不够用了怎么办？",
    "examType": "A",
    "score": 100,
    "description": "3020年，空间通信集团的员工人数突破20亿人，即将遇到现有工号不够用的窘境。现在，请你负责调研新工号系统。继承历史传统，新的工号系统由小写英文字母（a-z）和数字（0-9）两部分构成。新工号由一段英文字母开头，之后跟随一段数字，比如”aaahw0001″,”a12345″,”abcd1″,”a00″。注意新工号不能全为字母或者数字,允许数字部分有前导0或者全为0。但是过长的工号会增加同事们的记忆成本，现在给出新工号至少需要分配的人数X和新工号中字母的长度Y，求新工号中数字的最短长度Z。\n",
    "inputDesc": "一行两个非负整数 X Y，用数字用单个空格分隔。0< X <=2^50 – 10< Y <=5\n",
    "outputDesc": "这题应该就是一道数学问题。\n小写字母有26种，数字有10种，因此如果工号组合选择一个字母，一个数字的话，则有26 * 10 = 260种。\n如果选择两个字母，两个数字的话，则会产生 26^2 * 10^2 种工号。\n现在确定了需要的工号总个数x，以及字母个数y，也就是说\nx = 26^y * 10^z\n求最小的z，且z>=1。\n因此z的求解公式：\nz = log(x / 26^y)\n这里我们要保证z向上取整，且保证z最小取1\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    long x = sc.nextLong();\n    int y = sc.nextInt();\n\n    System.out.println((long) Math.max(1, Math.ceil(Math.log10(x / Math.pow(26, y)))));\n  }\n}",
      "python": "# 输入获取\nimport math\n\nx, y = map(int, input().split())\n\n\n# 算法入口\ndef getResult(x, y):\n    print(max(1, math.ceil(math.log10(x / math.pow(26, y)))))\n\n\n# 算法调用\ngetResult(x, y)",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const [x, y] = line.split(\" \").map(Number);\n\n  console.log(Math.max(1, Math.ceil(Math.log10(x / Math.pow(26, y)))));\n});",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "72",
    "title": "数组二叉树",
    "examType": "A",
    "score": 100,
    "description": "二叉树也可以用数组来存储，给定一个数组，树的根节点的值存储在下标1，对于存储在下标N的节点，它的左子节点和右子节点分别存储在下标2*N和2*N+1，并且我们用值-1代表一个节点为空。\n给定一个数组存储的二叉树，试求从根节点到最小的叶子节点的路径，路径由节点的值组成。\n",
    "inputDesc": "输入一行为数组的内容，数组的每个元素都是正整数，元素间用空格分隔。\n注意第一个元素即为根节点的值，即数组的第N个元素对应下标N，下标0在树的表示中没有使用，所以我们省略了。\n输入的树最多为7层。\n",
    "outputDesc": "输出从根节点到最小叶子节点的路径上，各个节点的值，由空格分隔，用例保证最小叶子节点只有一个。\n\n\n本题有两种思路，一种是从树顶节点向下找，直到找到最小值节点。\n这种方式是典型的深度优先搜索。\n\n\n还有一种思路是先找到最小值节点，然后从最小值节点向上找父节点，由于向上找只有一个父节点，因此只有一种路径。\n因此，我们应该选择这种方式。\n\n采用这种方式，首先需要找到最小值节点在数组中的索引位置idx，然后根据题目定义的规则\n对于存储在下标N的节点，它的左子节点和右子节点分别存储在下标2*N和2*N+1\n当然上面这个规则是针对根节点索引从1开始的，如果根节点索引从0开始算法，则上面规则应变为\n对于存储在下标N的节点，它的左子节点和右子节点分别存储在下标2*N+1和2*N+2\n每找到一个父节点，就将其当成新的子节点，继续向上找父节点，直到子节点本身就是树顶节点为止。\n\n另外，如何找到最小值叶子节点呢？\n我们可以反向遍历输入的节点数组，如果遍历的节点符合下面条件，那么他就是一个叶子节点：\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    Integer[] arr =\n        Arrays.stream(sc.nextLine().split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    System.out.println(getResult(arr));\n  }\n\n  public static String getResult(Integer[] arr) {\n    int n = arr.length - 1;\n\n    // 最小叶子节点的值\n    int min = Integer.MAX_VALUE;\n    // 最小叶子节点的索引\n    int minIdx = -1;\n\n    // 求解最小叶子节点的值和索引\n    for (int i = n; i >= 1; i--) {\n      if (arr[i] != -1) {\n        if (i * 2 + 1 <= n && arr[i * 2 + 1] != -1) continue;\n        if (i * 2 + 2 <= n && arr[i * 2 + 2] != -1) continue;\n        if (min > arr[i]) {\n          min = arr[i];\n          minIdx = i;\n        }\n      }\n    }\n\n    // path用于缓存最小叶子节点到根的路径\n    LinkedList<Integer> path = new LinkedList<>();\n    path.addFirst(min);\n\n    // 从最小叶子节点开始向上找父节点，直到树顶\n    while (minIdx != 0) {\n      int f = (minIdx - 1) / 2;\n      path.addFirst(arr[f]);\n      minIdx = f;\n    }\n\n    StringJoiner sj = new StringJoiner(\" \");\n    for (Integer val : path) sj.add(val + \"\");\n\n    return sj.toString();\n  }\n}",
      "python": "import sys\n\n# 输入获取\narr = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult(arr):\n    # 最小叶子节点的值\n    minV = sys.maxsize\n    # 最小节点在数组中的索引位置\n    minIdx = -1\n    n = len(arr) - 1\n\n    for i in range(n, 0, -1):\n        if arr[i] != -1:\n            if i * 2 + 1 <= n and arr[i * 2 + 1] != -1:\n                continue\n            if i * 2 + 2 <= n and arr[i * 2 + 2] != -1:\n                continue\n\n            if minV > arr[i]:\n                minV = arr[i]\n                minIdx = i\n\n    # path用于缓存最小叶子节点到根的路径\n    path = []\n    path.insert(0, str(minV))\n\n    # 从最小值节点开始向上找父节点，直到树顶\n    while minIdx != 0:\n        f = (minIdx - 1) // 2\n        path.insert(0, str(arr[f]))\n        minIdx = f\n\n    return \" \".join(path)\n\n\n# 算法调用\nprint(getResult(arr))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const arr = line.split(\" \").map(Number);\n  let n = arr.length - 1;\n  // 最小叶子节点的值\n  let min = Infinity;\n  // 最小节点在数组中的索引位置\n  let minIdx = -1;\n  for (let i = n; i >= 0; i--) {\n    if (arr[i] != -1) {\n      if (i * 2 + 1 <= n && arr[i * 2 + 1] != -1) continue;\n      if (i * 2 + 2 <= n && arr[i * 2 + 2] != -1) continue;\n\n      if (min > arr[i]) {\n        min = arr[i];\n        minIdx = i;\n      }\n    }\n  }\n\n  // path用于缓存最小叶子节点到根的路径\n  const path = [];\n  path.unshift(min);\n\n  // 从最小值节点开始向上找父节点，直到树顶\n  while (minIdx !== 0) {\n    let f = Math.floor((minIdx - 1) / 2);\n    path.unshift(arr[f]);\n    minIdx = f;\n  }\n\n  console.log(path.join(\" \"));\n});",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "73",
    "title": "数组连续和",
    "examType": "A",
    "score": 100,
    "description": "给定一个含有N个正整数的数组, 求出有多少个连续区间（包括单个正整数）, 它们的和大于等于x。\n",
    "inputDesc": "第一行两个整数N x（0 < N <= 100000, 0 <= x <= 10000000)\n第二行有N个正整数（每个正整数小于等于100)。\n",
    "outputDesc": "输出一个整数，表示所求的个数。\n注意：此题对效率有要求，暴力解法通过率不高，请考虑高效的实现方式。\n\n3 7 3 4 7\n10 10000 1 2 3 4 5 6 7 8 9 10\n\n区间和，最快的计算方式就是利用：一维前缀和，关于一维前缀和请看：\n算法设计 - 前缀和 & 差分数列_伏城之外的博客-CSDN博客\n因此，我们只需要计算出第二行输入数组的前缀和，即可快速计算出任意区间范围的和，比如求解arr数组的[L,R]范围的元素之和，只需要计算 preSum[R] - preSum[L-1]即可。\n\n本题中说区间可以是单个元素，因此preSum需要初始化为 arr.length + 1 长度，其中preSum[0] = 0，因为这样的话，才能基于preSum描述出第一个元素单独作为区间时的区间和，即preSum[1] - preSum[0]。\n\n本题描述第二行输入是：N个正整数的数组。\n即arr数组元素都是正整数，因此preSum数组必然是一个升序的数组。\n这意味着，如果preSum[R] - preSum[L] >= x的话，则必然成立：preSum[i] - preSum[L] >=x ，其中 i >= R。\n这样的话，如果preSum[R] - preSum[L] >= x，那么对于区间左边界固定为L的，且区间和大于等于x的区间个数就有 arr.length - R + 1 个，此时只需要O(1)时间。\n下一次，我们继续找左边界固定为L+1的情况。注意保证R>L。\n由于R必须大于L，因此当R越界时，即R>arr.length时，结束。\n\n2023.06.16\n本题的Python使用input()获取第二行输入时可能会超时，建议使用\n实现大数据量的高效获取\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int x = sc.nextInt();\n\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) arr[i] = sc.nextInt();\n    System.out.println(getResult(n, x, arr));\n  }\n\n  public static long getResult(int n, int x, int[] arr) {\n    int[] preSum = new int[n + 1];\n\n    for (int i = 1; i <= n; i++) {\n      preSum[i] = preSum[i - 1] + arr[i - 1];\n    }\n\n    int l = 0;\n    int r = 1;\n    long ans = 0;\n\n    while (r <= n) {\n      if (preSum[r] - preSum[l] >= x) {\n        ans += n - r + 1;\n        l++;\n        r = l + 1;\n      } else {\n        r++;\n      }\n    }\n\n    return ans;\n  }\n}",
      "python": "import sys\n\n# 输入获取\nn, x = map(int, input().split())\narr = list(map(int, sys.stdin.readline().split()))\n \n \n# 算法入口\ndef getResult():\n    preSum = [0]*(n+1)\n \n    for i in range(1, n+1):\n        preSum[i] = preSum[i-1] + arr[i-1]\n \n    l = 0\n    r = 1\n    ans = 0\n \n    while r <= n:\n        if preSum[r] - preSum[l] >= x:\n            ans += n - r + 1\n            l += 1\n            r = l + 1\n        else:\n            r += 1\n \n    return ans\n \n \n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "74",
    "title": "整数编码",
    "examType": "A",
    "score": 100,
    "description": "实现一种整数编码方法，使得待编码的数字越小，编码后所占用的字节数越小。\n编码规则如下:\n编码时7位一组，每个字节的低7位用于存储待编码数字的补码字节的最高位表示后续是否还有字节，置1表示后面还有更多的字节，置0表示当前字节为最后一个字节。采用小端序编码，低位和低字节放在低地址上。编码结果按16进制数的字符格式输出，小写字母需转换为大写字母\n",
    "inputDesc": "输入的为一个字符串表示的非负整数\n",
    "outputDesc": "输出一个字符串，表示整数编码的16进制码流\n\n待编码的数字取值范围为[0，1<<64 - 1]\n\n100的二进制表示为0110 0100，只需要一个字节进行编码;\n\n字节的最高位置0，剩余7位存储数字100的低7位 (110 0100) ，所以编码后的输出为64。\n1000的二进制表示为0011 1110 1000，至少需要两个字节进行编码;\n\n第一个字节最高位置1，剩余的7位存储数字1000的第一个低7位 (1101000)，所以第一个字节的二进制为1110 1000，即E8;\n\n第二个字节最高位置0，剩余的7位存储数字1000的第二个低7位 (0000111)，所以第一个字节的二进制为0000 0111，即07;\n\n采用小端序编码，所以低字节E8输出在前，高字节07输出在后。\n\n我的解题思路如下：\n首先将输入的十进制数转为二进制字符串binStr，然后基于binStr“倒序”每7位一段，以用例3画图说明：\n\n如果当前“段”的左边还有后续段，那么当前“段”需要在头部追加“1”形成新字节，如上图黄色段，由于其左边还有，则最终得到的新字节字符串是：\"1\" + \"1101000\"，新字节字符串转化为十六进制后为E8\n\n\n如果当前”段“不足7位，或者左边没有后续段了，那么当前”段“需要在头部追加”0“形成新字节（其实也可以不加），如上图绿色段，由于其左边没有后续段了，则最终得到的新字节字符串是：”0“ + ”00111“，新字节字符串转化为16进制后为7\n\n对于不足两位的16进制，要在前面补足0\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLong()));\n  }\n\n  public static String getResult(long num) {\n    String bin = Long.toBinaryString(num);\n\n    StringBuilder ans = new StringBuilder();\n\n    int end = bin.length();\n    while (end - 7 > 0) {\n      ans.append(getHexString(\"1\" + bin.substring(end - 7, end)));\n      end -= 7;\n    }\n\n    if (end >= 0) {\n      ans.append(getHexString(bin.substring(0, end)));\n    }\n\n    return ans.toString();\n  }\n\n  public static String getHexString(String binStr) {\n    String hexStr = Integer.toHexString(Integer.parseInt(binStr, 2));\n    if (hexStr.length() == 1) hexStr = \"0\" + hexStr;\n    return hexStr.toUpperCase();\n  }\n}",
      "python": "# 输入获取\nnum = int(input())\n\n\ndef getHexString(binStr):\n    # bin函数可以将十进制数转为16进制字符串，但是开头会带0x,因此下面做了字符串截取操作\n    hexStr = hex(int(binStr, 2))[2:]\n    if len(hexStr) == 1:\n        hexStr = \"0\" + hexStr\n    return hexStr.upper()\n\n\n# 算法入口\ndef getResult():\n    # bin函数可以将十进制数转为二进制字符串，但是开头会带0b,因此下面做了字符串截取操作\n    binStr = bin(num)[2:]\n\n    ans = []\n\n    end = len(binStr)\n    while end - 7 > 0:\n        ans.append(getHexString(\"1\" + binStr[end-7:end]))\n        end -= 7\n\n    if end >= 0:\n        ans.append(getHexString(binStr[:end]))\n\n    return \"\".join(ans)\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "75",
    "title": "最大矩阵和",
    "examType": "A",
    "score": 100,
    "description": "给定一个二维整数矩阵，要在这个矩阵中选出一个子矩阵，使得这个子矩阵内所有的数字和尽量大，我们把这个子矩阵称为和最大子矩阵，子矩阵的选取原则是原矩阵中一块相互连续的矩形区域。\n",
    "inputDesc": "输入的第一行包含2个整数n, m(1 <= n, m <= 10)，表示一个n行m列的矩阵，下面有n行，每行有m个整数，同一行中，每2个数字之间有1个空格，最后一个数字后面没有空格，所有的数字的在[-1000, 1000]之间。\n",
    "outputDesc": "输出一行一个数字，表示选出的和最大子矩阵内所有的数字和。\n\n3 4 -3 5 -1 5 2 4 -2 4 -1 3 -1 3\n\n看到这个题目标题，我很容易就联想到了最大子数组和，关于最大子数组和可以参考：LeetCode - 53 最大子数组和-CSDN博客\n\n区别在于最大子数组和是一维的，而最大子矩阵和是二维的。\n那么是不是有可能将最大子矩阵和的求解转成一维的呢？\n下面是子矩阵可能存在的区域，即一行子矩阵，两行子矩阵，三行子矩阵\n\n进一步简化，可得下图，即对求解下面每个区域的最大子矩阵\n\n此时因为子矩阵的行数已经确定，因此我们可以将多行压缩为一行\n\n此时对于最大子矩阵和的求解，就变为了最大子数组和的求解。\n而最大子数组和的求解的状态转移方程我们已经在前一小结总结出来了：\ndp[i] = max(dp[i-1], 0) + nums[i]。\n\n还有一个难点就是二维数组压缩为一维数组的问题，解决思路如下，获取二维数组的行数rows、列数cols，创建一个长度为cols的一维数组，然后将二维数组双重for循环，外层遍历cols，内层遍历rows，这样每次循环就可以得到二维数组一个列上的所有元素，然后求和存入一维数组中，实现如下\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int m = sc.nextInt();\n\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    System.out.println(getResult(n, m, matrix));\n  }\n\n  public static int getResult(int n, int m, int[][] matrix) {\n    ArrayList<Integer> dp = new ArrayList<>();\n\n    for (int i = 0; i < n; i++) {\n      dp.add(maxSubArraySum(matrix[i])); // 一行子矩阵最大和\n\n      for (int j = i + 1; j < n; j++) {\n        dp.add(maxSubArraySum(matrixZip(Arrays.copyOfRange(matrix, i, j + 1)))); // 多行子矩阵最大和\n      }\n    }\n\n    return dp.stream().max((a, b) -> a - b).orElse(0); // 求出最大和\n  }\n\n  // 最大子数组和求解\n  public static int maxSubArraySum(int[] nums) {\n    int[] dp = new int[nums.length];\n\n    int res = dp[0] = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n      dp[i] = Math.max(dp[i - 1], 0) + nums[i];\n      res = Math.max(res, dp[i]);\n    }\n\n    return res;\n  }\n\n  // 多行子矩阵，压缩为一行子数组\n  public static int[] matrixZip(int[][] matrix) {\n    int cols = matrix[0].length;\n    int rows = matrix.length;\n    int[] zip = new int[cols];\n\n    for (int c = 0; c < cols; c++) {\n      for (int r = 0; r < rows; r++) {\n        zip[c] += matrix[r][c];\n      }\n    }\n\n    return zip;\n  }\n}",
      "python": "# 输入获取\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for i in range(n)]\n\n\n# 最大子数组和求解\ndef maxSubArraySum(nums):\n    dp = [0 for i in range(len(nums))]\n    res = dp[0] = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(dp[i - 1], 0) + nums[i]\n        res = max(res, dp[i])\n\n    return res\n\n\n# 将多行子矩阵，压缩为一维数组\ndef matrixZip(matrix):\n    cols = len(matrix[0])\n    rows = len(matrix)\n    zip = [0 for i in range(cols)]\n\n    for c in range(cols):\n        for r in range(rows):\n            zip[c] += matrix[r][c]\n\n    return zip\n\n\n# 算法入口\ndef getResult(n, m, matrix):\n    dp = []\n\n    for i in range(n):\n        dp.append(maxSubArraySum(matrix[i]))\n        for j in range(i + 1, n):\n            dp.append(maxSubArraySum(matrixZip(matrix[i:j + 1])))\n\n    dp.sort()\n\n    return dp[-1]\n\n\n# 算法调用\nprint(getResult(n, m, matrix))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nlet lines = [];\nlet n, m;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  // 输入第一行时，提取出m、n\n  if (lines.length === 1) {\n    [n, m] = lines[0].split(\" \").map((ele) => parseInt(ele));\n  }\n\n  // 输入第一行后，再输入n行时，则开始启动算法程序\n  if (lines.length - 1 === n) {\n    // 干掉第一行输入，即lines中存储的全是就是matrix要素\n    lines.shift();\n\n    // matrix是算法程序的入参二维数组\n    let matrix = [];\n    // 将多行输入的matrix要素提取出来存到二维数组中\n    lines.forEach((line) => {\n      matrix.push(\n        line\n          .split(\" \")\n          .map((ele) => parseInt(ele))\n          .slice(0, m)\n      );\n    });\n\n    // 调用算法程序\n    console.log(maxSubMatrixSum(matrix));\n\n    // 将输入归0，重新接收下一轮\n    lines.length = 0;\n  }\n});\n\nfunction maxSubMatrixSum(matrix) {\n  let dp = [];\n  for (let i = 0; i < matrix.length; i++) {\n    dp.push(maxSubArraySum(matrix[i]));\n\n    for (let j = i + 1; j < matrix.length; j++) {\n      dp.push(maxSubArraySum(matrixZip(matrix.slice(i, j + 1))));\n    }\n  }\n\n  return dp.sort((a, b) => b - a)[0];\n}\n\nfunction maxSubArraySum(nums) {\n  let dp = new Array(nums.length);\n\n  let result = (dp[0] = nums[0]);\n\n  for (let i = 1; i < nums.length; i++) {\n    dp[i] = Math.max(dp[i - 1], 0) + nums[i];\n    result = Math.max(result, dp[i]);\n  }\n\n  return result;\n}\n\nfunction matrixZip(matrix) {\n  let cols = matrix[0].length;\n  let rows = matrix.length;\n  let zip = new Array(cols).fill(0);\n\n  for (let c = 0; c < cols; c++) {\n    for (let r = 0; r < rows; r++) {\n      zip[c] += matrix[r][c];\n    }\n  }\n\n  return zip;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "76",
    "title": "最大花费金额",
    "examType": "A",
    "score": 100,
    "description": "双十一众多商品进行打折销售，小明想购买自己心仪的一些物品，但由于受购买资金限制，所以他决定从众多心仪商品中购买三件，而且想尽可能的花完资金。\n现在请你设计一个程序帮助小明计算尽可能花费的最大资金数额。\n",
    "inputDesc": "输入第一行为一维整型数组M，数组长度小于100，数组元素记录单个商品的价格，单个商品价格小于1000。输入第二行为购买资金的额度R，R小于100000。输入格式是正确的，无需考虑格式错误的情况。\n",
    "outputDesc": "23,26,36,27\n78\n本题其实就是让我们从n个数中选择3个，保证这个3个数之和最接近且小于等于某个target。\n\n解题思路是：\n首先，我们将n个数的数组进行升序。\n然后用三个指针I，L，R去指向数组的三个元素，形成三数组合，其中：\n如下图所示：\n\n其中 I 指针在每一轮循环中是位置固定的，我们需要移动L，R来找不大于，且最接近target的组合。L，R指针的移动逻辑如下：\n假设 sum = arr[I] + arr[L] + arr[R]\n按此逻辑，将当前 I 指针固定的数的三数组合情况全部求出。\n之后，再 I ++ ，尝试其他三数组合。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  // 输入获取\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    Integer[] arrM =\n        Arrays.stream(sc.nextLine().split(\",\")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    int r = Integer.parseInt(sc.nextLine());\n\n    System.out.println(getResult(arrM, r));\n  }\n\n  // 算法入口\n  public static int getResult(Integer[] arr, int target) {\n    // 题目说小明要购买三件，如果商品不足三件直接返回-1\n    if (arr.length < 3) return -1;\n\n    // 数组升序\n    Arrays.sort(arr);\n\n    int ans = -1;\n\n    for (int i = 0; i < arr.length; i++) {\n      int l = i + 1;\n      int r = arr.length - 1;\n\n      while (l < r) {\n        int sum = arr[i] + arr[l] + arr[r];\n        if (sum == target) {\n          return sum;\n        } else if (sum < target) {\n          ans = Math.max(ans, sum);\n          l++;\n        } else {\n          r--;\n        }\n      }\n    }\n\n    return ans;\n  }\n}",
      "python": "# 输入获取\narr = list(map(int, input().split(\",\")))\ntarget = int(input())\n\n\n# 算法入口\ndef getResult():\n    # 题目说小明要购买三件，如果商品不足三件直接返回-1\n    if len(arr) < 3:\n        return -1\n\n    # 数组升序\n    arr.sort()\n\n    ans = -1\n\n    for i in range(len(arr)):\n        l = i + 1\n        r = len(arr) - 1\n\n        while l < r:\n            total = arr[i] + arr[l] + arr[r]\n\n            if total == target:\n                return total\n            elif total < target:\n                ans = max(ans, total)\n                l += 1\n            else:\n                r -= 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const arrM = lines[0].split(\",\").map(Number);\n    const r = lines[1] - 0;\n    console.log(getResult(arrM, r));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(arr, target) {\n  // 题目说小明要购买三件，如果商品不足三件直接返回-1\n  if (arr.length < 3) return -1;\n\n  // 数组升序\n  arr.sort((a, b) => a - b);\n\n  let ans = -1;\n\n  for (let i = 0; i < arr.length; i++) {\n    let l = i + 1;\n    let r = arr.length - 1;\n\n    while (l < r) {\n      const sum = arr[i] + arr[l] + arr[r];\n\n      if (sum == target) {\n        return sum;\n      } else if (sum < target) {\n        ans = Math.max(ans, sum);\n        l++;\n      } else {\n        r--;\n      }\n    }\n  }\n\n  return ans;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "77",
    "title": "最短木板长度",
    "examType": "A",
    "score": 100,
    "description": "小明有 n 块木板，第 i ( 1 ≤ i ≤ n ) 块木板长度为 ai。 小明买了一块长度为 m 的木料，这块木料可以切割成任意块，拼接到已有的木板上，用来加长木板。 小明想让最短的模板尽量长。请问小明加长木板后，最短木板的长度可以为多少？\n",
    "inputDesc": "输入的第一行包含两个正整数， n ( 1 ≤ n ≤ 10^3 ), m ( 1 ≤ m ≤ 10^6 )，n 表示木板数， m 表示木板长度。 输入的第二行包含 n 个正整数， a1, a2,…an ( 1 ≤ ai ≤ 10^6 )。\n",
    "outputDesc": "输出的唯一一行包含一个正整数，表示加长木板后，最短木板的长度最大可以为多少？\n\n本题的题意是比较明确的，我的解题思路如下：\n要想让最短的木板尽可能长，那么我们就要不停地递进式补足最短板，比如用例输入有5个板：4 5 3 5 5，可用材料m=3\n最短的板长度是3，只有一个，那么我们就将他补足到4，此时消耗了一单位长度的材料，m=2\n这样的话，只剩下两种长度的板4，5，\n且4长度有两个，5长度有三个，最短板是长度4.\n接下来我们应该尽量将最短板4长度的板补足到5长度，而刚好剩余材料m=2，可以将所有4长度的板补足到5长度，此时所有板都是5长度，且材料耗尽。\n\n我们还需要考虑一种特殊情况，那就是m还有值，但是只剩下一种长度的板，此时我们应该平分材料到每一个板，\n假设只剩一种长度的板有count个，则平均分的话，每个板能分得 m / count 长度，这个值有可能是小数，我们举个例子：\n5个一样长度x的板，m = 13，则 13 / 5 = 2...3，因此最短板长度就是x+2，\n再比如\n5个一样长度x的板，m = 15，则 13 / 5 = 3，因此最短板长度就是x+3。\n\n本题有点贪心思维，即优先分配m的长度给最短板。\n\n关于算法的时间复杂度，由于板子数量最多1000个，因此统计相同长度板子数量的时间复杂度很低。\n然后m的长度达到了10^6，这就比较大了，但是我们通过不断递进式累计最短板数量，最终不会受到m长度的影响，只会受到板子数量的影响。\n因此下面整体复杂度是O(N)，且N取值最多是1000。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int m = sc.nextInt();\n\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++) {\n      a[i] = sc.nextInt();\n    }\n\n    System.out.println(getResult(m, a));\n  }\n\n  public static int getResult(int m, int[] a) {\n    // 统计每种长度板的数量，记录到woods中，key是板长度，val是板数量\n    HashMap<Integer, Integer> woods = new HashMap<>();\n    for (Integer ai : a) {\n      if (woods.containsKey(ai)) {\n        Integer val = woods.get(ai);\n        woods.put(ai, ++val);\n      } else {\n        woods.put(ai, 1);\n      }\n    }\n\n    // 将统计到的板，按板长度排优先级，长度越短优先级越高，这里使用优先队列来实现优先级\n    PriorityQueue<Integer[]> pq = new PriorityQueue<>((b, c) -> b[0] - c[0]);\n    for (Integer wood : woods.keySet()) {\n      pq.offer(new Integer[] {wood, woods.get(wood)});\n    }\n\n    // 只要还有剩余的m长度，就将他补到最短板上\n    while (m > 0) {\n      // 如果只有一种板长度，那么就尝试将m平均分配到各个板上\n      if (pq.size() == 1) {\n        Integer[] info = pq.poll();\n        int len = info[0];\n        int count = info[1];\n        return len + m / count;\n      }\n\n      // 如果有多种板长度\n      // min1是最短板\n      Integer[] min1 = pq.poll();\n      // min2是第二最短板\n      Integer[] min2 = pq.peek();\n\n      // diff是最短板和第二最短板的差距\n      int diff = min2[0] - min1[0];\n      // 将所有最短板补足到第二短板的长度，所需要总长度total\n      int total = diff * min1[1];\n\n      // 如果m的长度不够补足所有最短板，那么说明此时最短板的长度就是题解\n      if (total > m) {\n        return min1[0] + m / min1[1];\n      }\n      // 如果m的长度刚好可以补足所有最短板，那么说明最短板可以全部升级到第二短板，且刚好用完m，因此第二短板的长度就是题解\n      else if (total == m) {\n        return min2[0];\n      }\n      // 如果m的长度足够长，能补足所有最短板到第二短板，还能有剩余，则将最短的数量加到第二短板的数量上，继续下轮循环\n      else {\n        m -= total;\n        min2[1] += min1[1];\n      }\n    }\n\n    return pq.peek()[0];\n  }\n}",
      "python": "# 输入获取\nimport math\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult(m, a):\n    # 统计每种长度板的数量，记录到count中，属性是板长度，属性值是板数量\n    count = {}\n    for ai in a:\n        if count.get(ai) is None:\n            count[ai] = 1\n        else:\n            count[ai] += 1\n\n    # 将统计到的板，按板长度升序\n    arr = []\n    for ai in count.keys():\n        arr.append([int(ai), count[ai]])\n\n    arr.sort(key=lambda x: x[0])\n\n    # 只要还有剩余的m长度，就将他补到最短板上\n    while m > 0:\n        # 如果只有一种板长度，那么就尝试将m平均分配到各个板上\n        if len(arr) == 1:\n            lenV, count = arr[0]\n            return lenV + math.floor(m / count)\n\n        # 如果有多种板长度\n        min1 = arr.pop(0) # min1是最短板\n        min2 = arr[0] # min2是第二最短板\n\n        # diff是最短板和第二最短板的差距\n        diff = min2[0] - min1[0]\n\n        # 将所有最短板补足到第二短板的长度，所需要总长度total\n        total = diff * min1[1]\n\n        # 如果m的长度不够补足所有最短板，那么说明此时最短板的长度就是题解\n        if total > m:\n            return min1[0] + math.floor(m / min1[1])\n        # 如果m的长度刚好可以补足所有最短板，那么说明最短板可以全部升级到第二短板，且刚好用完m，因此第二短板的长度就是题解\n        elif total == m:\n            return min2[0]\n        # 如果m的长度足够长，能补足所有最短板到第二短板，还能有剩余，则将最短的数量加到第二短板的数量上，继续下轮循环\n        else:\n            m -= total\n            min2[1] += min1[1]\n\n    return arr[0][0]\n\n\n# 算法调用\nprint(getResult(m, a))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const [n, m] = lines[0].split(\" \").map(Number);\n    const a = lines[1].split(\" \").map(Number);\n    console.log(getResult(m, a));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(m, a) {\n  // 统计每种长度板的数量，记录到count中，属性是板长度，属性值是板数量\n  const count = {};\n  for (let ai of a) {\n    count[ai] ? count[ai]++ : (count[ai] = 1);\n  }\n\n  // 将统计到的板，按板长度升序\n  const arr = [];\n  for (let ai in count) {\n    arr.push([ai - 0, count[ai]]);\n  }\n  arr.sort((a, b) => a[0] - b[0]);\n\n  // 只要还有剩余的m长度，就将他补到最短板上\n  while (m > 0) {\n    // 如果只有一种板长度，那么就尝试将m平均分配到各个板上\n    if (arr.length === 1) {\n      const [len, count] = arr[0];\n      return len + Math.floor(m / count);\n    }\n\n    // 如果有多种板长度\n    // min1是最短板\n    let min1 = arr.shift();\n    // min2是第二最短板\n    let min2 = arr[0];\n\n    // diff是最短板和第二最短板的差距\n    let diff = min2[0] - min1[0];\n\n    // 将所有最短板补足到第二短板的长度，所需要总长度total\n    let total = diff * min1[1];\n\n    // 如果m的长度不够补足所有最短板，那么说明此时最短板的长度就是题解\n    if (total > m) {\n      return min1[0] + Math.floor(m / min1[1]);\n    }\n    // 如果m的长度刚好可以补足所有最短板，那么说明最短板可以全部升级到第二短板，且刚好用完m，因此第二短板的长度就是题解\n    else if (total === m) {\n      return min2[0];\n    }\n    // 如果m的长度足够长，能补足所有最短板到第二短板，还能有剩余，则将最短的数量加到第二短板的数量上，继续下轮循环\n    else {\n      m -= total;\n      min2[1] += min1[1];\n    }\n  }\n\n  return arr[0][0];\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "78",
    "title": "最长的指定瑕疵度的元音子串",
    "examType": "A",
    "score": 100,
    "description": "开头和结尾都是元音字母（aeiouAEIOU）的字符串为元音字符串，其中混杂的非元音字母数量为其瑕疵度。比如:\n“a” 、 “aa”是元音字符串，其瑕疵度都为0“aiur”不是元音字符串（结尾不是元音字符） “abira”是元音字符串，其瑕疵度为2\n给定一个字符串，请找出指定瑕疵度的最长元音字符子串，并输出其长度，如果找不到满足条件的元音字符子串，输出0。\n子串：字符串中任意个连续的字符组成的子序列称为该字符串的子串。\n",
    "inputDesc": "首行输入是一个整数，表示预期的瑕疵度flaw，取值范围[0, 65535]。\n接下来一行是一个仅由字符a-z和A-Z组成的字符串，字符串长度(0, 65535]。\n",
    "outputDesc": "输出为一个整数，代表满足条件的元音字符子串的长度。\n\n\n\n瑕疵度计算规则如上图注解所示。\n当两指针之间划定的子串的瑕疵度diff 大于 指定的瑕疵度flaw时，则左指针 l++\n当两指针之间划定的子串的瑕疵度diff 小于 指定的瑕疵度flaw时，则右指针 r++\n当两指针之间划定的子串的瑕疵度diff 等于 指定的瑕疵度flaw时，则记录当前子串长度，并r++\n按以上逻辑，直到r指针移动到idxs数组的尾部。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int flaw = sc.nextInt();\n    String s = sc.next();\n\n    System.out.println(getResult(flaw, s));\n  }\n\n  public static int getResult(int flaw, String s) {\n    char[] yuan = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    HashSet<Character> set = new HashSet<>();\n    for (char c : yuan) set.add(c);\n\n    ArrayList<Integer> idxs = new ArrayList<>();\n    for (int i = 0; i < s.length(); i++) {\n      if (set.contains(s.charAt(i))) idxs.add(i);\n    }\n\n    int ans = 0;\n    int n = idxs.size();\n\n    int l = 0;\n    int r = 0;\n\n    while (r < n) {\n      // 瑕疵度计算\n      int diff = idxs.get(r) - idxs.get(l) - (r - l);\n\n      if (diff > flaw) {\n        l++;\n      } else if (diff < flaw) {\n        r++;\n      } else {\n        ans = Math.max(ans, idxs.get(r) - idxs.get(l) + 1);\n        r++;\n      }\n    }\n\n    return ans;\n  }\n}",
      "python": "# 输入获取\nflaw = int(input())\ns = input()\n\n\n# 算法入口\ndef getResult():\n    yuanSet = set(list(\"aeiouAEIOU\"))\n\n    idxs = []\n    for i in range(len(s)):\n        if s[i] in yuanSet:\n            idxs.append(i)\n\n    ans = 0\n\n    l = 0\n    r = 0\n\n    while r < len(idxs):\n        # 瑕疵度计算\n        diff = idxs[r] - idxs[l] - (r - l)\n\n        if diff > flaw:\n            l += 1\n        elif diff < flaw:\n            r += 1\n        else:\n            ans = max(ans, idxs[r] - idxs[l] + 1)\n            r += 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "79",
    "title": "机房布局",
    "examType": "A",
    "score": 100,
    "description": "小明正在规划一个大型数据中心机房，为了使得机柜上的机器都能正常满负荷工作，需要确保在每个机柜边上至少要有一个电箱。 为了简化题目，假设这个机房是一整排，M表示机柜，I表示间隔，请你返回这整排机柜，至少需要多少个电箱。 如果无解请返回 -1 。\n",
    "inputDesc": "无\n",
    "outputDesc": "无\n\n\n本题其实只要朝一个方向优先放电箱即可，但是通常我们习惯从左向右遍历，因此这里优先将电箱放在机柜的右边。\n为什么要将电箱优先放在右边呢？比如下面这个例子：\nI M I M\n优先将机柜放在红色I位置，则最终只需要一个电箱。如果将机柜放绿色I位置，则最终需要两个电箱。\n再比如下面这个例子\nM I M I\n由于我们是从左往右遍历，因此第一个机柜M，优先将电箱放在它的右边。\n\n但是，如果机柜的右侧放不了电箱呢？比如\nI M M I\n此时，我们需要看机柜的左侧能不能放，如果能放，则放，不然对应机柜就没有配置电箱了。\n\n如果机柜的左右两侧都放不了电箱呢？\nM M I\n此时应该直接返回-1。\n\n另外，还有一个重要的点就是：\n如果机柜的右侧可以放电箱，比如第 i 个位置是机柜，第 i + 1个位置是间隔，则我们可以将电箱放到第 i + 1个位置上，此时：第 i + 2 个位置是什么还需要关注吗？\n比如：\nM I M I\n上面红色的M还需关注放不放电箱吗？答案是不需要，因为他必然有一个电箱了。\n此时我们可以直接跳到i+3位置重新开始上面的判断。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String str = sc.next();\n\n    System.out.println(getResult(str));\n  }\n\n  public static int getResult(String str) {\n    int n = str.length();\n\n    // ans记录用了几个电箱\n    int ans = 0;\n\n    for (int i = 0; i < n; i++) {\n      // 如果当前是机柜\n      if (str.charAt(i) == 'M') {\n        // 则优先将电箱放到该机柜的右边，如果机柜右边有间隔I的话\n        if (i + 1 < n && str.charAt(i + 1) == 'I') {\n          ans++;\n          // 如果放成功了，即当前第 i 个位置是机柜，第i+1个位置是 电箱，那么第i+2个位置无论是机柜还是间隔都无所谓，下次我们直接从第i+3位置开始判断\n          i += 2; // 这里 i += 2结合下轮for循环的i++，就是i += 3\n        }\n        // 如果当前第i位置的机柜右边无法放入电箱，则只能将电箱放到其左边第i-1位置，但是第i-1位置必须是间隔I\n        else if (i - 1 >= 0 && str.charAt(i - 1) == 'I') {\n          ans++;\n        }\n        // 如果当前机柜左右都无法放入电箱，则返回-1\n        else {\n          ans = -1;\n          break;\n        }\n      }\n    }\n\n    return ans;\n  }\n}",
      "python": "# 输入获取\ns = input()\n\n\n# 算法入口\ndef getResult(s):\n    n = len(s)\n\n    # ans记录用了几个电箱\n    ans = 0\n    i = 0\n    while i < n:\n        # 如果当前是机柜\n        if s[i] == 'M':\n            # 则优先将电箱放到该机柜的右边，如果机柜右边有间隔I的话\n            if i + 1 < n and s[i + 1] == 'I':\n                ans += 1\n                # 如果放成功了，即当前第 i 个位置是机柜，第i+1个位置是 电箱，那么第i+2个位置无论是机柜还是间隔都无所谓，下次我们直接从第i+3位置开始判断\n                i += 2  # 这里 i += 2结合后面的i +=1 ，就是i += 3\n            #  如果当前第i位置的机柜右边无法放入电箱，则只能将电箱放到其左边第i-1位置，但是第i-1位置必须是间隔I\n            elif i - 1 >= 0 and s[i - 1] == 'I':\n                ans += 1\n            # 如果当前机柜左右都无法放入电箱，则返回-1\n            else:\n                ans = -1\n                break\n        i += 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult(s))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  console.log(getResult(line));\n});\n\nfunction getResult(str) {\n  const n = str.length;\n\n  // ans记录用了几个电箱\n  let ans = 0;\n  for (let i = 0; i < n; i++) {\n    // 如果当前是机柜\n    if (str[i] == \"M\") {\n      // 则优先将电箱放到该机柜的右边，如果机柜右边有间隔I的话\n      if (i + 1 < n && str[i + 1] == \"I\") {\n        ans++;\n        // 如果放成功了，即当前第 i 个位置是机柜，第i+1个位置是 电箱，那么第i+2个位置无论是机柜还是间隔都无所谓，下次我们直接从第i+3位置开始判断\n        i += 2; // 这里 i += 2结合下轮for循环的i++，就是i += 3\n      }\n      // 如果当前第i位置的机柜右边无法放入电箱，则只能将电箱放到其左边第i-1位置，但是第i-1位置必须是间隔I\n      else if (i - 1 >= 0 && str[i - 1] == \"I\") {\n        ans++;\n      }\n      // 如果当前机柜左右都无法放入电箱，则返回-1\n      else {\n        ans = -1;\n        break;\n      }\n    }\n  }\n\n  return ans;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "80",
    "title": "比赛的冠亚季军",
    "examType": "A",
    "score": 100,
    "description": "有N（3 ≤ N < 10000）个运动员，他们的id为0到N-1,他们的实力由一组整数表示。他们之间进行比赛，需要决出冠亚军。比赛的规则是0号和1号比赛，2号和3号比赛，以此类推，每一轮，相邻的运动员进行比赛，获胜的进入下一轮；实力值大的获胜，实力值相等的情况，id小的情况下获胜；轮空的直接进入下一轮。\n",
    "inputDesc": "输入一行N个数字代表N的运动员的实力值(0<=实力值<=10000000000)。\n",
    "outputDesc": "输出冠亚季军的id，用空格隔开。\n\n第一轮比赛，\nid为0实力值为2的运动员和id为1实力值为3的运动员比赛，1号胜出进入下一轮争夺冠亚军，\nid为2的运动员和id为3的运动员比赛，3号胜出进入下一轮争夺冠亚军，\n冠亚军比赛，3号胜1号，\n故冠军为3号，亚军为1号，2号与0号，比赛进行季军的争夺，2号实力值为4，0号实力值2，故2号胜出，得季军。冠亚季军为3 1 2。\n\n本题主要考察逻辑分析。\n\n每轮晋级赛，都会将人数砍一半，因此本题不怕大数量级。\n在每轮晋级赛中，相邻的运动员组队进行比赛，比如有实力数组：[0,1,2,3,4,5,6,7,8]\n其中0,1比赛，2,3比赛，4,5比赛，6,7比赛，其中实力值较大者晋级去竞争冠军组，对于8而言，没有对手，按照题目意思是直接晋级。\n按照上面逻辑，得到获胜组为：[1,3,5,7,8]，失败组为：[0,2,4,6]\n我们可以创建一个链表用于保存每轮的获胜组和失败组，但是需要保证获胜组在头部\n即可得 [1,3,5,7,8] -> [0,2,4,6]\n\n接下来取出链表头部组[1,3,5,7,8]，继续进行晋级赛：\n其中1,3比赛，5,7比赛，8没有对手直接晋级，\n最后得到获胜组[3,7,8]，失败组[1,5]，将它们压入链表头部\n[3,7,8] -> [1,5] -> [0,2,4,6]\n\n接下来取出链表头部组[3,7,8] ，继续进行晋级赛：\n其中3,7比赛，8没有对手直接晋级，\n最后得到获胜组[7,8]，失败组[3]，将它们压入链表头部\n[7,8] -> [3] -> [1,5] -> [0,2,4,6]\n\n此时链表长度超过了3，因此链表尾部的组失去了竞争季军的资格，因此弹出尾部\n[7,8] -> [3] -> [1,5]\n而链表头部组的运动员个数还不为1，即还有多个人竞争冠军\n\n因此，继续取出链表头部组[7,8]，进行晋级赛：\n其中7,8比赛，\n最后得到获胜组[8]，失败组[7]，将它们压入链表头部\n[8] -> [7] -> [3] -> [1,5]\n\n此时链表长度超过了3，因此链表尾部的组失去了竞争季军的资格，因此弹出尾部\n[8] -> [7] -> [3]\n最后的冠军实力值8，亚军实力值7，季军实力值3\n但是题目最后要求输出的是运动员的id，因此我们在一开始的时候可以定义一个运动员类，属性有运动员的id和运动员的实力。\n这样最后输出就可以获取到运动员id了。\n\n这里还有一个需要注意的点是：\n最后一轮晋级赛，必然只有两个人，即分出冠军和亚军\n倒数第二轮晋级赛，只可能是4人，或者3人，如下图所示\n\n\n如果倒数第二轮晋级赛有五人的话，是无法在下轮中产生冠军和亚军的\n\n\n因此，季军争夺组只会有2人或者1人，因为，如下图，倒数第二轮晋级赛的失败者只有两人或者一人\n\n\n因此，前面定义的链表，最终的形态下：\n第一个节点只有一个运动员（冠军），第二个节点只有一个运动员（亚军），第三个节点可能有一个，也可能有两个（季军争夺）\n因此针对第三个节点，需要进行季军争夺，直接进行排序取第一个人即可，排序逻辑：\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  // 运动员类\n  static class Sport {\n    int id; // 运动员的id\n    long strength; // 运动员的实力\n\n    public Sport(int id, long strength) {\n      this.id = id;\n      this.strength = strength;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    long[] strengths = Arrays.stream(sc.nextLine().split(\" \")).mapToLong(Long::parseLong).toArray();\n\n    System.out.println(getResult(strengths));\n  }\n\n  public static String getResult(long[] strength) {\n    // ans只记录三个组，冠军组，亚军组，季军组\n    LinkedList<ArrayList<Sport>> ans = new LinkedList<>();\n\n    // 将输入的实力值，转化为运动员集合\n    ArrayList<Sport> sports = new ArrayList<>();\n    for (int i = 0; i < strength.length; i++) sports.add(new Sport(i, strength[i]));\n\n    // 晋级赛\n    promote(sports, ans);\n\n    // 冠军组如果不是一个人，那么还需要取出冠军组继续进行晋级赛\n    while (ans.getFirst().size() > 1) {\n      promote(ans.removeFirst(), ans);\n    }\n\n    // 冠军\n    int first = ans.get(0).get(0).id;\n\n    // 亚军\n    int second = ans.get(1).get(0).id;\n\n    // 季军\n    ans.get(2)\n        .sort(\n            (a, b) ->\n                a.strength != b.strength ? b.strength - a.strength > 0 ? 1 : -1 : a.id - b.id);\n    int third = ans.get(2).get(0).id;\n\n    return first + \" \" + second + \" \" + third;\n  }\n\n  public static void promote(ArrayList<Sport> sports, LinkedList<ArrayList<Sport>> ans) {\n    // 记录获胜组\n    ArrayList<Sport> win = new ArrayList<>();\n    // 记录失败组\n    ArrayList<Sport> fail = new ArrayList<>();\n\n    for (int i = 1; i < sports.size(); i += 2) {\n      // 序号大的运动员\n      Sport major = sports.get(i);\n      // 序号小的运动员\n      Sport minor = sports.get(i - 1);\n\n      if (major.strength > minor.strength) {\n        win.add(major);\n        fail.add(minor);\n      } else {\n        // 如果序号大的运动员的实力 <= 序号小的运动员，则序号小的运动员获胜\n        win.add(minor);\n        fail.add(major);\n      }\n    }\n\n    // 如果晋级赛中运动员个数是奇数个，那么最后一个运动员直接晋级\n    if (sports.size() % 2 != 0) {\n      win.add(sports.get(sports.size() - 1));\n    }\n\n    // 依次头部压入失败组，获胜组，保证头部是获胜组\n    ans.addFirst(fail);\n    ans.addFirst(win);\n\n    // 如果保留组个数超过3个，那么需要将超过部分的组去掉，因为这部分人已经无缘季军\n    while (ans.size() > 3) ans.removeLast();\n  }\n}",
      "python": "# 输入获取\ntmp = list(map(int, input().split()))\n\n\nclass Sport:\n    def __init__(self, idx, strength):\n        self.idx = idx  # 运动员的id\n        self.strength = strength    # 运动员的实力\n\n\n# 将输入的实力值，转化为运动员集合\nsports = []\nfor i in range(len(tmp)):\n    sports.append(Sport(i, tmp[i]))\n\n\ndef promote(sports, ans):\n    # 记录获胜组\n    win = []\n    # 记录失败组\n    fail = []\n\n    for i in range(1, len(sports), 2):\n        # 序号大的运动员\n        major = sports[i]\n        # 序号小的运动员\n        minor = sports[i-1]\n\n        if major.strength > minor.strength:\n            win.append(major)\n            fail.append(minor)\n        else:\n            # 如果序号大的运动员的实力 <= 序号小的运动员，则序号小的运动员获胜\n            win.append(minor)\n            fail.append(major)\n\n    # 如果晋级赛中运动员个数是奇数个，那么最后一个运动员直接晋级\n    if len(sports) % 2 != 0:\n        win.append(sports[-1])\n\n    # 依次头部压入失败组，获胜组，保证头部是获胜组\n    ans.insert(0, fail)\n    ans.insert(0, win)\n\n    # 如果保留组个数超过3个，那么需要将超过部分的组去掉，因为这部分人已经无缘季军\n    while len(ans) > 3:\n        ans.pop()\n\n\n# 算法入口\ndef getResult():\n    # ans只记录三个组，冠军组，亚军组，季军组\n    ans = []\n\n    # 晋级赛\n    promote(sports, ans)\n\n    # 冠军组如果不是一个人，那么还需要取出冠军组继续进行晋级赛\n    while len(ans[0]) > 1:\n        promote(ans.pop(0), ans)\n\n    # 冠军\n    first = ans[0][0].idx\n\n    # 亚军\n    second = ans[1][0].idx\n\n    # 季军\n    ans[2].sort(key=lambda x: (-x.strength, x.idx))\n    third = ans[2][0].idx\n\n    return f\"{first} {second} {third}\"\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "81",
    "title": "求字符串中所有整数的最小和",
    "examType": "A",
    "score": 100,
    "description": "输入字符串s，输出s中包含所有整数的最小和。\n说明：\n字符串s，只包含 a-z A-Z ± ； 合法的整数包括\n1） 正整数 一个或者多个0-9组成，如 0 2 3 002 102 2）负整数 负号 – 开头，数字部分由一个或者多个0-9组成，如 -0 -012 -23 -00023\n",
    "inputDesc": "包含数字的字符串\n",
    "outputDesc": "所有整数的最小和\n\n本题看上去很难，其实想清楚三点那就很简单\n\n我的解题思路如下：\n定义一个容器negative，用于存储负数的数字字符\n定义一个标识isNegative，用来记录是否遇到负数，初始化为false，标识一开始没有遇到负数\n遍历输入字符串s的每一个字符c\n需要注意的是，当c == '-'，也需要注意出现 “-34-40” 这种情况，即 c == '-'，也需要先判断isNegative == true，则需要将negative容器中内容拼接，然后转化为负数合入结果，ans -= parseInt(negative.join(\"\"))，完成后，将isNeagtive = false，并且清空negative容器。\n2023.06.01\n本题没有说明数字长度，因此Java和JS需要使用大数处理。\n2023.12.08\n修复一个问题，比如用例\nbb12-a-34aa\n可能会出现不完整负数情况，即只有一个符号的情况，此时我们应该过滤掉这种不完整负数场景\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  public static String getResult(String s) {\n    boolean isNegative = false;\n    StringBuilder negative = new StringBuilder();\n\n    //    int ans = 0;\n    BigInteger ans = new BigInteger(\"0\");\n\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n\n      if (c >= '0' && c <= '9') {\n        if (isNegative) {\n          negative.append(c);\n        } else {\n          //          ans += Integer.parseInt(c + \"\");\n          ans = ans.add(new BigInteger(c + \"\"));\n        }\n      } else {\n        if (isNegative && negative.length() > 0) {\n          //          ans -= Integer.parseInt(negative.toString());\n          ans = ans.subtract(new BigInteger(negative.toString()));\n          negative = new StringBuilder();\n        }\n\n        isNegative = c == '-';\n      }\n    }\n\n    if (negative.length() > 0) {\n      //      ans -= Integer.parseInt(negative.toString());\n      ans = ans.subtract(new BigInteger(negative.toString()));\n    }\n\n    return ans.toString();\n  }\n}",
      "python": "# 输入获取\ns = input()\n\n\n# 算法入口\ndef getResult():\n    isNegative = False\n    negative = []\n\n    ans = 0\n    for c in s:\n        if '0' <= c <= '9':\n            if isNegative:\n                negative.append(c)\n            else:\n                ans += int(c)\n        else:\n            if isNegative and len(negative) > 0:\n                ans -= int(\"\".join(negative))\n                negative.clear()\n            isNegative = c == '-'\n\n    if len(negative) > 0:\n        ans -= int(\"\".join(negative))\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "82",
    "title": "玩牌高手",
    "examType": "A",
    "score": 100,
    "description": "给定一个长度为n的整型数组，表示一个选手在n轮内可选择的牌面分数。选手基于规则选牌，\n请计算所有轮结束后其可以获得的最高总分数。\n选择规则如下：\n在每轮里选手可以选择获取该轮牌面，则其总分数加上该轮牌面分数，为其新的总分数。选手也可不选择本轮牌面直接跳到下一轮，此时将当前总分数还原为3轮前的总分数，若当前轮次小于等于3（即在第1、2、3轮选择跳过轮次），则总分数置为0。选手的初始总分数为0，且必须依次参加每一轮。\n",
    "inputDesc": "第一行为一个小写逗号分割的字符串，表示n轮的牌面分数，1<= n <=20。\n分数值为整数，-100 <= 分数值 <= 100。\n不考虑格式问题。\n",
    "outputDesc": "所有轮结束后选手获得的最高总分数。\n\n\n这题是一道简单的动态规划的题目，因为每一轮的总分都与前面轮次的总分有状态转移关系。\n\n比如 1,-5,-6,4,3,6,-2\n第1轮，牌面1，我们选了的话，总分1，不选的话，总分0，而本轮总分正数的话，对后面轮总分有益，因此我们选牌面1，让总分为1\n第2轮，牌面-5，我们选了的话，总分-5+1=-4，不选的话，总分重置为0，因此我们不选，因为负数总分对后面轮次总分无益，此时总分为0\n第3轮，牌面-6，同样不选，总分为0\n第4轮，牌面4，选，总分4\n第5轮，牌面3，选，总分7\n第6轮，牌面6，选，总分13\n第7轮，牌面-2，如果我们不选，则总分将还原为3轮前的总分数，即第4轮，总分变为4，如果我们选了，则总分为13-2=11，而11>4，因此我们选牌面-2\n最终最高总分为11。\n\n通过上面逻辑我们可以总结出状态转移方程如下：\ndp[0] = max(arr[0], 0)\ndp[i] = max(dp[i-1] + arr[i], 0) , 1<=i<=2\ndp[i] = max(dp[i-1] + arr[i], dp[i-3]), i>2\n\ndp数组用于存储每轮的最高总分。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n \npublic class Main {\n  // 输入获取\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n \n    Integer[] arr =\n        Arrays.stream(sc.nextLine().split(\",\")).map(Integer::parseInt).toArray(Integer[]::new);\n \n    System.out.println(getResult(arr));\n  }\n \n  // 算法入口\n  public static int getResult(Integer[] arr) {\n    int n = arr.length;\n \n    int[] dp = new int[n];\n \n    for (int i = 0; i < n; i++) {\n      if (i == 0) {\n        dp[0] = Math.max(0, arr[0]);\n      } else if (i < 3) {\n        dp[i] = Math.max(0, dp[i - 1] + arr[i]);\n      } else {\n        dp[i] = Math.max(dp[i - 3], dp[i - 1] + arr[i]);\n      }\n    }\n \n    return dp[n - 1];\n  }\n}",
      "python": "# 输入获取\narr = list(map(int, input().split(\",\")))\n \n \n# 算法入口\ndef getResult():\n    n = len(arr)\n \n    dp = [0] * n\n \n    for i in range(n):\n        if i == 0:\n            dp[0] = max(0, arr[0])\n        elif i < 3:\n            dp[i] = max(0, dp[i - 1] + arr[i])\n        else:\n            dp[i] = max(dp[i - 3], dp[i - 1] + arr[i])\n \n    return dp[-1]\n \n \n# 算法调用\nprint(getResult())",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const arr = line.split(\",\").map((ele) => parseInt(ele));\n\n  console.log(getMaxScore(arr));\n});\n\nfunction getMaxScore(arr) {\n  const dp = [];\n\n  for (let i = 0; i < arr.length; i++) {\n    if (i === 0) {\n      dp[0] = Math.max(arr[0], 0);\n    } else if (i > 0 && i < 3) {\n      dp[i] = Math.max(dp[i - 1] + arr[i], 0);\n    } else {\n      dp[i] = Math.max(dp[i - 1] + arr[i], dp[i - 3]);\n    }\n  }\n\n  return dp.pop();\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "83",
    "title": "用户调度问题",
    "examType": "A",
    "score": 100,
    "description": "在通信系统中，一个常见的问题是对用户进行不同策略的调度，会得到不同的系统消耗和性能。\n假设当前有n个待串行调度用户，每个用户可以使用A/B/C三种不同的调度策略，不同的策略会消耗不同的系统资源。请你根据如下规则进行用户调度，并返回总的消耗资源数。\n规则：\n相邻的用户不能使用相同的调度策略，例如，第1个用户使用了A策略，则第2个用户只能使用B或者C策略。对单个用户而言，不同的调度策略对系统资源的消耗可以归一化后抽象为数值。例如，某用户分别使用A/B/C策略的系统消耗分别为15/8/17。每个用户依次选择当前所能选择的对系统资源消耗最少的策略（局部最优），如果有多个满足要求的策略，选最后一个。\n",
    "inputDesc": "第一行表示用户个数n\n接下来每一行表示一个用户分别使用三个策略的系统消耗resA resB resC\n",
    "outputDesc": "最优策略组合下的总的系统资源消耗数\n\n3 15 8 17 12 20 9 11 7 5\n\n本题第3个条件如下：\n每个用户依次选择当前所能选择的对系统资源消耗最少的策略（局部最优），如果有多个满足要求的策略，选最后一个。\n其中，每个用户选择得策略，只需要满足局部最优即可，比如题目用例：\n第1个用户，局部最优应该选[15, 8, 17]中最小值8\n第2个用户，由于受限于相邻用户不能选相同位置得策略，因此只能选择[12, 9]中局部最优的9\n第3个用户，由于受限于相邻用户不能选相同位置得策略，因此只能选择[11, 7]中局部最优的7\n因此，最终总消耗为：8 + 9 + 7 = 24\n因此，有了这个局部最优的条件，本题的难度大大降低了。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    int[][] res = new int[n][3];\n    for (int i = 0; i < n; i++) {\n      res[i][0] = sc.nextInt();\n      res[i][1] = sc.nextInt();\n      res[i][2] = sc.nextInt();\n    }\n\n    System.out.println(getResult(n, res));\n  }\n\n  public static int getResult(int n, int[][] res) {\n    int last = -1;\n    int sum = 0;\n\n    for (int i = 0; i < n; i++) {\n      last = getMinEleIdx(res[i], last);\n      sum += res[i][last];\n    }\n\n    return sum;\n  }\n\n  public static int getMinEleIdx(int[] arr, int excludeIdx) {\n    int minEleVal = Integer.MAX_VALUE;\n    int minEleIdx = -1;\n\n    for (int i = 0; i < arr.length; i++) {\n      if (i == excludeIdx) continue;\n\n      if (arr[i] <= minEleVal) {\n        minEleVal = arr[i];\n        minEleIdx = i;\n      }\n    }\n\n    return minEleIdx;\n  }\n}",
      "python": "import sys\n\n# 输入获取\nn = int(input())\nres = [list(map(int, input().split())) for _ in range(n)]\n\n\ndef getMinEleIdx(arr, excludeIdx):\n    minEleVal = sys.maxsize\n    minEleIdx = -1\n\n    for i in range(len(arr)):\n        if i == excludeIdx:\n            continue\n\n        if arr[i] <= minEleVal:\n            minEleVal = arr[i]\n            minEleIdx = i\n\n    return minEleIdx\n\n\n# 算法入口\ndef getResult():\n    last = -1\n    total = 0\n\n    for i in range(n):\n        last = getMinEleIdx(res[i], last)\n        total += res[i][last]\n\n    return total\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet m;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    m = parseInt(lines[0]);\n  }\n\n  if (m != undefined && lines.length === m + 1) {\n    lines.shift();\n    const res = lines.map((line) => line.split(\" \").map(Number));\n    const ans = [Infinity];\n    dfs(res, m, 0, -1, 0, ans);\n    console.log(ans[0]);\n\n    lines.length = 0;\n  }\n});\n\nfunction dfs(res, m, level, index, total, ans) {\n  if (level == m) {\n    ans[0] = Math.min(ans[0], total);\n    return;\n  }\n\n  const r = res[level];\n  for (let i = 0; i < r.length; i++) {\n    if (i != index) {\n      dfs(res, m, level + 1, i, total + r[i], ans);\n    }\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "84",
    "title": "矩阵扩散",
    "examType": "A",
    "score": 100,
    "description": "存在一个m×n的二维数组，其成员取值范围为0或1。\n其中值为1的成员具备扩散性，每经过1S，将上下左右值为0的成员同化为1。\n二维数组的成员初始值都为0，将第[i,j]和[k,l]两个个位置上元素修改成1后，求矩阵的所有元素变为1需要多长时间。\n",
    "inputDesc": "输入数据中的前2个数字表示这是一个m×n的矩阵，m和n不会超过1024大小；\n中间两个数字表示一个初始扩散点位置为i,j；\n最后2个数字表示另一个扩散点位置为k,l。\n",
    "outputDesc": "输出矩阵的所有元素变为1所需要秒数。\n\n输入数据中的前2个数字表示这是一个4*4的矩阵；\n中间两个数字表示一个初始扩散点位置为0,0；\n最后2个数字表示另一个扩散点位置为3,3。\n给出的样例是一个简单模型，初始点在对角线上，达到中间的位置分别为3次迭代，即3秒。所以输出为3。\n\n用例图示如下：\n\n一共需要4-1=3秒。\n\n本题可以使用图的多源BFS来解题。\n关于图的多源BFS得解析，请看：\n华为OD机试 - 计算疫情扩散时间_伏城之外的博客-CSDN博客\n更多相关题目请看：\n华为OD机试 - 污染水域_伏城之外的博客-CSDN博客\n华为OD机试 - 计算网络信号、输出给定位置的信号强弱_伏城之外的博客-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    Integer[] arr =\n        Arrays.stream(sc.next().split(\",\")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    System.out.println(getResult(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]));\n  }\n\n  /**\n   * @param m m m×n的二维数组\n   * @param n n m×n的二维数组\n   * @param i 扩散点位置为i,j\n   * @param j 扩散点位置为i,j\n   * @param k 扩散点位置为k,l\n   * @param l 扩散点位置为k,l\n   * @return 扩散所有点需要的时间\n   */\n  public static int getResult(int m, int n, int i, int j, int k, int l) {\n    int[][] matrix = new int[m][n];\n    matrix[i][j] = 1;\n    matrix[k][l] = 1;\n\n    // count记录未被扩散的点的数量\n    int count = m * n - 2;\n\n    // 多源BFS实现队列\n    LinkedList<int[]> queue = new LinkedList<>();\n    queue.addLast(new int[] {i, j});\n    queue.addLast(new int[] {k, l});\n\n    // 上下左右偏移量\n    int[][] offsets = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    int day = 0;\n    // 如果扩散点没有了，或者所有点已被扩散，则停止循环\n    while (queue.size() > 0 && count > 0) {\n      LinkedList<int[]> newQueue = new LinkedList<>();\n\n      for (int[] pos : queue) {\n        int x = pos[0];\n        int y = pos[1];\n\n        for (int[] offset : offsets) {\n          int newX = x + offset[0];\n          int newY = y + offset[1];\n\n          if (newX >= 0 && newX < m && newY >= 0 && newY < n && matrix[newX][newY] == 0) {\n            // 将点被扩散的时间记录为该点的值\n            matrix[newX][newY] = 1;\n            // 被扩散到的点将变为新的扩散源\n            newQueue.addLast(new int[] {newX, newY});\n            // 未被扩散点的数量--\n            count--;\n          }\n        }\n      }\n\n      queue = newQueue;\n      day++;\n    }\n\n    return day;\n  }\n}",
      "python": "# 输入获取\nm, n, i, j, k, l = map(int, input().split(\",\"))\n\n\n# 算法入口\ndef getResult(m, n, i, j, k, l):\n    \"\"\"\n    :param m: 矩阵行数\n    :param n: 矩阵列数\n    :param i: 扩散点1行号\n    :param j: 扩散点1列好\n    :param k: 扩散点2行号\n    :param l: 扩散点2列号\n    :return: 矩阵的所有元素变为1所需要秒数\n    \"\"\"\n    matrix = [[0 for _ in range(n)] for _ in range(m)]\n    matrix[i][j] = 1\n    matrix[k][l] = 1\n\n    # count记录未被扩散的点的数量\n    count = m * n - 2\n\n    # 多源BFS实现队列\n    queue = [[i, j], [k, l]]\n\n    # 上下左右偏移量\n    offsets = ((1, 0), (-1, 0), (0, 1), (0, -1))\n\n    day = 0\n\n    # 如果扩散点没有了，或者所有点已被扩散，则停止循环\n    while len(queue) > 0 and count > 0:\n        newQueue = []\n\n        for x, y in queue:\n            for offsetX, offsetY in offsets:\n                newX = x + offsetX\n                newY = y + offsetY\n\n                if 0 <= newX < m and 0 <= newY < n and matrix[newX][newY] == 0:\n                    # 将点被扩散的时间记录为该点的值\n                    matrix[newX][newY] = 1\n                    # 被扩散到的点将变为新的扩散源\n                    newQueue.append([newX, newY])\n                    # 未被扩散点的数量--\n                    count -= 1\n\n        queue = newQueue\n        day += 1\n\n    return day\n\n\n# 算法调用\nprint(getResult(m, n, i, j, k, l))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const [m, n, i, j, k, l] = line.split(\",\").map(Number);\n  console.log(getResult(m, n, i, j, k, l));\n});\n\n/**\n * @param {*} m m×n的二维数组\n * @param {*} n m×n的二维数组\n * @param {*} i 扩散点位置为i,j\n * @param {*} j 扩散点位置为i,j\n * @param {*} k 扩散点位置为k,l\n * @param {*} l 扩散点位置为k,l\n */\nfunction getResult(m, n, i, j, k, l) {\n  const matrix = new Array(m).fill(0).map(() => new Array(n).fill(0));\n  matrix[i][j] = 1;\n  matrix[k][l] = 1;\n\n  // count记录未被扩散的点的数量\n  let count = m * n - 2;\n\n  // 多源BFS实现队列\n  let queue = [\n    [i, j],\n    [k, l],\n  ];\n\n  // 上下左右偏移量\n  const offsets = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1],\n  ];\n\n  let day = 0;\n\n  // 如果扩散点没有了，或者所有点已被扩散，则停止循环\n  while (queue.length > 0 && count > 0) {\n    const newQueue = [];\n\n    for (const [x, y] of queue) {\n      for (let [offsetX, offsetY] of offsets) {\n        const newX = x + offsetX;\n        const newY = y + offsetY;\n\n        if (\n          newX >= 0 &&\n          newX < m &&\n          newY >= 0 &&\n          newY < n &&\n          matrix[newX][newY] == 0\n        ) {\n          // 将点被扩散的时间记录为该点的值\n          matrix[newX][newY] = 1;\n          // 被扩散到的点将变为新的扩散源\n          newQueue.push([newX, newY]);\n          // 未被扩散点的数量--\n          count--;\n        }\n      }\n    }\n\n    queue = newQueue;\n    day++;\n  }\n\n  return day;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "85",
    "title": "租车骑绿岛",
    "examType": "A",
    "score": 100,
    "description": "部门组织绿岛骑行团建活动。租用公共双人自行车，每辆自行车最多坐两人，最大载重M。 给出部门每个人的体重，请问最多需要租用多少双人自行车。\n",
    "inputDesc": "第一行两个数字m、n，分别代表自行车限重，部门总人数。\n第二行，n个数字，代表每个人的体重，体重都小于等于自行车限重m。\n0<m<=2000<n<=1000000\n",
    "outputDesc": "最小需要的双人自行车数量。\n\n\n本题需要最少的车辆，即尽可能组合出重量小于等于m的两人组。\n\n首先，我们可以将所有人按体重升序，然后将最大体重和m比较，若最大体重大于等于m，则这个人只能一人占一辆车，车数量count++，然后将最大体重弹出，继续将剩下体重中最大的和m比较，逻辑同上，直到最大体重小于m时，停止弹出。\n\n在剩余体重中，我们利用双指针，i指针指向最小体重，j指针指向最大体重，然后组合它们，即arr[i]+arr[j]，和m比较，若小于等于m，则说明这两个人可以共享一辆车，车数量count++，然后i++，j--。如果arr[i]+arr[j]>m，则说明两个人无法共享一辆车，我们只能优先将这里车分配给较大体重的人，此时车数量count++，然后j--。\n\n按上面逻辑移动双指针，最后可能会出现两种情况：\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n      arr[i] = sc.nextInt();\n    }\n\n    System.out.println(getResult(arr, m));\n  }\n\n  public static int getResult(int[] arr, int m) {\n    Arrays.sort(arr);\n\n    int count = 0;\n\n    int i = 0;\n    int j = arr.length - 1;\n\n    while (i < j) {\n      if (arr[i] + arr[j] <= m) i++;\n      j--;\n      count++;\n    }\n\n    if (i == j) count++;\n\n    return count;\n  }\n}",
      "python": "# 输入获取\nm, n = map(int, input().split())\narr = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult(arr, m, n):\n    arr.sort()\n\n    count = 0\n\n    i = 0\n    j = n - 1\n\n    while i < j:\n        if arr[i] + arr[j] <= m:\n            i += 1\n        j -= 1\n        count += 1\n\n    if i == j:\n        count += 1\n\n    return count\n\n\n# 算法调用\nprint(getResult(arr, m, n))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const [m, n] = lines[0].split(\" \").map(Number);\n    const arr = lines[1].split(\" \").map(Number);\n\n    console.log(getResult(arr, m, n));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(arr, m, n) {\n  arr.sort((a, b) => a - b);\n\n  let count = 0;\n\n  // while (arr.at(-1) >= m) {\n  //   count++;\n  //   arr.pop();\n  // }\n\n  let i = 0;\n  let j = arr.length - 1;\n\n  while (i < j) {\n    if (arr[i] + arr[j] <= m) i++;\n    j--;\n    count++;\n  }\n\n  if (i === j) count++;\n\n  return count;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "86",
    "title": "箱子之字形摆放",
    "examType": "A",
    "score": 100,
    "description": "有一批箱子（形式为字符串，设为str）， 要求将这批箱子按从上到下以之字形的顺序摆放在宽度为 n 的空地，请输出箱子的摆放位置。 例如：箱子ABCDEFG，空地宽度为3，摆放结果如图：\n\n则输出结果为：AFGBECD\n",
    "inputDesc": "输入一行字符串，通过空格分隔，前面部分为字母或数字组成的字符串str，表示箱子； 后面部分为数字n，表示空地的宽度。例如：ABCDEFG 3\n",
    "outputDesc": "箱子摆放结果，如题目示例所示\nAFGBECD\n\n\n\n我的解题思路如下：\n首先定义一个不定宽的二维矩阵，JS的话很简单，Java的话需要定义为List<List>结构，这个二维矩阵的高度就是给定的空地的n大小，即用例对应的初始二维矩阵应该如下\n{\n{},\n{},\n{}\n}\n然后，遍历字符串的每一个字符，比如用例中ABCDEFG，首先A被插入二维矩阵的第0行，即字符A在字符串中的索引 i % n 的值，比如A字符索引为i=0，n=3, 因此插入行为 i % n = 0\n{\n{A},\n{},\n{}\n}\n遍历B，插入二维矩阵第1行，即 i=1 , n =3, i % n = 1\n{\n{A},\n{B},\n{}\n}\n遍历C，插入二维矩阵的第2行，即 i=2, n=3, i%n=2\n{\n{A},\n{B},\n{C}\n}\n下面到关键点了，遍历D，应该插入二维矩阵的第几行呢？按照前面公式 i=3，n=3，插入行应该是第 i % n = 0 行。\n但是实际上，应该要是第2行，如下面所示\n{\n{A},\n{B},\n{C，D}\n}\n因此，此时插入行的公式应该变为 插入行 = n - 1 - (i%n) = 3-1-0 = 2\n后面E、F的插入都遵循该公式\n{\n{A，F},\n{B，E},\n{C，D}\n}\n但是遍历到G时，G的索引i = 6，n=3, i % n = 0，那么此时G应该插入哪一行呢？按照前面的公式，应该插入n - 1 - (i%n) = 3-1-0 = 2，但是实际上应该插入第0行，如下所示\n{\n{A，F，G},\n{B，E},\n{C，D}\n}\n此时，我们可以总结出，遍历的字符插入到二维矩阵的行数和其索引有关，索引和行数的转换方程有两个：\n初始时，用公式：行数 = i % n，\n当遇到 i % n ==0时，变换公式为：行数 = n - 1 - (i%n)，\n当遇到 i%n==0时，再变换公式为：行数 = i % n，\n当遇到 i % n ==0时，变换公式为：行数 = n - 1 - (i%n)，\n当遇到 i%n==0时，再变换公式为：行数 = i % n，\n.......\n\n因此我们可以用一个reverse来标记，\n当reverse=true，用公式：行数 = i % n\n当reverse=false，用公式：行数 = n - 1 - (i%n)\n而reverse变化的条件就是i % n ==0，每遇到i % n ==0，reverse = !reverse\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String str = sc.next();\n    int n = sc.nextInt();\n\n    getResult(str, n);\n  }\n\n  public static void getResult(String str, int n) {\n    ArrayList<ArrayList<Character>> matrix = new ArrayList<>();\n    for (int i = 0; i < n; i++) matrix.add(new ArrayList<>());\n\n    boolean reverse = true;\n    for (int i = 0; i < str.length(); i++) {\n      int k = i % n;\n      if (k == 0) reverse = !reverse;\n      if (reverse) k = n - 1 - k;\n      matrix.get(k).add(str.charAt(i));\n    }\n\n    for (ArrayList<Character> list : matrix) {\n      StringBuilder sb = new StringBuilder();\n      for (Character character : list) {\n        sb.append(character);\n      }\n      System.out.println(sb);\n    }\n  }\n}",
      "python": "",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const [str, n] = line.split(\" \");\n  getResult(str, n - 0);\n});\n\nfunction getResult(str, n) {\n  const len = str.length;\n\n  const matrix = new Array(n).fill(0).map(() => new Array());\n\n  let reverse = true;\n  for (let i = 0; i < len; i++) {\n    k = i % n;\n    if (k === 0) reverse = !reverse;\n    if (reverse) k = n - 1 - k;\n    matrix[k].push(str[i]);\n  }\n\n  matrix.forEach((arr) => console.log(arr.join(\"\")));\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "87",
    "title": "计算最接近的数",
    "examType": "A",
    "score": 100,
    "description": "给定一个数组X和正整数K，请找出使表达式：\nX[i] - X[i + 1] - ... - X[i + K - 1]\n结果最接近于数组中位数的下标 i ，如果有多个 i 满足条件，请返回最大的 i.\n其中，数组中位数：长度为N的数组，按照元素的值大小升序排列后，下标为 N/2 元素的值\n",
    "inputDesc": "无\n",
    "outputDesc": "无\n\n\n\n本题应该是采用核心代码模式，非ACM模式，因此不需要我们处理输入输出。\n下面代码仍然以ACM模式实现，但是会将输入输出处理 和 核心代码 分离。考试时，只需要写出核心代码即可。\n\n本题可以使用滑动窗口解题。\n本题其实就是要遍历所有长度为k的滑窗，滑窗内部元素需要按照表达式\nX[i] - X[i + 1] - ... - X[i + K - 1]\n来求得该滑窗对应得表达式计算结果window。\n然后，求解window和数组x中位数mid的差距，差距绝对值越小，则说明二者越接近\n结果最接近于数组中位数的下标 i ，如果有多个 i 满足条件，请返回最大的 i.\n\n本题的难点在于滑窗右移时，新、旧滑窗的状态转移。\n\n假设旧滑窗的表达式计算结果为window，那么新滑窗的表达式计算结果应该是：\nwindow - x[i-1] + x[i] * 2 - x[i + k -1]\n其中 x[i] * 2 的原因是，新滑窗中x[i]是正的，而旧滑窗中x[i]是负的，为了将-x[i] 变为 +x[i]， 则需要为 -x[i] + x[i] * 2\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String line = sc.nextLine();\n\n    int i = line.lastIndexOf(\",\");\n\n    int[] x =\n        Arrays.stream(line.substring(1, i - 1).split(\",\")).mapToInt(Integer::parseInt).toArray();\n    int k = Integer.parseInt(line.substring(i + 1));\n\n    System.out.println(getResult(x, k));\n  }\n\n  public static int getResult(int[] x, int k) {\n    int n = x.length;\n\n    // x数组的中位数\n    int mid = Arrays.stream(x).sorted().toArray()[n / 2];\n\n    // 初始化滑窗0~k-1, window为滑窗内部元素的表达式计算结果\n    int window = x[0];\n    for (int i = 1; i < k; i++) {\n      window -= x[i];\n    }\n\n    // window和中位数的差距\n    int minDiff = Math.abs(mid - window);\n    // window滑窗起始索引\n    int idx = 0;\n\n    // 滑窗右移\n    for (int i = 1; i <= n - k; i++) {\n      // 右移一格后，新滑窗的表达式计算结果\n      window += -x[i - 1] + 2 * x[i] - x[i + k - 1];\n\n      // 新滑窗window值和中位数的差距\n      int diff = Math.abs(mid - window);\n\n      // 结果最接近于数组中位数的下标 i ，如果有多个 i 满足条件，请返回最大的 i\n      if (diff <= minDiff) {\n        minDiff = diff;\n        idx = i;\n      }\n    }\n\n    return idx;\n  }\n}",
      "python": "# 输入获取\ntmp = input()\n\ni = tmp.rfind(\",\")\n\nx = list(map(int, tmp[1:i-1].split(\",\")))\nk = int(tmp[i+1:])\n\n\n# 核心代码\ndef getResult():\n    n = len(x)\n\n    # x数组的中位数\n    mid = sorted(x)[n // 2]\n\n    # 初始化滑窗0~k-1, window为滑窗内部元素的表达式计算结果\n    window = x[0]\n    for j in range(1, k):\n        window -= x[j]\n\n    # window和中位数的差距\n    minDiff = abs(mid - window)\n    # window滑窗起始索引\n    idx = 0\n\n    # 滑窗右移\n    for i in range(1, n-k+1):\n        # 右移一格后，新滑窗的表达式计算结果\n        window += -x[i-1] + 2 * x[i] - x[i + k -1]\n\n        # 新滑窗window值和中位数的差距\n        diff = abs(mid - window)\n\n        # 结果最接近于数组中位数的下标 i ，如果有多个 i 满足条件，请返回最大的 i\n        if diff <= minDiff:\n            minDiff = diff\n            idx = i\n\n    return idx\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "88",
    "title": "路灯照明问题",
    "examType": "A",
    "score": 100,
    "description": "在一条笔直的公路上安装了N个路灯，从位置0开始安装，路灯之间间距固定为100米。 每个路灯都有自己的照明半径，请计算第一个路灯和最后一个路灯之间，无法照明的区间的长度和。\n",
    "inputDesc": "第一行为一个数N，表示路灯个数，1<=N<=100000 第二行为N个空格分隔的数，表示路灯的照明半径，1<=照明半径<=100000*100\n",
    "outputDesc": "第一个路灯和最后一个路灯之间，无法照明的区间的长度和\n\n输入\n解释\n\n本题可以转化为区间问题。\n每个路灯的位置都是确定，假设路灯的索引为 i，那么其位置就是 i * 100。\n根据第二行输入的路灯的照明半径数组arr，我们可以基于路灯的位置，求得路灯的照明范围区间\n假设center = i * 100，r = arr[i]，那么照明范围区间即为：[center - r, center + r]\n这样的话，我们就得到了一组区间。\n\n接下来，我们就需要将这些区间进行合并，合并后，求剩余没有交集的区间的间隙之和就是题解。\n这里区间合并是有技巧的，我们一般：\n这样排序的好处是，所有区间都按照起始位置升序排序了，比如第一个ran[0]和第二个区间ran[1]，我们可以确定：ran[0].start <= ran[1].start\n由于这两个区间的起始位置关系已经确定了，判断这两个区间是否有交集，只要看ran[0].end和ran[1].start即可，如果ran[0].end > ran[1].start，则说明这两个区间有交集，可以合并。\n另外，如果ran[0]和ran[1]的起始位置相同的话，则上面排序还会按照结束位置进行降序，即必然ran[0].end >= ran[1].end。\n这样排序的好处是，后面区间的结束位置小于前面区间的结束位置时，可以直接放心并入前面区间，而不需要再进行起始位置相同的两个区间的结束位置比较。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    int[][] ranges = new int[n][2];\n    for (int i = 0; i < n; i++) {\n      int center = i * 100;\n      int r = sc.nextInt();\n      ranges[i][0] = center - r;\n      ranges[i][1] = center + r;\n    }\n\n    System.out.println(getResult(n, ranges));\n  }\n\n  public static int getResult(int n, int[][] ranges) {\n    int ans = 0;\n\n    // 按起始位置升序，起始位置相同，则继续按结束位置降序\n    Arrays.sort(ranges, (a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\n\n    int t = ranges[0][1]; // 上一个区间的结束位置\n\n    for (int i = 1; i < n; i++) {\n      // 当前区间的【开始位置，结束位置】\n      int s = ranges[i][0];\n      int e = ranges[i][1];\n\n      // 有交集\n      if (t >= s) {\n        // 合并后的新区间将变为下一轮的上一个区间，t为新区间的结束位置\n        t = Math.max(e, t);\n      } else {\n        // 没有交集，则统计区间间隙 s - t\n        ans += s - t;\n        // 当前区间变为下一轮的上一个区间，更新t\n        t = e;\n      }\n    }\n\n    return ans;\n  }\n}",
      "python": "# 输入获取\nn = int(input())\narr = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult():\n    rans = []\n\n    for i in range(n):\n        center = i * 100\n        rans.append([center - arr[i], center + arr[i]])\n\n    # 按起始位置升序，起始位置相同，则继续按结束位置降序\n    rans.sort(key=lambda ran: (ran[0], -ran[1]))\n\n    ans = 0\n\n    t = rans[0][1]  # 上一个区间的结束位置\n    for i in range(1, n):\n        s, e = rans[i]  # 当前区间的【开始位置，结束位置】\n\n        # 有交集\n        if t >= s:\n            # 合并后的新区间将变为下一轮的上一个区间，t为新区间的结束位置\n            t = max(e, t)\n        else:\n            # 没有交集，则统计区间间隙 s - t\n            ans += s - t\n            #  当前区间变为下一轮的上一个区间，更新t\n            t = e\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const n = lines[0] - 0;\n    const arr = lines[1].split(\" \").map(Number);\n\n    console.log(getResult(n, arr));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(n, arr) {\n  const ranges = [];\n\n  for (let i = 0; i < n; i++) {\n    const center = i * 100;\n    ranges.push([center - arr[i], center + arr[i]]);\n  }\n\n  // 按起始位置升序，起始位置相同，则继续按结束位置降序\n  ranges.sort((a, b) => (a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]));\n\n  let ans = 0;\n\n  let t = ranges[0][1]; // 上一个区间的结束位置\n  for (let i = 1; i < n; i++) {\n    const [s, e] = ranges[i]; // 当前区间的【开始位置，结束位置】\n\n    // 有交集\n    if (t >= s) {\n      // 合并后的新区间将变为下一轮的上一个区间，t为新区间的结束位置\n      t = Math.max(e, t);\n    } else {\n      // 没有交集，则统计区间间隙 s - t\n      ans += s - t;\n      // 当前区间变为下一轮的上一个区间，更新t\n      t = e;\n    }\n  }\n\n  return ans;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "89",
    "title": "静态扫描",
    "examType": "A",
    "score": 100,
    "description": "静态扫描可以快速识别源代码的缺陷，静态扫描的结果以扫描报告作为输出：\n1、文件扫描的成本和文件大小相关，如果文件大小为N，则扫描成本为N个金币\n2、扫描报告的缓存成本和文件大小无关，每缓存一个报告需要M个金币\n3、扫描报告缓存后，后继再碰到该文件则不需要扫描成本，直接获取缓存结果\n给出源代码文件标识序列和文件大小序列，求解采用合理的缓存策略，最少需要的金币数。\n",
    "inputDesc": "第一行为缓存一个报告金币数M，L<= M <= 100\n第二行为文件标识序列：F1,F2,F3,....,Fn。\n第三行为文件大小序列：S1,S2,S3,....,Sn。\n\n备注：\n1 <= N <= 100001 <= Fi <= 10001 <= Si <= 10\n",
    "outputDesc": "采用合理的缓存策略，需要的最少金币数\n\n简单的贪心思维逻辑题，解析请看代码注释。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = Integer.parseInt(sc.nextLine());\n    Integer[] f =\n        Arrays.stream(sc.nextLine().split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n    Integer[] s =\n        Arrays.stream(sc.nextLine().split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    System.out.println(getResult(m, f, s));\n  }\n\n  public static int getResult(int m, Integer[] f, Integer[] s) {\n    // count用于保存每个文件出现的次数\n    HashMap<Integer, Integer> count = new HashMap<>();\n    // size用于保存文件的大小，即扫描成本\n    HashMap<Integer, Integer> size = new HashMap<>();\n\n    for (int i = 0; i < f.length; i++) {\n      // k是文件标识\n      Integer k = f[i];\n      count.put(k, count.getOrDefault(k, 0) + 1);\n      size.putIfAbsent(k, s[i]);\n    }\n\n    int ans = 0;\n    for (Integer k : count.keySet()) {\n      // 选择每次都重新扫描的成本  和  扫描一次+缓存的成本  中最小的\n      ans += Math.min(count.get(k) * size.get(k), size.get(k) + m);\n    }\n\n    return ans;\n  }\n}",
      "python": "# 输入获取\nm = int(input())\nf = list(map(int, input().split()))\ns = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult(m, f, s):\n    # count用于保存每个文件出现的次数\n    count = {}\n    # size用于保存文件的大小，即扫描成本\n    size = {}\n\n    for i in range(len(f)):\n        # k是文件标识\n        k = f[i]\n        if count.get(k) is None:\n            count[k] = 1\n        else:\n            count[k] += 1\n\n        if size.get(k) is None:\n            size[k] = s[i]\n\n    ans = 0\n    for k in count.keys():\n        # 选择每次都重新扫描的成本  和  扫描一次+缓存的成本  中最小的\n        ans += min(count[k] * size[k], size[k] + m)\n    return ans\n\n\nprint(getResult(m, f, s))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet m, f, s;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 3) {\n    m = lines[0] - 0;\n    f = lines[1].split(\" \").map(Number);\n    s = lines[2].split(\" \").map(Number);\n\n    console.log(getResult(m, f, s));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(m, f, s) {\n  // count用于保存每个文件出现的次数\n  const count = {};\n  // size用于保存文件的大小，即扫描成本\n  const size = {};\n  for (let i = 0; i < f.length; i++) {\n    // k是文件标识\n    const k = f[i];\n    count[k] ? count[k]++ : (count[k] = 1);\n    if (!size[k]) {\n      size[k] = s[i];\n    }\n  }\n\n  let ans = 0;\n  for (let k in count) {\n    // 选择每次都重新扫描的成本  和  扫描一次+缓存的成本  中最小的\n    ans += Math.min(count[k] * size[k], size[k] + m);\n  }\n\n  return ans;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "90",
    "title": "boss的收入",
    "examType": "A",
    "score": 100,
    "description": "一个XX产品行销总公司，只有一个boss，其有若干一级分销，一级分销又有若干二级分销，每个分销只有唯一的上级分销。\n规定，每个月，下级分销需要将自己的总收入（自己的+下级上交的）每满100元上交15元给自己的上级。\n现给出一组分销的关系，和每个分销的收入，请找出boss并计算出这个boss的收入。\n比如：\n收入100元，上交15元；收入199元（99元不够100），上交15元；收入200元，上交30元。\n输入：\n分销关系和收入：[[分销id 上级分销id 收入], [分销id 上级分销id 收入], [分销id 上级分销id 收入]]\n分销ID范围： 0…65535收入范围：0…65535，单位元\n提示： 输入的数据只存在1个boss，不存在环路\n输出：\n[boss的ID, 总收入]",
    "inputDesc": "第一行输入关系的总数量 N 第二行开始，输入关系信息，格式：\n分销ID 上级分销ID 收入\n比如：\n123456",
    "outputDesc": "输出：\nboss的ID 总收入\n比如：\n0 120\n给定的输入数据都是合法的，不存在环路，重复的",
    "examples": [
      {
        "input": "0 100\n 0 199\n 0 200\n 0 200\n 0 200",
        "output": "120",
        "explanation": "无"
      }
    ],
    "solution": "这个题目描述了一个分销网络的收入上交机制，并要求我们找到网络中的boss节点（即没有上级的分销节点），然后计算出这个boss节点的总收入。\n分销网络：这是一个树形结构，每个分销节点都有一个唯一的上级分销。需要注意的点：唯一没有上级分销的节点就是boss节点。收入上交规则： 每个分销节点在每月需要将其总收入中每满100元上交15元给它的上级分销。如果一个分销节点有下级分销，那么下级分销上交的收入也算作该分销的收入的一部分。\n每个分销节点在每月需要将其总收入中每满100元上交15元给它的上级分销。如果一个分销节点有下级分销，那么下级分销上交的收入也算作该分销的收入的一部分。\n输入：\n123456\n解释：\n0号分销是boss，因为其他分销都将收入上交给0。1号分销的收入是100元，上交15元给0。2号分销的收入是199元，上交15元给0。3号、4号和5号分销的收入各是200元，分别上交30元给0。\nboss的总收入计算：\n收到的上交收入：15 + 15 + 30 + 30 + 30 = 120 元。\n输出：\n1",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 读取分销关系的数量\n        int n = Integer.parseInt(sc.nextLine().trim());\n\n        // 记录每个分销商的收入\n        HashMap<Integer, Long> income = new HashMap<>();\n        // 记录所有的分销商 ID\n        HashSet<Integer> ids = new HashSet<>();\n        // 记录子分销商到父分销商的映射关系\n        HashMap<Integer, Integer> childToParent = new HashMap<>();\n        // 记录父分销商到其所有子分销商的映射关系\n        HashMap<Integer, LinkedList<Integer>> parentToChildren = new HashMap<>();\n\n        // 读取输入数据并构建映射关系\n        for (int i = 0; i < n; i++) {\n            // 读取当前行\n            String[] parts = sc.nextLine().split(\" \");\n            // 解析当前子分销商的 ID\n            int childId = Integer.parseInt(parts[0]);\n            // 解析当前子分销商的父分销商 ID\n            int parentId = Integer.parseInt(parts[1]);\n            // 解析当前子分销商的收入\n            long childIncome = Long.parseLong(parts[2]);\n\n            // 将子分销商的收入记录在 income 映射中\n            income.put(childId, childIncome);\n            // 将子分销商和父分销商的 ID 添加到分销商 ID 集合中\n            ids.add(childId);\n            ids.add(parentId);\n\n            // 记录子分销商到父分销商的映射关系\n            childToParent.put(childId, parentId);\n\n            // 如果父分销商还没有子分销商列表，则初始化一个新的列表\n            parentToChildren.putIfAbsent(parentId, new LinkedList<>());\n            // 将当前子分销商 ID 添加到父分销商的子分销商列表中\n            parentToChildren.get(parentId).add(childId);\n        }\n\n        // 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\n        for (int id : ids) {\n            // 如果当前分销商 ID 不在 childToParent 映射中，说明它是顶级分销商\n            if (!childToParent.containsKey(id)) {\n                // 初始化顶级分销商的收入为0，因为它自身没有任何直接收入\n                income.put(id, 0L);\n                // 调用深度优先搜索算法计算该顶级分销商的总收入（包括来自下级分销商的提成）\n                calcTotalIncome(id, parentToChildren, income);\n                // 输出顶级分销商的 ID 和其计算出的总收入\n                System.out.println(id + \" \" + income.get(id));\n                // 一旦找到顶级分销商，结束循环\n                break;\n            }\n        }\n    }\n\n    // 使用递归的深度优先搜索算法计算分销商的总收入，包括从下级分销商获取的部分\n    private static void calcTotalIncome(int parentId, \n                                        HashMap<Integer, LinkedList<Integer>> parentToChildren, \n                                        HashMap<Integer, Long> income) {\n        // 获取当前父分销商的子分销商列表\n        LinkedList<Integer> children = parentToChildren.get(parentId);\n\n        // 如果该父分销商有子分销商\n        if (children != null && !children.isEmpty()) {\n            // 遍历所有子分销商\n            for (int childId : children) {\n                // 递归计算子分销商的总收入\n                calcTotalIncome(childId, parentToChildren, income);\n                // 计算父分销商从该子分销商处获取的提成收入\n                long additionalIncome = income.get(childId) / 100 * 15;\n                // 将提成收入累加到父分销商的总收入中\n                income.put(parentId, income.get(parentId) + additionalIncome);\n            }\n        }\n    }\n}",
      "python": "# 导入必要的库\nfrom collections import defaultdict, deque\n \n    \n\ndef calc_total_income(parent_id, parent_to_children, income):\n    \"\"\"\n    使用递归的深度优先搜索算法计算分销商的总收入，包括从下级分销商获取的部分\n    \"\"\"\n    # 获取当前父分销商的子分销商列表\n    children = parent_to_children[parent_id]\n\n    # 如果该父分销商有子分销商\n    if children:\n        # 遍历所有子分销商\n        for child_id in children:\n            # 递归计算子分销商的总收入\n            calc_total_income(child_id, parent_to_children, income)\n            # 计算父分销商从该子分销商处获取的提成收入\n            additional_income = income[child_id] // 100 * 15\n            # 将提成收入累加到父分销商的总收入中\n            income[parent_id] += additional_income\n\n# 读取输入的分销关系数量\nn = int(input().strip())\n\n# 记录每个分销商的收入\nincome = {}\n# 记录所有的分销商 ID\nids = set()\n# 记录子分销商到父分销商的映射关系\nchild_to_parent = {}\n# 记录父分销商到其所有子分销商的映射关系\nparent_to_children = defaultdict(list)\n\n# 读取输入数据并构建映射关系\nfor _ in range(n):\n    # 读取当前行并按空格分割\n    parts = input().strip().split()\n    # 解析当前子分销商的 ID\n    child_id = int(parts[0])\n    # 解析当前子分销商的父分销商 ID\n    parent_id = int(parts[1])\n    # 解析当前子分销商的收入\n    child_income = int(parts[2])\n\n    # 将子分销商的收入记录在 income 映射中\n    income[child_id] = child_income\n    # 将子分销商和父分销商的 ID 添加到分销商 ID 集合中\n    ids.add(child_id)\n    ids.add(parent_id)\n\n    # 记录子分销商到父分销商的映射关系\n    child_to_parent[child_id] = parent_id\n\n    # 如果父分销商还没有子分销商列表，则初始化一个新的列表（由 defaultdict 自动处理）\n    # 将当前子分销商 ID 添加到父分销商的子分销商列表中\n    parent_to_children[parent_id].append(child_id)\n\n# 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\nfor id in ids:\n    # 如果当前分销商 ID 不在 child_to_parent 映射中，说明它是顶级分销商\n    if id not in child_to_parent:\n        # 初始化顶级分销商的收入为 0，因为它自身没有任何直接收入\n        income[id] = 0\n        # 调用深度优先搜索算法计算该顶级分销商的总收入（包括来自下级分销商的提成）\n        calc_total_income(id, parent_to_children, income)\n        # 输出顶级分销商的 ID 和其计算出的总收入\n        print(f\"{id} {income[id]}\")\n        # 一旦找到顶级分销商，结束循环\n        break",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 用于存储所有分销商信息的全局变量\nlet n; // 分销关系的数量\nconst income = {}; // 记录每个分销商的收入\nconst ids = new Set(); // 记录所有的分销商 ID\nconst childToParent = {}; // 记录子分销商到父分销商的映射关系\nconst parentToChildren = {}; // 记录父分销商到其所有子分销商的映射关系\n\n// 读取输入并处理\nrl.on('line', (input) => {\n    // 首次输入是分销关系的数量\n    if (n === undefined) {\n        n = parseInt(input.trim());\n    } else {\n        // 处理每一行输入\n        const parts = input.trim().split(' ');\n        const childId = parseInt(parts[0]);\n        const parentId = parseInt(parts[1]);\n        const childIncome = parseInt(parts[2]);\n\n        // 将子分销商的收入记录在 income 映射中\n        income[childId] = childIncome;\n        // 将子分销商和父分销商的 ID 添加到分销商 ID 集合中\n        ids.add(childId);\n        ids.add(parentId);\n\n        // 记录子分销商到父分销商的映射关系\n        childToParent[childId] = parentId;\n\n        // 如果父分销商还没有子分销商列表，则初始化一个新的列表\n        if (!parentToChildren[parentId]) {\n            parentToChildren[parentId] = [];\n        }\n        // 将当前子分销商 ID 添加到父分销商的子分销商列表中\n        parentToChildren[parentId].push(childId);\n\n        // 当所有数据读取完毕后，处理顶级分销商的收入计算\n        if (--n === 0) {\n            // 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\n            for (let id of ids) {\n                if (!childToParent.hasOwnProperty(id)) {\n                    // 初始化顶级分销商的收入为 0，因为它自身没有任何直接收入\n                    income[id] = 0;\n                    // 调用深度优先搜索算法计算该顶级分销商的总收入（包括来自下级分销商的提成）\n                    calcTotalIncome(id, parentToChildren, income);\n                    // 输出顶级分销商的 ID 和其计算出的总收入\n                    console.log(`${id} ${income[id]}`);\n                    // 一旦找到顶级分销商，结束循环\n                    break;\n                }\n            }\n        \n            rl.close();\n        }\n    }\n});\n\n/**\n * 使用递归的深度优先搜索算法计算分销商的总收入，包括从下级分销商获取的部分\n * @param {number} parentId - 父分销商的 ID\n * @param {object} parentToChildren - 父分销商到其子分销商列表的映射\n * @param {object} income - 分销商的收入映射\n */\nfunction calcTotalIncome(parentId, parentToChildren, income) {\n    // 获取当前父分销商的子分销商列表\n    const children = parentToChildren[parentId] || [];\n\n    // 如果该父分销商有子分销商\n    for (let childId of children) {\n        // 递归计算子分销商的总收入\n        calcTotalIncome(childId, parentToChildren, income);\n        // 计算父分销商从该子分销商处获取的提成收入\n        const additionalIncome = Math.floor(income[childId] / 100)  * 15;\n        // 将提成收入累加到父分销商的总收入中\n        income[parentId] += additionalIncome;\n    }\n}",
      "cpp": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// 使用递归的深度优先搜索算法计算分销商的总收入，包括从下级分销商获取的部分\nvoid calcTotalIncome(int parentId, \n                     unordered_map<int, list<int>>& parentToChildren, \n                     unordered_map<int, long long>& income) {\n    // 获取当前父分销商的子分销商列表\n    if (parentToChildren.find(parentId) != parentToChildren.end()) {\n        list<int>& children = parentToChildren[parentId];\n\n        // 遍历所有子分销商\n        for (int childId : children) {\n            // 递归计算子分销商的总收入\n            calcTotalIncome(childId, parentToChildren, income);\n            // 计算父分销商从该子分销商处获取的提成收入\n            long long additionalIncome = (income[childId] / 100) * 15;\n            // 将提成收入累加到父分销商的总收入中\n            income[parentId] += additionalIncome;\n        }\n    }\n}\n\nint main() {\n    int n;\n    // 读取分销关系的数量\n    cin >> n;\n    cin.ignore();\n\n    // 记录每个分销商的收入\n    unordered_map<int, long long> income;\n    // 记录所有的分销商 ID\n    unordered_set<int> ids;\n    // 记录子分销商到父分销商的映射关系\n    unordered_map<int, int> childToParent;\n    // 记录父分销商到其所有子分销商的映射关系\n    unordered_map<int, list<int>> parentToChildren;\n\n    // 读取输入数据并构建映射关系\n    for (int i = 0; i < n; i++) {\n        string line;\n        getline(cin, line);\n        stringstream ss(line);\n        int childId, parentId;\n        long long childIncome;\n\n        // 解析当前子分销商的 ID\n        ss >> childId;\n        // 解析当前子分销商的父分销商 ID\n        ss >> parentId;\n        // 解析当前子分销商的收入\n        ss >> childIncome;\n\n        // 将子分销商的收入记录在 income 映射中\n        income[childId] = childIncome;\n        // 将子分销商和父分销商的 ID 添加到分销商 ID 集合中\n        ids.insert(childId);\n        ids.insert(parentId);\n\n        // 记录子分销商到父分销商的映射关系\n        childToParent[childId] = parentId;\n\n        // 如果父分销商还没有子分销商列表，则初始化一个新的列表\n        if (parentToChildren.find(parentId) == parentToChildren.end()) {\n            parentToChildren[parentId] = list<int>();\n        }\n        // 将当前子分销商 ID 添加到父分销商的子分销商列表中\n        parentToChildren[parentId].push_back(childId);\n    }\n\n    // 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\n    for (int id : ids) {\n        // 如果当前分销商 ID 不在 childToParent 映射中，说明它是顶级分销商\n        if (childToParent.find(id) == childToParent.end()) {\n            // 初始化顶级分销商的收入为0，因为它自身没有任何直接收入\n            income[id] = 0;\n            // 调用深度优先搜索算法计算该顶级分销商的总收入（包括来自下级分销商的提成）\n            calcTotalIncome(id, parentToChildren, income);\n            // 输出顶级分销商的 ID 和其计算出的总收入\n            cout << id << \" \" << income[id] << endl;\n            // 一旦找到顶级分销商，结束循环\n            break;\n        }\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义结构体用于表示链表节点，链表用于存储子分销商ID\ntypedef struct Node {\n    int id;            // 子分销商的ID\n    struct Node* next; // 指向下一个子分销商的指针\n} Node;\n\n// 定义结构体用于表示分销商的收入信息以及子分销商链表\ntypedef struct {\n    long long income; // 分销商的收入\n    Node* children;   // 指向子分销商链表的头节点\n} Distributor;\n\n// 动态数组用于存储所有分销商的ID\nint ids[1000];\nint idsCount = 0;\n\n// 哈希表，用于记录分销商ID到其收入信息及子分销商链表的映射\nDistributor* distributors[1000];\n\n// 哈希表，用于记录子分销商到父分销商的映射关系\nint childToParent[1000];\nint childToParentCount = 0;\n\n// 初始化所有分销商的收入信息及子分销商链表\nvoid initializeDistributors() {\n    for (int i = 0; i < 1000; i++) {\n        distributors[i] = NULL;\n        childToParent[i] = -1;\n    }\n}\n\n// 创建新的链表节点\nNode* createNode(int id) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->id = id;\n    node->next = NULL;\n    return node;\n}\n\n// 添加子分销商到父分销商的链表中\nvoid addChild(int parentId, int childId) {\n    Node* childNode = createNode(childId);\n    childNode->next = distributors[parentId]->children;\n    distributors[parentId]->children = childNode;\n}\n\n// 递归计算分销商的总收入，包括从下级分销商获取的部分\nvoid calcTotalIncome(int parentId) {\n    Node* childNode = distributors[parentId]->children;\n    while (childNode != NULL) {\n        calcTotalIncome(childNode->id); // 递归计算子分销商的总收入\n        long long additionalIncome = (distributors[childNode->id]->income / 100) * 15;\n        distributors[parentId]->income += additionalIncome; // 累加提成收入\n        childNode = childNode->next;\n    }\n}\n\nint main() {\n    initializeDistributors();\n\n    int n;\n    scanf(\"%d\", &n); // 读取分销关系的数量\n\n    for (int i = 0; i < n; i++) {\n        int childId, parentId;\n        long long childIncome;\n        scanf(\"%d %d %lld\", &childId, &parentId, &childIncome); // 读取每个分销关系\n\n        // 如果分销商尚未创建，创建新的分销商结构体\n        if (distributors[childId] == NULL) {\n            distributors[childId] = (Distributor*)malloc(sizeof(Distributor));\n            distributors[childId]->income = 0;\n            distributors[childId]->children = NULL;\n        }\n\n        // 记录子分销商的收入\n        distributors[childId]->income = childIncome;\n\n        // 记录父分销商ID到子分销商ID的映射关系\n        childToParent[childId] = parentId;\n\n        // 将父分销商ID和子分销商ID添加到ID列表中\n        ids[idsCount++] = childId;\n        ids[idsCount++] = parentId;\n\n        // 如果父分销商尚未创建，创建新的分销商结构体\n        if (distributors[parentId] == NULL) {\n            distributors[parentId] = (Distributor*)malloc(sizeof(Distributor));\n            distributors[parentId]->income = 0;\n            distributors[parentId]->children = NULL;\n        }\n\n        // 将子分销商添加到父分销商的子分销商链表中\n        addChild(parentId, childId);\n    }\n\n    // 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\n    for (int i = 0; i < idsCount; i++) {\n        int id = ids[i];\n        if (childToParent[id] == -1) {\n            // 计算顶级分销商的总收入\n            calcTotalIncome(id);\n            // 输出顶级分销商的ID和总收入\n            printf(\"%d %lld\\n\", id, distributors[id]->income);\n            break;\n        }\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "91",
    "title": "出租车计费靠谱的车",
    "examType": "A",
    "score": 100,
    "description": "程序员小明打了一辆出租车去上班。出于职业敏感，他注意到这辆出租车的计费表有点问题，总是偏大。\n出租车司机解释说他不喜欢数字4，所以改装了计费表，任何数字位置遇到数字4就直接跳过，其余功能都正常。\n比如：\n23再多一块钱就变为25； 39再多一块钱变为50； 399再多一块钱变为500； 小明识破了司机的伎俩，准备利用自己的学识打败司机的阴谋。\n给出计费表的表面读数，返回实际产生的费用。",
    "inputDesc": "只有一行，数字N，表示里程表的读数。\n(1<=N<=888888888)。",
    "outputDesc": "一个数字，表示实际产生的费用。以回车结束。",
    "examples": [],
    "solution": "我们需要理解出租车司机改装计费表的方式。司机不喜欢数字4，所以他的计费表从1开始计数，直到3，然后跳过4，继续从5计数。这意味着计费表上的每一位数字实际上只有9种可能的值：0, 1, 2, 3, 5, 6, 7, 8, 9（跳过了4）。因此，这个计费表实际上是在使用一个基数为9的数制系统。\n现在，让我们用三个用例来解释这个过程：\n输入：5 输出：4 解释：由于计费表跳过了数字4，所以表面读数5实际上是9进制中的5。在10进制中，这是4。 输入：17 输出：15 解释：表面读数17在9进制中表示为 1 ∗ 9 1 1 * 9^1 1∗91 + 7 ∗ 9 0 7*9^0 7∗90。但是，因为我们跳过了4，所以实际的计算应该是 1 ∗ 9 1 + 6 ∗ 9 0 1*9^1 + 6*9^0 1∗91+6∗90（因为7实际上是8，但我们要减去1以补偿跳过的4），这等于9 + 6 = 15。 输入：100 输出：81 解释：表面读数100在9进制中表示为 1 ∗ 9 2 + 0 ∗ 9 1 + 0 ∗ 9 0 1*9^2 + 0*9^1 + 0*9^0 1∗92+0∗91+0∗90。在10进制中，这等于81。\n输入：5 输出：4 解释：由于计费表跳过了数字4，所以表面读数5实际上是9进制中的5。在10进制中，这是4。\n输入：17 输出：15 解释：表面读数17在9进制中表示为 1 ∗ 9 1 1 * 9^1 1∗91 + 7 ∗ 9 0 7*9^0 7∗90。但是，因为我们跳过了4，所以实际的计算应该是 1 ∗ 9 1 + 6 ∗ 9 0 1*9^1 + 6*9^0 1∗91+6∗90（因为7实际上是8，但我们要减去1以补偿跳过的4），这等于9 + 6 = 15。\n输入：100 输出：81 解释：表面读数100在9进制中表示为 1 ∗ 9 2 + 0 ∗ 9 1 + 0 ∗ 9 0 1*9^2 + 0*9^1 + 0*9^0 1∗92+0∗91+0∗90。在10进制中，这等于81。\n因此，通过将表面读数视为9进制数，并将其转换为10进制数，同时考虑到跳过的4，我们可以得到实际产生的费用。这就是为什么我们使用9进制进行求解的原因。\n在这个特殊的9进制系统中，我们跳过了数字4，所以当我们看到特殊9进制数15时，实际上是指真实9进制数13，它对应于10进制中的13（19^1 + 49^0）。注意，在这个系统中，我们将特殊9进制数转换为真实9进制数时，需要将每个大于4的数字减去1来得到真实的9进制数，然后再将其转换为10进制数。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String line = scanner.nextLine();\n        int correct = 0;\n        for (char c : line.toCharArray()) {\n            int digit = c - '0';\n            if (digit > 4) {\n                digit--;\n            }\n            correct = correct * 9 + digit;\n        }\n        System.out.println(correct);\n    }\n}",
      "python": "import sys\n\nline = sys.stdin.readline().strip()\ncorrect = 0\nfor c in line:\n    digit = int(c)\n    if digit > 4:\n        digit -= 1\n    correct = correct * 9 + digit\nprint(correct)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (line) => {\n  let correct = 0;\n  for (let i = 0; i < line.length; i++) {\n    let digit = parseInt(line[i]);\n    if (digit > 4) {\n      digit--;\n    }\n    correct = correct * 9 + digit;\n  }\n  console.log(correct);\n});",
      "cpp": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string line;\n    // 读取输入的表面读数\n    getline(cin, line);\n    // 初始化实际产生的费用\n    int correct = 0;\n    // 遍历读数的每一位数字\n    for (char c : line) {\n        int digit = c - '0'; // 将字符转换为数字\n        if (digit > 4) { // 如果数字大于4，则需要减1\n            digit--;\n        }\n        correct = correct * 9 + digit; // 将每一位数字加入到实际产生的费用中\n    }\n    // 输出实际产生的费用\n    cout << correct << endl;\n    \n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char line[10];  \n    scanf(\"%s\", line); // 读取输入的表面读数\n\n    int correct = 0; // 初始化实际产生的费用\n    int length = strlen(line); // 获取输入字符串的长度\n\n    // 遍历读数的每一位数字\n    for (int i = 0; i < length; i++) {\n        int digit = line[i] - '0'; // 将字符转换为数字\n\n        // 如果数字大于4，则需要减1，因为跳过了数字4\n        if (digit > 4) {\n            digit--;\n        }\n\n        correct = correct * 9 + digit; // 更新实际产生的费用\n    }\n\n    // 输出实际产生的费用\n    printf(\"%d\\n\", correct);\n    \n    return 0;\n}"
    }
  },
  {
    "id": "92",
    "title": "分糖果",
    "examType": "A",
    "score": 100,
    "description": "小明从糖果盒中随意抓一把糖果，每次小明会取出一半的糖果分给同学们。\n当糖果不能平均分配时，小明可以选择从糖果盒中（假设盒中糖果足够）取出一个糖果或放回一个糖果。\n小明最少需要多少次（取出、放回和平均分配均记一次），能将手中糖果分至只剩一颗。",
    "inputDesc": "抓取的糖果数（<10000000000）：15",
    "outputDesc": "最少分至一颗糖果的次数：5",
    "examples": [],
    "solution": "题目要求的是找出最少的操作次数，使得手中的糖果数从给定数量减少至仅剩一颗。每次操作包括取出糖果、放回糖果以及平分糖果。这个问题实质上是一个贪心算法的应用，目标是尽快将糖果数量减至1。\n循环直到糖果数为1。 在循环中，检查当前糖果数是否为奇数。 如果是奇数，检查加1后的数或减1后的数哪一个更适合下一步操作（即哪个能被2整除）。这里的贪心选择基于加1后能否被4整除，因为如果能被4整除，说明下一步可以继续平分两次。 特殊处理当糖果数为3的情况，因为这是最快减至1的路径。 每进行一次操作（不管是加1、减1还是分配），计数器加1。\n循环直到糖果数为1。\n在循环中，检查当前糖果数是否为奇数。\n如果是奇数，检查加1后的数或减1后的数哪一个更适合下一步操作（即哪个能被2整除）。这里的贪心选择基于加1后能否被4整除，因为如果能被4整除，说明下一步可以继续平分两次。\n特殊处理当糖果数为3的情况，因为这是最快减至1的路径。\n每进行一次操作（不管是加1、减1还是分配），计数器加1。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    long x = scanner.nextLong();\n    \n    int count = 0;\n\n    // 循环直到只剩一颗糖果\n    for (long i = x; i != 1; i /= 2, count++) {\n      // 当剩余糖果数量为3时，需要特殊处理\n      if (i == 3) {\n        count += 2; // 取出一个糖果，分给同学们，再放回一个糖果\n        break;\n      }\n      // 当剩余糖果数量为奇数时，需要进行调整\n      if (i % 2 != 0) {\n        // 如果将剩余糖果数量加1再除以2后是偶数，则取出一个糖果\n        if ((i + 1) / 2 % 2 == 0) {\n          i++;\n        } else { // 否则放回一个糖果\n          i--;\n        }\n        count++;\n      }\n    }\n\n    System.out.print(count);\n  }\n}",
      "python": "import math\n\n# 从标准输入读取糖果的初始数量\nx = int(input())\n# 初始化操作计数器\ncount = 0\n\n# 当糖果数量不为1时，继续操作\nwhile x != 1:\n    # 特殊情况，当糖果数为3时，直接通过两步操作减至1\n    if x == 3:\n        count += 2  # 直接加2到计数器（3-1=2，然后2/2=1）\n        break\n    # 如果当前糖果数是奇数，需要调整糖果数使其成为偶数\n    if x % 2 != 0:\n        # 选择加1还是减1：如果当前数加1后的一半是偶数，则加1\n        if (x + 1) // 2 % 2 == 0:\n            x += 1\n        else:\n            x -= 1  # 否则减1\n        count += 1  # 调整操作也算一次操作\n    # 糖果数除以2，模拟小明分糖果的过程\n    x //= 2\n    count += 1  # 分糖果的操作\n\n# 打印总的操作次数\nprint(count)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (x) => {\n  let count = 0;\n\n  // 循环直到只剩一颗糖果\n  for (let i = x; i !== 1; i /= 2, count++) {\n     // 当剩余糖果数量为3时，需要特殊处理\n    if (i === 3) {\n      count += 2; // 取出一个糖果，分给同学们，再放回一个糖果\n      break;\n    }\n    // 当剩余糖果数量为奇数时，需要进行调整\n    if (i % 2 !== 0) {\n      // 如果将剩余糖果数量加1再除以2后是偶数，则取出一个糖果\n \n      let T = ((Number(i) + 1) / 2) % 2;\n\n \n      if (T === 0) {\n        i++;\n      } else { // 否则放回一个糖果\n        i--;\n      }\n      count++;\n    }\n  }\n\n  console.log(count);\n\n  rl.close();\n});",
      "cpp": "#include <iostream>\n\nint main() {\n  long long x;\n  std::cin >> x;\n  \n  int count = 0;\n\n  // 循环直到只剩一颗糖果\n  for (long long i = x; i != 1; i /= 2, count++) {\n    // 当剩余糖果数量为3时，需要特殊处理\n    if (i == 3) {\n      count += 2; // 取出一个糖果，分给同学们，再放回一个糖果\n      break;\n    }\n    // 当剩余糖果数量为奇数时，需要进行调整\n    if (i % 2 != 0) {\n      // 如果将剩余糖果数量加1再除以2后是偶数，则取出一个糖果\n      if ((i + 1) / 2 % 2 == 0) {\n        i++;\n      } else { // 否则放回一个糖果\n        i--;\n      }\n      count++;\n    }\n  }\n\n  std::cout << count;\n\n  return 0;\n}",
      "c": "#include <stdio.h>\n\nint main() {\n    long long x;\n    scanf(\"%lld\", &x); // 从标准输入读取糖果的初始数量\n\n    int count = 0;\n\n    // 循环直到只剩一颗糖果\n    for (long long i = x; i != 1; i /= 2, count++) {\n        // 当剩余糖果数量为3时，需要特殊处理\n        if (i == 3) {\n            count += 2; // 直接进行两次操作，将3减到1\n            break;\n        }\n        // 当剩余糖果数量为奇数时，需要进行调整\n        if (i % 2 != 0) {\n            // 判断增加1后的数除以2是否为偶数，决定是加1还是减1\n            if ((i + 1) / 2 % 2 == 0) {\n                i++;  // 如果加1后的数可以被2整除，则增加1\n            } else {\n                i--;  // 否则减1\n            }\n            count++; // 对糖果数的调整也算作一次操作\n        }\n    }\n\n    printf(\"%d\", count); // 打印出执行的最小操作次数\n\n    return 0;\n}"
    }
  },
  {
    "id": "93",
    "title": "分苹果",
    "examType": "A",
    "score": 100,
    "description": "A、B两个人把苹果分为两堆，A希望按照他的计算规则等分苹果，他的计算规则是按照二进制加法计算，并且不计算进位 12+5=9（1100 + 0101 = 9），B的计算规则是十进制加法，包括正常进位，B希望在满足A的情况下获取苹果重量最多。\n输入苹果的数量和每个苹果重量，输出满足A的情况下B获取的苹果总重量。\n如果无法满足A的要求，输出-1。\n数据范围\n1 <= 总苹果数量 <= 200001 <= 每个苹果重量 <= 10000",
    "inputDesc": "输入第一行是苹果数量：3\n输入第二行是每个苹果重量：3 5 6",
    "outputDesc": "输出第一行是B获取的苹果总重量：11",
    "examples": [
      {
        "input": "5 6",
        "output": "",
        "explanation": ""
      },
      {
        "input": "6579 2602 6716 3050 3564 5396 1773",
        "output": "",
        "explanation": ""
      },
      {
        "input": "5 6",
        "output": "6579 2602 6716 3050 3564 5396 1773",
        "explanation": ""
      }
    ],
    "solution": "这道题目要求你在给定的条件下计算A和B两个人分苹果的结果。A的要求是按照二进制加法（不进位）等分苹果，而B希望在满足A的要求下获取苹果总重量的最大值。如果无法满足A的要求，则输出-1。\n二进制加法不进位： 二进制加法不进位的意思是直接对每一位进行相加，但不进行进位处理。比如：12（1100）和5（0101）相加的结果是9（1001），因为在二进制表示中： 1+0 = 11+1 = 0（不进位）0+0 = 00+1 = 1 题目要求： 你需要找到一个办法，把苹果分成两堆，使得两堆苹果的总重量按二进制加法（不进位）结果相等。在满足这个条件的前提下，让B获取的苹果总重量最大。\n二进制加法不进位：\n二进制加法不进位的意思是直接对每一位进行相加，但不进行进位处理。比如：12（1100）和5（0101）相加的结果是9（1001），因为在二进制表示中： 1+0 = 11+1 = 0（不进位）0+0 = 00+1 = 1\n1+0 = 11+1 = 0（不进位）0+0 = 00+1 = 1\n题目要求：\n你需要找到一个办法，把苹果分成两堆，使得两堆苹果的总重量按二进制加法（不进位）结果相等。在满足这个条件的前提下，让B获取的苹果总重量最大。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个扫描器对象，用于读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取苹果的数量 n\n        int n = scanner.nextInt();\n        // 创建一个大小为 n 的数组，用于存储每个苹果的重量\n        int[] a = new int[n];\n        // 循环读取每个苹果的重量，并存储到数组中\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        // 初始化异或总和变量\n        int sums = 0;\n        // 初始化最小值变量为整型的最大值\n        int min = Integer.MAX_VALUE;\n        // 遍历所有苹果的重量\n        for (int x : a) {\n            // 按位异或操作，更新异或总和\n            sums = sums ^ x;\n            // 找到当前最小的苹果重量\n            if (x < min) {\n                min = x;\n            }\n        }\n        // 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\n        if (sums != 0) {\n            System.out.println(-1);\n        } else {\n            // 计算所有苹果重量的总和\n            int sum = 0;\n            for (int x : a) {\n                sum += x;\n            }\n            // 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n            System.out.println(sum - min);\n        }\n    }\n}",
      "python": "import sys\n\n# 读取苹果的数量 n\nn = int(input())\n# 读取每个苹果的重量并存储到列表 a 中\na = list(map(int, input().split()))\n\n# 初始化异或总和\nsums = 0\n# 初始化最小值为系统的最大整数\nmin_val = sys.maxsize\n# 遍历所有苹果的重量\nfor x in a:\n    # 按位异或操作，更新异或总和\n    sums = sums ^ x\n    # 找到当前最小的苹果重量\n    if x < min_val:\n        min_val = x\n\n# 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\nif sums != 0:\n    print(-1)\nelse:\n    # 计算所有苹果重量的总和\n    total_sum = sum(a)\n    # 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n    print(total_sum - min_val)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet n;  // 苹果数量\nlet a;  // 每个苹果的重量数组\n\n// 读取输入的第一行，苹果数量 n\nrl.on('line', (inputN) => {\n  n = parseInt(inputN);\n  \n  // 读取输入的第二行，苹果的重量列表\n  rl.on('line', (inputA) => {\n    a = inputA.split(' ').map(Number);\n    \n    // 初始化异或总和\n    let sums = 0;\n    // 初始化最小值为 JavaScript 中安全的最大整数\n    let min_val = Number.MAX_SAFE_INTEGER;\n    \n    // 遍历所有苹果的重量\n    a.forEach((x) => {\n      // 按位异或操作，更新异或总和\n      sums = sums ^ x;\n      // 找到当前最小的苹果重量\n      if (x < min_val) {\n        min_val = x;\n      }\n    });\n    \n    // 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\n    if (sums !== 0) {\n      console.log(-1);\n    } else {\n      // 计算所有苹果重量的总和\n      const total_sum = a.reduce((sum, x) => sum + x, 0);\n      // 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n      console.log(total_sum - min_val);\n    }\n    \n    rl.close();  // 关闭读取接口\n  });\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <limits>\n\nint main() {\n    int n;\n    // 读取苹果的数量 n\n    std::cin >> n;\n    // 创建一个大小为 n 的向量，用于存储每个苹果的重量\n    std::vector<int> a(n);\n    // 循环读取每个苹果的重量，并存储到向量中\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    // 初始化异或总和变量\n    int sums = 0;\n    // 初始化最小值变量为整型的最大值\n    int min = std::numeric_limits<int>::max();\n    // 遍历所有苹果的重量\n    for (int x : a) {\n        // 按位异或操作，更新异或总和\n        sums = sums ^ x;\n        // 找到当前最小的苹果重量\n        if (x < min) {\n            min = x;\n        }\n    }\n    // 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\n    if (sums != 0) {\n        std::cout << -1 << std::endl;\n    } else {\n        // 计算所有苹果重量的总和\n        int sum = 0;\n        for (int x : a) {\n            sum += x;\n        }\n        // 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n        std::cout << sum - min << std::endl;\n    }\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <limits.h>  // 用于定义整型的最大值 INT_MAX\n\nint main() {\n    int n;\n    // 读取苹果的数量 n\n    scanf(\"%d\", &n);\n    \n    // 创建一个大小为 n 的数组，用于存储每个苹果的重量\n    int a[n];\n    \n    // 循环读取每个苹果的重量，并存储到数组中\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    \n    // 初始化异或总和变量\n    int sums = 0;\n    // 初始化最小值变量为整型的最大值\n    int min = INT_MAX;\n    \n    // 遍历所有苹果的重量\n    for (int i = 0; i < n; i++) {\n        // 按位异或操作，更新异或总和\n        sums = sums ^ a[i];\n        // 找到当前最小的苹果重量\n        if (a[i] < min) {\n            min = a[i];\n        }\n    }\n    \n    // 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\n    if (sums != 0) {\n        printf(\"-1\\n\");\n    } else {\n        // 计算所有苹果重量的总和\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += a[i];\n        }\n        // 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n        printf(\"%d\\n\", sum - min);\n    }\n    \n    return 0;\n}"
    }
  },
  {
    "id": "94",
    "title": "增强的strstr",
    "examType": "A",
    "score": 100,
    "description": "C 语言有一个库函数： char *strstr(const char *haystack, const char *needle) ，实现在字符串 haystack 中查找第一次出现字符串 needle 的位置，如果未找到则返回 null。\n现要求实现一个strstr的增强函数，可以使用带可选段的字符串来模糊查询，与strstr一样返回首次查找到的字符串位置。\n可选段使用“[]”标识，表示该位置是可选段中任意一个字符即可满足匹配条件。比如“a[bc]”表示可以匹配“ab”或“ac”。\n注意目标字符串中可选段可能出现多次。",
    "inputDesc": "与strstr函数一样，输入参数是两个字符串指针，分别是源字符串和目标字符串。",
    "outputDesc": "与strstr函数不同，返回的是源字符串中，匹配子字符串相对于源字符串地址的偏移（从0开始算），如果没有匹配返回-1。\n补充说明：源字符串中必定不包含‘[]’；目标字符串中‘[]’必定成对出现，且不会出现嵌套。\n输入的字符串长度在[1,100]之间。",
    "examples": [
      {
        "input": "abcd\nb[cd]",
        "output": "",
        "explanation": "相当于是在源字符串中查找bc或者bd，bc子字符串相对于abcd的偏移是1"
      }
    ],
    "solution": "正则表达式题",
    "codes": {
      "java": "import java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // 读取源字符串和目标字符串\n        String source = scanner.nextLine();\n        String target = scanner.nextLine();\n\n        // 将目标字符串中的可选段标记转换为正则表达式的可选字符\n        target = target.replaceAll(\"\\\\[(.*?)\\\\]\", \"[$1]\");\n\n        // 编译目标字符串为正则表达式模式\n        Pattern pattern = Pattern.compile(target);\n        // 创建匹配器，用于在源字符串中查找匹配的子字符串\n        Matcher matcher = pattern.matcher(source);\n\n        // 如果找到匹配的子字符串，则输出匹配的子字符串在源字符串中的起始位置\n        if (matcher.find()) {\n            System.out.println(matcher.start());\n        } else {\n            // 如果没有找到匹配的子字符串，则输出-1\n            System.out.println(-1);\n        }\n    }\n}",
      "python": "import re\n\nsource = input()\ntarget = input()\n\ntarget = re.sub(r'\\[(.*?)\\]', r'[\\1]', target)\n\npattern = re.compile(target)\nmatcher = pattern.search(source)\n\nif matcher:\n    print(matcher.start())\nelse:\n    print(-1)",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (source) => {\n  rl.on('line', (target) => {\n    target = target.replace(/\\[(.*?)\\]/g, '[$1]');\n\n    const pattern = new RegExp(target);\n    const matcher = pattern.exec(source);\n\n    if (matcher) {\n      console.log(matcher.index);\n    } else {\n      console.log(-1);\n    }\n\n    rl.close();\n  });\n});",
      "cpp": "#include <iostream>\n#include <regex>\nusing namespace std;\n\nint main() {\n    string source, target;\n    getline(cin, source);\n    getline(cin, target);\n\n    // 将目标字符串中的可选段标记转换为正则表达式的可选字符\n    regex reg(\"\\\\[(.*?)\\\\]\");\n    target = regex_replace(target, reg, \"[$1]\");\n\n    // 编译目标字符串为正则表达式模式\n    regex pattern(target);\n    // 创建匹配器，用于在源字符串中查找匹配的子字符串\n    smatch matcher;\n    regex_search(source, matcher, pattern);\n\n    // 如果找到匹配的子字符串，则输出匹配的子字符串在源字符串中的起始位置\n    if (matcher.size() > 0) {\n        cout << matcher.position() << endl;\n    } else {\n        // 如果没有找到匹配的子字符串，则输出-1\n        cout << -1 << endl;\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LEVELS 100\n#define MAX_CHARS  100\n\nint main() {\n    char src[1000], tar[1000];\n    char levels[MAX_LEVELS][MAX_CHARS]; // 用于存储多层结构\n    int levelsSize = 0; // 当前层的数量\n    char buffer[MAX_CHARS]; // 临时存储当前层的字符集\n    int bufferIndex = 0;\n    int isOpen = 0;   // 标记是否在[]内\n\n    // 输入src和tar字符串\n    fgets(src, sizeof(src), stdin);\n    fgets(tar, sizeof(tar), stdin);\n\n    // 去掉换行符\n    src[strcspn(src, \"\\n\")] = '\\0';\n    tar[strcspn(tar, \"\\n\")] = '\\0';\n\n    // 将tar字符串转化为多层结构levels\n    for (int i = 0; i < strlen(tar); i++) {\n        char c = tar[i];\n        if (c == '[') {\n            isOpen = 1; // 进入[]内\n            bufferIndex = 0; // 重置缓冲区索引\n        } else if (c == ']') {\n            isOpen = 0; // 退出[]内\n            buffer[bufferIndex] = '\\0';\n            strcpy(levels[levelsSize++], buffer); // 将当前层加入levels\n        } else {\n            if (isOpen) {\n                buffer[bufferIndex++] = c; // 在[]内，添加字符到当前层\n            } else {\n                buffer[0] = c;\n                buffer[1] = '\\0';\n                strcpy(levels[levelsSize++], buffer); // 在[]外，字符单独作为一层\n            }\n        }\n    }\n\n    // 滑动窗口匹配\n    int srcLen = strlen(src);\n    int result = -1; // 初始化结果为-1（未找到）\n    for (int i = 0; i <= srcLen - levelsSize; i++) {\n        int isFind = 1; // 标记是否找到匹配\n\n        // 匹配levels中的每一层\n        for (int j = 0; j < levelsSize; j++) {\n            if (strchr(levels[j], src[i + j]) == NULL) {\n                isFind = 0; // 如果不匹配，标记为未找到\n                break;\n            }\n        }\n\n        if (isFind) {\n            result = i; // 找到匹配，记录起始索引\n            break;\n        }\n    }\n\n    // 输出结果\n    printf(\"%d\\n\", result);\n\n    return 0;\n}"
    }
  },
  {
    "id": "95",
    "title": "字符串变换最小字符串",
    "examType": "A",
    "score": 100,
    "description": "给定一个字符串s，最多只能进行一次变换，返回变换后能得到的最小字符串（按照字典序进行比较）。\n变换规则：交换字符串中任意两个不同位置的字符。",
    "inputDesc": "一串小写字母组成的字符串s\ns是都是小写字符组成\n1<=s.length<=1000",
    "outputDesc": "一串小写字母组成的字符串s",
    "examples": [
      {
        "input": "abcdef",
        "output": "abcdef",
        "explanation": "abcdef已经是最小字符串，不需要交换。"
      },
      {
        "input": "bcdefa",
        "output": "acdefb",
        "explanation": "a和b进行位置交换，可以得到最小字符串。"
      }
    ],
    "solution": "题目要求给定一个字符串s，通过最多进行一次字符交换，找到能够得到的按字典序排序最小的字符串。\n只能进行一次变换（交换两个不同位置的字符），或者不变换。目标是找到最小的可能字符串，即字典序最小。字典序是按照字母顺序进行排列的顺序，例如\"abc\" < \"acb\"。在字典序中，前面的字符越小，整个字符串的字典序就越小。\n首先，我们需要检查字符串当前是否已经是字典序最小的（即字符串已经是按字典序排好序的）。如果是，那么直接输出原字符串即可。如果不是，我们需要找到如何通过交换两个字符使字符串变得更小。\n代码使用了贪心算法的思想。\n核心在于：\n逐字符比较：从字符串的最左边开始，逐字符比较原字符串与排序后的字符串，寻找第一个不匹配的字符。确保此位置的字符是尽可能的最小值。 如果存在多个字典序最小的字符，则选择尽可能靠后的。\n逐字符比较：从字符串的最左边开始，逐字符比较原字符串与排序后的字符串，寻找第一个不匹配的字符。确保此位置的字符是尽可能的最小值。\n如果存在多个字典序最小的字符，则选择尽可能靠后的。\n最小化的关键：\n代码接下来通过逐字符比较原字符串和排序后的字符串：\n当找到第一个不同的字符时，例如在\"dcab\"中，原字符串的第一个字符'd'与排序后字符串的第一个字符'a'不同。这个差异表明，如果将原字符串中的'd'换成'a'，字典序会变得更小。\n为什么第一次交换就足够（贪心）： 当我们找到第一个不同字符并进行交换后：\n我们确保了字符串的第一个字符已经是可能的最小字符。由于字典序的排列原则，最左边的字符影响最大。只要第一个字符已经是最小的，接下来的字符顺序无需再调整，因为再调整也不会得到更小的字典序。",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String s = sc.nextLine();\n    \n    // 对字符串进行排序\n    char[] sortedArr = s.toCharArray();\n    Arrays.sort(sortedArr);\n\n    // 如果排序后的字符串与原字符串相同，则说明已经是最小字符串，直接输出\n    if (new String(sortedArr).equals(s)) {\n        System.out.println(s);\n        return;\n    }\n\n    // 遍历原字符串\n    StringBuilder sb = new StringBuilder(s);\n    for (int i = 0; i < s.length(); i++) {\n      // 如果当前字符与排序后的字符不相同，则进行交换\n      if (s.charAt(i) != sortedArr[i]) {\n        char tmp = sb.charAt(i);\n        int swapIndex = -1;\n        // 找到排序后的字符在原字符串中的位置\n        for (int j = i + 1; j < s.length(); j++) {\n          if (sb.charAt(j) == sortedArr[i]) {\n            swapIndex = j;\n          }\n        }\n        // 将原字符与排序后的字符交换\n        sb.setCharAt(i, sortedArr[i]);\n        sb.setCharAt(swapIndex, tmp);\n        break;\n      }\n    }\n\n    // 输出最小字符串\n    System.out.println(sb.toString());\n  }\n}",
      "python": "s = input()\n\n# 对字符串进行排序\nsortedArr = sorted(s)\n\n# 如果排序后的字符串与原字符串相同，则说明已经是最小字符串，直接输出\nif ''.join(sortedArr) == s:\n    print(s)\n    exit()\n\n# 遍历原字符串\nsb = list(s)\nfor i in range(len(s)):\n    # 如果当前字符与排序后的字符不相同，则进行交换\n    if s[i] != sortedArr[i]:\n        tmp = sb[i]\n        swapIndex = -1\n        # 找到排序后的字符在原字符串中的位置\n        for j in range(i + 1, len(s)):\n            if sb[j] == sortedArr[i]:\n                swapIndex = j\n        # 将原字符与排序后的字符交换\n        sb[i] = sortedArr[i]\n        sb[swapIndex] = tmp\n        break\n\n# 输出最小字符串\nprint(''.join(sb))",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (s) => {\n  // 对字符串进行排序\n  const sortedArr = s.split('').sort();\n\n  // 如果排序后的字符串与原字符串相同，则说明已经是最小字符串，直接输出\n  if (sortedArr.join('') === s) {\n    console.log(s);\n    rl.close();\n    return;\n  }\n\n  // 遍历原字符串\n  let sb = s.split('');\n  for (let i = 0; i < s.length; i++) {\n    // 如果当前字符与排序后的字符不相同，则进行交换\n    if (s.charAt(i) !== sortedArr[i]) {\n      const tmp = sb[i];\n      let swapIndex = -1;\n      // 找到排序后的字符在原字符串中的位置\n      for (let j = i + 1; j < s.length; j++) {\n        if (sb[j] === sortedArr[i]) {\n          swapIndex = j;\n        }\n      }\n      // 将原字符与排序后的字符交换\n      sb[i] = sortedArr[i];\n      sb[swapIndex] = tmp;\n      break;\n    }\n  }\n\n  // 输出最小字符串\n  console.log(sb.join(''));\n  rl.close();\n});",
      "cpp": "#include <iostream>\n#include <algorithm>\n#include <string>\n\nint main() {\n    std::string s;\n    std::cin >> s;\n\n    // 对字符串进行排序\n    std::string sortedArr = s;\n    std::sort(sortedArr.begin(), sortedArr.end());\n\n    // 如果排序后的字符串与原字符串相同，则说明已经是最小字符串，直接输出\n    if (sortedArr == s) {\n        std::cout << s << std::endl;\n        return 0;\n    }\n\n    // 遍历原字符串\n    std::string sb = s;\n    for (int i = 0; i < s.length(); i++) {\n        // 如果当前字符与排序后的字符不相同，则进行交换\n        if (s[i] != sortedArr[i]) {\n            char tmp = sb[i];\n            int swapIndex = -1;\n            // 找到排序后的字符在原字符串中的位置\n            for (int j = i + 1; j < s.length(); j++) {\n                if (sb[j] == sortedArr[i]) {\n                    swapIndex = j;\n                }\n            }\n            // 将原字符与排序后的字符交换\n            sb[i] = sortedArr[i];\n            sb[swapIndex] = tmp;\n            break;\n        }\n    }\n\n    // 输出最小字符串\n    std::cout << sb << std::endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_STR_LEN 1000\n\n// 定义比较函数，用于 qsort 函数\nint cmp(const void *a, const void *b) {\n    return *(char *)a - *(char *)b;\n}\n\nint main() {\n    char s[MAX_STR_LEN], sortedArr[MAX_STR_LEN];\n    scanf(\"%s\", s);\n\n    // 对字符串进行排序\n    strcpy(sortedArr, s);\n    qsort(sortedArr, strlen(sortedArr), sizeof(char), cmp);\n\n    // 如果排序后的字符串与原字符串相同，则说明已经是最小字符串，直接输出\n    if (strcmp(sortedArr, s) == 0) {\n        printf(\"%s\\n\", s);\n        return 0;\n    }\n\n    // 遍历原字符串\n    for (int i = 0; i < strlen(s); i++) {\n        // 如果当前字符与排序后的字符不相同，则进行交换\n        if (s[i] != sortedArr[i]) {\n            char tmp = s[i];\n            int swapIndex = -1;\n            // 找到排序后的字符在原字符串中的位置\n            for (int j = i + 1; j < strlen(s); j++) {\n                if (s[j] == sortedArr[i]) {\n                    swapIndex = j;\n                }\n            }\n            // 将原字符与排序后的字符交换\n            s[i] = sortedArr[i];\n            s[swapIndex] = tmp;\n            break;\n        }\n    }\n\n    // 输出最小字符串\n    printf(\"%s\\n\", s);\n\n    return 0;\n}"
    }
  },
  {
    "id": "96",
    "title": "报文响应时间",
    "examType": "A",
    "score": 100,
    "description": "IGMP 协议中，有一个字段称作最大响应时间 (Max Response Time) ，HOST收到查询报文，解折出 MaxResponsetime 字段后，需要在 (0，MaxResponseTime] 时间 (s) 内选取随机时间回应一个响应报文，如果在随机时间内收到一个新的查询报文，则会根据两者时间的大小，选取小的一方刷新回应时间。\n最大响应时间有如下计算方式：\n当 Max Resp Code < 128, Max Resp Time = Max Resp Code；当 Max Resp Code ≥ 128, Max Resp Time = (mant | 0x10) << (exp + 3)；\n\n注: exp最大响应时间的高5~7位: mant 为最大响应时间的低4位。\n其中接收到的MaxRespCode 最大值为 255，以上出现所有字段均为无符号数。\n现在我们认为 HOST收到查询报文时，选取的随机时间必定为最大值，现给出 HOST 收到查询报文个数 C，HOST 收到该报文的时间T，以及查询报文的最大响应时间字段值 M，请计算出HOST 发送响应报文的时间。",
    "inputDesc": "第一行为查询报文个数 C，后续每行分别为 HOST 收到报文时间 T，及最大响应时间M，以空格分割。",
    "outputDesc": "HOST 发送响应报文的时间。\n用例确定只会发送一个响应报文， 不存在计时结束后依然收到查询报文的情况。",
    "examples": [
      {
        "input": "20\n 10\n 20",
        "output": "",
        "explanation": "收到3个报文， 第0秒收到第1个报文，响应时间为20秒，则要到0+20=20秒响应； 第1秒收到第2个报文，响应时间为10秒，则要到1+10=11秒响应，与上面的报文的响应时间比较获得响应时间最小为11秒； 第8秒收到第3个报文，响应时间为20秒，则要到8+20=28秒响应，与第上面的报文的响应时间比较获得响应时间最小为11秒； 最终得到最小响应报文时间为11秒"
      },
      {
        "input": "255\n 60",
        "output": "",
        "explanation": "收到2个报文， 第0秒收到第1个报文，响应时间为255秒，则要到(15 | 0x10) << (7 + 3)= 31744秒响应; (mant = 15，exp =7) 第200秒收到第2个报文，响应时间为60秒，则要到200+60-260秒响应，与第上面的报文的响应时间比较获得响应时间最小为260秒: 最终得到最小响应报文时间为260秒"
      }
    ],
    "solution": "这道题目要求计算在IGMP协议下，HOST在收到多个查询报文后，确定的最早发送响应报文的时间点。HOST需要根据每个报文的最大响应时间字段MaxRespCode来计算其最大响应时间，并在计算出所有可能的响应时间后选取最早的那个时间点。\n核心是：\n当 m < 128 时，m 直接作为 MaxResponseTime。 当 m >= 128 时，需要将 m 转换为8位二进制字符串，将第1至第3位提取为 exp，第4至第7位提取为 mant。接着，将 exp 和 mant 转换为十进制值，并代入公式 (mant | 0x10) << (exp + 3) 进行计算，即可得到 MaxResponseTime。\n当 m < 128 时，m 直接作为 MaxResponseTime。\n当 m >= 128 时，需要将 m 转换为8位二进制字符串，将第1至第3位提取为 exp，第4至第7位提取为 mant。接着，将 exp 和 mant 转换为十进制值，并代入公式 (mant | 0x10) << (exp + 3) 进行计算，即可得到 MaxResponseTime。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main{\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int numQueries = in.nextInt(); // 查询报文个数\n        int[] arrivalTime = new int[numQueries]; // HOST收到报文时间\n        int[] maxRespCode = new int[numQueries]; // 最大响应时间字段值\n\n        for (int i = 0; i < numQueries; i++) {\n            arrivalTime[i] = in.nextInt();\n            maxRespCode[i] = in.nextInt();\n        }\n\n        int minResponseTime = Integer.MAX_VALUE; // HOST发送响应报文的时间\n        for (int i = 0; i < numQueries; i++) {\n            int maxRespTime = 0;\n            if (maxRespCode[i] < 128) { // 当MaxRespCode < 128 ,MaxRespTime = MaxRespCode\n                maxRespTime = maxRespCode[i];\n            } else { // 当MaxRespCode >= 128 ,MaxRespTime = (mant | 0x10) << (exp + 3)\n                int exp = (maxRespCode[i] & 0x70) >> 4; // exp 最大响应时间的 高5~7位\n                int mant = maxRespCode[i] & 0x0F; // mant 为最大响应时间的 低4位\n                maxRespTime = (mant | 0x10) << (exp + 3);\n            }\n            int responseTime = arrivalTime[i] + maxRespTime; // HOST发送响应报文的时间\n            minResponseTime = Math.min(minResponseTime, responseTime); // 更新最小的 HOST发送响应报文的时间\n        }\n        System.out.println(minResponseTime);    \n    }\n}",
      "python": "import sys\n\nnumQueries = int(input()) # 查询报文个数\narrivalTime = [0] * numQueries # HOST收到报文时间\nmaxRespCode = [0] * numQueries # 最大响应时间字段值\n\nfor i in range(numQueries):\n    arrivalTime[i], maxRespCode[i] = map(int, input().split())\n\nminResponseTime = sys.maxsize # HOST发送响应报文的时间\nfor i in range(numQueries):\n    maxRespTime = 0\n    if maxRespCode[i] < 128: # 当MaxRespCode < 128 ,MaxRespTime = MaxRespCode\n        maxRespTime = maxRespCode[i]\n    else: # 当MaxRespCode >= 128 ,MaxRespTime = (mant | 0x10) << (exp + 3)\n        exp = (maxRespCode[i] & 0x70) >> 4 # exp 最大响应时间的 高5~7位\n        mant = maxRespCode[i] & 0x0F # mant 为最大响应时间的 低4位\n        maxRespTime = (mant | 0x10) << (exp + 3)\n    responseTime = arrivalTime[i] + maxRespTime # HOST发送响应报文的时间\n    minResponseTime = min(minResponseTime, responseTime) # 更新最小的 HOST发送响应报文的时间\n\nprint(minResponseTime)",
      "javascript": "const readline = require('readline');  \n\n \nconst rl = readline.createInterface({\n  input: process.stdin,  \n  output: process.stdout  \n});\n\nlet numQueries; // 存储查询的数量\nlet arrivalTime = []; // 存储每次查询的到达时间\nlet maxRespCode = []; // 存储每次查询的最大响应码\n\n \nrl.on('line', (input) => {\n  // 首次输入，用于获取查询的数量\n  if (!numQueries) {\n    numQueries = parseInt(input); // 解析输入为整数，并存储到 numQueries\n  } else {\n    // 分割输入的两个数值，并将其转换为数字类型\n    const [a, b] = input.split(' ').map(Number);\n    arrivalTime.push(a); // 将到达时间存入 arrivalTime 数组\n    maxRespCode.push(b); // 将最大响应码存入 maxRespCode 数组\n\n    // 当输入的查询数达到指定的数量时，开始处理计算\n    if (arrivalTime.length === numQueries) {\n      let minResponseTime = Number.MAX_SAFE_INTEGER; // 初始化最小响应时间为一个很大的值\n      for (let i = 0; i < numQueries; i++) { // 遍历每个查询\n        let maxRespTime = 0; // 用于存储当前查询的最大响应时间\n\n        // 根据 maxRespCode 的值决定计算方式\n        if (maxRespCode[i] < 128) {\n          maxRespTime = maxRespCode[i]; // 如果 maxRespCode 小于 128，直接使用其值作为 maxRespTime\n        } else {\n          // 如果 maxRespCode 大于等于 128，进行复杂计算\n          const exp = (maxRespCode[i] & 0x70) >> 4; // 提取 maxRespCode 的第 4 至 6 位作为 exp\n          const mant = maxRespCode[i] & 0x0F; // 提取 maxRespCode 的第 1 至 3 位作为 mant\n          maxRespTime = (mant | 0x10) << (exp + 3); // 计算 maxRespTime 的实际值\n        }\n\n        // 计算当前查询的响应时间\n        const responseTime = arrivalTime[i] + maxRespTime;\n        // 更新最小响应时间\n        minResponseTime = Math.min(minResponseTime, responseTime);\n      }\n      console.log(minResponseTime); // 输出最小响应时间\n      rl.close(); // 关闭 readline 接口\n    }\n  }\n});",
      "cpp": "#include <iostream>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int numQueries;\n    cin >> numQueries; // 查询报文个数\n    int arrivalTime[numQueries]; // HOST收到报文时间\n    int maxRespCode[numQueries]; // 最大响应时间字段值\n\n    for (int i = 0; i < numQueries; i++) {\n        cin >> arrivalTime[i];\n        cin >> maxRespCode[i];\n    }\n\n    int minResponseTime = INT_MAX; // HOST发送响应报文的时间\n    for (int i = 0; i < numQueries; i++) {\n        int maxRespTime = 0;\n        if (maxRespCode[i] < 128) { // 当MaxRespCode < 128 ,MaxRespTime = MaxRespCode\n            maxRespTime = maxRespCode[i];\n        } else { // 当MaxRespCode >= 128 ,MaxRespTime = (mant | 0x10) << (exp + 3)\n            int exp = (maxRespCode[i] & 0x70) >> 4; // exp 最大响应时间的 高5~7位\n            int mant = maxRespCode[i] & 0x0F; // mant 为最大响应时间的 低4位\n            maxRespTime = (mant | 0x10) << (exp + 3);\n        }\n        int responseTime = arrivalTime[i] + maxRespTime; // HOST发送响应报文的时间\n        minResponseTime = min(minResponseTime, responseTime); // 更新最小的 HOST发送响应报文的时间\n    }\n    cout << minResponseTime << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <limits.h> \n\nint main() {\n    int numQueries;\n    scanf(\"%d\", &numQueries);  \n\n    int arrivalTime[numQueries]; // 定义数组存储 HOST 收到报文的时间\n    int maxRespCode[numQueries]; // 定义数组存储最大响应时间字段值\n\n    // 读取每个查询的到达时间和最大响应码\n    for (int i = 0; i < numQueries; i++) {\n        scanf(\"%d\", &arrivalTime[i]); // 读取到达时间\n        scanf(\"%d\", &maxRespCode[i]); // 读取最大响应码\n    }\n\n    int minResponseTime = INT_MAX; // 初始化最小响应时间为最大整数值\n\n    // 遍历所有查询，计算最小的响应时间\n    for (int i = 0; i < numQueries; i++) {\n        int maxRespTime = 0; // 初始化最大响应时间为0\n\n        // 判断 maxRespCode 的值以决定如何计算最大响应时间\n        if (maxRespCode[i] < 128) {\n            // 如果 maxRespCode 小于 128，直接将其作为 maxRespTime\n            maxRespTime = maxRespCode[i];\n        } else {\n            // 如果 maxRespCode 大于等于 128，根据给定的公式计算 maxRespTime\n            int exp = (maxRespCode[i] & 0x70) >> 4; // 提取 maxRespCode 的第 4 至 6 位作为 exp\n            int mant = maxRespCode[i] & 0x0F; // 提取 maxRespCode 的第 1 至 3 位作为 mant\n            maxRespTime = (mant | 0x10) << (exp + 3); // 计算 maxRespTime 的实际值\n        }\n\n        // 计算当前查询的响应时间\n        int responseTime = arrivalTime[i] + maxRespTime;\n\n        // 更新最小的响应时间\n        if (responseTime < minResponseTime) {\n            minResponseTime = responseTime;\n        }\n    }\n\n    // 输出最小的响应时间\n    printf(\"%d\\n\", minResponseTime);\n\n    return 0; // 程序正常结束\n}"
    }
  },
  {
    "id": "97",
    "title": "敏感字段加密",
    "examType": "A",
    "score": 100,
    "description": "给定一个由多个命令字组成的命令字符串：\n1、字符串长度小于等于127字节，只包含大小写字母，数字，下划线和偶数个双引号； 2、命令字之间以一个或多个下划线_进行分割； 3、可以通过两个双引号””来标识包含下划线_的命令字或空命令字（仅包含两个双引号的命令字），双引号不会在命令字内部出现；\n请对指定索引的敏感字段进行加密，替换为******（6个*），并删除命令字前后多余的下划线_。\n如果无法找到指定索引的命令字，输出字符串ERROR。",
    "inputDesc": "输入为两行，第一行为命令字索引K（从0开始），第二行为命令字符串S。",
    "outputDesc": "输出处理后的命令字符串，如果无法找到指定索引的命令字，输出字符串ERROR",
    "examples": [
      {
        "input": "password__a12345678_timeout_100",
        "output": "password_******_timeout_100",
        "explanation": ""
      },
      {
        "input": "aaa_password_\"a12_45678\"_timeout__100_\"\"_",
        "output": "aaa_password_******_timeout_100_\"\"",
        "explanation": ""
      },
      {
        "input": "aaa_password_\"a12_45678\"_timeout__100_\"\"_",
        "output": "aaa_password_******_timeout_100_\"\"",
        "explanation": ""
      }
    ],
    "solution": "就是查找替换的事！\n题目要求：\n读取输入中的命令字索引 K（从0开始计数）和命令字符串 S。查找命令字符串 S 中第 K 个命令字，将其替换为 ******（6个 *）。去除处理后字符串中每个命令字前后的多余下划线 _。如果找不到指定索引的命令字，则输出字符串 \"ERROR\"。\n初始化变量： 定义一个空字符串 command 来存储当前正在解析的命令字。定义一个列表 commandList 来存储解析后的命令字列表。 遍历字符数组并处理每个字符： a. 如果当前字符是双引号且 command 中已经包含一个双引号： 将双引号添加到 command 中。将解析完毕的命令字添加到 commandList 中，然后重置 command。 b. 如果 command 不包含双引号且当前字符是下划线： 检查 command 是否为空，如果不为空： 将解析完毕的命令字添加到 commandList 中，然后重置 command。 c. 如果已经到达字符串末尾： 将当前字符添加到 command 中。将解析完毕的命令字添加到 commandList 中，然后重置 command。 d. 否则，将当前字符添加到 command 中。 检查命令字索引 K 是否超出范围： 如果超出范围，输出 \"ERROR\"。 否则： 将指定索引的命令字替换为 \"******\"，并构建结果字符串。\n初始化变量：\n定义一个空字符串 command 来存储当前正在解析的命令字。定义一个列表 commandList 来存储解析后的命令字列表。\n遍历字符数组并处理每个字符：\na. 如果当前字符是双引号且 command 中已经包含一个双引号： 将双引号添加到 command 中。将解析完毕的命令字添加到 commandList 中，然后重置 command。 b. 如果 command 不包含双引号且当前字符是下划线： 检查 command 是否为空，如果不为空： 将解析完毕的命令字添加到 commandList 中，然后重置 command。 c. 如果已经到达字符串末尾： 将当前字符添加到 command 中。将解析完毕的命令字添加到 commandList 中，然后重置 command。 d. 否则，将当前字符添加到 command 中。\n将双引号添加到 command 中。将解析完毕的命令字添加到 commandList 中，然后重置 command。\n检查 command 是否为空，如果不为空： 将解析完毕的命令字添加到 commandList 中，然后重置 command。\n将解析完毕的命令字添加到 commandList 中，然后重置 command。\n将当前字符添加到 command 中。将解析完毕的命令字添加到 commandList 中，然后重置 command。\n检查命令字索引 K 是否超出范围：\n如果超出范围，输出 \"ERROR\"。\n否则：\n将指定索引的命令字替换为 \"******\"，并构建结果字符串。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int index = Integer.parseInt(scanner.nextLine()); // 输入命令字索引K\n        String input = scanner.nextLine(); // 输入命令字符串S\n        char[] charArray = input.toCharArray(); // 将命令字符串转换为字符数组\n        String command = \"\"; // 当前正在解析的命令字\n        List<String> commandList = new ArrayList<>(); // 存储解析后的命令字列表\n\n        for (int i = 0; i < charArray.length; i++) {\n            char ch = charArray[i];\n\n            if (ch == '\"' && command.contains(ch + \"\")) { // 如果当前字符为双引号且命令字中已经包含了一个双引号\n                command += '\"'; // 将双引号添加到命令字中\n                commandList.add(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            } else if (!command.contains(\"\\\"\") && ch == '_') { // 如果命令字不包含双引号且当前字符为下划线\n                if (!command.isEmpty()) { // 如果命令字不为空\n                    commandList.add(command); // 将解析完毕的命令字添加到命令字列表中\n                    command = \"\"; // 重置命令字\n                }\n            } else if (i == charArray.length - 1) { // 如果已经到达字符串末尾\n                command += ch; // 将当前字符添加到命令字中\n                commandList.add(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            } else {\n                command += ch; // 将当前字符添加到命令字中\n            }\n        }\n\n        if (index < 0 || index > commandList.size() - 1) { // 如果命令字索引超出范围\n            System.out.println(\"ERROR\");\n        } else {\n            commandList.set(index, \"******\"); // 将指定索引的命令字替换为******\n            StringBuilder result = new StringBuilder();\n\n            for (String item : commandList) {\n                result.append(\"_\").append(item); // 在命令字之前添加下划线\n            }\n\n            result.deleteCharAt(0); // 删除第一个下划线\n            System.out.println(result.toString());\n        }\n    }\n}",
      "python": "import sys\n\nindex = int(input()) # 输入命令字索引K\ninput = input() # 输入命令字符串S\ncharArray = list(input) # 将命令字符串转换为字符数组\ncommand = \"\" # 当前正在解析的命令字\ncommandList = [] # 存储解析后的命令字列表\n\nfor i in range(len(charArray)):\n    ch = charArray[i]\n\n    if ch == '\"' and ch in command: # 如果当前字符为双引号且命令字中已经包含了一个双引号\n        command += '\"' # 将双引号添加到命令字中\n        commandList.append(command) # 将解析完毕的命令字添加到命令字列表中\n        command = \"\" # 重置命令字\n    elif '\"' not in command and ch == '_': # 如果命令字不包含双引号且当前字符为下划线\n        if command: # 如果命令字不为空\n            commandList.append(command) # 将解析完毕的命令字添加到命令字列表中\n            command = \"\" # 重置命令字\n    elif i == len(charArray) - 1: # 如果已经到达字符串末尾\n        command += ch # 将当前字符添加到命令字中\n        commandList.append(command) # 将解析完毕的命令字添加到命令字列表中\n        command = \"\" # 重置命令字\n    else:\n        command += ch # 将当前字符添加到命令字中\n\nif index < 0 or index > len(commandList) - 1: # 如果命令字索引超出范围\n    print(\"ERROR\")\nelse:\n    commandList[index] = \"******\" # 将指定索引的命令字替换为******\n    result = []\n\n    for item in commandList:\n        result.append(\"_\" + item) # 在命令字之前添加下划线\n\n    result = \"\".join(result)\n    result = result[1:] # 删除第一个下划线\n    print(result)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (index) => {\n    rl.on('line', (input) => {\n        const charArray = input.split(''); // 将命令字符串转换为字符数组\n        let command = \"\"; // 当前正在解析的命令字\n        let commandList = []; // 存储解析后的命令字列表\n\n        for (let i = 0; i < charArray.length; i++) {\n            const ch = charArray[i];\n\n            if (ch === '\"' && command.includes(ch)) { // 如果当前字符为双引号且命令字中已经包含了一个双引号\n                command += '\"'; // 将双引号添加到命令字中\n                commandList.push(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            } else if (!command.includes('\"') && ch === '_') { // 如果命令字不包含双引号且当前字符为下划线\n                if (command !== \"\") { // 如果命令字不为空\n                    commandList.push(command); // 将解析完毕的命令字添加到命令字列表中\n                    command = \"\"; // 重置命令字\n                }\n            } else if (i === charArray.length - 1) { // 如果已经到达字符串末尾\n                command += ch; // 将当前字符添加到命令字中\n                commandList.push(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            } else {\n                command += ch; // 将当前字符添加到命令字中\n            }\n        }\n\n        if (index < 0 || index > commandList.length - 1) { // 如果命令字索引超出范围\n            console.log(\"ERROR\");\n        } else {\n            commandList[index] = \"******\"; // 将指定索引的命令字替换为******\n            let result = \"\";\n\n            for (let i = 0; i < commandList.length; i++) {\n                result += \"_\" + commandList[i]; // 在命令字之前添加下划线\n            }\n\n            result = result.substring(1); // 删除第一个下划线\n            console.log(result);\n        }\n\n        rl.close();\n    });\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int index;\n    cin >> index; // 输入命令字索引K\n    string input;\n    cin >> input; // 输入命令字符串S\n    vector<char> charArray(input.begin(), input.end()); // 将命令字符串转换为字符数组\n    string command = \"\"; // 当前正在解析的命令字\n    vector<string> commandList; // 存储解析后的命令字列表\n\n    for (int i = 0; i < charArray.size(); i++) {\n        char ch = charArray[i];\n\n        if (ch == '\"' && command.find(ch) != string::npos) { // 如果当前字符为双引号且命令字中已经包含了一个双引号\n            command += '\"'; // 将双引号添加到命令字中\n            commandList.push_back(command); // 将解析完毕的命令字添加到命令字列表中\n            command = \"\"; // 重置命令字\n        } else if (command.find('\"') == string::npos && ch == '_') { // 如果命令字不包含双引号且当前字符为下划线\n            if (!command.empty()) { // 如果命令字不为空\n                commandList.push_back(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            }\n        } else if (i == charArray.size() - 1) { // 如果已经到达字符串末尾\n            command += ch; // 将当前字符添加到命令字中\n            commandList.push_back(command); // 将解析完毕的命令字添加到命令字列表中\n            command = \"\"; // 重置命令字\n        } else {\n            command += ch; // 将当前字符添加到命令字中\n        }\n    }\n\n    if (index < 0 || index > commandList.size() - 1) { // 如果命令字索引超出范围\n        cout << \"ERROR\" << endl;\n    } else {\n        commandList[index] = \"******\"; // 将指定索引的命令字替换为******\n        string result = \"\";\n\n        for (string item : commandList) {\n            result += \"_\" + item; // 在命令字之前添加下划线\n        }\n\n        result = result.substr(1); // 删除第一个下划线\n        cout << result << endl;\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义一个宏，用于最大字符串长度\n#define MAX_LEN 128\n\n// 定义一个函数来分割命令字符串\nvoid split_command(char *input, char commandList[][MAX_LEN], int *commandCount) {\n    char command[MAX_LEN] = \"\"; // 当前正在解析的命令字\n    int j = 0; // 用于记录命令字的字符位置\n\n    for (int i = 0; i < strlen(input); i++) {\n        char ch = input[i];\n\n        // 如果当前字符为双引号且命令字中已经包含了一个双引号\n        if (ch == '\"' && strchr(command, '\"') != NULL) {\n            command[j++] = '\"'; // 将双引号添加到命令字中\n            command[j] = '\\0'; // 结束当前命令字字符串\n            strcpy(commandList[*commandCount], command); // 将命令字存储到命令列表中\n            (*commandCount)++; // 增加命令字计数\n            j = 0; // 重置命令字的字符位置\n            command[0] = '\\0'; // 重置命令字\n        }\n        // 如果命令字不包含双引号且当前字符为下划线\n        else if (strchr(command, '\"') == NULL && ch == '_') {\n            if (j > 0) { // 如果命令字不为空\n                command[j] = '\\0'; // 结束当前命令字字符串\n                strcpy(commandList[*commandCount], command); // 将命令字存储到命令列表中\n                (*commandCount)++; // 增加命令字计数\n                j = 0; // 重置命令字的字符位置\n                command[0] = '\\0'; // 重置命令字\n            }\n        }\n        // 如果已经到达字符串末尾\n        else if (i == strlen(input) - 1) {\n            command[j++] = ch; // 将当前字符添加到命令字中\n            command[j] = '\\0'; // 结束当前命令字字符串\n            strcpy(commandList[*commandCount], command); // 将命令字存储到命令列表中\n            (*commandCount)++; // 增加命令字计数\n        }\n        // 其他情况下，将当前字符添加到命令字中\n        else {\n            command[j++] = ch;\n        }\n    }\n}\n\nint main() {\n    int index;\n    char input[MAX_LEN];\n    char commandList[MAX_LEN][MAX_LEN]; // 存储解析后的命令字列表\n    int commandCount = 0; // 记录解析到的命令字数\n\n    // 输入命令字索引K\n    scanf(\"%d\", &index);\n    // 输入命令字符串S\n    scanf(\"%s\", input);\n\n    // 将命令字符串转换为命令列表\n    split_command(input, commandList, &commandCount);\n\n    // 如果命令字索引超出范围\n    if (index < 0 || index >= commandCount) {\n        printf(\"ERROR\\n\");\n    } else {\n        // 将指定索引的命令字替换为******\n        strcpy(commandList[index], \"******\");\n        \n        // 构建结果字符串\n        for (int i = 0; i < commandCount; i++) {\n            if (i > 0) {\n                printf(\"_\"); // 在命令字之间添加下划线\n            }\n            printf(\"%s\", commandList[i]); // 输出命令字\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "98",
    "title": "数大雁",
    "examType": "A",
    "score": 100,
    "description": "一群大雁往南飞，给定一个字符串记录地面上的游客听到的大雁叫声，请给出叫声最少由几只大雁发出。\n具体的:\n​ 1.大雁发出的完整叫声为”quack“，因为有多只大雁同一时间嘎嘎作响，所以字符串中可能会混合多个”quack”。\n​ 2.大雁会依次完整发出”quack”，即字符串中’q’ ,‘u’, ‘a’, ‘c’, ‘k’ 这5个字母按顺序完整存在才能计数为一只大雁。如果不完整或者没有按顺序则不予计数。\n​ 3.如果字符串不是由’q’, ‘u’, ‘a’, ‘c’, ‘k’ 字符组合而成，或者没有找到一只大雁，请返回-1。",
    "inputDesc": "一个字符串，包含大雁quack的叫声。1 <= 字符串长度 <= 1000，字符串中的字符只有’q’, ‘u’, ‘a’, ‘c’, ‘k’。",
    "outputDesc": "大雁的数量",
    "examples": [
      {
        "input": "quackquack",
        "output": "",
        "explanation": "无"
      },
      {
        "input": "qaauucqcaa",
        "output": "-1",
        "explanation": "无"
      },
      {
        "input": "quacqkuackquack",
        "output": "",
        "explanation": "无"
      },
      {
        "input": "qququaauqccauqkkcauqqkcauuqkcaaukccakkck",
        "output": "",
        "explanation": "无"
      },
      {
        "input": "quacqkuquacqkacuqkackuack",
        "output": "",
        "explanation": "无"
      }
    ],
    "solution": "这个题目要求根据地面上的游客听到的大雁叫声（由字符串表示），判断至少有几只大雁在发出叫声。题目假设大雁的完整叫声为“quack”，并且同一时间可能有多只大雁发出这样的叫声。\n完整性：一个大雁的叫声必须按顺序完整地发出“quack”。这意味着字符串中的字符必须严格按照顺序出现：q -> u -> a -> c -> k。 多只大雁的情况：多个大雁可以同时发出叫声，造成“quack”片段在字符串中交错出现。例如，字符串“quqacuackk”表示两只大雁在同时发出叫声。 输入约束：字符串长度在1到1000之间，字符只能是q, u, a, c, k。如果字符串中存在不符合规则的部分，或者字符串无法组合成至少一个完整的“quack”，就需要返回-1。\n完整性：一个大雁的叫声必须按顺序完整地发出“quack”。这意味着字符串中的字符必须严格按照顺序出现：q -> u -> a -> c -> k。\n多只大雁的情况：多个大雁可以同时发出叫声，造成“quack”片段在字符串中交错出现。例如，字符串“quqacuackk”表示两只大雁在同时发出叫声。\n输入约束：字符串长度在1到1000之间，字符只能是q, u, a, c, k。如果字符串中存在不符合规则的部分，或者字符串无法组合成至少一个完整的“quack”，就需要返回-1。",
    "codes": {
      "java": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class Quack {\n    public static void main(String[] args) {\n        // 创建Scanner对象用于读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取输入的字符串\n        String chars = scanner.nextLine();\n        // 定义大雁叫声的字符串\n        String quack = \"quack\";\n        // 定义一个数组，用于存储每个字符的状态\n        int[] states = new int[quack.length()];\n        // 定义一个ArrayList，用于存储每只大雁的叫声数量\n        ArrayList<Integer> dp = new ArrayList<>();\n        // 初始化最大值为0\n        int max_ = 0;\n\n        // 遍历输入的字符串\n        for (int i = 0; i < chars.length(); i++) {\n            // 获取当前字符在\"quack\"中的索引\n            int index = quack.indexOf(chars.charAt(i));\n            // 如果索引为-1，表示输入的字符串包含非法字符，输出-1并退出程序\n            if (index == -1) {\n                System.out.println(-1);\n                System.exit(0);\n            }\n\n            // 如果索引为0，表示当前字符是'q'，更新状态数组\n            if (index == 0) {\n                states[index] += 1;\n            } else {\n                // 如果当前字符的前一个字符的状态大于0，更新状态数组\n                if (states[index - 1] > 0) {\n                    states[index - 1] -= 1;\n                    states[index] += 1;\n                }\n\n                // 如果当前字符是'k'，表示一个完整的\"quack\"叫声已经结束\n                if (quack.charAt(quack.length() - 1) == chars.charAt(i)) {\n                    // 如果状态数组的最后一个元素不为0，表示有大雁正在叫\n                    if (states[states.length - 1] != 0) {\n                        // 创建一个临时数组，用于计算当前大雁的叫声数量\n                        int[] temp = Arrays.copyOf(states, states.length);\n                        temp[states.length - 1] = 0;\n                        max_ = Math.max(max_, Arrays.stream(temp).sum());\n                        // 遍历剩余的字符，更新临时数组\n                        for (int j = i; j < chars.length(); j++) {\n                            index = quack.indexOf(chars.charAt(j));\n                            if (index > 0 && temp[index - 1] > 0) {\n                                temp[index - 1] -= 1;\n                                temp[index] += 1;\n                            }\n                            if (temp[states.length - 1] == max_) {\n                                break;\n                            }\n                        }\n                        // 将当前大雁的叫声数量添加到ArrayList中\n                        dp.add(temp[states.length - 1] + 1);\n                        // 更新状态数组\n                        states[states.length - 1] -= 1;\n                    }\n                }\n            }\n        }\n\n        // 输出结果，如果dp为空，表示没有找到一只大雁，输出-1；否则输出最大值\n        System.out.println(dp.isEmpty() ? -1 : (int) Collections.max(dp));\n    }\n}",
      "python": "chars = input()  # 输入字符串，包含大雁的叫声\nquack = \"quack\"  # 大雁叫声的顺序\nstates = [0] * len(quack)  # 用于跟踪每个字符当前出现的状态，初始为全0\ndp = []  # 动态规划数组，记录每次完成一个“quack”所需要的最少大雁数量\nmax_ = 0  # 记录当前最大的大雁数量\n\nfor i in range(len(chars)):\n    index = quack.find(chars[i])  # 找到当前字符在“quack”中的位置\n    if index == -1:  # 如果字符不在“quack”中，直接返回-1\n        print(-1)\n        exit()\n\n    if index == 0:  # 如果是“q”，表示一个新的大雁叫声的开始\n        states[index] += 1  # 对应位置状态加1\n    else:\n        if states[index - 1]:  # 如果前一个字符的位置状态存在（即有前置字符）\n            states[index - 1] -= 1  # 前一个字符的状态减1\n            states[index] += 1  # 当前字符的状态加1\n\n        if quack[-1] == chars[i]:  # 如果当前字符是“k”，即完成了一个“quack”\n            if states[-1] != 0:  # 确保有完整的大雁叫声\n                temp = [t for t in states]  # 当前状态\n                temp[-1] = 0  # 将最后一个字符的状态设为0，表示一个大雁叫声结束\n                max_ = max(max_, sum(temp))  # 更新最大的大雁数量\n                for j in range(i, len(chars)):  # 从当前位置向后继续检查是否有完整的“quack”\n                    index = quack.find(chars[j])\n                    if temp[index - 1]:  # 如果前一个字符的位置状态存在\n                        temp[index - 1] -= 1  # 前一个字符的状态减1\n                        temp[index] += 1  # 当前字符的状态加1\n                    if temp[-1] == max_:  # 如果状态达到最大值\n                        break  # 结束当前循环\n                dp.append(temp[-1] + 1)  # 将当前计算的结果记录到动态规划数组\n                states[-1] -= 1  # 减少完成的“quack”计数\n\n# 输出最大的大雁数量，如果没有找到有效的“quack”，则返回-1\nprint(max(dp) if dp else -1)",
      "javascript": "// 引入 readline 模块并创建接口用于读取来自标准输入（stdin）的数据\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\n\n// 创建异步迭代器，用于按行读取输入\nvar iter = rl[Symbol.asyncIterator]();\n\n// 定义一个异步函数用于读取一行输入\nconst readline = async () => (await iter.next()).value;\n\n// 立即执行的异步函数，主逻辑在此执行\nvoid (async function () {\n    const chars = await readline();  // 读取一行输入数据（假设为大雁叫声的字符串）\n    const quack = \"quack\";  // 定义标准的“大雁叫声”顺序\n    const states = new Array(quack.length).fill(0);  // 初始化状态数组，用于跟踪每个字符的出现次数\n    const dp = [];  // 动态规划数组，用于记录完成“quack”时大雁的数量\n    let max_ = 0;  // 记录同时发出叫声的大雁的最大数量\n\n    // 遍历输入的每一个字符\n    for (let i = 0; i < chars.length; i++) {\n        const index = quack.indexOf(chars[i]);  // 查找当前字符在“quack”中的位置\n        if (index === -1) {  // 如果字符不在“quack”中，表示无效输入\n            console.log(-1);  // 输出-1表示错误\n            process.exit();  // 终止程序\n        }\n\n        if (index === 0) {  // 如果是“q”，表示一个新的大雁叫声的开始\n            states[index] += 1;  // 更新状态数组，记录一个新“q”的出现\n        } else {\n            if (states[index - 1]) {  // 如果前一个字符的状态有效\n                states[index - 1] -= 1;  // 前一个字符状态减1\n                states[index] += 1;  // 当前字符状态加1\n            }\n\n            // 如果当前字符是“k”，表示一个完整的“quack”结束\n            if (quack[quack.length - 1] === chars[i]) {\n                if (states[states.length - 1] !== 0) {  // 确保有一个完整的“quack”\n                    const temp = [...states];  // 当前状态数组\n                    temp[states.length - 1] = 0;  // 重置最后一个字符的状态\n                    max_ = Math.max(max_, temp.reduce((a, b) => a + b));  // 更新最大大雁数量\n\n                    // 检查剩余的字符，尝试找到更多的完整“quack”\n                    for (let j = i; j < chars.length; j++) {\n                        const index = quack.indexOf(chars[j]);  // 查找字符位置\n                        if (temp[index - 1]) {  // 如果前一个字符状态有效\n                            temp[index - 1] -= 1;  // 前一个字符状态减1\n                            temp[index] += 1;  // 当前字符状态加1\n                        }\n                        if (temp[temp.length - 1] === max_) {  // 如果达到最大大雁数量\n                            break;  // 停止搜索\n                        }\n                    }\n                    dp.push(temp[temp.length - 1] + 1);  // 记录当前的最大大雁数量\n                    states[states.length - 1] -= 1;  // 减少完成的“quack”计数\n                }\n            }\n        }\n    }\n\n    // 输出最大的大雁数量，如果没有找到有效的“quack”，则返回-1\n    console.log(dp.length ? Math.max(...dp) : -1);\n})();",
      "cpp": "#include <iostream>    \n#include <vector>      \n#include <algorithm>    \n#include <numeric>       \n\nusing namespace std;\n\nint main() {\n    string chars;  // 定义输入字符串，用于存储游客听到的大雁叫声\n    cin >> chars;  // 从标准输入中读取字符串\n    string quack = \"quack\";  // 定义标准的大雁叫声顺序\n    vector<int> states(quack.size(), 0);  // 定义一个状态数组，用于跟踪每个字符的出现次数\n    vector<int> dp;  // 动态规划数组，用于记录完成“quack”时大雁的数量\n    int max_ = 0;  // 用于记录同时发出叫声的大雁的最大数量\n\n    // 遍历输入字符串中的每一个字符\n    for (int i = 0; i < chars.size(); i++) {\n        int index = quack.find(chars[i]);  // 找到当前字符在“quack”中的位置\n        if (index == -1) {  // 如果字符不在“quack”中，输出-1并结束程序\n            cout << -1 << endl;\n            exit(0);\n        }\n\n        if (index == 0) {  // 如果是“q”，表示一个新的大雁叫声的开始\n            states[index] += 1;  // 更新状态数组，表示一个新“q”的开始\n        }\n        else {\n            if (states[index - 1]) {  // 检查前一个字符的状态是否有效\n                states[index - 1] -= 1;  // 前一个字符的状态减1\n                states[index] += 1;  // 当前字符的状态加1\n            }\n\n            if (quack[quack.size() - 1] == chars[i]) {  // 如果当前字符是“k”，表示一个完整的“quack”结束\n                if (states[states.size() - 1] != 0) {  // 确保有一个完整的“quack”存在\n                    vector<int> temp(states);  // 当前状态数组\n                    temp[states.size() - 1] = 0;  // 重置最后一个字符的状态\n                    max_ = max(max_, accumulate(temp.begin(), temp.end(), 0));  // 更新最大大雁数量\n\n                    // 检查剩余的字符，尝试找到更多的完整“quack”\n                    for (int j = i; j < chars.size(); j++) {\n                        index = quack.find(chars[j]);\n                        if (temp[index - 1]) {  // 检查前一个字符的状态是否有效\n                            temp[index - 1] -= 1;  // 前一个字符的状态减1\n                            temp[index] += 1;  // 当前字符的状态加1\n                        }\n                        if (temp[states.size() - 1] == max_) {  // 如果达到最大大雁数量，停止循环\n                            break;\n                        }\n                    }\n                    dp.push_back(temp[states.size() - 1] + 1);  // 记录当前的最大大雁数量\n                    states[states.size() - 1] -= 1;  // 减少完成的“quack”计数\n                }\n            }\n        }\n    }\n\n    // 输出最大的大雁数量，如果没有找到有效的“quack”，则返回-1\n    cout << (dp.empty() ? -1 : *max_element(dp.begin(), dp.end())) << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>   // 标准输入输出库\n#include <stdlib.h>  // 包含 exit 函数\n#include <string.h>  // 字符串处理库\n\n#define MAX_LEN 1000  // 定义输入字符串的最大长度\n\nint main() {\n    char chars[MAX_LEN];  // 定义输入字符串数组，用于存储游客听到的大雁叫声\n    scanf(\"%s\", chars);  // 从标准输入中读取字符串\n    char quack[] = \"quack\";  // 定义标准的大雁叫声顺序\n    int states[5] = {0};  // 定义一个状态数组，用于跟踪每个字符的出现次数\n    int dp[MAX_LEN] = {0};  // 动态规划数组，用于记录完成“quack”时大雁的数量\n    int max_ = 0;  // 用于记录同时发出叫声的大雁的最大数量\n    int dp_index = 0;  // 动态规划数组的索引\n\n    // 遍历输入字符串中的每一个字符\n    for (int i = 0; i < strlen(chars); i++) {\n        int index = -1;  // 用于存储当前字符在“quack”中的位置\n        for (int k = 0; k < strlen(quack); k++) {  // 手动查找当前字符在“quack”中的位置\n            if (chars[i] == quack[k]) {\n                index = k;\n                break;\n            }\n        }\n        if (index == -1) {  // 如果字符不在“quack”中，输出-1并结束程序\n            printf(\"-1\\n\");\n            exit(0);\n        }\n\n        if (index == 0) {  // 如果是“q”，表示一个新的大雁叫声的开始\n            states[index] += 1;  // 更新状态数组，表示一个新“q”的开始\n        }\n        else {\n            if (states[index - 1]) {  // 检查前一个字符的状态是否有效\n                states[index - 1] -= 1;  // 前一个字符的状态减1\n                states[index] += 1;  // 当前字符的状态加1\n            }\n\n            if (quack[strlen(quack) - 1] == chars[i]) {  // 如果当前字符是“k”，表示一个完整的“quack”结束\n                if (states[strlen(quack) - 1] != 0) {  // 确保有一个完整的“quack”存在\n                    int temp[5];  // 定义临时状态数组\n                    for (int t = 0; t < 5; t++) {\n                        temp[t] = states[t];  // 当前状态数组\n                    }\n                    temp[strlen(quack) - 1] = 0;  // 重置最后一个字符的状态\n                    int temp_sum = 0;  // 计算当前状态数组的和\n                    for (int t = 0; t < 5; t++) {\n                        temp_sum += temp[t];\n                    }\n                    if (temp_sum > max_) {  // 更新最大大雁数量\n                        max_ = temp_sum;\n                    }\n\n                    // 检查剩余的字符，尝试找到更多的完整“quack”\n                    for (int j = i; j < strlen(chars); j++) {\n                        int inner_index = -1;\n                        for (int k = 0; k < strlen(quack); k++) {\n                            if (chars[j] == quack[k]) {\n                                inner_index = k;\n                                break;\n                            }\n                        }\n                        if (temp[inner_index - 1]) {  // 检查前一个字符的状态是否有效\n                            temp[inner_index - 1] -= 1;  // 前一个字符的状态减1\n                            temp[inner_index] += 1;  // 当前字符的状态加1\n                        }\n                        if (temp[strlen(quack) - 1] == max_) {  // 如果达到最大大雁数量，停止循环\n                            break;\n                        }\n                    }\n                    dp[dp_index++] = temp[strlen(quack) - 1] + 1;  // 记录当前的最大大雁数量\n                    states[strlen(quack) - 1] -= 1;  // 减少完成的“quack”计数\n                }\n            }\n        }\n    }\n\n    // 输出最大的大雁数量，如果没有找到有效的“quack”，则返回-1\n    if (dp_index == 0) {\n        printf(\"-1\\n\");\n    } else {\n        int result = dp[0];\n        for (int i = 1; i < dp_index; i++) {\n            if (dp[i] > result) {\n                result = dp[i];\n            }\n        }\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "99",
    "title": "斗地主之顺子",
    "examType": "A",
    "score": 100,
    "description": "在斗地主扑克牌游戏中， 扑克牌由小到大的顺序为：3,4,5,6,7,8,9,10,J,Q,K,A,2，玩家可以出的扑克牌阵型有：单张、对子、顺子、飞机、炸弹等。\n其中顺子的出牌规则为：由至少5张由小到大连续递增的扑克牌组成，且不能包含2。\n例如：{3,4,5,6,7}、{3,4,5,6,7,8,9,10,J,Q,K,A}都是有效的顺子；而{J,Q,K,A,2}、 {2,3,4,5,6}、{3,4,5,6}、{3,4,5,6,8}等都不是顺子。\n给定一个包含13张牌的数组，如果有满足出牌规则的顺子，请输出顺子。\n如果存在多个顺子，请每行输出一个顺子，且需要按顺子的第一张牌的大小（必须从小到大）依次输出。\n如果没有满足出牌规则的顺子，请输出No。",
    "inputDesc": "13张任意顺序的扑克牌，每张扑克牌数字用空格隔开，每张扑克牌的数字都是合法的，并且不包括大小王：\n2 9 J 2 3 4 K A 7 9 A 5 6\n不需要考虑输入为异常字符的情况",
    "outputDesc": "组成的顺子，每张扑克牌数字用空格隔开：\n3 4 5 6 7",
    "examples": [
      {
        "input": "9 J 2 3 4 K A 7 9 A 5 6",
        "output": "4 5 6 7",
        "explanation": "13张牌中，可以组成的顺子只有1组：3 4 5 6 7。"
      },
      {
        "input": "9 J 10 3 4 K A 7 Q A 5 6",
        "output": "4 5 6 7\n 10 J Q K A",
        "explanation": "13张牌中，可以组成2组顺子，从小到大分别为：3 4 5 6 7 和 9 10 J Q K A"
      },
      {
        "input": "9 9 9 3 4 K A 10 Q A 5 6",
        "output": "No",
        "explanation": "13张牌中，无法组成顺子。"
      }
    ],
    "solution": "这个问题涉及解析一个包含13张扑克牌的数组，目的是识别出所有符合条件的有效顺子。顺子定义为至少包含5张按牌面大小顺序连续的扑克牌，不包括牌面为“2”的牌。\n题目描述存在不明确之处，未具体说明是要求解最多数量的顺子，还是单个最长的顺子。\n考虑以下示例：\n1\n如果目标是找到数量最多的顺子，答案将是两个独立的顺子：【4 5 6 7 8】和【6 7 8 9 10】。\n如果目标是找到单个最长的顺子，答案则是【4 5 6 7 8 9 10】。\n此外，如果【数量最多的顺子】，尽管【5 6 7 8 9】也是一个有效顺子，但在按照第二个示例的选择规则，它不是答案。这表明题目可能更倾向于寻找最长的顺子，且实际机考按照最长的去找，通过率高于数量最多。",
    "codes": {
      "java": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    // 静态初始化一个用于映射扑克牌面到数字的HashMap，以方便后续比较大小\n    private static final Map<String, Integer> CARD_TO_NUMBER;\n\n    static {\n        // 初始化HashMap\n        CARD_TO_NUMBER = new HashMap<>();\n        // 将每张扑克牌对应的面值映射到一个整数，其中2被认为是最大的牌\n        CARD_TO_NUMBER.put(\"3\", 3);\n        CARD_TO_NUMBER.put(\"4\", 4);\n        CARD_TO_NUMBER.put(\"5\", 5);\n        CARD_TO_NUMBER.put(\"6\", 6);\n        CARD_TO_NUMBER.put(\"7\", 7);\n        CARD_TO_NUMBER.put(\"8\", 8);\n        CARD_TO_NUMBER.put(\"9\", 9);\n        CARD_TO_NUMBER.put(\"10\", 10);\n        CARD_TO_NUMBER.put(\"J\", 11);\n        CARD_TO_NUMBER.put(\"Q\", 12);\n        CARD_TO_NUMBER.put(\"K\", 13);\n        CARD_TO_NUMBER.put(\"A\", 14);\n        CARD_TO_NUMBER.put(\"2\", 16);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);  // 创建Scanner对象用于读取输入\n        String[] cards = sc.nextLine().split(\" \");  // 读取一行输入，并按空格分割成数组\n        // 对输入的扑克牌按照定义的牌面大小进行排序\n        Arrays.sort(cards, (a, b) -> CARD_TO_NUMBER.get(a) - CARD_TO_NUMBER.get(b));\n\n        ArrayList<LinkedList<String>> straights = new ArrayList<>();  // 用于存储所有可能的顺子序列\n        LinkedList<String> currentStraight = new LinkedList<>();  // 初始化当前正在检查的顺子序列\n        currentStraight.add(cards[0]);  // 将排序后的第一张牌加入到当前顺子序列中\n        straights.add(currentStraight);  // 将当前顺子序列加入到顺子列表中\n\n        // 从第二张牌开始遍历所有牌\n        for (int i = 1; i < cards.length; i++) {\n            String card = cards[i];\n            boolean added = false;  // 标记当前牌是否已被添加到某个顺子中\n\n            // 遍历当前已存在的所有顺子序列，尝试将当前牌加入\n            for (LinkedList<String> straight : straights) {\n                // 判断当前牌是否可以追加到顺子的末尾\n                if (CARD_TO_NUMBER.get(card) - CARD_TO_NUMBER.get(straight.getLast()) == 1) {\n                    straight.add(card);\n                    added = true;\n                    break;\n                }\n            }\n\n            // 如果当前牌没有加入到任何顺子中，创建一个新的顺子序列\n            if (!added) {\n                LinkedList<String> newStraight = new LinkedList<>();\n                newStraight.add(card);\n                straights.add(newStraight);\n            }\n        }\n\n        // 筛选出长度至少为5的有效顺子序列\n        List<LinkedList<String>> validStraights =\n            straights.stream().filter(straight -> straight.size() >= 5).collect(Collectors.toList());\n\n        // 如果没有找到有效的顺子序列，输出\"No\"\n        if (validStraights.isEmpty()) {\n            System.out.println(\"No\");\n        } else {\n            // 将所有有效的顺子按照起始牌的大小进行排序并输出\n            validStraights.stream()\n                .sorted((a, b) -> CARD_TO_NUMBER.get(a.getFirst()) - CARD_TO_NUMBER.get(b.getFirst()))\n                .forEach(straight -> System.out.println(String.join(\" \", straight)));\n        }\n    }\n}",
      "python": "# 导入Python标准库\nfrom collections import deque\n\n# 定义一个字典，用于映射扑克牌的牌面到数字，方便比较大小\nCARD_TO_NUMBER = {\n    '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8,\n    '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13,\n    'A': 14, '2': 16\n}\n\n \n# 使用input函数读取一行输入，并用split方法按空格分割字符串，得到牌面数组\ncards = input().split()\n# 根据牌面大小对牌进行排序\ncards.sort(key=lambda x: CARD_TO_NUMBER[x])\n\nstraights = []  # 存储所有可能的顺子序列\ncurrent_straight = deque([cards[0]])  # 初始化当前顺子序列，使用deque提高效率\nstraights.append(current_straight)  # 将当前顺子序列添加到列表中\n\n# 遍历输入的牌，从第二张牌开始\nfor card in cards[1:]:\n    added = False  # 标记当前牌是否已被添加到某个顺子中\n\n    # 尝试将当前牌加入到已存在的顺子序列中\n    for straight in straights:\n        # 判断当前牌是否可以追加到顺子末尾\n        if CARD_TO_NUMBER[card] - CARD_TO_NUMBER[straight[-1]] == 1:\n            straight.append(card)\n            added = True\n            break\n    \n    # 如果当前牌没有加入到任何顺子中，创建一个新的顺子序列\n    if not added:\n        new_straight = deque([card])\n        straights.append(new_straight)\n\n# 筛选出长度至少为5的有效顺子序列\nvalid_straights = [list(straight) for straight in straights if len(straight) >= 5]\n\n# 如果没有找到有效的顺子序列，输出\"No\"\nif not valid_straights:\n    print(\"No\")\nelse:\n    # 对所有有效的顺子进行排序，并输出\n    valid_straights.sort(key=lambda x: CARD_TO_NUMBER[x[0]])\n    for straight in valid_straights:\n        print(\" \".join(straight))",
      "javascript": "// 引入 readline 模块并创建接口用于读取来自标准输入(stdin)的数据\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 定义一个映射扑克牌面到数字的对象，方便后续比较大小\nconst CARD_TO_NUMBER = {\n    '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8,\n    '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13,\n    'A': 14, '2': 16\n};\n\n// 读取一行输入\nrl.on('line', (input) => {\n    // 按空格分割输入的字符串，得到牌的数组\n    let cards = input.split(' ');\n    // 根据牌面大小对牌进行排序\n    cards.sort((a, b) => CARD_TO_NUMBER[a] - CARD_TO_NUMBER[b]);\n\n    let straights = [];  // 存储所有可能的顺子序列\n    let currentStraight = [cards[0]];  // 初始化当前顺子序列\n    straights.push(currentStraight);  // 将当前顺子序列加入到列表中\n\n    // 从第二张牌开始遍历所有牌\n    for (let i = 1; i < cards.length; i++) {\n        let card = cards[i];\n        let added = false;  // 标记当前牌是否已被添加到某个顺子中\n\n        // 尝试将当前牌加入到已存在的顺子序列中\n        for (let straight of straights) {\n            // 判断当前牌是否可以追加到顺子的末尾\n            if (CARD_TO_NUMBER[card] - CARD_TO_NUMBER[straight[straight.length - 1]] === 1) {\n                straight.push(card);\n                added = true;\n                break;\n            }\n        }\n\n        // 如果当前牌没有加入到任何顺子中，创建一个新的顺子序列\n        if (!added) {\n            let newStraight = [card];\n            straights.push(newStraight);\n        }\n    }\n\n    // 筛选出长度至少为5的有效顺子序列\n    let validStraights = straights.filter(straight => straight.length >= 5);\n\n    // 如果没有找到有效的顺子序列，输出\"No\"\n    if (validStraights.length === 0) {\n        console.log(\"No\");\n    } else {\n        // 对所有有效的顺子进行排序，并输出\n        validStraights.sort((a, b) => CARD_TO_NUMBER[a[0]] - CARD_TO_NUMBER[b[0]]);\n        validStraights.forEach(straight => console.log(straight.join(' ')));\n    }\n\n    rl.close(); // 关闭readline接口\n});",
      "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <list>\n\nusing namespace std;\nint main() {\n    // 定义一个映射扑克牌面到数字的map，方便后续比较大小\n    map<string, int> card_to_number = {\n        {\"3\", 3}, {\"4\", 4}, {\"5\", 5}, {\"6\", 6}, {\"7\", 7},\n        {\"8\", 8}, {\"9\", 9}, {\"10\", 10}, {\"J\", 11}, {\"Q\", 12},\n        {\"K\", 13}, {\"A\", 14}, {\"2\", 16}\n    };\n\n    // 从标准输入读取一行数据\n    string input;\n    getline(cin, input);\n    istringstream iss(input);\n    vector<string> cards;\n    string card;\n\n    // 将输入的扑克牌存入vector\n    while (iss >> card) {\n        cards.push_back(card);\n    }\n\n    // 根据定义的牌面大小对牌进行排序\n    sort(cards.begin(), cards.end(), [&card_to_number](const string& a, const string& b) {\n        return card_to_number[a] < card_to_number[b];\n    });\n\n    // 用于存储所有可能的顺子序列\n    vector<list<string>> straights;\n    list<string> current_straight;\n    current_straight.push_back(cards[0]);\n    straights.push_back(current_straight);\n\n    // 从第二张牌开始遍历所有牌\n    for (size_t i = 1; i < cards.size(); i++) {\n        bool added = false;  // 标记当前牌是否已被添加到某个顺子中\n        for (auto& straight : straights) {\n            // 判断当前牌是否可以追加到顺子的末尾\n            if (card_to_number[cards[i]] - card_to_number[straight.back()] == 1) {\n                straight.push_back(cards[i]);\n                added = true;\n                break;\n            }\n        }\n\n        // 如果当前牌没有加入到任何顺子中，创建一个新的顺子序列\n        if (!added) {\n            list<string> new_straight;\n            new_straight.push_back(cards[i]);\n            straights.push_back(new_straight);\n        }\n    }\n\n    // 筛选出长度至少为5的有效顺子序列\n    vector<list<string>> valid_straights;\n    for (const auto& straight : straights) {\n        if (straight.size() >= 5) {\n            valid_straights.push_back(straight);\n        }\n    }\n\n    // 如果没有找到有效的顺子序列，输出\"No\"\n    if (valid_straights.empty()) {\n        cout << \"No\\n\";\n    } else {\n        // 输出所有有效的顺子序列\n        for (const auto& straight : valid_straights) {\n            for (const auto& card : straight) {\n                cout << card << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义扑克牌与其数值的映射关系结构体\ntypedef struct {\n    char card[3];  // 扑克牌面（考虑到\"10\"有两个字符，所以数组大小为3）\n    int value;     // 对应的数值\n} CardMap;\n\n// 扑克牌面到数值的映射表\nCardMap card_to_number[] = {\n    {\"3\", 3}, {\"4\", 4}, {\"5\", 5}, {\"6\", 6}, {\"7\", 7}, {\"8\", 8}, {\"9\", 9}, \n    {\"10\", 10}, {\"J\", 11}, {\"Q\", 12}, {\"K\", 13}, {\"A\", 14}, {\"2\", 16}\n};\nint card_map_size = sizeof(card_to_number) / sizeof(card_to_number[0]);\n\n// 用于比较扑克牌的函数\nint compare_cards(const void *a, const void *b) {\n    const char *card1 = *(const char **)a;\n    const char *card2 = *(const char **)b;\n    int value1 = 0, value2 = 0;\n\n    for (int i = 0; i < card_map_size; ++i) {\n        if (strcmp(card_to_number[i].card, card1) == 0) {\n            value1 = card_to_number[i].value;\n        }\n        if (strcmp(card_to_number[i].card, card2) == 0) {\n            value2 = card_to_number[i].value;\n        }\n    }\n\n    return value1 - value2;\n}\n\nint main() {\n    char input[100];  // 存储输入字符串\n    char *cards[20];  // 存储分割后的扑克牌字符串指针\n    int count = 0;    // 扑克牌数量\n\n    // 读取一行输入\n    fgets(input, sizeof(input), stdin);\n    input[strcspn(input, \"\\n\")] = 0;  // 移除换行符\n\n    // 分割输入字符串\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        cards[count++] = token;\n        token = strtok(NULL, \" \");\n    }\n\n    // 对扑克牌进行排序\n    qsort(cards, count, sizeof(char *), compare_cards);\n\n    // 动态分配二维数组来存储可能的顺子序列\n    char **straights[count];\n    int lengths[count];  // 存储每个顺子的长度\n    for (int i = 0; i < count; ++i) {\n        straights[i] = malloc(count * sizeof(char *));\n        straights[i][0] = cards[i];\n        lengths[i] = 1;\n    }\n    int num_straights = count;\n\n    // 生成顺子序列\n    for (int i = 0; i < count; ++i) {\n        for (int j = 0; j < num_straights; ++j) {\n            if (compare_cards(&cards[i], &straights[j][lengths[j] - 1]) == 1) {\n                straights[j][lengths[j]++] = cards[i];\n                break;\n            }\n        }\n    }\n\n    // 输出长度至少为5的顺子序列\n    int found = 0;\n    for (int i = 0; i < num_straights; ++i) {\n        if (lengths[i] >= 5) {\n            found = 1;\n            for (int j = 0; j < lengths[i]; ++j) {\n                printf(\"%s \", straights[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        free(straights[i]);\n    }\n\n    if (!found) {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "100",
    "title": "日志采集系统",
    "examType": "A",
    "score": 100,
    "description": "日志采集是运维系统的的核心组件。日志是按行生成，每行记做一条，由采集系统分批上报。\n如果上报太频繁，会对服务端造成压力;如果上报太晚，会降低用户的体验；如果一次上报的条数太多，会导致超时失败。\n为此，项目组设计了如下的上报策略：\n每成功上报一条日志，奖励1分每条日志每延迟上报1秒，扣1分积累日志达到100条，必须立即上报\n给出日志序列，根据该规则，计算首次上报能获得的最多积分数。",
    "inputDesc": "按时序产生的日志条数 T1,T2…Tn，其中 1<=n<=1000，0<=Ti<=100",
    "outputDesc": "首次上报最多能获得的积分数",
    "examples": [
      {
        "input": "98 1",
        "output": "",
        "explanation": "T1 时刻上报得 1 分 T2 时刻上报得98分，最大 T3 时刻上报得 0 分"
      },
      {
        "input": "60 1",
        "output": "",
        "explanation": "如果第1个时刻上报，获得积分50。如果第2个时刻上报，最多上报100条，前50条延迟上报1s，每条扣除1分，共获得积分为 100-50=50"
      },
      {
        "input": "7 40 10 60",
        "output": "",
        "explanation": "T1时刻上报得3分 T2时刻上报得7分 T3时刻上报得37分，最大 T4时刻上报得-3分 T5时刻上报，因为已经超了100条限制，所以只能上报100条，得-23分"
      }
    ],
    "solution": "积分奖励：每成功上报一条日志，可以获得 1 分。延迟扣分：每条日志每延迟 1 秒上报，会扣除 1 分。强制上报：当积累的日志数量达到 100 条时，必须立即上报，无法再继续等待更多日志。\n输入：1 98 1，输出：98 在第1时刻，上报1条日志，获得1分。在第2时刻，累计生成99条日志（1+98），上报这99条日志，获得99 -1 = 98分（因为第1条日志延迟1秒扣1分，其余98条按时上报不扣分）。在第3时刻，累计生成100条日志（99+1），必须立即上报，获得100 -2 - 98= 0分。最大积分出现在第2时刻，为98分。 输入：50 60 1，输出：50 在第1时刻，上报50条日志，获得50分。在第2时刻，累计生成110条日志（50+60），强制上报100条。前50条日志延迟1秒，每条扣1分，最终得分为50分（100 - 50）。 输入：3 7 40 10 60，输出：37 在第3时刻上报，当前为40条，加上前两秒的，总共50条，上报得50分，但是T2的 7条超时了1秒，减7分，T1的3条超时了2秒，减6分，最后得37分。\n输入：1 98 1，输出：98\n在第1时刻，上报1条日志，获得1分。在第2时刻，累计生成99条日志（1+98），上报这99条日志，获得99 -1 = 98分（因为第1条日志延迟1秒扣1分，其余98条按时上报不扣分）。在第3时刻，累计生成100条日志（99+1），必须立即上报，获得100 -2 - 98= 0分。最大积分出现在第2时刻，为98分。\n输入：50 60 1，输出：50\n在第1时刻，上报50条日志，获得50分。在第2时刻，累计生成110条日志（50+60），强制上报100条。前50条日志延迟1秒，每条扣1分，最终得分为50分（100 - 50）。\n输入：3 7 40 10 60，输出：37\n在第3时刻上报，当前为40条，加上前两秒的，总共50条，上报得50分，但是T2的 7条超时了1秒，减7分，T1的3条超时了2秒，减6分，最后得37分。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class LogCollection {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        // 读取输入的日志序列\n        String input = in.nextLine();\n        // 将日志序列按空格分割成数组\n        String[] logs = input.split(\" \");\n\n        int totalCount = 0; // 总日志条数\n        int maxScore = 0; // 最大积分数\n        for (int i = 0; i < logs.length; i++) {\n            int logCount = Integer.valueOf(logs[i]); // 当前时间点的日志条数\n            if (logCount == 0) {\n                continue; // 如果当前时间点没有日志条数，则跳过\n            }\n\n            totalCount += logCount; // 更新总日志条数\n\n            int score = 0; // 当前时间点的积分数\n            for (int j = 0; j <= i; j++) {\n                if (totalCount > 100 && i == j) {\n                    // 如果总日志条数超过100，并且当前时间点是最后一个时间点\n                    score += logCount - (totalCount - 100); // 计算得分\n                } else {\n                    score += Integer.valueOf(logs[j]) - (i - j) * Integer.valueOf(logs[j]); // 计算得分\n                }\n            }\n\n            if (score > maxScore) {\n                maxScore = score; // 更新最大积分数\n            }\n\n            if (totalCount >= 100) {\n                break; // 如果总日志条数达到100条以上，则退出循环\n            }\n        }\n\n        System.out.println(maxScore); // 输出最大积分数\n    }\n}",
      "python": "import sys\n\n# 读取输入的日志序列\ninput = sys.stdin.readline().strip()\n# 将日志序列按空格分割成数组\nlogs = input.split(\" \")\n\ntotalCount = 0  # 总日志条数\nmaxScore = 0  # 最大积分数\nfor i in range(len(logs)):\n    logCount = int(logs[i])  # 当前时间点的日志条数\n    if logCount == 0:\n        continue  # 如果当前时间点没有日志条数，则跳过\n\n    totalCount += logCount  # 更新总日志条数\n\n    score = 0  # 当前时间点的积分数\n    for j in range(i+1):\n        if totalCount > 100 and i == j:\n            # 如果总日志条数超过100，并且当前时间点是最后一个时间点\n            score += logCount - (totalCount - 100)  # 计算得分\n        else:\n            score += int(logs[j]) - (i - j) * int(logs[j])  # 计算得分\n\n    if score > maxScore:\n        maxScore = score  # 更新最大积分数\n\n    if totalCount >= 100:\n        break  # 如果总日志条数达到100条以上，则退出循环\n\nprint(maxScore)  # 输出最大积分数",
      "javascript": "var readline = require('readline');\n\nvar rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', function (input) {\n    var logs = input.split(\" \");\n\n    var totalCount = 0; // 总日志条数\n    var maxScore = 0; // 最大积分数\n    for (var i = 0; i < logs.length; i++) {\n        var logCount = parseInt(logs[i]); // 当前时间点的日志条数\n        if (logCount === 0) {\n            continue; // 如果当前时间点没有日志条数，则跳过\n        }\n\n        totalCount += logCount; // 更新总日志条数\n\n        var score = 0; // 当前时间点的积分数\n        for (var j = 0; j <= i; j++) {\n            if (totalCount > 100 && i === j) {\n                // 如果总日志条数超过100，并且当前时间点是最后一个时间点\n                score += logCount - (totalCount - 100); // 计算得分\n            } else {\n                score += parseInt(logs[j]) - (i - j) * parseInt(logs[j]); // 计算得分\n            }\n        }\n\n        if (score > maxScore) {\n            maxScore = score; // 更新最大积分数\n        }\n\n        if (totalCount >= 100) {\n            break; // 如果总日志条数达到100条以上，则退出循环\n        }\n    }\n\n    console.log(maxScore); // 输出最大积分数\n\n    rl.close();\n});",
      "cpp": "#include <iostream>  // 包含输入输出流库\n#include <vector>    // 包含向量容器库\nusing namespace std;\n\nint main() {\n    string input;\n    getline(cin, input);  // 从标准输入读取整行数据\n    vector<string> logs;  // 用于存储日志条数的字符串向量\n    string temp = \"\";     // 临时字符串变量，用于逐字符拼接日志条数\n    for (int i = 0; i < input.length(); i++) {  // 遍历输入的每一个字符\n        if (input[i] == ' ') {  // 遇到空格时，表示一个日志条数的结束\n            logs.push_back(temp);  // 将当前拼接的字符串加入日志向量\n            temp = \"\";  // 重置临时字符串变量\n        } else {\n            temp += input[i];  // 拼接字符\n        }\n    }\n    logs.push_back(temp);  // 将最后一个日志条数加入日志向量\n\n    int totalCount = 0;  // 累计日志总条数\n    int maxScore = 0;    // 记录最大积分数\n    for (int i = 0; i < logs.size(); i++) {  // 遍历每个时间点的日志\n        int logCount = stoi(logs[i]);  // 将当前日志条数从字符串转换为整数\n        if (logCount == 0) {  // 如果当前时间点日志条数为0，跳过该时间点\n            continue;\n        }\n\n        totalCount += logCount;  // 累加日志总条数\n\n        int score = 0;  // 当前时间点的积分\n        for (int j = 0; j <= i; j++) {  // 计算当前时间点的积分\n            if (totalCount > 100 && i == j) {  // 如果总日志条数超过100且当前为最后一个时间点\n                score += logCount - (totalCount - 100);  // 计算积分，考虑超出100条的部分\n            } else {\n                score += stoi(logs[j]) - (i - j) * stoi(logs[j]);  // 正常积分计算，考虑延迟扣分\n            }\n        }\n\n        if (score > maxScore) {  // 更新最大积分数\n            maxScore = score;\n        }\n\n        if (totalCount >= 100) {  // 如果总日志条数达到或超过100，提前结束循环\n            break;\n        }\n    }\n\n    cout << maxScore << endl;  // 输出最大积分数\n\n    return 0;\n}",
      "c": "#include <stdio.h>    \n#include <string.h>  \n#include <stdlib.h> \n\nint main() {\n    char input[1000];  // 定义一个字符数组用于存储输入\n    fgets(input, 1000, stdin);  // 从标准输入读取一行数据\n\n    char logs[100][10];  // 定义一个二维字符数组存储日志条数，每条日志最长为10个字符\n    int logCount = 0;    // 日志条数计数器\n    char *token = strtok(input, \" \");  // 使用空格分割输入字符串，获取第一个日志条数\n\n    while (token != NULL) {  // 逐个分割字符串，直到没有更多的分割部分\n        strcpy(logs[logCount], token);  // 将当前日志条数到日志数组中\n        logCount++;  // 增加日志条数计数\n        token = strtok(NULL, \" \");  // 获取下一个日志条数\n    }\n\n    int totalCount = 0;  // 累积日志总条数\n    int maxScore = 0;    // 记录最大积分数\n    for (int i = 0; i < logCount; i++) {  // 遍历每个时间点的日志\n        int logNum = atoi(logs[i]);  // 将当前日志条数从字符串转换为整数\n        if (logNum == 0) {  // 如果当前时间点日志条数为0，跳过该时间点\n            continue;\n        }\n\n        totalCount += logNum;  // 累加日志总条数\n\n        int score = 0;  // 当前时间点的积分\n        for (int j = 0; j <= i; j++) {  // 计算当前时间点的积分\n            int logAtJ = atoi(logs[j]);  // 将日志条数从字符串转换为整数\n            if (totalCount > 100 && i == j) {  // 如果总日志条数超过100且当前为最后一个时间点\n                score += logNum - (totalCount - 100);  // 计算积分，考虑超出100条的部分\n            } else {\n                score += logAtJ - (i - j) * logAtJ;  // 正常积分计算，考虑延迟扣分\n            }\n        }\n\n        if (score > maxScore) {  // 更新最大积分数\n            maxScore = score;\n        }\n\n        if (totalCount >= 100) {  // 如果总日志条数达到或超过100，提前结束循环\n            break;\n        }\n    }\n\n    printf(\"%d\\n\", maxScore);  // 输出最大积分数\n\n    return 0;\n}"
    }
  },
  {
    "id": "101",
    "title": "最大利润贪心的商人",
    "examType": "A",
    "score": 100,
    "description": "商人经营一家店铺，有number种商品，由于仓库限制每件商品的最大持有数量是item[index]，每种商品的价格是item-price[item_index][day]\n通过对商品的买进和卖出获取利润，请给出商人在days天内能获取的最大的利润 注：同一件商品可以反复买进和卖出",
    "inputDesc": "第一行输入商品的数量number，比如3 第二行输入商品售货天数 days，比如3 第三行输入仓库限制每件商品的最大持有数量是item[index]，比如4 5 6 后面继续输入number行days列，含义如下： 第一件商品每天的价格，比如1 2 3 第二件商品每天的价格，比如4 3 2 第三件商品每天的价格，比如1 5 3\n第一行输入商品的数量number，比如3\n第二行输入商品售货天数 days，比如3\n第三行输入仓库限制每件商品的最大持有数量是item[index]，比如4 5 6\n后面继续输入number行days列，含义如下：\n第一件商品每天的价格，比如1 2 3\n第二件商品每天的价格，比如4 3 2\n第三件商品每天的价格，比如1 5 3",
    "outputDesc": "输出商人在这段时间内的最大利润。",
    "examples": [
      {
        "input": "5 6\n 2 3\n 3 2\n 5 2",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "我们只要找到商品价格走势的上升区段，然后低价买入，高价卖出即可求得最大利润。\n和lettcode上的这题差不多！\n122. 买卖股票的最佳时机 II - 力扣（LeetCode）\n使用贪心算法来计算每天售卖商品能够获得的最大利润。",
    "codes": {
      "java": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Main {\n    public static void main(String[] args) {\n        // 处理输入\n        Scanner in = new Scanner(System.in);\n        int itemNumber = in.nextInt(); // 商品数量\n        int days = in.nextInt(); // 售货天数\n        int[] maxItems = new int[itemNumber]; // 每件商品最大持有数量\n        for (int i = 0; i < itemNumber; i++) {\n            maxItems[i] = in.nextInt();\n        }\n        int[][] prices = new int[itemNumber][days]; // 商品价格列表\n        for (int i = 0; i < itemNumber; i++) {\n            for (int j = 0; j < days; j++) {\n                prices[i][j] = in.nextInt();\n            }\n        }\n\n        // 贪心算法\n        int maxProfit = 0;\n        for (int i = 0; i < itemNumber; i++) { // 遍历每件商品\n            for (int j = 1; j < days; j++) { // 遍历商品价格列表，求出每天的利润\n                int profit = Math.max(0, prices[i][j] - prices[i][j - 1]);\n                // 当前价格减去前一天价格，如果为负数则代表亏本，不计入利润\n                maxProfit += profit * maxItems[i]; // 求出当前商品能够获取的最大利润\n            }\n        }\n\n        System.out.println(maxProfit); // 输出最大利润\n    }\n}",
      "python": "# 处理输入\nitemNumber = int(input())  # 商品数量\ndays = int(input())  # 售货天数\n\nmaxItems = list(map(int, input().split()))  # 每件商品最大持有数量\n\nprices = [list(map(int, input().split())) for _ in range(itemNumber)]  # 商品价格列表\n\n# 贪心算法\nmaxProfit = 0\nfor i in range(itemNumber):  # 遍历每件商品\n    for j in range(1, days):  # 遍历商品价格列表，求出每天的利润\n        profit = max(0, prices[i][j] - prices[i][j - 1])\n        # 当前价格减去前一天价格，如果为负数则代表亏本，不计入利润\n        maxProfit += profit * maxItems[i]  # 求出当前商品能够获取的最大利润\n\nprint(maxProfit)  # 输出最大利润",
      "javascript": "const readline = require('readline').createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\n// 处理输入\nlet input = [];\nreadline.on('line', (line) => {\n  input.push(line);\n});\n\nreadline.on('close', () => {\n  const itemNumber = parseInt(input[0])\n  const days = parseInt(input[1]); // 商品数量和售货天数\n\n  const maxItems = input[2].split(' ').map(Number); // 每件商品最大持有数量\n\n  const prices = input.slice(3).map((line) => line.split(' ').map(Number)); // 商品价格列表\n \n  let maxProfit = 0;\n  for (let i = 0; i < itemNumber; i++) { // 遍历每件商品\n    for (let j = 1; j < days; j++) { // 遍历商品价格列表，求出每天的利润\n      const profit = Math.max(0, prices[i][j] - prices[i][j - 1]);\n      // 当前价格减去前一天价格，如果为负数则代表亏本，不计入利润\n      maxProfit += profit * maxItems[i]; // 求出当前商品能够获取的最大利润\n    }\n  }\n\n  console.log(maxProfit); // 输出最大利润\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    // 处理输入\n    int itemNumber, days;\n    cin >> itemNumber >> days;\n\n    vector<int> maxItems(itemNumber); // 每件商品最大持有数量\n    for (int i = 0; i < itemNumber; i++) {\n        cin >> maxItems[i];\n    }\n\n    vector<vector<int>> prices(itemNumber, vector<int>(days)); // 商品价格列表\n    for (int i = 0; i < itemNumber; i++) {\n        for (int j = 0; j < days; j++) {\n            cin >> prices[i][j];\n        }\n    }\n\n    // 贪心算法\n    int maxProfit = 0;\n    for (int i = 0; i < itemNumber; i++) { // 遍历每件商品\n        for (int j = 1; j < days; j++) { // 遍历商品价格列表，求出每天的利润\n            int profit = max(0, prices[i][j] - prices[i][j - 1]);\n            // 当前价格减去前一天价格，如果为负数则代表亏本，不计入利润\n            maxProfit += profit * maxItems[i]; // 求出当前商品能够获取的最大利润\n        }\n    }\n\n    cout << maxProfit << endl; // 输出最大利润\n    return 0;\n}",
      "c": "#include <stdio.h>\n\nint max(int a, int b) {\n    return (a > b) ? a : b; // 返回两个整数中的较大值\n}\n\nint main() {\n    // 处理输入\n    int itemNumber; // 商品数量\n    int days; // 售货天数\n\n    // 从标准输入读取商品数量和售货天数\n    scanf(\"%d %d\", &itemNumber, &days);\n\n    int maxItems[itemNumber]; // 每件商品的最大持有数量\n    for (int i = 0; i < itemNumber; i++) {\n        scanf(\"%d\", &maxItems[i]); // 读取每件商品的最大持有数量\n    }\n\n    int prices[itemNumber][days]; // 商品价格列表，二维数组存储\n    for (int i = 0; i < itemNumber; i++) {\n        for (int j = 0; j < days; j++) {\n            scanf(\"%d\", &prices[i][j]); // 读取每件商品在每一天的价格\n        }\n    }\n\n    // 贪心算法计算最大利润\n    int maxProfit = 0; // 初始化最大利润为0\n    for (int i = 0; i < itemNumber; i++) { // 遍历每件商品\n        for (int j = 1; j < days; j++) { // 遍历每一天的价格\n            // 当前价格减去前一天的价格，计算利润\n            int profit = max(0, prices[i][j] - prices[i][j - 1]);\n            // 如果利润为正，则将其乘以该商品的最大持有量，加到总利润中\n            maxProfit += profit * maxItems[i];\n        }\n    }\n\n    // 输出最大利润\n    printf(\"%d\\n\", maxProfit);\n\n    return 0;\n}"
    }
  },
  {
    "id": "102",
    "title": "最大报酬",
    "examType": "A",
    "score": 100,
    "description": "小明每周上班都会拿到自己的工作清单，工作清单内包含 n 项工作，每项工作都有对应的耗时时间（单位 h）和报酬，工作的总报酬为所有已完成工作的报酬之和，那么请你帮小明安排一下工作，保证小明在指定的工作时间内工作收入最大化。",
    "inputDesc": "T 代表工作时长（单位 h， 0 < T < 1000000）， n 代表工作数量（ 1 < n ≤ 3000）。 接下来是 n 行，每行包含两个整数 t，w。 t 代表该工作消耗的时长（单位 h， t > 0），w 代表该项工作的报酬。",
    "outputDesc": "输出小明指定工作时长内工作可获得的最大报酬。",
    "examples": [
      {
        "input": "3\n 10\n 20\n 5",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "本题是典型的01背包问题，其中：\n工作时长 ( T ) 相当于背包的承重。每一项工作相当于每件物品。工作消耗的时长相当于物品的重量。工作的报酬相当于物品的价值。\n初始化与输入： 首先读入工作时间 ( T ) 和工作数量。读入每项工作的耗时和报酬，存储在二维数组中。 动态规划： 确定所有工作中耗时最短的那个 ( \\text{min_time} )，以便从该时间开始计算dp数组。初始化一个二维dp数组 ( \\text{dp}[i][j] )，其中 ( \\text{dp}[i][j] ) 表示前 ( i ) 项工作在 ( j ) 时间内能获得的最大报酬。 动态规划执行： 使用两个嵌套的for循环遍历工作项 ( i ) 和时间 ( j )。对于第 ( i ) 项工作： 如果耗时 ( \\text{tasks}[i-1][0] ) 大于 ( j )，则无法完成该项工作，此时最大报酬为 0。否则，能完成该项工作，最大报酬为 ( \\text{tasks}[i-1][1] ) 加上前 ( i-1 ) 项工作在 ( j-\\text{tasks}[i-1][0] ) 时间内能获得的最大报酬。 更新dp数组，( \\text{dp}[i][j] = \\max(\\text{dp}[i-1][j], \\text{current}) )，其中 (\\text{current}) 是如果包含当前工作所得到的报酬。 输出结果： 输出 ( \\text{dp}[n][T] )，表示前 ( n ) 项工作在 ( T ) 时间内能获得的最大报酬。\n初始化与输入：\n首先读入工作时间 ( T ) 和工作数量。读入每项工作的耗时和报酬，存储在二维数组中。\n动态规划：\n确定所有工作中耗时最短的那个 ( \\text{min_time} )，以便从该时间开始计算dp数组。初始化一个二维dp数组 ( \\text{dp}[i][j] )，其中 ( \\text{dp}[i][j] ) 表示前 ( i ) 项工作在 ( j ) 时间内能获得的最大报酬。\n动态规划执行：\n使用两个嵌套的for循环遍历工作项 ( i ) 和时间 ( j )。对于第 ( i ) 项工作： 如果耗时 ( \\text{tasks}[i-1][0] ) 大于 ( j )，则无法完成该项工作，此时最大报酬为 0。否则，能完成该项工作，最大报酬为 ( \\text{tasks}[i-1][1] ) 加上前 ( i-1 ) 项工作在 ( j-\\text{tasks}[i-1][0] ) 时间内能获得的最大报酬。 更新dp数组，( \\text{dp}[i][j] = \\max(\\text{dp}[i-1][j], \\text{current}) )，其中 (\\text{current}) 是如果包含当前工作所得到的报酬。\n如果耗时 ( \\text{tasks}[i-1][0] ) 大于 ( j )，则无法完成该项工作，此时最大报酬为 0。否则，能完成该项工作，最大报酬为 ( \\text{tasks}[i-1][1] ) 加上前 ( i-1 ) 项工作在 ( j-\\text{tasks}[i-1][0] ) 时间内能获得的最大报酬。\n输出结果：\n输出 ( \\text{dp}[n][T] )，表示前 ( n ) 项工作在 ( T ) 时间内能获得的最大报酬。",
    "codes": {
      "java": "import java.util.Scanner;\nimport java.util.*;\n\nclass Main {\n    \n\tpublic static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt(); // 工作时长\n        int n = scanner.nextInt(); // 工作数量\n        int[][] works = new int[n][2]; // 工作清单，每个工作包含耗时和报酬\n        for (int i = 0; i < n; i++) {\n            works[i][0] = scanner.nextInt(); // 耗时\n            works[i][1] = scanner.nextInt(); // 报酬\n        }\n \n        int minTime = Integer.MAX_VALUE; // 记录工作清单中最小的耗时\n        for (int[] work : works) {\n            minTime = Math.min(minTime, work[0]);\n        }\n \n        int[][] dp = new int[n + 1][T + 1]; // 动态规划数组\n        for (int i = 1; i <= n; i++) {\n            for (int j = minTime; j <= T; j++) {\n                int last = dp[i - 1][j]; // 不选当前工作\n                int current = works[i - 1][0] > j ? 0 : works[i - 1][1] + dp[i - 1][j - works[i - 1][0]]; // 选当前工作\n                dp[i][j] = Math.max(last, current); // 取最大值\n            }\n        }\n        System.out.print(dp[n][T]); // 输出最大报酬\n        \n    }\n \n}",
      "python": "import sys\ninput = sys.stdin.readline\n\nwork_time, n = map(int, input().split()) # 工作时间和工作数量\ntasks = [] # 存储每项工作的耗时时间和报酬\nfor i in range(n):\n    tasks.append(list(map(int, input().split())))\n\nmin_time = float('inf') # 找到所有工作中耗时最短的那个min_time\nfor task in tasks:\n    min_time = min(min_time, task[0])\n\ndp = [[0] * (work_time + 1) for _ in range(n + 1)] # 初始化dp数组\nfor i in range(1, n + 1):\n    for j in range(min_time, work_time + 1):\n        last = dp[i - 1][j] # 上一项工作在j时间内能获得的最大报酬\n        current = 0 if tasks[i - 1][0] > j else tasks[i - 1][1] + dp[i - 1][j - tasks[i - 1][0]] # 当前工作在j时间内能获得的最大报酬\n        dp[i][j] = max(last, current) # 取上一项工作和当前工作在j时间内能获得的最大报酬的最大值\n\nprint(dp[n][work_time]) # 输出前n项工作在T时间内能获得的最大报酬",
      "javascript": "const readline = require('readline');\n// 创建 readline 接口实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 用于存储输入的数据\nconst lines = [];\nlet workTime, n;\n// 监听每行输入的数据\nrl.on(\"line\", (line) => {\n  // 将输入的数据存入 lines 数组中\n  lines.push(line);\n  // 当 lines 数组长度为 1 时，表示输入的是工作时长和工作数量\n  if (lines.length === 1) {\n    [workTime, n] = lines[0].split(\" \").map(Number);\n  }\n  // 当 lines 数组长度为 n + 1 时，表示输入的是 n 个工作的耗时时间和报酬\n  if (n && lines.length === n + 1) {\n    // 删除 lines 数组中的第一个元素，即工作耗时时间和报酬的数量\n    lines.shift();\n    // 将每个工作的耗时时间和报酬存入 tasks 数组中\n    const tasks = lines.map((line) => line.split(\" \").map(Number));\n    // 找出所有工作中的最小耗时时间\n    let minTime = Infinity;\n    for (const task of tasks) {\n      minTime = Math.min(minTime, task[0]);\n    }\n    // 创建 dp 数组，用于存储不同工作在不同时间下的最大报酬\n    const dp = new Array(n + 1).fill().map(() => new Array(workTime + 1).fill(0));\n    // 遍历所有工作，计算在不同时间下的最大报酬\n    for (let i = 1; i <= n; i++) {\n      for (let j = minTime; j <= workTime; j++) {\n        // 当前工作不在可用时间内，无法完成，报酬为 0\n        if (tasks[i - 1][0] > j) {\n          dp[i][j] = dp[i - 1][j];\n        } else {\n          // 当前工作在可用时间内，可完成，计算完成后的总报酬\n          const last = dp[i - 1][j];\n          const current = tasks[i - 1][1] + dp[i - 1][j - tasks[i - 1][0]];\n          dp[i][j] = Math.max(last, current);\n        }\n      }\n    }\n    // 输出在指定工作时间内的最大报酬\n    console.log(dp[n][workTime]);\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int work_time, n; // 工作时间和工作数量\n    cin >> work_time >> n;\n    vector<vector<int>> tasks(n, vector<int>(2)); // 存储每项工作的耗时时间和报酬\n    for (int i = 0; i < n; i++) {\n        cin >> tasks[i][0] >> tasks[i][1];\n    }\n\n    int min_time = INT_MAX; // 找到所有工作中耗时最短的那个min_time\n    for (auto task : tasks) {\n        min_time = min(min_time, task[0]);\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(work_time + 1)); // 初始化dp数组\n    for (int i = 1; i <= n; i++) {\n        for (int j = min_time; j <= work_time; j++) {\n            int last = dp[i - 1][j]; // 上一项工作在j时间内能获得的最大报酬\n            int current = tasks[i - 1][0] > j ? 0 : tasks[i - 1][1] + dp[i - 1][j - tasks[i - 1][0]]; // 当前工作在j时间内能获得的最大报酬\n            dp[i][j] = max(last, current); // 取上一项工作和当前工作在j时间内能获得的最大报酬的最大值\n        }\n    }\n    cout << dp[n][work_time] << endl; // 输出前n项工作在T时间内能获得的最大报酬\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\nint main() {\n    int work_time, n; // 工作时间和工作数量\n    scanf(\"%d %d\", &work_time, &n);\n    int tasks[n][2]; // 存储每项工作的耗时时间和报酬\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &tasks[i][0], &tasks[i][1]);\n    }\n\n    int min_time = INT_MAX; // 找到所有工作中耗时最短的那个min_time\n    for (int i = 0; i < n; i++) {\n        if (tasks[i][0] < min_time) {\n            min_time = tasks[i][0];\n        }\n    }\n\n    // 动态规划数组\n    int **dp = (int**) malloc((n + 1) * sizeof(int*));\n    for (int i = 0; i <= n; i++) {\n        dp[i] = (int*) malloc((work_time + 1) * sizeof(int));\n        for (int j = 0; j <= work_time; j++) {\n            dp[i][j] = 0;\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = min_time; j <= work_time; j++) {\n            int last = dp[i - 1][j]; // 上一项工作在j时间内能获得的最大报酬\n            int current = tasks[i - 1][0] > j ? 0 : tasks[i - 1][1] + dp[i - 1][j - tasks[i - 1][0]]; // 当前工作在j时间内能获得的最大报酬\n            dp[i][j] = (last > current) ? last : current; // 取上一项工作和当前工作在j时间内能获得的最大报酬的最大值\n        }\n    }\n\n    printf(\"%d\\n\", dp[n][work_time]); // 输出前n项工作在T时间内能获得的最大报酬\n\n    // 释放动态分配的内存\n    for (int i = 0; i <= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n\n    return 0;\n}"
    }
  },
  {
    "id": "103",
    "title": "最左侧冗余覆盖子串",
    "examType": "A",
    "score": 100,
    "description": "给定两个字符串s1和s2和正整数K，其中s1长度为n1，s2长度为n2，在s2中选一个子串，满足:\n该子串长度为n1+k该子串中包含s1中全部字母，该子串每个字母出现次数不小于s1中对应的字母，\n我们称s2以长度k冗余覆盖s1，给定s1，s2，k，求最左侧的s2以长度k冗余覆盖s1的子串的首个元素的下标，如果没有返回**-1**。",
    "inputDesc": "输入三行，第一行为s1，第二行为s2，第三行为k，s1和s2只包含小写字母\n0 ≤ len(s1) ≤ 10000000 ≤ len(s2) ≤ 200000000 ≤ k ≤ 1000",
    "outputDesc": "最左侧的s2以长度k冗余覆盖s1的子串首个元素下标，如果没有返回**-1。**",
    "examples": [
      {
        "input": "ab\naabcd",
        "output": "",
        "explanation": "子串aab和abc符合要求，由于aab在abc的左侧，因此输出aab的下标：0"
      },
      {
        "input": "abc\ndfs",
        "output": "-1",
        "explanation": "s2无法覆盖s1，输出 -1"
      }
    ],
    "solution": "这个题目要求在字符串 s2 中找到一个满足特定条件的子串，然后返回这个子串的首个元素的下标。如果没有找到符合条件的子串，则返回 -1。\n考察的是字符串处理和滑动窗口等算法技巧。你需要在遍历 s2 的过程中检查每一个可能的子串，并判断它是否符合题目要求。\n题目的要求如下：\n给定两个字符串 s1 和 s2 以及一个正整数 k，其中 s1 的长度为 n1，s2 的长度为 n2。在 s2 中找到一个子串，这个子串的长度为 n1 + k。这个子串必须包含 s1 中的所有字母，并且每个字母在子串中出现的次数不能少于在 s1 中出现的次数。你需要找到第一个满足上述条件的子串在 s2 中的起始位置下标。如果没有符合条件的子串，返回 -1。\n示例说明：\ns1 = \"ab\"，s2 = \"aabcd\"，k = 1：在 s2 中，长度为 n1 + k = 3 的子串有 “aab” 和 “abc”。这两个子串都包含 s1 的所有字母，并且每个字母出现的次数都不小于 s1 中的次数。因为 “aab” 出现在 “abc” 的左侧，所以返回 “aab” 的起始位置 0。 s1 = \"abc\"，s2 = \"dfs\"，k = 10：s2 中没有任何长度为 n1 + k = 13 的子串包含 s1 中的所有字母，因此返回 -1。\ns1 = \"ab\"，s2 = \"aabcd\"，k = 1：在 s2 中，长度为 n1 + k = 3 的子串有 “aab” 和 “abc”。这两个子串都包含 s1 的所有字母，并且每个字母出现的次数都不小于 s1 中的次数。因为 “aab” 出现在 “abc” 的左侧，所以返回 “aab” 的起始位置 0。\ns1 = \"abc\"，s2 = \"dfs\"，k = 10：s2 中没有任何长度为 n1 + k = 13 的子串包含 s1 中的所有字母，因此返回 -1。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s1 = scanner.nextLine();\n        String s2 = scanner.nextLine();\n        int k = Integer.parseInt(scanner.nextLine().trim());\n\n        // 调用查找函数并输出结果\n        System.out.println(findRedundantCover(s1, s2, k));\n    }\n\n    /**\n     * 查找满足条件的子串起始位置\n     * @param s1 字符串 s1\n     * @param s2 字符串 s2\n     * @param k  冗余长度 k\n     * @return 返回满足条件的子串的最左侧起始位置，如果没有返回 -1\n     */\n    public static int findRedundantCover(String s1, String s2, int k) {\n        // 计算 s1 中每个字符的出现次数\n        int[] s1Count = new int[26];\n        for (char c : s1.toCharArray()) {\n            s1Count[c - 'a']++;\n        }\n\n        // 初始化滑动窗口的左右边界、剩余需要匹配的 s1 字符数和窗口内字符计数数组\n        int left = 0, right = 0;\n        int s1CharsLeft = s1.length();\n        int[] windowCount = new int[26];\n\n        // 遍历 s2 字符串\n        while (right < s2.length()) {\n            // 将右边界字符加入窗口计数\n            char rightChar = s2.charAt(right);\n            windowCount[rightChar - 'a']++;\n\n            // 如果窗口中的字符在 s1 中出现过，减少剩余需要匹配的字符数\n            if (windowCount[rightChar - 'a'] <= s1Count[rightChar - 'a']) {\n                s1CharsLeft--;\n            }\n\n            // 如果窗口长度大于 s1 长度 + k，需要移动左边界\n            if (right - left + 1 > s1.length() + k) {\n                char leftChar = s2.charAt(left);\n                // 如果左边界字符在 s1 中出现过，增加剩余需要匹配的字符数\n                if (windowCount[leftChar - 'a'] <= s1Count[leftChar - 'a']) {\n                    s1CharsLeft++;\n                }\n                // 将左边界字符从窗口计数中移除\n                windowCount[leftChar - 'a']--;\n                left++;\n            }\n\n            // 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n            if (s1CharsLeft == 0) {\n                return left;\n            }\n\n            // 移动右边界\n            right++;\n        }\n\n        // 如果遍历完 s2 仍未找到满足条件的子串，返回 -1\n        return -1;\n    }\n}",
      "python": "def find_redundant_cover(s1, s2, k):\n    \"\"\"\n    查找满足条件的子串起始位置\n    :param s1: 字符串 s1\n    :param s2: 字符串 s2\n    :param k: 冗余长度 k\n    :return: 返回满足条件的子串的最左侧起始位置，如果没有返回 -1\n    \"\"\"\n    # 计算 s1 中每个字符的出现次数\n    s1_count = [0] * 26  # 创建一个长度为26的数组，用于记录每个字母的出现次数\n    for c in s1:\n        s1_count[ord(c) - ord('a')] += 1  # 通过字符的ASCII码计算其在数组中的位置并递增计数\n\n    # 初始化滑动窗口的左右边界、剩余需要匹配的 s1 字符数和窗口内字符计数数组\n    left, right = 0, 0  # 滑动窗口的左右边界初始都为0\n    s1_chars_left = len(s1)  # 剩余需要匹配的字符数为 s1 的长度\n    window_count = [0] * 26  # 初始化滑动窗口中每个字母的出现次数数组\n\n    # 开始遍历 s2 字符串\n    while right < len(s2):\n        # 将右边界字符加入窗口计数\n        right_char = s2[right]  # 获取当前右边界字符\n        window_count[ord(right_char) - ord('a')] += 1  # 增加该字符在窗口中的计数\n\n        # 如果该字符在 s1 中存在且匹配的数量不超过 s1 中的数量，减少剩余需要匹配的字符数\n        if window_count[ord(right_char) - ord('a')] <= s1_count[ord(right_char) - ord('a')]:\n            s1_chars_left -= 1\n\n        # 如果窗口的长度大于 s1 长度 + k，移动左边界\n        if right - left + 1 > len(s1) + k:\n            left_char = s2[left]  # 获取当前左边界字符\n            # 如果左边界字符在 s1 中存在且数量不超过 s1 中的数量，增加剩余需要匹配的字符数\n            if window_count[ord(left_char) - ord('a')] <= s1_count[ord(left_char) - ord('a')]:\n                s1_chars_left += 1\n            # 将左边界字符从窗口计数中移除\n            window_count[ord(left_char) - ord('a')] -= 1\n            left += 1  # 左边界右移\n\n        # 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n        if s1_chars_left == 0:\n            return left\n\n        # 移动右边界\n        right += 1\n\n    # 如果遍历完 s2 仍未找到满足条件的子串，返回 -1\n    return -1\n\n   \ns1 = input()   # 读取字符串 s1\ns2 = input()   # 读取字符串 s2\nk = int(input().strip())  # 读取并将字符串转换为整数的 k\n\n# 调用查找函数并输出结果\nprint(find_redundant_cover(s1, s2, k))",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet s1, s2, k;\nrl.on('line', (input) => {\n  if (!s1) {\n    s1 = input.trim();\n  } else if (!s2) {\n    s2 = input.trim();\n  } else {\n    k = parseInt(input.trim());\n    console.log(findRedundantCover(s1, s2, k));\n    rl.close();\n  }\n});\n\n/**\n * 查找满足条件的子串起始位置\n * @param {string} s1\n * @param {string} s2\n * @param {number} k\n * @returns {number}\n */\nfunction findRedundantCover(s1, s2, k) {\n  // 计算s1中每个字符的出现次数\n  const s1Count = new Array(26).fill(0);\n  for (const c of s1) {\n    s1Count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n  }\n\n  // 初始化滑动窗口的左右边界、剩余需要匹配的s1字符数和窗口内字符计数数组\n  let left = 0, right = 0, s1CharsLeft = s1.length;\n  const windowCount = new Array(26).fill(0);\n\n  // 遍历s2字符串\n  while (right < s2.length) {\n    // 将右边界字符加入窗口计数\n    const rightChar = s2.charAt(right);\n    windowCount[rightChar.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    // 如果窗口中的字符在s1中出现过，减少剩余需要匹配的字符数\n    if (windowCount[rightChar.charCodeAt(0) - 'a'.charCodeAt(0)] <= s1Count[rightChar.charCodeAt(0) - 'a'.charCodeAt(0)]) {\n      s1CharsLeft--;\n    }\n\n    // 如果窗口长度大于s1长度+k，需要移动左边界\n    if (right - left + 1 > s1.length + k) {\n      const leftChar = s2.charAt(left);\n      // 如果左边界字符在s1中出现过，增加剩余需要匹配的字符数\n      if (windowCount[leftChar.charCodeAt(0) - 'a'.charCodeAt(0)] <= s1Count[leftChar.charCodeAt(0) - 'a'.charCodeAt(0)]) {\n        s1CharsLeft++;\n      }\n      // 将左边界字符从窗口计数中移除\n      windowCount[leftChar.charCodeAt(0) - 'a'.charCodeAt(0)]--;\n      left++;\n    }\n\n    // 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n    if (s1CharsLeft === 0) {\n      return left;\n    }\n\n    // 移动右边界\n    right++;\n  }\n\n  // 如果遍历完s2仍未找到满足条件的子串，返回-1\n  return -1;\n}",
      "cpp": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint findRedundantCover(const string &s1, const string &s2, int k);\n\nint main() {\n    \n    string s1, s2;\n    getline(cin, s1);  // 读取整行字符串 s1\n    getline(cin, s2);  // 读取整行字符串 s2\n    int k;\n    cin >> k;  // 读取整数 k\n\n    // 调用查找函数并输出结果\n    cout << findRedundantCover(s1, s2, k) << endl;\n\n    return 0;\n}\n\nint findRedundantCover(const string &s1, const string &s2, int k) {\n    // 计算 s1 中每个字符的出现次数\n    vector<int> s1Count(26, 0);  // 创建一个长度为26的数组，用于记录每个字母的出现次数\n    for (char c : s1) {\n        s1Count[c - 'a']++;  // 计算每个字符在 s1 中的出现次数\n    }\n\n    // 初始化滑动窗口的左右边界、剩余需要匹配的 s1 字符数和窗口内字符计数数组\n    int left = 0, right = 0;\n    int s1CharsLeft = s1.length();  // 剩余需要匹配的字符数\n    vector<int> windowCount(26, 0);  // 初始化滑动窗口中每个字母的出现次数数组\n\n    // 遍历 s2 字符串\n    while (right < s2.length()) {\n        // 将右边界字符加入窗口计数\n        char rightChar = s2[right];\n        windowCount[rightChar - 'a']++;\n\n        // 如果该字符在 s1 中存在且匹配的数量不超过 s1 中的数量，减少剩余需要匹配的字符数\n        if (windowCount[rightChar - 'a'] <= s1Count[rightChar - 'a']) {\n            s1CharsLeft--;\n        }\n\n        // 如果窗口的长度大于 s1 长度 + k，移动左边界\n        if (right - left + 1 > s1.length() + k) {\n            char leftChar = s2[left];\n            // 如果左边界字符在 s1 中存在且数量不超过 s1 中的数量，增加剩余需要匹配的字符数\n            if (windowCount[leftChar - 'a'] <= s1Count[leftChar - 'a']) {\n                s1CharsLeft++;\n            }\n            // 将左边界字符从窗口计数中移除\n            windowCount[leftChar - 'a']--;\n            left++;\n        }\n\n        // 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n        if (s1CharsLeft == 0) {\n            return left;\n        }\n\n        // 移动右边界\n        right++;\n    }\n\n    // 如果遍历完 s2 仍未找到满足条件的子串，返回 -1\n    return -1;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint findRedundantCover(const char *s1, const char *s2, int k);\n\nint main() {\n     \n    char s1[1000], s2[1000];\n    fgets(s1, 1000, stdin);  // 读取整行字符串 s1\n    fgets(s2, 1000, stdin);  // 读取整行字符串 s2\n    int k;\n    scanf(\"%d\", &k);  // 读取整数 k\n\n    // 去除换行符\n    s1[strcspn(s1, \"\\n\")] = '\\0';\n    s2[strcspn(s2, \"\\n\")] = '\\0';\n\n    // 调用查找函数并输出结果\n    printf(\"%d\\n\", findRedundantCover(s1, s2, k));\n\n    return 0;\n}\n\nint findRedundantCover(const char *s1, const char *s2, int k) {\n    // 计算 s1 中每个字符的出现次数\n    int s1Count[26] = {0};  // 创建一个长度为26的数组，用于记录每个字母的出现次数\n    for (int i = 0; s1[i] != '\\0'; i++) {\n        s1Count[s1[i] - 'a']++;  // 计算每个字符在 s1 中的出现次数\n    }\n\n    // 初始化滑动窗口的左右边界、剩余需要匹配的 s1 字符数和窗口内字符计数数组\n    int left = 0, right = 0;\n    int s1CharsLeft = strlen(s1);  // 剩余需要匹配的字符数\n    int windowCount[26] = {0};  // 初始化滑动窗口中每个字母的出现次数数组\n\n    // 遍历 s2 字符串\n    while (s2[right] != '\\0') {\n        // 将右边界字符加入窗口计数\n        char rightChar = s2[right];\n        windowCount[rightChar - 'a']++;\n\n        // 如果该字符在 s1 中存在且匹配的数量不超过 s1 中的数量，减少剩余需要匹配的字符数\n        if (windowCount[rightChar - 'a'] <= s1Count[rightChar - 'a']) {\n            s1CharsLeft--;\n        }\n\n        // 如果窗口的长度大于 s1 长度 + k，移动左边界\n        if (right - left + 1 > strlen(s1) + k) {\n            char leftChar = s2[left];\n            // 如果左边界字符在 s1 中存在且数量不超过 s1 中的数量，增加剩余需要匹配的字符数\n            if (windowCount[leftChar - 'a'] <= s1Count[leftChar - 'a']) {\n                s1CharsLeft++;\n            }\n            // 将左边界字符从窗口计数中移除\n            windowCount[leftChar - 'a']--;\n            left++;\n        }\n\n        // 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n        if (s1CharsLeft == 0) {\n            return left;\n        }\n\n        // 移动右边界\n        right++;\n    }\n\n    // 如果遍历完 s2 仍未找到满足条件的子串，返回 -1\n    return -1;\n}"
    }
  },
  {
    "id": "104",
    "title": "最长连续子序列",
    "examType": "A",
    "score": 100,
    "description": "有N个正整数组成的一个序列。给定整数sum，求长度最长的连续子序列，使他们的和等于sum，返回此子序列的长度，\n如果没有满足要求的序列，返回-1。",
    "inputDesc": "第一行输入是：N个正整数组成的一个序列\n第二行输入是：给定整数sum",
    "outputDesc": "最长的连续子序列的长度",
    "examples": [
      {
        "input": ",2,3,4,2",
        "output": "",
        "explanation": "1,2,3和4,2两个序列均能满足要求，所以最长的连续序列为1,2,3，因此结果为3。"
      },
      {
        "input": ",2,3,4,2",
        "output": "-1",
        "explanation": "没有满足要求的子序列，返回-1"
      }
    ],
    "solution": "使用滑动窗口的方式来解决这个问题\n通过 left 和 right 这两个指针维护一个滑动窗口，sum 用于跟踪当前窗口内的元素和。当 sum 大于 target 时，代码缩小窗口，通过移动左指针并减少 sum 来调整窗口。一旦 sum 等于 target，更新最大长度 maxLen。",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int[] nums = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n        int target = Integer.parseInt(sc.nextLine());\n\n        int n = nums.length;\n        int left = 0, right = 0, sum = 0, maxLen = -1;\n\n        while (right < n) {\n            // 不断扩大窗口，增加右边界\n            sum += nums[right];\n            right++;\n\n            // 如果当前窗口内的和大于目标值，收缩左边界\n            while (sum > target && left < right) {\n                sum -= nums[left];\n                left++;\n            }\n\n            // 检查是否等于目标值，并更新最大长度\n            if (sum == target) {\n                maxLen = Math.max(maxLen, right - left);\n            }\n        }\n\n        System.out.println(maxLen);\n    }\n}",
      "python": "nums = list(map(int, input().split(',')))\ntarget = int(input())\n\nn = len(nums)\nleft, right, sum_, max_len = 0, 0, 0, -1\n\nwhile right < n:\n    # 不断扩大窗口，增加右边界\n    sum_ += nums[right]\n    right += 1\n\n    # 如果当前窗口内的和大于目标值，收缩左边界\n    while sum_ > target and left < right:\n        sum_ -= nums[left]\n        left += 1\n\n    # 检查是否等于目标值，并更新最大长度\n    if sum_ == target:\n        max_len = max(max_len, right - left)\n\n# 输出结果\nprint(max_len)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 读取用户输入的序列和目标值\nrl.on('line', (line1) => {\n    rl.on('line', (line2) => {\n        \n        const nums = line1.split(',').map(Number);\n        const target = parseInt(line2);\n        rl.close();\n\n        let n = nums.length;\n        let left = 0, right = 0, sum = 0, maxLen = -1;\n\n        while (right < n) {\n            // 不断扩大窗口，增加右边界\n            sum += nums[right];\n            right++;\n\n            // 如果当前窗口内的和大于目标值，收缩左边界\n            while (sum > target && left < right) {\n                sum -= nums[left];\n                left++;\n            }\n\n            // 检查是否等于目标值，并更新最大长度\n            if (sum === target) {\n                maxLen = Math.max(maxLen, right - left);\n            }\n        }\n\n        // 输出结果\n        console.log(maxLen);\n    });\n});",
      "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string line1, line2;\n    getline(cin, line1);  // 读取序列输入\n    getline(cin, line2);  // 读取目标值输入\n\n    // 解析输入的序列\n    vector<int> nums;\n    stringstream ss(line1);\n    string token;\n    while (getline(ss, token, ',')) {\n        nums.push_back(stoi(token));\n    }\n\n    int target = stoi(line2);\n    int n = nums.size();\n    int left = 0, right = 0, sum = 0, maxLen = -1;\n\n    while (right < n) {\n        // 不断扩大窗口，增加右边界\n        sum += nums[right];\n        right++;\n\n        // 如果当前窗口内的和大于目标值，收缩左边界\n        while (sum > target && left < right) {\n            sum -= nums[left];\n            left++;\n        }\n\n        // 检查是否等于目标值，并更新最大长度\n        if (sum == target) {\n            maxLen = max(maxLen, right - left);\n        }\n    }\n\n    // 输出结果\n    cout << maxLen << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char line1[1000], line2[10];\n    fgets(line1, 1000, stdin);  // 读取序列输入\n    fgets(line2, 10, stdin);    // 读取目标值输入\n\n    // 解析输入的序列\n    int nums[200], n = 0;\n    char *token = strtok(line1, \",\");\n    while (token != NULL) {\n        nums[n++] = atoi(token);\n        token = strtok(NULL, \",\");\n    }\n\n    int target = atoi(line2);\n    int left = 0, right = 0, sum = 0, maxLen = -1;\n\n    while (right < n) {\n        // 不断扩大窗口，增加右边界\n        sum += nums[right++];\n        \n        // 如果当前窗口内的和大于目标值，收缩左边界\n        while (sum > target && left < right) {\n            sum -= nums[left++];\n        }\n\n        // 检查是否等于目标值，并更新最大长度\n        if (sum == target) {\n            int len = right - left;\n            if (len > maxLen) {\n                maxLen = len;\n            }\n        }\n    }\n\n    // 输出结果\n    printf(\"%d\\n\", maxLen);\n    return 0;\n}"
    }
  },
  {
    "id": "105",
    "title": "机器人活动区域",
    "examType": "A",
    "score": 100,
    "description": "现有一个机器人，可放置于 M × N 的网格中任意位置，每个网格包含一个非负整数编号，当相邻网格的数字编号差值的绝对值小于等于 1 时，机器人可以在网格间移动。\n问题： 求机器人可活动的最大范围对应的网格点数目。\n说明：网格左上角坐标为 (0,0) ,右下角坐标为(m−1,n−1)，机器人只能在相邻网格间上下左右移动",
    "inputDesc": "第 1 行输入为 M 和 N\nM 表示网格的行数N 表示网格的列数\n之后 M 行表示网格数值，每行 N 个数值（数值大小用 k 表示），数值间用单个空格分隔，行首行尾无多余空格。\nM、 N、 k 均为整数1 ≤ M，N ≤ 150,0 ≤ k ≤ 50",
    "outputDesc": "输出 1 行，包含 1 个数字，表示最大活动区域的网格点数目， 行首行尾无多余空格。",
    "examples": [
      {
        "input": "4\n 2 5 2\n 4 4 5\n 5 7 1\n 6 2 4",
        "output": "",
        "explanation": "如下图： 图中红色区域，相邻网格差值绝对值都小于等于 1 ，且为最大区域，对应网格点数目为 6。"
      },
      {
        "input": "3\n 3 5\n 1 3",
        "output": "",
        "explanation": "任意两个相邻网格的差值绝对值都大于1，机器人不能在网格间移动，只能在单个网格内活动，对应网格点数目为1"
      }
    ],
    "solution": "使用BFS求最大连通分量，规则：当相邻网格的数字编号差值的绝对值小于等于 1 时",
    "codes": {
      "java": "import java.util.Scanner;\n\nclass Main {\n    // 定义四个方向，上下左右\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public static void main(String[] args) {\n        // 输入处理\n        Scanner in = new Scanner(System.in);\n        int m = in.nextInt(); // 行数\n        int n = in.nextInt(); // 列数\n        int[][] matrix = new int[m][n]; // 定义矩阵\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = in.nextInt(); // 读入矩阵中的值\n            }\n        }\n\n        // 遍历每个点作为起点，求最大活动范围\n        int maxRange = 0; // 定义最大活动范围\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                boolean[][] visited = new boolean[m][n]; // 定义是否访问过\n                int range = dfs(matrix, visited, i, j); // 深度优先搜索\n                maxRange = Math.max(maxRange, range); // 更新最大活动范围\n            }\n        }\n\n        System.out.println(maxRange); // 输出最大活动范围\n    }\n\n    public static int dfs(int[][] matrix, boolean[][] visited, int x, int y) {\n        visited[x][y] = true; // 标记当前点已经访问过\n        int range = 1; // 定义活动范围\n        for (int[] direction : directions) { // 遍历四个方向\n            int newX = x + direction[0]; // 新的横坐标\n            int newY = y + direction[1]; // 新的纵坐标\n            if (newX >= 0 && newX < matrix.length && newY >= 0 && newY < matrix[0].length\n                    && !visited[newX][newY] && Math.abs(matrix[newX][newY] - matrix[x][y]) <= 1) { // 判断是否越界、是否访问过、是否符合条件\n                range += dfs(matrix, visited, newX, newY); // 更新活动范围\n            }\n        }\n        return range; // 返回活动范围\n    }\n}",
      "python": "import sys\n\n# 定义四个可能的移动方向：右，左，下，上\ndirections = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n# 使用深度优先搜索（DFS）来探索网格\ndef dfs(matrix, visited, x, y):\n    # 标记当前网格点为已访问\n    visited[x][y] = True\n    # 初始化当前网格点的范围计数为1\n    range = 1\n    # 遍历所有可能的移动方向\n    for direction in directions:\n        newX = x + direction[0]  # 计算新的行坐标\n        newY = y + direction[1]  # 计算新的列坐标\n        # 检查新坐标是否在网格内部，且未访问过，并且满足编号差值绝对值小于等于1的条件\n        if newX >= 0 and newX < len(matrix) and newY >= 0 and newY < len(matrix[0]) \\\n            and not visited[newX][newY] and abs(matrix[newX][newY] - matrix[x][y]) <= 1:\n            # 递归地继续探索并累加可活动的网格点数目\n            range += dfs(matrix, visited, newX, newY)\n    # 返回从当前网格点出发可活动的最大网格点数目\n    return range\n\n# 读取输入数据\nm, n = 0, 0  # 初始化网格的行数和列数\nmatrix = []  # 初始化网格矩阵\n\n# 逐行读取输入\nfor line in sys.stdin:\n    if not m and not n:\n        m, n = map(int, line.split())  # 读取网格的行数和列数\n    else:\n        matrix.append(list(map(int, line.split())))  # 读取网格中的数值\n        if len(matrix) == m:  # 如果已经读取完所有行，结束读取\n            break\n\n# 寻找机器人可以活动的最大范围\nmaxRange = 0\nfor i in range(m):\n    for j in range(n):\n        visited = [[False] * n for _ in range(m)]  # 初始化访问标记数组\n        ranges = dfs(matrix, visited, i, j)  # 对每个网格点执行DFS\n        maxRange = max(maxRange, ranges)  # 更新最大活动范围\n\n# 输出机器人可以活动的最大范围对应的网格点数目\nprint(maxRange)",
      "javascript": "// 导入readline模块以读取和处理输入数据\nconst readline = require('readline');\n\n// 创建readline接口，配置输入来自标准输入，输出到标准输出\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 定义四个可能的移动方向：右，左，下，上\nconst directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n\n// 使用深度优先搜索（DFS）来探索网格\nfunction dfs(matrix, visited, x, y) {\n  visited[x][y] = true;  // 标记当前网格点为已访问\n  let range = 1;  // 初始化当前网格点的范围计数为1\n  // 遍历所有可能的移动方向\n  for (let direction of directions) {\n    let newX = x + direction[0];  // 计算新的行坐标\n    let newY = y + direction[1];  // 计算新的列坐标\n    // 检查新坐标是否在网格内部，且未访问过，并且满足编号差值绝对值小于等于1的条件\n    if (newX >= 0 && newX < matrix.length && newY >= 0 && newY < matrix[0].length\n        && !visited[newX][newY] && Math.abs(matrix[newX][newY] - matrix[x][y]) <= 1) {\n      range += dfs(matrix, visited, newX, newY);  // 递归地继续探索并累加可活动的网格点数目\n    }\n  }\n  return range;  // 返回从当前网格点出发可活动的最大网格点数目\n}\n\nlet m, n;  // 声明变量m和n来存储网格的行数和列数\nlet matrix = [];  // 初始化网格矩阵\n\n// 处理每行输入\nrl.on('line', (line) => {\n  if (!m && !n) {\n    [m, n] = line.split(' ').map(Number);  // 解析输入的行数和列数\n    return;\n  }\n  matrix.push(line.split(' ').map(Number));  // 读取网格中的数值\n  if (matrix.length === m) {  // 如果已经读取完所有行，关闭输入流\n    rl.close();\n  }\n});\n\n// 输入流关闭后开始处理数据\nrl.on('close', () => {\n  let maxRange = 0;  // 初始化最大活动范围\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let visited = Array.from({length: m}, () => Array(n).fill(false));  // 初始化访问标记数组\n      let range = dfs(matrix, visited, i, j);  // 对每个网格点执行DFS\n      maxRange = Math.max(maxRange, range);  // 更新最大活动范围\n    }\n  }\n  console.log(maxRange);  // 输出机器人可以活动的最大范围对应的网格点数目\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// 定义四个方向，上下左右\nconst vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint dfs(vector<vector<int>>& matrix, vector<vector<bool>>& visited, int x, int y) {\n    visited[x][y] = true; // 标记当前点已经访问过\n    int range = 1; // 定义活动范围\n    for (vector<int> direction : directions) { // 遍历四个方向\n        int newX = x + direction[0]; // 新的横坐标\n        int newY = y + direction[1]; // 新的纵坐标\n        if (newX >= 0 && newX < matrix.size() && newY >= 0 && newY < matrix[0].size()\n                && !visited[newX][newY] && abs(matrix[newX][newY] - matrix[x][y]) <= 1) { // 判断是否越界、是否访问过、是否符合条件\n            range += dfs(matrix, visited, newX, newY); // 更新活动范围\n        }\n    }\n    return range; // 返回活动范围\n}\n\nint main() {\n    // 输入处理\n    int m, n;\n    cin >> m >> n;\n    vector<vector<int>> matrix(m, vector<int>(n)); // 定义矩阵\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> matrix[i][j]; // 读入矩阵中的值\n        }\n    }\n\n    // 遍历每个点作为起点，求最大活动范围\n    int maxRange = 0; // 定义最大活动范围\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            vector<vector<bool>> visited(m, vector<bool>(n, false)); // 定义是否访问过\n            int range = dfs(matrix, visited, i, j); // 深度优先搜索\n            maxRange = max(maxRange, range); // 更新最大活动范围\n        }\n    }\n\n    cout << maxRange << endl; // 输出最大活动范围\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n// 定义四个方向，上下左右\nint directions[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n// 深度优先搜索函数\nint dfs(int **matrix, bool **visited, int x, int y, int m, int n) {\n    visited[x][y] = true; // 标记当前点已经访问过\n    int range = 1; // 定义活动范围\n    for (int i = 0; i < 4; i++) { // 遍历四个方向\n        int newX = x + directions[i][0]; // 新的横坐标\n        int newY = y + directions[i][1]; // 新的纵坐标\n        // 判断是否越界、是否访问过、是否符合条件\n        if (newX >= 0 && newX < m && newY >= 0 && newY < n &&\n            !visited[newX][newY] && abs(matrix[newX][newY] - matrix[x][y]) <= 1) {\n            range += dfs(matrix, visited, newX, newY, m, n); // 更新活动范围\n        }\n    }\n    return range; // 返回活动范围\n}\n\nint main() {\n    int m, n;\n    scanf(\"%d %d\", &m, &n); // 输入行数和列数\n\n    // 动态分配矩阵空间\n    int **matrix = (int **)malloc(m * sizeof(int *));\n    for (int i = 0; i < m; i++) {\n        matrix[i] = (int *)malloc(n * sizeof(int));\n    }\n\n    // 动态分配访问标记数组空间\n    bool **visited = (bool **)malloc(m * sizeof(bool *));\n    for (int i = 0; i < m; i++) {\n        visited[i] = (bool *)malloc(n * sizeof(bool));\n    }\n\n    // 读入矩阵中的值\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n\n    int maxRange = 0; // 定义最大活动范围\n    // 遍历每个点作为起点，求最大活动范围\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            // 初始化访问标记数组为未访问\n            for (int a = 0; a < m; a++) {\n                for (int b = 0; b < n; b++) {\n                    visited[a][b] = false;\n                }\n            }\n            int range = dfs(matrix, visited, i, j, m, n); // 深度优先搜索\n            if (range > maxRange) {\n                maxRange = range; // 更新最大活动范围\n            }\n        }\n    }\n\n    printf(\"%d\\n\", maxRange); // 输出最大活动范围\n\n    // 释放分配的内存\n    for (int i = 0; i < m; i++) {\n        free(matrix[i]);\n        free(visited[i]);\n    }\n    free(matrix);\n    free(visited);\n\n    return 0;\n}"
    }
  },
  {
    "id": "106",
    "title": "查找充电设备组合",
    "examType": "A",
    "score": 100,
    "description": "某个充电站，可提供 n 个充电设备，每个充电设备均有对应的输出功率。\n任意个充电设备组合的输出功率总和，均构成功率集合 P 的 1 个元素。\n功率集合 P 的最优元素，表示最接近充电站最大输出功率 p_max 的元素。",
    "inputDesc": "输入为 3 行：\n第 1 行为充电设备个数 n第 2 行为每个充电设备的输出功率第 3 行为充电站最大输出功率 p_max\n充电设备个数 n > 0最优元素必须小于或等于充电站最大输出功率 p_max",
    "outputDesc": "功率集合 P 的最优元素",
    "examples": [
      {
        "input": "20 20 60",
        "output": "",
        "explanation": "当充电设备输出功率50、20、20组合时，其输出功率总和为90，最接近充电站最大充电输出功率，因此最优元素为90。"
      },
      {
        "input": "40",
        "output": "",
        "explanation": "所有充电设备的输出功率组合，均大于充电站最大充电输出功率30，此时最优元素值为0。"
      },
      {
        "input": "3 10",
        "output": "",
        "explanation": "选择功率为2，3的设备构成功率集合，总功率为5，最接近最大功率9。不能选择设备10，因为已经超过了最大功率9。"
      },
      {
        "input": "2 3",
        "output": "",
        "explanation": "无"
      }
    ],
    "solution": "这是一道01背包的题目。题目要求任意个充电设备组合的输出功率总和，均构成功率集合P的1个元素。因此，我们可以将问题转化为求解最接近充电站最大输出功率p_max的元素。\n第3行中的充电站最大输出功率p_max可以看作是背包的最大承重； 第2行中每个充电设备的输出功率可以看作是不同物品的重量和价值，即重量=价值。\n第3行中的充电站最大输出功率p_max可以看作是背包的最大承重；\n第2行中每个充电设备的输出功率可以看作是不同物品的重量和价值，即重量=价值。\n因此，现在需要求出在背包承重下能够装入的最大价值。\n我们可以使用一个二维数组dp[i][j]表示前i个充电设备中，总功率不超过j时的最大功率。其中，i表示前i个充电设备，j表示总功率不超过j。\n对于每个充电设备，我们可以选择选或不选。如果当前充电设备的功率大于当前总功率j，那么不能选，我们就不选当前充电设备。如果当前充电设备的功率小于等于当前总功率j，那么我们可以选择选或不选当前充电设备。如果选当前充电设备，那么当前总功率就是当前充电设备的功率加上前i-1个充电设备中总功率不超过j-当前充电设备功率的最大值，即dp[i-1][j-power[i-1]]+power[i-1]；如果不选当前充电设备，那么当前总功率就是前i-1个充电设备中总功率不超过j的最大值，即dp[i-1][j]。因此，我们可以得到状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-power[i-1]]+power[i-1])。\n最终，dp[n][p_max]就是最大功率，即功率集合P的最优元素。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建Scanner对象\n        Scanner scanner = new Scanner(System.in);\n        // 读取输入的整数\n        int n = scanner.nextInt();\n\n        // 创建一个长度为n的整型数组\n        int[] power = new int[n];\n        // 循环读取n个整数，存入数组中\n        for (int i = 0; i < n; i++) {\n            power[i] = scanner.nextInt();\n        }\n\n        // 读取输入的整数\n        int p_max = scanner.nextInt();\n\n        // 创建一个n+1行，p_max+1列的二维整型数组\n        int[][] dp = new int[n + 1][p_max + 1];\n\n        // 循环计算dp数组的每个元素\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= p_max; j++) {\n                // 如果当前能量值大于当前承受的伤害值，则不受伤\n                if (power[i - 1] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else { // 否则需要扣除相应的能量值\n                    dp[i][j] = Math.max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]);\n                }\n            }\n        }\n\n        // 输出结果\n        System.out.println(dp[n][p_max]);\n    }\n}",
      "python": "n = int(input()) # 充电设备个数\npower = list(map(int, input().split())) # 每个充电设备的输出功率\np_max = int(input()) # 充电站最大输出功率\n\ndp = [[0] * (p_max + 1) for _ in range(n + 1)] # 初始化为0\n\nfor i in range(1, n + 1):\n    for j in range(1, p_max + 1):\n        if power[i - 1] > j: # 当前充电设备的功率大于当前总功率j，不能选\n            dp[i][j] = dp[i - 1][j] # 不选当前充电设备\n        else:\n            dp[i][j] = max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]) # 选或不选当前充电设备\n\nprint(dp[n][p_max]) # 输出最大功率",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet n, power, p_max;\nlet dp = [];\n\n// 监听输入流中的每一行数据\nrl.on('line', (line) => {\n  // 如果n还未赋值，则将输入的第一行数据赋值给n\n  if (!n) {\n    n = parseInt(line.trim());\n  } \n  // 如果power还未赋值，则将输入的第二行数据转化为数组赋值给power\n  else if (!power) {\n    power = line.trim().split(' ').map(Number);\n  } \n  // 如果p_max还未赋值，则将输入的第三行数据赋值给p_max，并进行动态规划\n  else if (!p_max) {\n    p_max = parseInt(line.trim());\n    // 初始化dp数组\n    dp = new Array(n + 1).fill().map(() => new Array(p_max + 1).fill(0));\n    // 进行动态规划\n    for (let i = 1; i <= n; i++) {\n      for (let j = 1; j <= p_max; j++) {\n        if (power[i - 1] > j) {\n          dp[i][j] = dp[i - 1][j];\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]);\n        }\n      }\n    }\n    // 输出结果\n    console.log(dp[n][p_max]);\n    // 关闭接口实例\n    rl.close();\n  }\n});",
      "cpp": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n; // 充电设备个数\n    cin >> n;\n\n    int power[n]; // 每个充电设备的输出功率\n    for (int i = 0; i < n; i++) {\n        cin >> power[i];\n    }\n\n    int p_max; // 充电站最大输出功率\n    cin >> p_max;\n\n    int dp[n + 1][p_max + 1] = {}; // 初始化为0\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= p_max; j++) {\n            if (power[i - 1] > j) { // 当前充电设备的功率大于当前总功率j，不能选\n                dp[i][j] = dp[i - 1][j]; // 不选当前充电设备\n            } else {\n                dp[i][j] = max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]); // 选或不选当前充电设备\n            }\n        }\n    }\n\n    cout << dp[n][p_max] << endl; // 输出最大功率\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h> // 用于memset函数\n\nint max(int a, int b) {\n    return (a > b) ? a : b; // 返回两个整数中的较大值\n}\n\nint main() {\n    int n; // 充电设备个数\n    scanf(\"%d\", &n); // 输入充电设备的个数\n\n    int power[n]; // 每个充电设备的输出功率\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &power[i]); // 输入每个充电设备的输出功率\n    }\n\n    int p_max; // 充电站最大输出功率\n    scanf(\"%d\", &p_max); // 输入充电站的最大输出功率\n\n    // 定义一个二维数组dp，初始化为0\n    int dp[n + 1][p_max + 1];\n    memset(dp, 0, sizeof(dp)); // 使用memset将数组dp初始化为0\n\n    // 动态规划计算最大输出功率\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= p_max; j++) {\n            if (power[i - 1] > j) { // 如果当前充电设备的功率大于当前总功率j，不能选择这个设备\n                dp[i][j] = dp[i - 1][j]; // 不选择当前充电设备，最大功率为上一个状态的值\n            } else {\n                // 选择当前充电设备与不选择当前充电设备的最大值\n                dp[i][j] = max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]);\n            }\n        }\n    }\n\n    // 输出结果，即充电站可以达到的最大输出功率\n    printf(\"%d\\n\", dp[n][p_max]);\n\n    return 0;\n}"
    }
  },
  {
    "id": "107",
    "title": "流浪地球",
    "examType": "A",
    "score": 100,
    "description": "流浪地球计划在赤道上均匀部署了N个转向发动机，按位置顺序编号为0~N-1。\n初始状态下所有的发动机都是未启动状态;发动机启动的方式分为”手动启动\"和”关联启动\"两种方式;如果在时刻1一个发动机被启动，下一个时刻2与之相邻的两个发动机就会被”关联启动”;如果准备启动某个发动机时，它已经被启动了，则什么都不用做;发动机0与发动机N-1是相邻的;\n地球联合政府准备挑选某些发动机在某些时刻进行“手动启动”。当然最终所有的发动机都会被启动。\n哪些发动机最晚被启动呢?",
    "inputDesc": "第一行两个数字N和E，中间有空格 N代表部署发动机的总个数，E代表计划手动启动的发动机总个数 1<N<=1000,1<=E<=1000,E<=N接下来共E行，每行都是两个数字T和P，中间有空格 T代表发动机的手动启动时刻，P代表此发动机的位置编号。 0<=T<=N.0<=P<N",
    "outputDesc": "",
    "examples": [
      {
        "input": "2\n 2\n 6",
        "output": "4",
        "explanation": "8个发动机，时刻0启动2和6号发动机"
      },
      {
        "input": "2\n 0\n 7",
        "output": "",
        "explanation": "8个发动机，时刻0手动启动0，时刻1手动启动7."
      }
    ],
    "solution": "初始状态：所有的发动机都是未启动状态。 启动方式： 手动启动：你可以在某个时刻手动启动指定位置的发动机。关联启动：如果一个发动机在时刻1被启动，那么它的相邻发动机（左右两个，位置编号上相邻）会在下一时刻（时刻2）被自动启动。 循环关系：发动机0和N-1是相邻的，这意味着整个发动机的排列是环形的。 发动机启动规则： 如果准备启动的发动机已经被启动，那么就不需要做任何操作。需要根据手动启动的时刻和位置，推算出所有发动机何时被启动，并确定哪些发动机在最后一个时刻被启动。\n初始状态：所有的发动机都是未启动状态。\n启动方式：\n手动启动：你可以在某个时刻手动启动指定位置的发动机。关联启动：如果一个发动机在时刻1被启动，那么它的相邻发动机（左右两个，位置编号上相邻）会在下一时刻（时刻2）被自动启动。\n循环关系：发动机0和N-1是相邻的，这意味着整个发动机的排列是环形的。\n发动机启动规则：\n如果准备启动的发动机已经被启动，那么就不需要做任何操作。需要根据手动启动的时刻和位置，推算出所有发动机何时被启动，并确定哪些发动机在最后一个时刻被启动。\n如图所示：\n在时刻0，发动机2和6被手动启动。在时刻1，发动机1、3、5、7将被关联启动。到了时刻2，发动机0和4将被关联启动。因此，发动机0和4是最后一批被启动的。\n",
    "codes": {
      "java": "import java.util.*;\n\npublic class EngineManager {\n    // 检查数组中是否有引擎处于未激活状态（即状态为 -1）\n    public static boolean hasInactiveEngines(int[] engineStatuses) {\n        return Arrays.stream(engineStatuses).anyMatch(status -> status == -1);\n    }\n \n    // 激活指定引擎的相邻引擎\n    public static void activateAdjacentEngines(int[] engineStatuses, int currentEngine, int activationTime, int totalEngines) {\n        int leftEngine = currentEngine == 0 ? totalEngines - 1 : (currentEngine - 1);  // 计算左边相邻引擎的索引\n        int rightEngine = currentEngine == totalEngines - 1 ? 0 : currentEngine + 1;  // 计算右边相邻引擎的索引\n        engineStatuses[leftEngine] = engineStatuses[leftEngine] == -1 ? activationTime : engineStatuses[leftEngine];  // 若左引擎未激活，则激活\n        engineStatuses[rightEngine] = engineStatuses[rightEngine] == -1 ? activationTime : engineStatuses[rightEngine];  // 若右引擎未激活，则激活\n    }\n \n    // 更新所有引擎的激活状态，直到所有引擎都被激活\n    public static void updateEngineStatuses(int[] engineStatuses, int startTime) {\n        boolean continueUpdate = true;\n        while (continueUpdate) {\n            for (int i = 0; i < engineStatuses.length; i++) {\n                if (engineStatuses[i] == startTime) {              \n                    activateAdjacentEngines(engineStatuses, i, startTime + 1, engineStatuses.length);  // 激活当前引擎的相邻引擎\n                }\n            }\n            startTime++;  // 增加时间步长，检查下一个时间点\n            continueUpdate = hasInactiveEngines(engineStatuses);  // 检查是否还有未激活的引擎\n        }\n        int lastActivationTime = Arrays.stream(engineStatuses).max().getAsInt();  // 获取最后一个被激活的时间\n        int countActiveEngines = 0;\n        StringBuilder enginesReport = new StringBuilder();\n        for (int i = 0; i < engineStatuses.length; i++) {\n            if(lastActivationTime == engineStatuses[i]) {\n                enginesReport.append(i + \" \");\n                countActiveEngines++;\n            }\n        }\n        System.out.println(countActiveEngines);  // 输出最后激活时间的引擎数量\n        System.out.println(enginesReport.toString().trim());  // 输出这些引擎的编号\n    }\n \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String[] inputs = scanner.nextLine().split(\" \");\n            int numberOfEngines = Integer.parseInt(inputs[0]);  // 引擎总数\n            int numberOfEntries = Integer.parseInt(inputs[1]);  // 输入的数据条数\n\n            int[] engineStatuses = new int[numberOfEngines];\n            Arrays.fill(engineStatuses, -1);  // 初始状态设置所有引擎为未激活\n            int earliestActivation = Integer.MAX_VALUE;\n\n            for (int i = 0; i < numberOfEntries; i++) {\n                String[] timeIndex = scanner.nextLine().split(\" \");\n                int activationTime = Integer.parseInt(timeIndex[0]);  // 激活时间\n                int engineIndex = Integer.parseInt(timeIndex[1]);  // 引擎索引\n                engineStatuses[engineIndex] = activationTime;  // 设置激活时间\n                earliestActivation = Math.min(earliestActivation, activationTime);  // 记录最早的激活时间\n            }\n            updateEngineStatuses(engineStatuses, earliestActivation);  // 根据最早的激活时间开始更新状态\n        }\n    }\n}",
      "python": "def has_inactive_engines(engine_statuses):\n    \"\"\"检查列表中是否有引擎处于未激活状态（即状态为 -1）。\n    返回值为布尔类型，True表示存在未激活的引擎，False则表示所有引擎均已激活。\"\"\"\n    return -1 in engine_statuses\n\ndef activate_adjacent_engines(engine_statuses, current_engine, activation_time, total_engines):\n    \"\"\"激活指定引擎的相邻引擎。计算并更新左右两边的引擎状态。\n    - current_engine: 当前引擎的索引。\n    - activation_time: 当前引擎的激活时间。\n    - total_engines: 引擎总数，用于计算边界条件。\"\"\"\n    left_engine = total_engines - 1 if current_engine == 0 else current_engine - 1\n    right_engine = 0 if current_engine == total_engines - 1 else current_engine + 1\n    if engine_statuses[left_engine] == -1:\n        engine_statuses[left_engine] = activation_time\n    if engine_statuses[right_engine] == -1:\n        engine_statuses[right_engine] = activation_time\n\ndef update_engine_statuses(engine_statuses, start_time):\n    \"\"\"更新所有引擎的激活状态，直到所有引擎都被激活。\n    进行循环检查，若当前时间点有引擎被激活，则激活其相邻引擎，并递增时间步长。\"\"\"\n    continue_update = True\n    while continue_update:\n        for i, status in enumerate(engine_statuses):\n            if status == start_time:        \n                activate_adjacent_engines(engine_statuses, i, start_time + 1, len(engine_statuses))\n        start_time += 1\n        continue_update = has_inactive_engines(engine_statuses)\n    last_activation_time = max(engine_statuses)\n    count_active_engines = sum(status == last_activation_time for status in engine_statuses)\n    engines_report = ' '.join(str(i) for i, status in enumerate(engine_statuses) if status == last_activation_time)\n    print(count_active_engines)  # 打印在最后一个激活时间被激活的引擎数量\n    print(engines_report.strip())  # 打印这些引擎的索引\n\n# 主循环，持续接受输入直到遇到文件结束符（EOF）\nwhile True:\n    try:\n        inputs = input().split()\n        number_of_engines = int(inputs[0])  # 读取引擎总数\n        number_of_entries = int(inputs[1])  # 读取条目数量\n\n        engine_statuses = [-1] * number_of_engines  # 初始化引擎状态数组，初始值为-1表示未激活\n        earliest_activation = float('inf')  # 设置最早激活时间为无穷大\n\n        for _ in range(number_of_entries):\n            time_index = input().split()\n            activation_time = int(time_index[0])\n            engine_index = int(time_index[1])\n            engine_statuses[engine_index] = activation_time  # 更新指定引擎的激活时间\n            earliest_activation = min(earliest_activation, activation_time)  # 更新最早激活时间\n\n        update_engine_statuses(engine_statuses, earliest_activation)  # 根据最早激活时间更新引擎状态\n    except EOFError:\n        break  # 结束循环，等待输入结束",
      "javascript": "// 引入 readline 模块并创建接口用于读取来自标准输入（stdin）的数据\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\n\n// 创建异步迭代器，用于按行读取输入\nvar iter = rl[Symbol.asyncIterator]();\n\n// 定义一个异步函数用于读取一行输入\nconst readline = async () => (await iter.next()).value;\n\n// 立即执行的异步函数\nvoid (async function () {\n    // 读取一行输入并按空格分割，获取输入的参数\n    const inputs = (await readline()).split(\" \");\n    const numberOfEngines = parseInt(inputs[0], 10);  // 引擎总数\n    const numberOfEntries = parseInt(inputs[1], 10);  // 输入的数据条数\n\n    // 创建一个数组，初始值为 -1，表示所有引擎初始时都未激活\n    const engineStatuses = new Array(numberOfEngines).fill(-1);\n    let earliestActivation = Infinity;  // 设置一个变量用于记录最早的激活时间\n\n    // 遍历每一个输入条目\n    for (let i = 0; i < numberOfEntries; i++) {\n        const timeIndex = (await readline()).split(\" \");\n        const activationTime = parseInt(timeIndex[0], 10);  // 读取激活时间\n        const engineIndex = parseInt(timeIndex[1], 10);  // 读取引擎索引\n        engineStatuses[engineIndex] = activationTime;  // 设置引擎的激活时间\n        earliestActivation = Math.min(earliestActivation, activationTime);  // 更新最早的激活时间\n    }\n\n    // 根据最早的激活时间开始更新所有引擎的状态\n    await updateEngineStatuses(engineStatuses, earliestActivation);\n    process.exit(0);  // 执行完成后退出程序\n})();\n\n// 检查是否有未激活的引擎\nfunction hasInactiveEngines(engineStatuses) {\n    return engineStatuses.some(status => status === -1);  // 使用 some 方法检查数组中是否存在未激活的引擎\n}\n\n// 激活指定引擎的相邻引擎\nfunction activateAdjacentEngines(engineStatuses, currentEngine, activationTime, totalEngines) {\n    const leftEngine = currentEngine === 0 ? totalEngines - 1 : currentEngine - 1;  // 计算左侧相邻引擎的索引\n    const rightEngine = currentEngine === totalEngines - 1 ? 0 : currentEngine + 1;  // 计算右侧相邻引擎的索引\n    // 如果相邻引擎未激活，则设置其激活时间\n    if (engineStatuses[leftEngine] === -1) {\n        engineStatuses[leftEngine] = activationTime;\n    }\n    if (engineStatuses[rightEngine] === -1) {\n        engineStatuses[rightEngine] = activationTime;\n    }\n}\n\n// 循环更新所有引擎的状态，直到没有未激活的引擎\nasync function updateEngineStatuses(engineStatuses, startTime) {\n    let continueUpdate = true;\n    while (continueUpdate) {\n        for (let i = 0; i < engineStatuses.length; i++) {\n            if (engineStatuses[i] === startTime) {\n                activateAdjacentEngines(engineStatuses, i, startTime + 1, engineStatuses.length);\n            }\n        }\n        startTime++;  // 增加时间步，继续检查和更新状态\n        continueUpdate = hasInactiveEngines(engineStatuses);  // 检查是否还有未激活的引擎\n    }\n    const lastActivationTime = Math.max(...engineStatuses);  // 计算最后一个被激活的时间\n    const countActiveEngines = engineStatuses.filter(status => status === lastActivationTime).length;  // 计算在最后一次激活时间激活的引擎数量\n    const enginesReport = engineStatuses.map((status, index) => status === lastActivationTime ? index : '').filter(String).join(' ');  // 创建引擎索引报告\n\n    console.log(countActiveEngines);  // 输出激活的引擎数量\n    console.log(enginesReport.trim());  // 输出激活的引擎索引\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <limits>\nusing namespace std;\n\n// 检查 vector 中是否有引擎处于未激活状态（即状态为 -1）\nbool hasInactiveEngines(const vector<int>& engineStatuses) {\n    return find(engineStatuses.begin(), engineStatuses.end(), -1) != engineStatuses.end();\n}\n\n// 激活指定引擎的相邻引擎\nvoid activateAdjacentEngines(vector<int>& engineStatuses, int currentEngine, int activationTime, int totalEngines) {\n    int leftEngine = currentEngine == 0 ? totalEngines - 1 : currentEngine - 1; // 计算左边相邻引擎的索引\n    int rightEngine = currentEngine == totalEngines - 1 ? 0 : currentEngine + 1; // 计算右边相邻引擎的索引\n    if (engineStatuses[leftEngine] == -1) {\n        engineStatuses[leftEngine] = activationTime; // 若左引擎未激活，则激活\n    }\n    if (engineStatuses[rightEngine] == -1) {\n        engineStatuses[rightEngine] = activationTime; // 若右引擎未激活，则激活\n    }\n}\n\n// 更新所有引擎的激活状态，直到所有引擎都被激活\nvoid updateEngineStatuses(vector<int>& engineStatuses, int startTime) {\n    bool continueUpdate = true;\n    while (continueUpdate) {\n        for (size_t i = 0; i < engineStatuses.size(); i++) {\n            if (engineStatuses[i] == startTime) {\n                activateAdjacentEngines(engineStatuses, i, startTime + 1, engineStatuses.size()); // 激活当前引擎的相邻引擎\n            }\n        }\n        startTime++; // 增加时间步长，检查下一个时间点\n        continueUpdate = hasInactiveEngines(engineStatuses); // 检查是否还有未激活的引擎\n    }\n    int lastActivationTime = *max_element(engineStatuses.begin(), engineStatuses.end()); // 获取最后一个被激活的时间\n    int countActiveEngines = count(engineStatuses.begin(), engineStatuses.end(), lastActivationTime); // 计算最后激活时间的引擎数量\n    cout << countActiveEngines << endl; // 输出最后激活时间的引擎数量\n    for (size_t i = 0; i < engineStatuses.size(); i++) {\n        if (engineStatuses[i] == lastActivationTime) {\n            cout << i << \" \"; // 输出最后激活时间的引擎编号\n        }\n    }\n    cout << endl;\n}\n\nint main() {\n    string input;\n    while (getline(cin, input)) {\n        stringstream ss(input);\n        int numberOfEngines, numberOfEntries;\n        ss >> numberOfEngines >> numberOfEntries;\n\n        vector<int> engineStatuses(numberOfEngines, -1); // 初始状态设置所有引擎为未激活\n        int earliestActivation = numeric_limits<int>::max(); // 设置最早的激活时间为最大值\n\n        for (int i = 0; i < numberOfEntries; i++) {\n            getline(cin, input);\n            stringstream ss2(input);\n            int activationTime, engineIndex;\n            ss2 >> activationTime >> engineIndex;\n            engineStatuses[engineIndex] = activationTime; // 设置激活时间\n            earliestActivation = min(earliestActivation, activationTime); // 更新最早的激活时间\n        }\n        updateEngineStatuses(engineStatuses, earliestActivation); // 根据最早的激活时间开始更新状态\n    }\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// 检查数组中是否有引擎处于未激活状态（即状态为 -1）\nint hasInactiveEngines(int *engineStatuses, int totalEngines) {\n    for (int i = 0; i < totalEngines; i++) {\n        if (engineStatuses[i] == -1) {\n            return 1;  // 发现未激活的引擎，返回1表示\"真\"\n        }\n    }\n    return 0;  // 所有引擎都已激活，返回0表示\"假\"\n}\n\n// 激活指定引擎的相邻引擎\nvoid activateAdjacentEngines(int *engineStatuses, int currentEngine, int activationTime, int totalEngines) {\n    int leftEngine = currentEngine == 0 ? totalEngines - 1 : currentEngine - 1;  // 计算左边相邻引擎的索引\n    int rightEngine = currentEngine == totalEngines - 1 ? 0 : currentEngine + 1;  // 计算右边相邻引擎的索引\n    if (engineStatuses[leftEngine] == -1) {\n        engineStatuses[leftEngine] = activationTime;  // 若左引擎未激活，则激活\n    }\n    if (engineStatuses[rightEngine] == -1) {\n        engineStatuses[rightEngine] = activationTime;  // 若右引擎未激活，则激活\n    }\n}\n\n// 更新所有引擎的激活状态，直到所有引擎都被激活\nvoid updateEngineStatuses(int *engineStatuses, int startTime, int totalEngines) {\n    int continueUpdate = 1;\n    while (continueUpdate) {\n        for (int i = 0; i < totalEngines; i++) {\n            if (engineStatuses[i] == startTime) {\n                activateAdjacentEngines(engineStatuses, i, startTime + 1, totalEngines);  // 激活当前引擎的相邻引擎\n            }\n        }\n        startTime++;  // 增加时间步长，检查下一个时间点\n        continueUpdate = hasInactiveEngines(engineStatuses, totalEngines);  // 检查是否还有未激活的引擎\n    }\n    int lastActivationTime = -1;\n    int countActiveEngines = 0;\n    for (int i = 0; i < totalEngines; i++) {\n        if (engineStatuses[i] > lastActivationTime) {\n            lastActivationTime = engineStatuses[i];  // 更新最后一个被激活的时间\n        }\n    }\n    for (int i = 0; i < totalEngines; i++) {\n        if (engineStatuses[i] == lastActivationTime) {\n            countActiveEngines++;  // 计算最后激活时间的引擎数量\n        }\n    }\n    printf(\"%d\\n\", countActiveEngines);  // 输出最后激活时间的引擎数量\n    for (int i = 0; i < totalEngines; i++) {\n        if (engineStatuses[i] == lastActivationTime) {\n            printf(\"%d \", i);  // 输出这些引擎的编号\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    char line[1024];\n    while (fgets(line, sizeof(line), stdin)) {  // 从标准输入读取一行\n        int numberOfEngines, numberOfEntries;\n        sscanf(line, \"%d %d\", &numberOfEngines, &numberOfEntries);  // 解析引擎总数和输入的数据条数\n\n        int *engineStatuses = (int *)malloc(numberOfEngines * sizeof(int));\n        memset(engineStatuses, -1, numberOfEngines * sizeof(int));  // 初始状态设置所有引擎为未激活\n        int earliestActivation = INT_MAX;\n\n        for (int i = 0; i < numberOfEntries; i++) {\n            fgets(line, sizeof(line), stdin);  // 读取每个激活信息\n            int activationTime, engineIndex;\n            sscanf(line, \"%d %d\", &activationTime, &engineIndex);  // 解析激活时间和引擎索引\n            engineStatuses[engineIndex] = activationTime;  // 设置激活时间\n            if (activationTime < earliestActivation) {\n                earliestActivation = activationTime;  // 更新最早的激活时间\n            }\n        }\n        updateEngineStatuses(engineStatuses, earliestActivation, numberOfEngines);  // 根据最早的激活时间开始更新状态\n        free(engineStatuses);  // 释放动态分配的内存\n    }\n    return 0;\n}"
    }
  },
  {
    "id": "108",
    "title": "爱吃蟠桃的孙悟空",
    "examType": "A",
    "score": 100,
    "description": "孙悟空爱吃蟠桃，有一天趁着蟠桃园守卫不在来偷吃。已知蟠桃园有 N 棵桃树，每颗树上都有桃子，守卫将在 H 小时后回来。\n孙悟空可以决定他吃蟠桃的速度K（个/小时），每个小时选一颗桃树，并从树上吃掉 K 个，如果树上的桃子少于 K 个，则全部吃掉，并且这一小时剩余的时间里不再吃桃。\n孙悟空喜欢慢慢吃，但又想在守卫回来前吃完桃子。\n请返回孙悟空可以在 H 小时内吃掉所有桃子的最小速度 K（K为整数）。如果以任何速度都吃不完所有桃子，则返回0。",
    "inputDesc": "一行输入为 N 个数字，N 表示桃树的数量，这 N 个数字表示每颗桃树上蟠桃的数量。\n第二行输入为一个数字，表示守卫离开的时间 H。\n其中数字通过空格分割，N、H为正整数，每颗树上都有蟠桃，且 0 < N < 10000，0 < H < 10000。",
    "outputDesc": "吃掉所有蟠桃的最小速度 K，无解或输入异常时输出 0。",
    "examples": [
      {
        "input": "3 4 5",
        "output": "",
        "explanation": ""
      },
      {
        "input": "3 4 5",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "本题22年、23年、24年都考过。\n参考：875. 爱吃香蕉的珂珂 - 力扣（LeetCode）",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个Scanner对象用于读取输入\n        Scanner cin = new Scanner(System.in);\n        // 读取一行输入并转换为整数数组，代表每棵桃树上的桃子数量\n        int[] peachCounts = Arrays.stream(cin.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 读取下一行输入，转换为整数，代表可用的小时数\n        int h = Integer.parseInt(cin.nextLine());\n        // 获取桃树的数量\n        int n = peachCounts.length;\n \n        // 输入验证：如果桃树数量为0，或小时数不合法，或桃树数量大于小时数，则输出0并返回\n        if (n == 0 || h <= 0 || n >= 10000 || h >= 10000 || n > h) {\n            System.out.println(0);\n            return;\n        }\n\n        // 初始化二分查找的左右边界\n        int left = 1, right = (int)1e9; // 假设最大的吃桃速度不会超过1e9\n        // 当左边界小于右边界时，执行二分查找\n        while (left < right) {\n            // 计算中间值\n            int mid = left + (right - left) / 2;\n            // 如果以mid的速度可以在h小时内吃完桃子，则尝试更小的速度\n            if (canFinish(peachCounts, h, mid)) {\n                right = mid;\n            } else {\n                // 否则尝试更大的速度\n                left = mid + 1;\n            }\n        }\n\n        // 输出最小吃桃速度，此时left是满足条件的最小速度\n        System.out.println(left);\n    }\n\n    // 定义一个方法，判断以速度k是否能在h小时内吃完所有桃子\n    static boolean canFinish(int[] p, int h, int k) {\n        // 初始化所需的总小时数\n        int ans = 0;\n        // 遍历每棵桃树\n        for (int x : p) {\n            // 计算吃完这棵桃树上桃子所需的小时数，向上取整\n            ans += Math.ceil(x * 1.0 / k);\n        }\n        // 如果所需总小时数小于等于h，则返回true，表示可以完成\n        return ans <= h;\n    }\n}",
      "python": "import math\n\n# 判断以速度k是否能在h小时内吃完所有桃子\ndef can_finish(p, h, k):\n    ans = 0\n    for x in p:\n        ans += math.ceil(x / k)\n    return ans <= h\n\n# 读取输入\npeach_counts = list(map(int, input().split()))\nh = int(input())\n\n# 输入验证\nn = len(peach_counts)\nif n == 0 or h <= 0 or n >= 10000 or h >= 10000 or n > h:\n    print(0)\n    exit(0)\n\n# 二分查找最小吃桃速度\nleft, right = 1, int(1e9)\nwhile left < right:\n    mid = (left + right) // 2\n    if can_finish(peach_counts, h, mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# 输出最小吃桃速度\nprint(left)",
      "javascript": "// 读取标准输入\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 判断以速度k是否能在h小时内吃完所有桃子\nfunction canFinish(p, h, k) {\n    let ans = 0;\n    for (let x of p) {\n        ans += Math.ceil(x / k);\n    }\n    return ans <= h;\n}\n\n// 处理输入\nrl.on('line', (input) => {\n    if (!this.peachCounts) {\n        // 第一行输入，转换为桃子数量数组\n        this.peachCounts = input.split(' ').map(Number);\n        return;\n    }\n    // 第二行输入，转换为小时数\n    const h = Number(input);\n    rl.close(); // 不再读取输入\n\n    // 输入验证\n    const n = this.peachCounts.length;\n    if (n === 0 || h <= 0 || n >= 10000 || h >= 10000 || n > h) {\n        console.log(0);\n        return;\n    }\n\n    // 二分查找最小吃桃速度\n    let left = 1, right = 1e9;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (canFinish(this.peachCounts, h, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    // 输出最小吃桃速度\n    console.log(left);\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\n// 判断以速度k是否能在h小时内吃完所有桃子\nbool canFinish(vector<int>& p, int h, int k) {\n    long long ans = 0; // 使用 long long 防止溢出\n    for (int x : p) {\n        ans += ceil(x * 1.0 / k); // 向上取整\n    }\n    return ans <= h;\n}\n\nint main() {\n    // 读取输入\n    string line;\n    getline(cin, line);\n    istringstream iss(line);\n    vector<int> peachCounts;\n    int x;\n    while (iss >> x) {\n        peachCounts.push_back(x);\n    }\n    int h;\n    cin >> h;\n\n    // 输入验证\n    int n = peachCounts.size();\n    if (n == 0 || h <= 0 || n >= 10000 || h >= 10000 || n > h) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    // 二分查找最小吃桃速度\n    int left = 1, right = 1e9; // 假设最大的吃桃速度不会超过1e9\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (canFinish(peachCounts, h, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    // 输出最小吃桃速度\n    cout << left << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// 判断以速度k是否能在h小时内吃完所有桃子\nint can_finish(int* p, int n, int h, int k) {\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans += (int)ceil((double)p[i] / k);\n    }\n    return ans <= h;\n}\n\nint main() {\n \n    char input[10000];\n    fgets(input, sizeof(input), stdin);\n\n    // 将输入分割并存入数组\n    int peach_counts[10000];  \n    int n = 0;\n\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        peach_counts[n++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n\n    int h;\n    scanf(\"%d\", &h);\n\n    // 输入验证\n    if (n == 0 || h <= 0 || n >= 10000 || h >= 10000 || n > h) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    // 二分查找最小吃桃速度\n    int left = 1, right = (int)1e9;\n    while (left < right) {\n        int mid = (left + right) / 2;\n        if (can_finish(peach_counts, n, h, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    // 输出最小吃桃速度\n    printf(\"%d\\n\", left);\n\n    return 0;\n}"
    }
  },
  {
    "id": "109",
    "title": "猜字谜",
    "examType": "A",
    "score": 100,
    "description": "小王设计了一个简单的猜字谜游戏，游戏的谜面是一个错误的单词，比如nesw，玩家需要猜出谜底库中正确的单词。猜中的要求如下： 对于某个谜面和谜底单词，满足下面任一条件都表示猜中：\n变换顺序以后一样的，比如通过变换w和e的顺序，“nwes”跟“news”是可以完全对应的；字母去重以后是一样的，比如“woood”和“wood”是一样的，它们去重后都是“wod”\n请你写一个程序帮忙在谜底库中找到正确的谜底。谜面是多个单词，都需要找到对应的谜底，如果找不到的话，返回”not found”",
    "inputDesc": "谜面单词列表，以“,”分隔谜底库单词列表，以\",\"分隔",
    "outputDesc": "",
    "examples": [
      {
        "input": "bdni,wooood\nbind,wrong,wood",
        "output": "bind,wood",
        "explanation": ""
      }
    ],
    "solution": "猜中的情况：\n变换顺序以后一样的，比如通过变换w和e的顺序，“nwes”跟“news”是可以完全对应的；字母去重以后是一样的，比如“woood”和“wood”是一样的，它们去重后都是“wod”以上两个同时满足\n直接对谜底和谜面单词进行去重+字典序排序，然后对比即可。\n两个字符串变为数组后进行排序，如果排序后的数组一致，则表示变序后一致。\n去重后是否一致:将两个字符串去重后加入列表中，如果两个列表一致，则表示去重后一致。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // 读取谜面单词列表，以逗号分隔\n        String[] puzzleWords = scanner.nextLine().split(\",\");\n        // 读取谜底库单词列表，以逗号分隔\n        String[] answerBank = scanner.nextLine().split(\",\");\n        // 创建一个列表，用于存储匹配到的正确单词\n        List<String> matchedAnswers = new ArrayList<>();\n\n        // 遍历谜面单词列表\n        for (String puzzleWord : puzzleWords) {\n            // 去除谜面单词中的重复字母，TreeSet自动升序排序\n            String puzzleWordNoDuplicate = String.join(\"\", new TreeSet<>(Arrays.asList(puzzleWord.split(\"\"))));\n            // 标记是否匹配到对应的谜底\n            boolean isFound = false;\n\n            // 遍历谜底库单词列表\n            for (String answer : answerBank) {\n                // 去除谜底单词中的重复字母，TreeSet自动升序排序\n                String answerNoDuplicate = String.join(\"\", new TreeSet<>(Arrays.asList(answer.split(\"\"))));\n\n                // 如果去重后的谜面单词与谜底单词相同，则将谜底单词添加到结果列表中，并将 isFound 标记为 true\n                if (puzzleWordNoDuplicate.equals(answerNoDuplicate)) {\n                    matchedAnswers.add(answer);\n                    isFound = true;\n                }\n            }\n\n            // 如果没有找到匹配的单词，则将 \"not found\" 添加到结果列表中\n            if (!isFound) {\n                matchedAnswers.add(\"not found\");\n            }\n        }\n\n        // 输出匹配到的正确单词列表，以逗号分隔\n        System.out.println(String.join(\",\", matchedAnswers));\n    }\n}",
      "python": "puzzle_words = input().split(\",\")\nword_bank = input().split(\",\")\n\n# 用于存储匹配到的正确单词列表\nmatched_words = []\n\n# 遍历每个谜面\nfor puzzle_word in puzzle_words:\n    # 将谜面中的字符去重并排序\n    sorted_puzzle_word = \"\".join(sorted(set(puzzle_word)))\n    # 标记是否找到匹配的谜底\n    found = False\n\n    # 遍历每个谜底\n    for word in word_bank:\n        # 将谜底中的字符去重并排序\n        sorted_word = \"\".join(sorted(set(word)))\n\n        # 判断谜底是否与谜面匹配\n        if sorted_puzzle_word == sorted_word:\n            # 将匹配到的谜底添加到结果列表中\n            matched_words.append(word)\n            # 标记为已找到匹配的谜底\n            found = True\n\n    # 如果没有找到匹配的谜底，将\"not found\"添加到结果列表中\n    if not found:\n        matched_words.append(\"not found\")\n\n# 输出匹配到的正确单词列表，以\",\"分隔\nprint(\",\".join(matched_words))",
      "javascript": "// 导入 readline 模块，用于从标准输入读取数据\nconst readline = require('readline');\n\n// 创建 readline 接口实例，用于处理输入输出\nconst rl = readline.createInterface({\n  input: process.stdin, // 指定标准输入流\n  output: process.stdout // 指定标准输出流\n});\n\n// 监听第一个输入行，即谜面单词列表\nrl.on('line', (puzzleInput) => {\n  // 监听第二个输入行，即谜底库单词列表\n  rl.on('line', (answerBankInput) => {\n    // 将谜面单词列表按照逗号分隔成数组\n    const puzzles = puzzleInput.split(',');\n    // 将谜底库单词列表按照逗号分隔成数组\n    const answerBank = answerBankInput.split(',');\n    // 用于存储匹配到的正确单词\n    const matchedAnswers = [];\n\n    // 遍历每一个谜面单词\n    for (let puzzleIndex = 0; puzzleIndex < puzzles.length; puzzleIndex++) {\n      // 对谜面单词进行排序并去重\n      const sortedPuzzle = puzzles[puzzleIndex].split('') // 将单词分割成字符数组\n        .sort() // 对字符数组进行排序\n        .filter((char, index, array) => {\n          // 通过过滤函数去重，保留第一次出现的字符\n          return index === 0 || char !== array[index - 1];\n        })\n        .join(''); // 将处理后的字符数组重新组合成字符串\n\n      let found = false; // 用于标记当前谜面是否找到匹配的正确单词\n\n      // 遍历谜底库中的每一个单词\n      for (let answerIndex = 0; answerIndex < answerBank.length; answerIndex++) {\n        // 对谜底单词进行排序并去重，方法同上\n        const sortedAnswer = answerBank[answerIndex].split('')\n          .sort()\n          .filter((char, index, array) => {\n            return index === 0 || char !== array[index - 1];\n          })\n          .join('');\n\n        // 如果处理后的谜面单词和谜底单词相同，则表示匹配成功\n        if (sortedPuzzle === sortedAnswer) {\n          // 将匹配到的谜底单词加入结果数组\n          matchedAnswers.push(answerBank[answerIndex]);\n          found = true; // 标记为已找到匹配\n          break; // 一旦找到匹配的正确单词，跳出当前循环\n        }\n      }\n\n      // 如果没有找到匹配的正确单词，加入\"not found\"标记\n      if (!found) {\n        matchedAnswers.push(\"not found\");\n      }\n    }\n\n    // 将匹配到的正确单词以逗号分隔的形式输出\n    console.log(matchedAnswers.join(', '));\n    rl.close(); // 关闭 readline 接口\n  });\n});",
      "cpp": "#include <iostream>\n#include <algorithm>  \n#include <vector>  \n#include <string> \n\nusing namespace std;\n\nint main() {\n    string input_puzzles, input_solutions;\n    \n \n    getline(cin, input_puzzles); // 读取第一行谜面单词列表\n    getline(cin, input_solutions); // 读取第二行谜底单词列表\n\n    vector<string> puzzles, solutions;\n    string temp = \"\";\n    \n    // 将输入的谜面单词列表以“,”分隔并存储在puzzles向量中\n    for (char c : input_puzzles) {\n        if (c == ',') {\n            puzzles.push_back(temp); // 遇到逗号，将temp中的单词加入puzzles\n            temp = \"\"; // 重置temp\n        } else {\n            temp += c; // 将字符加入temp\n        }\n    }\n    puzzles.push_back(temp); // 将最后一个单词加入puzzles\n\n    temp = \"\";\n    // 将输入的谜底库单词列表以“,”分隔并存储在solutions向量中\n    for (char c : input_solutions) {\n        if (c == ',') {\n            solutions.push_back(temp); // 遇到逗号，将temp中的单词加入solutions\n            temp = \"\"; // 重置temp\n        } else {\n            temp += c; // 将字符加入temp\n        }\n    }\n    solutions.push_back(temp); // 将最后一个单词加入solutions\n\n    vector<string> matched_solutions; // 用于存储匹配到的谜底单词\n    // 遍历每个谜面单词\n    for (string puzzle : puzzles) {\n        string sorted_puzzle = puzzle;\n        sort(sorted_puzzle.begin(), sorted_puzzle.end()); // 对谜面单词排序\n        sorted_puzzle.erase(unique(sorted_puzzle.begin(), sorted_puzzle.end()), sorted_puzzle.end()); // 去重\n\n        bool found = false; // 标记是否找到匹配的谜底单词\n\n        // 遍历谜底库中的每个单词\n        for (string solution : solutions) {\n            string sorted_solution = solution;\n            sort(sorted_solution.begin(), sorted_solution.end()); // 对谜底单词排序\n            sorted_solution.erase(unique(sorted_solution.begin(), sorted_solution.end()), sorted_solution.end()); // 去重\n\n            if (sorted_puzzle == sorted_solution) { // 如果排序去重后的结果相同\n                matched_solutions.push_back(solution); // 将该谜底单词加入匹配结果中\n                found = true; // 标记为找到匹配\n                break; // 跳出当前循环\n            }\n        }\n\n        if (!found) { // 如果未找到匹配的谜底单词\n            matched_solutions.push_back(\"not found\"); // 加入\"not found\"\n        }\n    }\n\n    // 输出第一个匹配结果\n    cout << matched_solutions[0];\n    // 输出剩余的匹配结果，中间以逗号分隔\n    for (int i = 1; i < matched_solutions.size(); i++) {\n        cout << \",\" << matched_solutions[i];\n    }\n\n    return 0; // 程序结束\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// 自定义比较函数，用于qsort中的字符排序\nint compare(const void *a, const void *b) {\n    return *(char *)a - *(char *)b;\n}\n\n// 去重函数，将字符串中的重复字符移除\nvoid remove_duplicates(char *str) {\n    int length = strlen(str);\n    if (length < 2) return;\n\n    int j = 0;\n    for (int i = 1; i < length; i++) {\n        if (str[i] != str[j]) {\n            j++;\n            str[j] = str[i];\n        }\n    }\n    str[j + 1] = '\\0';\n}\n\nint main() {\n    char input_puzzles[1000], input_solutions[1000];\n\n    // 从标准输入读取谜面和谜底列表\n    fgets(input_puzzles, sizeof(input_puzzles), stdin); // 读取第一行谜面单词列表\n    fgets(input_solutions, sizeof(input_solutions), stdin); // 读取第二行谜底单词列表\n\n    // 移除字符串末尾的换行符\n    input_puzzles[strcspn(input_puzzles, \"\\n\")] = '\\0';\n    input_solutions[strcspn(input_solutions, \"\\n\")] = '\\0';\n\n    char *puzzles[1000];\n    char *solutions[1000];\n    int puzzle_count = 0, solution_count = 0;\n\n    // 将谜面单词列表以“,”分隔并存储在puzzles数组中\n    char *token = strtok(input_puzzles, \",\");\n    while (token != NULL) {\n        puzzles[puzzle_count++] = strdup(token); // 将分隔出的单词到puzzles中\n        token = strtok(NULL, \",\");\n    }\n\n    // 将谜底库单词列表以“,”分隔并存储在solutions数组中\n    token = strtok(input_solutions, \",\");\n    while (token != NULL) {\n        solutions[solution_count++] = strdup(token); // 将分隔出的单词到solutions中\n        token = strtok(NULL, \",\");\n    }\n\n    char *matched_solutions[1000];\n    int match_count = 0;\n\n    // 遍历每个谜面单词\n    for (int i = 0; i < puzzle_count; i++) {\n        char sorted_puzzle[1000];\n        strcpy(sorted_puzzle, puzzles[i]);\n        qsort(sorted_puzzle, strlen(sorted_puzzle), sizeof(char), compare); // 对谜面单词排序\n        remove_duplicates(sorted_puzzle); // 去重\n\n        int found = 0; // 标记是否找到匹配的谜底单词\n\n        // 遍历谜底库中的每个单词\n        for (int j = 0; j < solution_count; j++) {\n            char sorted_solution[1000];\n            strcpy(sorted_solution, solutions[j]);\n            qsort(sorted_solution, strlen(sorted_solution), sizeof(char), compare); // 对谜底单词排序\n            remove_duplicates(sorted_solution); // 去重\n\n            if (strcmp(sorted_puzzle, sorted_solution) == 0) { // 如果排序去重后的结果相同\n                matched_solutions[match_count++] = solutions[j]; // 将该谜底单词加入匹配结果中\n                found = 1; // 标记为找到匹配\n                break; // 跳出当前循环\n            }\n        }\n\n        if (!found) { // 如果未找到匹配的谜底单词\n            matched_solutions[match_count++] = \"not found\"; // 加入\"not found\"\n        }\n    }\n\n    // 输出第一个匹配结果\n    printf(\"%s\", matched_solutions[0]);\n    // 输出剩余的匹配结果，中间以逗号分隔\n    for (int i = 1; i < match_count; i++) {\n        printf(\",%s\", matched_solutions[i]);\n    }\n\n    // 释放动态分配的内存\n    for (int i = 0; i < puzzle_count; i++) {\n        free(puzzles[i]);\n    }\n    for (int i = 0; i < solution_count; i++) {\n        free(solutions[i]);\n    }\n\n    return 0;  \n}"
    }
  },
  {
    "id": "110",
    "title": "猜数字",
    "examType": "A",
    "score": 100,
    "description": "一个人设定一组四码的数字作为谜底，另一方猜。\n每猜一个数，出数者就要根据这个数字给出提示，提示以XAYB形式呈现，直到猜中位置。\n其中X表示位置正确的数的个数（数字正确且位置正确），而Y表示数字正确而位置不对的数的个数。\n例如，当谜底为8123，而猜谜者猜1052时，出题者必须提示0A2B。\n例如，当谜底为5637，而猜谜者才4931时，出题者必须提示1A0B。\n当前已知N组猜谜者猜的数字与提示，如果答案确定，请输出答案，不确定则输出NA。",
    "inputDesc": "第一行输入一个正整数，0＜N ＜ 100。\n接下来N行，每一行包含一个猜测的数字与提示结果。",
    "outputDesc": "输出最后的答案，答案不确定则输出NA。",
    "examples": [
      {
        "input": "1A1B\n 0A1B\n 0A1B\n 0A0B\n 3A0B\n 2A1B",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "暴力枚举所有可能的谜底，即0000~9999，然后用每一个谜底去匹配输入的猜测。如果当前谜底与输入的猜测产生的提示符合预期，则说明该谜底是可行的。如果某个谜底可以符合所有输入的猜测，那么该谜底就是题解。如果暴力枚举出来的所有谜底中只有一个可行的谜底，那么该谜底就是题解，否则本题无解，返回NA。\n由于需要验证0000~9999这一万个可能的谜底，而每个谜底最多需要验证100个输入的猜测数字，因此该算法非常容易超时。为了优化算法，我们可以对输入的猜测进行剪枝处理。例如，当输入的猜测提示为0A0B时，我们可以排除所有包含输入数字的谜底，因为这些谜底与输入数字的位置和数字都不匹配。同样地，当输入的猜测提示为0A时，我们可以排除所有包含输入数字的位置的谜底，因为这些谜底与输入数字的位置不匹配。通过对输入的猜测进行剪枝处理，我们可以大大减少需要验证的谜底数量，从而提高算法效率。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // 输入猜测的次数\n\n        // 存储所有猜测的数字和提示结果\n        List<String[]> guessInfos = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            String guessNum = scanner.next(); // 输入猜测的数字\n            String guessResult = scanner.next(); // 输入猜测的结果\n            guessInfos.add(new String[]{guessNum, guessResult}); // 将猜测的数字和结果存入列表中\n        }\n\n        int validCount = 0; // 记录符合条件的答案数量\n        String validAnswer = \"\"; // 存储符合条件的答案\n\n        // 遍历所有可能的四位数\n        for (int num = 0; num <= 9999; num++) {\n            String answer = String.format(\"%04d\", num); // 将数字格式化为四位数字符串\n            boolean isValid = true; // 标记当前答案是否有效\n\n            // 遍历每个猜测的数字和结果\n            for (String[] guessInfo : guessInfos) {\n                String guess = guessInfo[0]; // 获取猜测的数字\n                String expectResult = guessInfo[1]; // 获取猜测的结果\n\n                int countA = 0; // 记录数字和位置都正确的个数\n                int countB = 0; // 记录数字正确但位置不正确的个数\n\n                int[] answerArr = new int[10]; // 存储答案中每个数字出现的次数\n                int[] guessArr = new int[10]; // 存储猜测中每个数字出现的次数\n\n                // 遍历每个位置\n                for (int i = 0; i < guess.length(); i++) {\n                    int c1Int = guess.charAt(i) - '0'; // 获取猜测中该位置上的数字\n                    int c2Int = answer.charAt(i) - '0'; // 获取答案中该位置上的数字\n\n                    if (c1Int == c2Int) {\n                        countA++; // 如果数字和位置都正确，countA+1\n                    } else {\n                        guessArr[c1Int]++; // 在 guessArr 中记录该数字出现的次数\n                        answerArr[c2Int]++; // 在 answerArr 中记录该数字出现的次数\n                    }\n                }\n\n                for (int i = 0; i < 10; i++) {\n                    countB += Math.min(answerArr[i], guessArr[i]); // 计算数字正确但位置不正确的个数\n                }\n\n                String realResult = countA + \"A\" + countB + \"B\"; // 根据猜测和答案计算真实结果\n\n                if (!realResult.equals(expectResult)) {\n                    isValid = false; // 如果真实结果和猜测结果不一致，标记当前答案为无效\n                    break;\n                }\n            }\n\n            if (isValid) {\n                validCount++; // 如果当前答案有效，更新符合条件的答案数量\n                validAnswer = answer; // 更新符合条件的答案\n\n                if (validCount > 1) {\n                    break; // 如果符合条件的答案数量大于1，跳出循环\n                }\n            }\n        }\n\n        if (validCount != 1) {\n            System.out.println(\"NA\"); // 如果符合条件的答案不唯一，输出 NA\n        } else {\n            System.out.println(validAnswer); // 如果符合条件的答案唯一，输出答案\n        }\n    }\n}",
      "python": "from typing import List, Tuple\n\ndef main():\n    n = int(input())  # 输入猜测的次数\n\n    # 存储所有猜测的数字和提示结果\n    guess_infos = [tuple(input().split()) for _ in range(n)]\n\n    valid_count = 0  # 记录符合条件的答案数量\n    valid_answer = \"\"  # 存储符合条件的答案\n\n    # 遍历所有可能的四位数\n    for num in range(10000):\n        answer = f\"{num:04d}\"  # 将数字格式化为四位数字符串\n        is_valid = True  # 标记当前答案是否有效\n\n        # 遍历每个猜测的数字和结果\n        for guess, expect_result in guess_infos:\n            count_a = 0  # 记录数字和位置都正确的个数\n            count_b = 0  # 记录数字正确但位置不正确的个数\n\n            answer_arr = [0] * 10  # 存储答案中每个数字出现的次数\n            guess_arr = [0] * 10  # 存储猜测中每个数字出现的次数\n\n            # 遍历每个位置\n            for i in range(len(guess)):\n                c1_int = int(guess[i])  # 获取猜测中该位置上的数字\n                c2_int = int(answer[i])  # 获取答案中该位置上的数字\n\n                if c1_int == c2_int:\n                    count_a += 1  # 如果数字和位置都正确，countA+1\n                else:\n                    guess_arr[c1_int] += 1  # 在 guessArr 中记录该数字出现的次数\n                    answer_arr[c2_int] += 1  # 在 answerArr 中记录该数字出现的次数\n\n            count_b = sum(min(answer_arr[i], guess_arr[i]) for i in range(10))  # 计算数字正确但位置不正确的个数\n\n            real_result = f\"{count_a}A{count_b}B\"  # 根据猜测和答案计算真实结果\n\n            if real_result != expect_result:\n                is_valid = False  # 如果真实结果和猜测结果不一致，标记当前答案为无效\n                break\n\n        if is_valid:\n            valid_count += 1  # 如果当前答案有效，更新符合条件的答案数量\n            valid_answer = answer  # 更新符合条件的答案\n\n            if valid_count > 1:\n                break  # 如果符合条件的答案数量大于1，跳出循环\n\n    if valid_count != 1:\n        print(\"NA\")  # 如果符合条件的答案不唯一，输出 NA\n    else:\n        print(valid_answer)  # 如果符合条件的答案唯一，输出答案\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "// 引入readline库，用于从标准输入读取数据\nconst readline = require('readline');\n// 创建readline接口实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 定义变量n来存储猜测的总数\nlet n;\n// 定义数组来存储每次的猜测数字和结果\nlet guessInfos = [];\n\n// 监听行输入事件\nrl.on('line', (line) => {\n  if (!n) {\n    // 如果n未定义，读取第一行作为猜测总数\n    n = parseInt(line.trim());\n  } else {\n    // 否则读取猜测数字和相应的结果，并存入guessInfos数组\n    const [guessNum, guessResult] = line.split(' ');\n    guessInfos.push([guessNum, guessResult]);\n    if (guessInfos.length === n) {\n      // 当读取完所有数据后关闭接口\n      rl.close();\n    }\n  }\n});\n\n// 监听关闭事件，开始处理数据\nrl.on('close', () => {\n  // 用于记录符合条件的答案数量\n  let validCount = 0;\n  // 用于存储有效的答案\n  let validAnswer = '';\n\n  // 遍历0000到9999所有可能的答案\n  for (let num = 0; num <= 9999; num++) {\n    const answer = num.toString().padStart(4, '0');\n    let isValid = true;\n\n    // 遍历所有的猜测信息\n    for (const [guess, expectResult] of guessInfos) {\n      let countA = 0; // 位置和数字都正确的数量\n      let countB = 0; // 数字正确但位置错误的数量\n      // 初始化数字出现频次的数组\n      const answerArr = new Array(10).fill(0);\n      const guessArr = new Array(10).fill(0);\n\n      // 对每个位置的数字进行比较\n      for (let i = 0; i < guess.length; i++) {\n        const c1Int = parseInt(guess[i]);\n        const c2Int = parseInt(answer[i]);\n\n        if (c1Int === c2Int) {\n          countA++;\n        } else {\n          guessArr[c1Int]++;\n          answerArr[c2Int]++;\n        }\n      }\n\n      // 计算位置不正确但数字正确的数量\n      for (let i = 0; i < 10; i++) {\n        countB += Math.min(answerArr[i], guessArr[i]);\n      }\n\n      // 构造实际结果字符串\n      const realResult = `${countA}A${countB}B`;\n\n      // 如果实际结果与预期结果不匹配，该答案无效\n      if (realResult !== expectResult) {\n        isValid = false;\n        break;\n      }\n    }\n\n    // 如果该答案有效，记录下来\n    if (isValid) {\n      validCount++;\n      validAnswer = answer;\n\n      // 如果找到多于一个有效答案，则停止搜索\n      if (validCount > 1) {\n        break;\n      }\n    }\n  }\n\n  // 根据有效答案数量输出结果\n  if (validCount !== 1) {\n    console.log('NA');\n  } else {\n    console.log(validAnswer);\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n; // 输入猜测的次数\n\n    // 存储所有猜测的数字和提示结果\n    vector<pair<string, string>> guessInfos;\n    for (int i = 0; i < n; i++) {\n        string guessNum, guessResult;\n        cin >> guessNum >> guessResult; // 输入猜测的数字和结果\n        guessInfos.push_back(make_pair(guessNum, guessResult)); // 将猜测的数字和结果存入列表中\n    }\n\n    int validCount = 0; // 记录符合条件的答案数量\n    string validAnswer = \"\"; // 存储符合条件的答案\n\n    // 遍历所有可能的四位数\n    for (int num = 0; num <= 9999; num++) {\n        stringstream ss;\n        ss << setw(4) << setfill('0') << num;\n        string answer = ss.str(); // 将数字格式化为四位数字符串\n        bool isValid = true; // 标记当前答案是否有效\n\n        // 遍历每个猜测的数字和结果\n        for (const auto& guessInfo : guessInfos) {\n            string guess = guessInfo.first; // 获取猜测的数字\n            string expectResult = guessInfo.second; // 获取猜测的结果\n\n            int countA = 0; // 记录数字和位置都正确的个数\n            int countB = 0; // 记录数字正确但位置不正确的个数\n\n            vector<int> answerArr(10, 0); // 存储答案中每个数字出现的次数\n            vector<int> guessArr(10, 0); // 存储猜测中每个数字出现的次数\n\n            // 遍历每个位置\n            for (int i = 0; i < guess.length(); i++) {\n                int c1Int = guess[i] - '0'; // 获取猜测中该位置上的数字\n                int c2Int = answer[i] - '0'; // 获取答案中该位置上的数字\n\n                if (c1Int == c2Int) {\n                    countA++; // 如果数字和位置都正确，countA+1\n                } else {\n                    guessArr[c1Int]++; // 在 guessArr 中记录该数字出现的次数\n                    answerArr[c2Int]++; // 在 answerArr 中记录该数字出现的次数\n                }\n            }\n\n            for (int i = 0; i < 10; i++) {\n                countB += min(answerArr[i], guessArr[i]); // 计算数字正确但位置不正确的个数\n            }\n\n            string realResult = to_string(countA) + \"A\" + to_string(countB) + \"B\"; // 根据猜测和答案计算真实结果\n\n            if (realResult != expectResult) {\n                isValid = false; // 如果真实结果和猜测结果不一致，标记当前答案为无效\n                break;\n            }\n        }\n\n        if (isValid) {\n            validCount++; // 如果当前答案有效，更新符合条件的答案数量\n            validAnswer = answer; // 更新符合条件的答案\n\n            if (validCount > 1) {\n                break; // 如果符合条件的答案数量大于1，跳出循环\n            }\n        }\n    }\n\n    if (validCount != 1) {\n        cout << \"NA\" << endl; // 如果符合条件的答案不唯一，输出 NA\n    } else {\n        cout << validAnswer << endl; // 如果符合条件的答案唯一，输出答案\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n); // 读取输入的猜测次数\n\n    char guessNum[5], guessResult[5];\n    char guessInfos[n][10][2][5]; // 创建数组存储每次的猜测和结果\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s %s\", guessNum, guessResult); // 读取每次的猜测数字和结果\n        strcpy(guessInfos[i][0], guessNum);\n        strcpy(guessInfos[i][1], guessResult);\n    }\n\n    int validCount = 0; // 用于记录符合条件的答案数量\n    char validAnswer[5]; // 用于存储有效答案\n\n    // 遍历所有可能的四位数\n    for (int num = 0; num <= 9999; num++) {\n        char answer[5];\n        sprintf(answer, \"%04d\", num); // 将数字格式化为四位数字符串\n\n        int isValid = 1; // 假设当前答案有效\n\n        // 对每组猜测信息进行验证\n        for (int j = 0; j < n; j++) {\n            char *guess = guessInfos[j][0];\n            char *expectResult = guessInfos[j][1];\n\n            int countA = 0; // 位置和数字都正确的数量\n            int countB = 0; // 数字正确位置错误的数量\n            int answerArr[10] = {0};\n            int guessArr[10] = {0};\n\n            // 比较猜测数字和答案数字\n            for (int i = 0; i < 4; i++) {\n                int c1Int = guess[i] - '0';\n                int c2Int = answer[i] - '0';\n\n                if (c1Int == c2Int) {\n                    countA++;\n                } else {\n                    guessArr[c1Int]++;\n                    answerArr[c2Int]++;\n                }\n            }\n\n            // 计算位置不对但数字正确的情况\n            for (int i = 0; i < 10; i++) {\n                countB += (answerArr[i] < guessArr[i]) ? answerArr[i] : guessArr[i];\n            }\n\n            char realResult[5];\n            sprintf(realResult, \"%dA%dB\", countA, countB); // 构造实际的结果字符串\n\n            if (strcmp(realResult, expectResult) != 0) {\n                isValid = 0; // 如果实际结果和预期结果不符，标记为无效\n                break;\n            }\n        }\n\n        // 如果当前答案有效，记录下来\n        if (isValid) {\n            validCount++;\n            strcpy(validAnswer, answer);\n\n            if (validCount > 1) {\n                break; // 如果找到多于一个有效答案，停止搜索\n            }\n        }\n    }\n\n    // 根据有效答案的数量输出结果\n    if (validCount != 1) {\n        printf(\"NA\\n\");\n    } else {\n        printf(\"%s\\n\", validAnswer);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "111",
    "title": "绘图机器",
    "examType": "A",
    "score": 100,
    "description": "绘图机器的绘图笔初始位置在原点(0,0)机器启动后按照以下规则来进行绘制直线。\n1. 尝试沿着横线坐标正向绘制直线直到给定的终点E\n2. 期间可以通过指令在纵坐标轴方向进行偏移，offsetY为正数表示正向偏移,为负数表示负向偏移\n给定的横坐标终点值E 以及若干条绘制指令，\n请计算绘制的直线和横坐标轴以及x=E的直线组成的图形面积。",
    "inputDesc": "首行为两个整数 N 和 E表示有N条指令,机器运行的横坐标终点值E接下来N行 每行两个整数表示一条绘制指令x offsetY用例保证横坐标x以递增排序的方式出现且不会出现相同横坐标x\n取值范围\n0<N<=100000<=x<=E<=20000-10000<=offsetY<=10000",
    "outputDesc": "一个整数表示计算得到的面积 用例保证结果范围在0到4294967295之内。",
    "examples": [
      {
        "input": "10\n 1\n 1\n 1\n -2",
        "output": "",
        "explanation": ""
      },
      {
        "input": "4\n 1\n -2",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt(); // 输入指令的数量\n        int e = scanner.nextInt(); // 终点横坐标\n\n        if (e == 0) { // 如果终点横坐标为0\n            System.out.println(0); // 输出面积为0\n            return;\n        }\n\n        int[] offsets = new int[e]; // 创建一个长度为终点横坐标的整数数组，用于存储纵坐标偏移量\n\n        for (int i = 0; i < n; i++) {\n            int cur_x = scanner.nextInt(); // 当前点的横坐标\n            int offset_y = scanner.nextInt(); // 当前点纵坐标相较于上一个点纵坐标的偏移量\n            offsets[cur_x] = offset_y; // 将偏移量存储在对应横坐标位置上\n        }\n\n        int[] dp = new int[e]; // 创建一个长度为终点横坐标的整数数组，用于存储每个横坐标位置的纵坐标偏移量之和\n        dp[0] = offsets[0]; // 第一个位置的纵坐标偏移量为指令中的纵坐标偏移量\n        for (int i = 1; i < e; i++) { // 从第二个位置开始遍历\n            dp[i] = offsets[i] + dp[i - 1]; // 当前位置的纵坐标偏移量为指令中的纵坐标偏移量加上前一个位置的纵坐标偏移量之和\n        }\n\n        int ans = 0; // 初始化面积为0\n        for (int num : dp) { // 遍历每个横坐标位置的纵坐标偏移量之和\n            ans += Math.abs(num); // 将绝对值加到面积中\n        }\n        System.out.println(ans); // 输出面积\n\n        scanner.close(); // 关闭输入流\n    }\n}",
      "python": "n , e = map(int, input().split())\n\n\nif e == 0: # 如果终点横坐标为0\n    print(0) # 输出面积为0\n    exit()\n\noffsets = [0] * e # 创建一个长度为终点横坐标的整数数组，用于存储纵坐标偏移量\n\nfor _ in range(n):\n    cur_x , offset_y = map(int, input().split())\n    offsets[cur_x] = offset_y # 将偏移量存储在对应横坐标位置上\n\ndp = [0] * e # 创建一个长度为终点横坐标的整数数组，用于存储每个横坐标位置的纵坐标偏移量之和\ndp[0] = offsets[0] # 第一个位置的纵坐标偏移量为指令中的纵坐标偏移量\nfor i in range(1, e): # 从第二个位置开始遍历\n    dp[i] = offsets[i] + dp[i - 1] # 当前位置的纵坐标偏移量为指令中的纵坐标偏移量加上前一个位置的纵坐标偏移量之和\n\nans = 0 # 初始化面积为0\nfor num in dp: # 遍历每个横坐标位置的纵坐标偏移量之和\n    ans += abs(num) # 将绝对值加到面积中\nprint(ans) # 输出面积",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet lines = [];\nlet n = 0, e = 0;\n\nrl.on('line', (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [n, e] = line.split(' ').map(Number);\n    if (e === 0) {\n      console.log(0);\n      lines = [];\n    }\n  }\n  if (e !== 0 && n !== 0 && lines.length === n + 1) {\n    lines.shift();\n\n    // 求出每个横轴单位上的offsetY偏移值，如果输入未给定offsetY，则相当于offsetY=0\n    const offsets = new Array(e).fill(0);\n    for (const line of lines) {\n      const [x, offsetY] = line.split(' ').map(Number);\n      offsets[x] = offsetY;\n    }\n\n    const dp = new Array(e).fill(0);\n    dp[0] = offsets[0];\n    for (let i = 1; i < e; i++) {\n      dp[i] = offsets[i] + dp[i - 1];\n    }\n\n    let ans = 0;\n    for (const num of dp) {\n      ans += Math.abs(num);\n    }\n    console.log(ans);\n\n    lines = [];\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    int n, e;\n    cin >> n >> e;\n    \n    if (e == 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    \n    vector<int> offsets(e);\n    \n    for (int i = 0; i < n; i++) {\n        int cur_x, offset_y;\n        cin >> cur_x >> offset_y;\n        offsets[cur_x] = offset_y;\n    }\n    \n    vector<int> dp(e);\n    dp[0] = offsets[0];\n    for (int i = 1; i < e; i++) {\n        dp[i] = offsets[i] + dp[i - 1];\n    }\n    \n    int ans = 0;\n    for (int num : dp) {\n        ans += abs(num);\n    }\n    cout << ans << endl;\n    \n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 定义绘图指令的结构体\ntypedef struct {\n    int x;       // 横坐标\n    int offsetY; // 纵坐标偏移\n} Command;\n\nint main() {\n    int N, E;\n    scanf(\"%d %d\", &N, &E); // 读取指令数量和终点横坐标E\n\n    Command commands[N + 1]; // 存储绘图指令，多一个位置用于终点\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &commands[i].x, &commands[i].offsetY); // 读取每条指令\n    }\n\n    // 添加终点作为最后一条指令\n    commands[N].x = E;\n    commands[N].offsetY = 0;\n\n    unsigned long area = 0; // 总面积\n    int currentY = 0;       // 当前纵坐标偏移\n\n    for (int i = 0; i < N; i++) {\n        int base = commands[i + 1].x - commands[i].x;      // 底边长度\n        int height = currentY + commands[i].offsetY;       // 高度\n        area += base * abs(height);                        // 计算梯形面积\n\n        currentY += commands[i].offsetY; // 更新当前纵坐标偏移\n    }\n\n    printf(\"%lu\\n\", area); // 输出总面积\n    return 0;\n}"
    }
  },
  {
    "id": "112",
    "title": "连续字母长度",
    "examType": "A",
    "score": 100,
    "description": "给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。",
    "inputDesc": "第一行有一个子串(1<长度<=100)，只包含大写字母。",
    "outputDesc": "输出连续出现次数第k多的字母的次数。",
    "examples": [
      {
        "input": "AAAAHHHBBCDHHHH",
        "output": "",
        "explanation": "同一字母连续出现的最多的是A和H，四次； 第二多的是H，3次，但是H已经存在4个连续的，故不考虑； 下个最长子串是BB，所以最终答案应该输出2。"
      },
      {
        "input": "AABAAA",
        "output": "",
        "explanation": "同一字母连续出现的最多的是A，三次； 第二多的还是A，两次，但A已经存在最大连续次数三次，故不考虑； 下个最长子串是B，所以输出1。"
      },
      {
        "input": "ABC",
        "output": "-1",
        "explanation": "只含有3个包含同一字母的子串，小于k，输出-1"
      },
      {
        "input": "ABC",
        "output": "",
        "explanation": "三个子串长度均为1，所以此时k = 1，k=2，k=3这三种情况均输出1。"
      }
    ],
    "solution": "题目要求我们找到一个字符串中由相同字母连续组成的第 k 长子串的长度。需要注意的是，如果某个字母的子串出现多个，且这些子串的长度不同，则只取最长的那个。若字串数量不足 k 个，则返回 -1。\n例子解释：\n输入例子 1： 输入： AAAAHHHBBCDHHHH 3 输出： 2 12345 解释：连续出现最多的字母子串是 “AAAA” 和 “HHHH”，长度为 4。第二长的子串是 “HHH” (但已经有一个长度为4的 “HHHH” 不考虑)，所以下一个考虑的最长子串是 “BB”，长度为 2。所以输出为 2。 输入例子 2： 输入： AABAAA 2 输出： 1 12345 解释：最长的连续字母子串是 “AAA”，长度为 3。第二长的是 “AA” (但已经有一个长度为3的 “AAA” 不考虑)，所以下一个最长的子串是 “B”，长度为 1。所以输出为 1。 输入例子 3： 输入： ABC 4 输出： -1 12345 解释：只含有3个由相同字母组成的子串（“A”, “B”, “C”），且每个子串的长度都是 1。因为 k=4，但只存在3个子串，所以输出 -1。 输入例子 4： 输入： ABC 2 输出： 1 12345 解释：三个子串长度均为 1，所以不管 k 是 1, 2, 3，只要是有效的范围，输出的最长子串的长度都为 1。\n输入例子 1：\n12345\n解释：连续出现最多的字母子串是 “AAAA” 和 “HHHH”，长度为 4。第二长的子串是 “HHH” (但已经有一个长度为4的 “HHHH” 不考虑)，所以下一个考虑的最长子串是 “BB”，长度为 2。所以输出为 2。\n输入例子 2：\n12345\n解释：最长的连续字母子串是 “AAA”，长度为 3。第二长的是 “AA” (但已经有一个长度为3的 “AAA” 不考虑)，所以下一个最长的子串是 “B”，长度为 1。所以输出为 1。\n输入例子 3：\n12345\n解释：只含有3个由相同字母组成的子串（“A”, “B”, “C”），且每个子串的长度都是 1。因为 k=4，但只存在3个子串，所以输出 -1。\n输入例子 4：\n12345\n解释：三个子串长度均为 1，所以不管 k 是 1, 2, 3，只要是有效的范围，输出的最长子串的长度都为 1。",
    "codes": {
      "java": "import java.util.Scanner;            \nimport java.util.HashSet;         \nimport java.util.HashMap;            \nimport java.util.regex.Pattern;      \nimport java.util.regex.Matcher;     \nimport java.util.ArrayList;       \nimport java.util.Collections;      \n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);  \n        String str = input.next();              // 读取字符串输入\n        int k = input.nextInt();                // 读取整数k值\n\n        HashSet<Character> charSet = new HashSet<>(); // 创建HashSet，用于存储字符串中不同的字符\n        for (char c : str.toCharArray()) {           // 遍历字符串中的每个字符\n            charSet.add(c);                          // 将字符添加到HashSet中（自动去重）\n        }\n\n        HashMap<Character, Integer> charMap = new HashMap<>(); // 创建HashMap，用于存储每个字符的最长子串长度\n        for (char c : charSet) {                               // 遍历HashSet中的每个字符\n            // 创建一个正则表达式模式，用于匹配当前字符的连续子串\n            Pattern pattern = Pattern.compile(String.valueOf(c) + \"+\");\n            // 使用Matcher在字符串中查找所有匹配的子串\n            Matcher matcher = pattern.matcher(str);\n            while (matcher.find()) {                         // 当找到匹配的子串时\n                int repeatTimes = matcher.group().length();  // 获取匹配子串的长度\n                // 更新HashMap中的最长子串长度\n                if (charMap.containsKey(c)) { \n                    // 如果当前字符已在Map中，比较并存储最大长度\n                    charMap.put(c, Math.max(charMap.get(c), repeatTimes));\n                } else {\n                    // 如果当前字符不在Map中，直接存储当前长度\n                    charMap.put(c, repeatTimes);\n                }\n            }\n        }\n\n        // 将所有字符的最长子串长度存储到ArrayList中\n        ArrayList<Integer> values = new ArrayList<>(charMap.values());\n        // 对ArrayList中的长度值进行降序排序\n        Collections.sort(values, Collections.reverseOrder());\n        // 如果k大于ArrayList中的元素数量，返回-1，否则返回第k大的长度值\n        int rt = k > values.size() ? -1 : values.get(k - 1);\n        System.out.println(rt); // 输出结果\n    }\n}",
      "python": "import re\n\nstr = input()\nk = int(input())\ncharSet = set(str)\ncharMap = {}\nfor c in charSet:\n    reg = re.compile(c + \"+\")\n    it = re.finditer(reg, str)\n    for match in it:\n        repeatTimes = len(match.group())\n        if c in charMap:\n            charMap[c] = max(charMap[c], repeatTimes)\n        else:\n            charMap[c] = repeatTimes\nvalues = list(charMap.values())\nvalues.sort(reverse=True)\nrt = -1 if k > len(values) else values[k-1]\nprint(rt)",
      "javascript": "const { listeners } = require(\"process\"); \nconst readline = require(\"readline\");  \nconst { isNumber } = require(\"util\");  \n\n \nconst rl = readline.createInterface({\n  input: process.stdin,  \n  output: process.stdout  \n});\n\n \nrl.on(\"line\", (str) => {  \n  rl.on(\"line\", (k) => {  \n\n    // 创建一个Set集合，用于存储字符串中的唯一字符\n    let set = new Set(str);\n    // 创建一个空对象，用于存储每个字符的最长连续子串长度\n    let obj = {};\n\n    // 遍历Set集合中的每个字符\n    for (let letter of set) {\n      // 创建一个正则表达式，用于匹配当前字符的连续子串\n      const reg = new RegExp(`${letter}+`, \"g\");\n\n      // 无限循环，直到正则表达式匹配结束\n      while (true) {\n        // 使用正则表达式在字符串中查找匹配的子串\n        let res = reg.exec(str);\n        if (res === null) { // 如果没有更多匹配的子串，则跳出循环\n          break;\n        } else {\n          // 获取匹配子串的长度\n          let repeatTimes = res[0].length;\n          // 更新对象中当前字符的最长子串长度\n          obj[letter] = obj[letter]\n            ? Math.max(obj[letter], repeatTimes) // 如果已存在该字符，则取最大长度\n            : repeatTimes; // 如果不存在，则直接存储当前长度\n        }\n      }\n    }\n\n    // 对对象中所有字符的最长子串长度进行降序排序，并返回第k大的值，如果k超出范围则返回-1\n    let res = Object.values(obj).sort((a, b) => b - a)[k - 1] ?? -1;\n    console.log(res); // 输出结果\n\n  });\n});",
      "cpp": "#include <iostream>       \n#include <string>        \n#include <unordered_map>  \n#include <unordered_set> \n#include <regex>         \nusing namespace std;\n\nint main() {\n    string str; // 定义字符串变量，用于存储输入的字符串\n    int k = 0;  // 定义整数变量，用于存储输入的k值\n    cin >> str; // 从输入中读取字符串\n    cin >> k;   // 从输入中读取k值\n\n    unordered_set<char> charSet; // 定义无序集合，用于存储字符串中出现的不同字符\n    for (char c : str) {\n        charSet.insert(c); // 遍历字符串，将每个字符插入集合中（自动去重）\n    }\n\n    unordered_map<char, int> charMap; // 定义无序映射，用于存储每个字符对应的最长连续子串长度\n    for (char c : charSet) { \n        // 对于集合中的每个字符，构造一个正则表达式，匹配该字符的连续子串\n        const regex reg(string(1, c) + \"+\"); \n        // 使用正则表达式在字符串中查找所有匹配的子串\n        sregex_iterator it(str.begin(), str.end(), reg);\n        while (it != sregex_iterator()) {\n            int repeatTimes = it->str().length(); // 获取匹配子串的长度\n            // 更新映射中的最长子串长度，如果当前长度大于已存储的长度，则更新\n            charMap[c] = charMap.count(c) ? max(charMap[c], repeatTimes) : repeatTimes;\n            ++it; // 继续查找下一个匹配的子串\n        }\n    }\n\n    vector<int> values; // 定义一个向量，用于存储所有字符的最长子串长度\n    for (auto it : charMap) {\n        values.push_back(it.second); // 将映射中的长度值添加到向量中\n    }\n    // 对向量中的长度值进行降序排序\n    sort(values.begin(), values.end(), greater<int>());\n    // 如果k大于向量中的元素数量，则返回-1，否则返回第k大的长度值\n    int rt = k > values.size() ? -1 : values[k - 1];\n    cout << rt << endl; // 输出结果\n    return 0; // 程序正常结束\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[101]; // 存储输入的字符串，最大长度100\n    int k, charMaxCount[26] = {0}, count = 0, maxCount = 0;\n    scanf(\"%s\", str); // 读取字符串\n    scanf(\"%d\", &k); // 读取k的值\n\n    // 计算每个字符的最大连续出现次数\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        if (i == 0 || str[i] != str[i - 1]) {\n            count = 1; // 如果当前字符和前一个字符不同，重置计数器\n        } else {\n            count++; // 如果当前字符和前一个字符相同，增加计数器\n        }\n\n        int index = str[i] - 'A'; // 将字符转换为索引（0-25）\n        if (count > charMaxCount[index]) {\n            charMaxCount[index] = count; // 更新字符的最大连续出现次数\n        }\n    }\n\n    // 将连续出现次数存储在数组中，并排序\n    int counts[26], j = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charMaxCount[i] > 0) {\n            counts[j++] = charMaxCount[i];\n        }\n    }\n\n    // 冒泡排序\n    for (int i = 0; i < j - 1; i++) {\n        for (int p = 0; p < j - i - 1; p++) {\n            if (counts[p] < counts[p + 1]) {\n                int temp = counts[p];\n                counts[p] = counts[p + 1];\n                counts[p + 1] = temp;\n            }\n        }\n    }\n\n    // 输出结果\n    if (k > j) {\n        printf(\"-1\\n\"); // 如果k大于数组长度，输出-1\n    } else {\n        printf(\"%d\\n\", counts[k - 1]); // 输出第k多的字符的次数\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "113",
    "title": "原A卷老题)- 处理器问题",
    "examType": "A",
    "score": 100,
    "description": "某公司研发了一款高性能AI处理器。每台物理设备具备8颗AI处理器，编号分别为0、1、2、3、4、5、6、7。\n编号0-3的处理器处于同一个链路中，编号4-7的处理器处于另外一个链路中，不通链路中的处理器不能通信。\n如下图所示。现给定服务器可用的处理器编号数组array，以及任务申请的处理器数量num，找出符合下列亲和性调度原则的芯片组合。\n如果不存在符合要求的组合，则返回空列表。\n\n亲和性调度原则：\n-如果申请处理器个数为1，则选择同一链路，剩余可用的处理器数量为1个的最佳，其次是剩余3个的为次佳，然后是剩余2个，最后是剩余4个。\n-如果申请处理器个数为2，则选择同一链路剩余可用的处理器数量2个的为最佳，其次是剩余4个，最后是剩余3个。\n-如果申请处理器个数为4，则必须选择同一链路剩余可用的处理器数量为4个。\n-如果申请处理器个数为8，则申请节点所有8个处理器。\n\n提示：\n任务申请的处理器数量只能是1、2、4、8。编号0-3的处理器处于一个链路，编号4-7的处理器处于另外一个链路。处理器编号唯一，且不存在相同编号处理器。\n",
    "inputDesc": "输入包含可用的处理器编号数组array，以及任务申请的处理器数量num两个部分。\n第一行为array，第二行为num。例如：\n[0, 1, 4, 5, 6, 7] 1\n表示当前编号为0、1、4、5、6、7的处理器可用。任务申请1个处理器。\n0 <= array.length <= 80 <= array[i] <= 7num in [1, 2, 4, 8]\n",
    "outputDesc": "输出为组合列表，当array=[0，1，4，5，6，7]，num=1 时，输出为[[0], [1]]。\n\n根据第一条亲和性调度原则，在剩余两个处理器的链路（0, 1, 2, 3）中选择处理器。\n由于只有0和1可用，则返回任意一颗处理器即可。\n\n用例中，链路link1=[0,1]，链路link2=[4,5,6,7]\n现在要选1个处理器，则需要按照亲和性调度原则\n如果申请处理器个数为1，则选择同一链路，剩余可用的处理器数量为1个的最佳，其次是剩余3个的为次佳，然后是剩余2个，最后是剩余4个。\n最佳的是，找剩余可用1个处理器的链路，发现没有，link1剩余可用2，link2剩余可用4\n其次的是，找剩余可用3个处理器的链路，发现没有\n再次的是，找剩余可用2个处理器的链路，link1符合要求，即从0和1处理器中任选一个，有两种选择，可以使用dfs找对应组合。\n\n关于回溯算法求解组合，可以看下：\nLeetCode - 77 组合_算法的组合_伏城之外的博客-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    Integer[] arr =\n        Arrays.stream(sc.nextLine().split(\"[\\\\[\\\\]\\\\,\\\\s]\"))\n            .filter(str -> !\"\".equals(str))\n            .map(Integer::parseInt)\n            .toArray(Integer[]::new);\n\n    String num = sc.next();\n\n    System.out.println(getResult(arr, num));\n  }\n\n  public static String getResult(Integer[] arr, String num) {\n    ArrayList<Integer> link1 = new ArrayList<>();\n    ArrayList<Integer> link2 = new ArrayList<>();\n\n    Arrays.sort(arr, (a, b) -> a - b);\n    for (Integer e : arr) {\n      if (e < 4) {\n        link1.add(e);\n      } else {\n        link2.add(e);\n      }\n    }\n\n    ArrayList<ArrayList<Integer>> ans = new ArrayList<>();\n    int len1 = link1.size();\n    int len2 = link2.size();\n\n    switch (num) {\n      case \"1\":\n        if (len1 == 1 || len2 == 1) {\n          if (len1 == 1) dfs(link1, 0, 1, new ArrayList<>(), ans);\n          if (len2 == 1) dfs(link2, 0, 1, new ArrayList<>(), ans);\n        } else if (len1 == 3 || len2 == 3) {\n          if (len1 == 3) dfs(link1, 0, 1, new ArrayList<>(), ans);\n          if (len2 == 3) dfs(link2, 0, 1, new ArrayList<>(), ans);\n        } else if (len1 == 2 || len2 == 2) {\n          if (len1 == 2) dfs(link1, 0, 1, new ArrayList<>(), ans);\n          if (len2 == 2) dfs(link2, 0, 1, new ArrayList<>(), ans);\n        } else if (len1 == 4 || len2 == 4) {\n          if (len1 == 4) dfs(link1, 0, 1, new ArrayList<>(), ans);\n          if (len2 == 4) dfs(link2, 0, 1, new ArrayList<>(), ans);\n        }\n        break;\n      case \"2\":\n        if (len1 == 2 || len2 == 2) {\n          if (len1 == 2) dfs(link1, 0, 2, new ArrayList<>(), ans);\n          if (len2 == 2) dfs(link2, 0, 2, new ArrayList<>(), ans);\n        } else if (len1 == 4 || len2 == 4) {\n          if (len1 == 4) dfs(link1, 0, 2, new ArrayList<>(), ans);\n          if (len2 == 4) dfs(link2, 0, 2, new ArrayList<>(), ans);\n        } else if (len1 == 3 || len2 == 3) {\n          if (len1 == 3) dfs(link1, 0, 2, new ArrayList<>(), ans);\n          if (len2 == 3) dfs(link2, 0, 2, new ArrayList<>(), ans);\n        }\n        break;\n      case \"4\":\n        if (len1 == 4 || len2 == 4) {\n          if (len1 == 4) ans.add(link1);\n          if (len2 == 4) ans.add(link2);\n        }\n        break;\n      case \"8\":\n        if (len1 == 4 && len2 == 4) {\n          ans.add(\n              Stream.concat(link1.stream(), link2.stream())\n                  .collect(Collectors.toCollection(ArrayList<Integer>::new)));\n        }\n        break;\n    }\n\n    return ans.toString();\n  }\n\n  public static void dfs(\n      ArrayList<Integer> arr,\n      int index,\n      int level,\n      ArrayList<Integer> path,\n      ArrayList<ArrayList<Integer>> res) {\n    if (path.size() == level) {\n      res.add(new ArrayList<>(path));\n      return;\n    }\n\n    for (int i = index; i < arr.size(); i++) {\n      path.add(arr.get(i));\n      dfs(arr, i + 1, level, path, res);\n      path.remove(path.size() - 1);\n    }\n  }\n}",
      "python": "# 输入获取\narr = eval(input())\nnum = int(input())\n\n\n# 算法入口\ndef getResult(arr, num):\n    link1 = []\n    link2 = []\n\n    arr.sort()\n\n    for e in arr:\n        if e < 4:\n            link1.append(e)\n        else:\n            link2.append(e)\n\n    ans = []\n    len1 = len(link1)\n    len2 = len(link2)\n\n    if num == 1:\n        if len1 == 1 or len2 == 1:\n            if len1 == 1:\n                dfs(link1, 0, 1, [], ans)\n            if len2 == 1:\n                dfs(link2, 0, 1, [], ans)\n        elif len1 == 3 or len2 == 3:\n            if len1 == 3:\n                dfs(link1, 0, 1, [], ans)\n            if len2 == 3:\n                dfs(link2, 0, 1, [], ans)\n        elif len1 == 2 or len2 == 2:\n            if len1 == 2:\n                dfs(link1, 0, 1, [], ans)\n            if len2 == 2:\n                dfs(link2, 0, 1, [], ans)\n        elif len1 == 4 or len2 == 4:\n            if len1 == 4:\n                dfs(link1, 0, 1, [], ans)\n            if len2 == 4:\n                dfs(link2, 0, 1, [], ans)\n    elif num == 2:\n        if len1 == 2 or len2 == 2:\n            if len1 == 2:\n                dfs(link1, 0, 2, [], ans)\n            if len2 == 2:\n                dfs(link2, 0, 2, [], ans)\n        elif len1 == 4 or len2 == 4:\n            if len1 == 4:\n                dfs(link1, 0, 2, [], ans)\n            if len2 == 4:\n                dfs(link2, 0, 2, [], ans)\n        elif len1 == 3 or len2 == 3:\n            if len1 == 3:\n                dfs(link1, 0, 2, [], ans)\n            if len2 == 3:\n                dfs(link2, 0, 2, [], ans)\n    elif num == 4:\n        if len1 == 4 or len2 == 4:\n            if len1 == 4:\n                ans.append(link1)\n            if len2 == 4:\n                ans.append(link2)\n    elif num == 8:\n        if len1 == 4 and len2 == 4:\n            tmp = []\n            tmp.extend(link1)\n            tmp.extend(link2)\n            ans.append(tmp)\n\n    return ans\n\n\ndef dfs(arr, index, level, path, res):\n    if len(path) == level:\n        res.append(path[:])\n        return\n\n    for i in range(index, len(arr)):\n        path.append(arr[i])\n        dfs(arr, i + 1, level, path, res)\n        path.pop()\n\n\n# 算法调用\nprint(getResult(arr, num))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const arr = JSON.parse(lines[0]);\n    const num = lines[1];\n\n    console.log(getResult(arr, num));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(arr, num) {\n  const link1 = [];\n  const link2 = [];\n\n  arr\n    .sort((a, b) => a - b)\n    .forEach((e) => {\n      e < 4 ? link1.push(e) : link2.push(e);\n    });\n\n  const ans = [];\n  const len1 = link1.length;\n  const len2 = link2.length;\n\n  switch (num) {\n    case \"1\":\n      if (len1 === 1 || len2 === 1) {\n        if (len1 === 1) dfs(link1, 0, 1, [], ans);\n        if (len2 === 1) dfs(link2, 0, 1, [], ans);\n      } else if (len1 === 3 || len2 === 3) {\n        if (len1 === 3) dfs(link1, 0, 1, [], ans);\n        if (len2 === 3) dfs(link2, 0, 1, [], ans);\n      } else if (len1 === 2 || len2 === 2) {\n        if (len1 === 2) dfs(link1, 0, 1, [], ans);\n        if (len2 === 2) dfs(link2, 0, 1, [], ans);\n      } else if (len1 === 4 || len2 === 4) {\n        if (len1 === 4) dfs(link1, 0, 1, [], ans);\n        if (len2 === 4) dfs(link2, 0, 1, [], ans);\n      }\n      break;\n    case \"2\":\n      if (len1 === 2 || len2 === 2) {\n        if (len1 === 2) dfs(link1, 0, 2, [], ans);\n        if (len2 === 2) dfs(link2, 0, 2, [], ans);\n      } else if (len1 === 4 || len2 === 4) {\n        if (len1 === 4) dfs(link1, 0, 2, [], ans);\n        if (len2 === 4) dfs(link2, 0, 2, [], ans);\n      } else if (len1 === 3 || len2 === 3) {\n        if (len1 === 3) dfs(link1, 0, 2, [], ans);\n        if (len2 === 3) dfs(link2, 0, 2, [], ans);\n      }\n      break;\n    case \"4\":\n      if (len1 === 4 || len2 === 4) {\n        if (len1 === 4) ans.push(link1);\n        if (len2 === 4) ans.push(link2);\n      }\n      break;\n    case \"8\":\n      if (len1 === 4 && len2 === 4) {\n        ans.push([...link1, ...link2]);\n      }\n      break;\n  }\n\n  return JSON.stringify(ans).split(\",\").join(\", \");\n}\n\nfunction dfs(arr, index, level, path, res) {\n  if (path.length === level) {\n    return res.push([...path]);\n  }\n\n  for (let i = index; i < arr.length; i++) {\n    path.push(arr[i]);\n    dfs(arr, i + 1, level, path, res);\n    path.pop();\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "114",
    "title": "MELON的难题",
    "examType": "A",
    "score": 200,
    "description": "MELON有一堆精美的雨花石（数量为n，重量各异），准备送给S和W。MELON希望送给俩人的雨花石重量一致，请你设计一个程序，帮MELON确认是否能将雨花石平均分配。",
    "inputDesc": "第1行输入为雨花石个数: n，0 < n < 31. 第2行输入为空格分割的各雨花石重量: m[0] m[1] … m[n - 1]， 0 < m[k] < 1001\n不需要考虑异常输入的情况。",
    "outputDesc": "如果可以均分，从当前雨花石中最少拿出几块，可以使两堆的重量相等:如果不能均分，则输出-1。\n输入\n输出\n说明\n输入第一行代表共4颗雨花石，第二行代表4颗雨花石重量分别为1、1、2、2。均分时只能分别为1,2，需要拿出重量为1和2的两块雨花石，所以输出2。\n输入\n输出\n说明\n输入第一行代表共10颗雨花石，第二行代表4颗雨花石重量分别为1、1、1、1、1、9、8、3、7、10 。\n均分时可以1,1,1,1,1,9,7和10,8,3，也可以1,1,1,1,9.8和10,7,3,1，或者其他均分方式，但第一种只需要拿出重量为10.8,3的3块雨花石，第二种需要拿出4块，所以输出3(块数最少)。",
    "examples": [],
    "solution": "题目要求将雨花石平均分配，即找到一种方法，使得从雨花石中拿出最少的数量，使得两堆雨花石的重量相等。这个问题可以转化为一个01背包问题：从给定的雨花石中选取一些，使得它们的重量之和等于总重量的一半，且选取的雨花石数量最少。\n01背包问题的核心思路是使用动态规划。具体步骤如下：\n计算所有雨花石的总重量。如果总重量为奇数，那么无法将雨花石平均分配，直接输出-1。\n如果总重量为偶数，我们的目标是找到一些雨花石，使得它们的重量之和等于总重量的一半。定义一个动态规划数组dp，其中dp[j]表示从雨花石中选取一些，使得它们的重量之和为j时，所需的最少雨花石数量。\n初始化dp数组，将除了dp之外的其他元素设置为n，表示最坏情况下需要拿出所有雨花石。\n遍历每一块雨花石，对于每一块雨花石，从targetWeight开始递减，更新dp数组。如果使用当前雨花石能够减少所需雨花石数量，则更新dp[j]。\n最后，检查dp[targetWeight]的值。如果它等于n，表示无法找到满足条件的雨花石组合，输出-1。否则，输出dp[targetWeight]，表示从当前雨花石中最少拿出几块，可以使两堆的重量相等。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();  // 输入雨花石个数\n        int[] stones = new int[n];\n        for (int i = 0; i < n; i++) {\n            stones[i] = scanner.nextInt();  // 输入雨花石重量\n        }\n\n        int totalWeight = 0;\n        for (int stone : stones) {\n            totalWeight += stone;  // 计算雨花石总重量\n        }\n\n        if (totalWeight % 2 != 0) {  // 如果总重量为奇数，无法均分\n            System.out.println(-1);\n        } else {\n            int targetWeight = totalWeight / 2;  // 目标重量为总重量的一半\n\n            // 创建动态规划数组，dp[i]表示前i块雨花石中是否能够取出一些雨花石使得重量和为j\n            int[] dp = new int[targetWeight + 1];\n\n            // 初始化dp数组，将除了dp[0]之外的其他元素设置为n，表示最坏情况下需要拿出所有雨花石\n            for (int i = 1; i <= targetWeight; i++) {\n                dp[i] = n;\n            }\n\n            // 遍历每一块雨花石\n            for (int i = 1; i <= n; i++) {\n                int weight = stones[i - 1];  // 当前雨花石的重量\n                // 从目标重量开始递减，更新dp数组\n                for (int j = targetWeight; j >= weight; j--) {\n                    // 如果当前重量可以由前面的雨花石组成，更新dp[j]为最小需要拿出的雨花石数量\n                    dp[j] = Math.min(dp[j], dp[j - weight] + 1);\n                }\n            }\n\n            // 如果dp[targetWeight]仍然等于n，表示无法找到满足条件的雨花石组合\n            if (dp[targetWeight] == n) {\n                System.out.println(-1);\n            } else {\n                // 输出最少需要拿出的雨花石数量\n                System.out.println(dp[targetWeight]);\n            }\n        }\n    }\n}",
      "python": "# 输入雨花石个数\nn = int(input())\n\n# 输入雨花石重量，将输入的字符串转换为整数列表\nstones = list(map(int, input().split()))\n\n# 计算所有雨花石的总重量\ntotalWeight = 0\nfor stone in stones:\n    totalWeight += stone\n\n# 如果总重量为奇数，则无法平均分配，输出 -1\nif totalWeight % 2 != 0:\n    print(-1)\nelse:\n    # 计算目标重量，即总重量的一半\n    targetWeight = totalWeight // 2\n\n    # 初始化动态规划数组 dp，长度为目标重量加 1\n    dp = [0] * (targetWeight + 1)\n\n    # 将 dp 数组的值从索引 1 开始设置为 n\n    for i in range(1, targetWeight + 1):\n        dp[i] = n\n\n    # 遍历所有雨花石\n    for i in range(1, n + 1):\n        weight = stones[i - 1]\n        # 更新 dp 数组的值\n        for j in range(targetWeight, weight - 1, -1):\n            # 如果当前重量可以由前面的雨花石组成，更新dp[j]为最小需要拿出的雨花石数量\n            dp[j] = min(dp[j], dp[j - weight] + 1)\n\n    # 如果 dp[targetWeight] 等于 n，说明无法平均分配，输出 -1\n    if dp[targetWeight] == n:\n        print(-1)\n    else:\n        # 输出最少需要拿出的雨花石数量，使两堆的重量相等\n        print(dp[targetWeight])",
      "javascript": "const readline = require('readline');\n\n// 创建readline接口，用于读取输入\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst inputLines = [];\n// 当接收到一行输入时，将其添加到inputLines数组\nrl.on('line', (line) => {\n  inputLines.push(line);\n  // 当接收到两行输入时，处理输入并关闭readline接口\n  if (inputLines.length === 2) {\n    processInput();\n    rl.close();\n  }\n});\n\nfunction processInput() {\n  // 解析输入的雨花石数量和重量\n  const n = parseInt(inputLines[0]);\n  const stones = inputLines[1].split(' ').map(Number);\n\n  // 计算雨花石总重量\n  let totalWeight = 0;\n  for (const stone of stones) {\n    totalWeight += stone;\n  }\n\n  // 如果总重量不能被2整除，则无法平分\n  if (totalWeight % 2 !== 0) {\n    console.log(-1);\n  } else {\n    // 目标重量为总重量的一半\n    const targetWeight = totalWeight / 2;\n\n    // 初始化动态规划数组\n    const dp = new Array(targetWeight + 1).fill(0);\n\n    // 将除第一个元素外的其他元素设置为n\n    for (let i = 1; i <= targetWeight; i++) {\n      dp[i] = n;\n    }\n\n    // 遍历每个雨花石\n    for (let i = 1; i <= n; i++) {\n      const weight = stones[i - 1];\n      // 更新动态规划数组\n      for (let j = targetWeight; j >= weight; j--) {\n        // 如果当前重量可以由前面的雨花石组成，更新dp[j]为最小需要拿出的雨花石数量\n        dp[j] = Math.min(dp[j], dp[j - weight] + 1);\n      }\n    }\n\n    // 如果dp[targetWeight]等于n，说明无法平分\n    if (dp[targetWeight] === n) {\n      console.log(-1);\n    } else {\n      // 输出最少需要拿出的雨花石数量\n      console.log(dp[targetWeight]);\n    }\n  }\n}",
      "cpp": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;  // 输入雨花石个数\n    vector<int> stones(n);\n    for (int i = 0; i < n; i++) {\n        cin >> stones[i];  // 输入雨花石重量\n    }\n\n    int totalWeight = 0;\n    for (int stone : stones) {\n        totalWeight += stone;  // 计算雨花石总重量\n    }\n\n    if (totalWeight % 2 != 0) {  // 如果总重量为奇数，无法均分\n        cout << -1 << endl;\n    } else {\n        int targetWeight = totalWeight / 2;  // 目标重量为总重量的一半\n\n        // 创建动态规划数组，dp[i]表示前i块雨花石中是否能够取出一些雨花石使得重量和为j\n        vector<int> dp(targetWeight + 1, 0);\n\n        // 初始化dp数组，将除了dp[0]之外的所有值设为n，表示最大需要拿出n块雨花石\n        for (int i = 1; i <= targetWeight; i++) {\n            dp[i] = n;\n        }\n\n        // 遍历每一块雨花石\n        for (int i = 1; i <= n; i++) {\n            int weight = stones[i - 1];\n            // 更新dp数组，从后往前更新，避免重复使用同一块雨花石\n            for (int j = targetWeight; j >= weight; j--) {\n                // 如果当前重量可以由前面的雨花石组成，更新dp[j]为最小需要拿出的雨花石数量\n                dp[j] = min(dp[j], dp[j - weight] + 1);\n            }\n        }\n\n        // 如果dp[targetWeight]仍然等于n，表示无法均分雨花石\n        if (dp[targetWeight] == n) {\n            cout << -1 << endl;\n        } else {\n            // 输出最少需要拿出的雨花石数量\n            cout << dp[targetWeight] << endl;\n        }\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 31\n#define MAX_WEIGHT 1001\n\nint stones[MAX_N]; // 存储每块雨花石的重量\nint dp[MAX_WEIGHT]; // 动态规划数组，用于记录达到某个重量的最小雨花石数量\n\n// 求两个数中的较小值\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n); // 输入雨花石个数\n\n    int totalWeight = 0; // 雨花石总重量\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &stones[i]); // 输入每块雨花石的重量\n        totalWeight += stones[i]; // 累加总重量\n    }\n\n    // 如果总重量为奇数，无法均分\n    if (totalWeight % 2 != 0) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int targetWeight = totalWeight / 2; // 目标重量为总重量的一半\n\n    // 初始化动态规划数组，dp[0]为0，其余为最大值n\n    dp[0] = 0;\n    for (int i = 1; i <= targetWeight; i++) {\n        dp[i] = n;\n    }\n\n    // 动态规划求解\n    for (int i = 0; i < n; i++) {\n        for (int j = targetWeight; j >= stones[i]; j--) {\n            // 更新dp数组，求取最小需要拿出的雨花石数量\n            dp[j] = min(dp[j], dp[j - stones[i]] + 1);\n        }\n    }\n\n    // 如果dp[targetWeight]仍然等于n，表示无法均分雨花石\n    if (dp[targetWeight] == n) {\n        printf(\"-1\\n\");\n    } else {\n        // 输出最少需要拿出的雨花石数量\n        printf(\"%d\\n\", dp[targetWeight]);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "115",
    "title": "中文分词模拟器",
    "examType": "A",
    "score": 200,
    "description": "给定一个连续不包含空格的字符串，该字符串仅包含英文小写字母及英文标点符号（逗号、分号、句号），同时给定词库，对该字符串进行精确分词。\n说明：\n精确分词：字符串分词后，不会出现重叠。即\"ilovechina\"，不同词库可分割为\"i,love,china\"，“ilove,china”，不能分割出现重叠的\"i,ilove,china\"，i 出现重叠 标点符号不成词，仅用于断句 词库：根据外部知识库统计出来的常用词汇例：dictionary = [“i”, “love”, “china”, “lovechina”, “ilove”] 分词原则：采用分词顺序优先且最长匹配原则 “ilovechina”，假设分词结果 [i,ilove,lo,love,ch,china,lovechina]，则输出 [ilove,china] 错误输出：[i,lovechina]，原因：“ilove” > 优先于 “lovechina” 成词 错误输出：[i,love,china]，原因：“ilove” > \"i\"遵循最长匹配原则\n精确分词：字符串分词后，不会出现重叠。即\"ilovechina\"，不同词库可分割为\"i,love,china\"，“ilove,china”，不能分割出现重叠的\"i,ilove,china\"，i 出现重叠\n标点符号不成词，仅用于断句\n词库：根据外部知识库统计出来的常用词汇例：dictionary = [“i”, “love”, “china”, “lovechina”, “ilove”]\n分词原则：采用分词顺序优先且最长匹配原则\n“ilovechina”，假设分词结果 [i,ilove,lo,love,ch,china,lovechina]，则输出 [ilove,china]\n错误输出：[i,lovechina]，原因：“ilove” > 优先于 “lovechina” 成词\n错误输出：[i,love,china]，原因：“ilove” > \"i\"遵循最长匹配原则",
    "inputDesc": "第一行输入待分词语句 “ilovechina”\n字符串长度限制：0 < length < 256\n第二行输入中文词库 “i,love,china,ch,na,ve,lo,this,is,this,word”\n词库长度限制：1 < length < 100000",
    "outputDesc": "按顺序输出分词结果 “i,love,china”\n输入\n​\n输出\n说明 无\n输入\n输出\n说明\n单个字母，不在词库中且不成词则输出单个字母\n输入\n输出\n说明\n标点符号为英文标点符号",
    "examples": [],
    "solution": "题目的要求是给定一个连续的字符串，该字符串只包含英文小写字母和英文标点符号（逗号、分号、句号），同时给出一个词库。你需要根据这个词库将字符串进行分词。\n这里的分词有两个原则：\n分词顺序优先：如果一个字符串可以被分割成多种可能的词序列，那么应该优先选择在词库中出现顺序较前的词。例如，如果词库是 [“i”, “love”, “china”, “lovechina”, “ilove”]，那么字符串 “ilovechina” 应该被分割为 “ilove,china”，而不是 “i,lovechina”，因为 “ilove” 在词库中出现的顺序比 “lovechina” 要前。 最长匹配原则：如果一个字符串可以被分割成多种可能的词序列，那么应该优先选择长度较长的词。例如，如果词库是 [“i”, “love”, “china”, “lovechina”, “ilove”]，那么字符串 “ilovechina” 应该被分割为 “ilove,china”，而不是 “i,love,china”，因为 “ilove” 的长度比 “i” 要长。\n分词顺序优先：如果一个字符串可以被分割成多种可能的词序列，那么应该优先选择在词库中出现顺序较前的词。例如，如果词库是 [“i”, “love”, “china”, “lovechina”, “ilove”]，那么字符串 “ilovechina” 应该被分割为 “ilove,china”，而不是 “i,lovechina”，因为 “ilove” 在词库中出现的顺序比 “lovechina” 要前。\n最长匹配原则：如果一个字符串可以被分割成多种可能的词序列，那么应该优先选择长度较长的词。例如，如果词库是 [“i”, “love”, “china”, “lovechina”, “ilove”]，那么字符串 “ilovechina” 应该被分割为 “ilove,china”，而不是 “i,love,china”，因为 “ilove” 的长度比 “i” 要长。\n注意，标点符号不会成为词的一部分，它们只用于断句。如果一个字符不在词库中，也不是标点符号，那么它会被当作一个单独的词。\n12\n在这个例子中，输入的句子是 “ilovechina,thewordisbeautiful”，字典中的单词是 “i”, “love”, “china”, “ch”, “na”, “ve”, “lo”, “this”, “is”, “the”, “word”, “beauti”, “tiful”, “ful”。\n首先，将字典中的每个单词插入到 Trie 中。这个过程中，Trie 会根据字典中的单词构建出相应的路径。 然后，开始遍历句子中的每个字符。首先遇到的字符是 ‘i’，在 Trie 中可以找到以 ‘i’ 为起点的单词 “i”，所以将 “i” 添加到结果中。 接下来的字符是 ‘l’，在 Trie 中可以找到以 ‘l’ 为起点的最长单词 “love”，所以将 “love” 添加到结果中。 然后的字符是 ‘c’，在 Trie 中可以找到以 ‘c’ 为起点的最长单词 “china”，所以将 “china” 添加到结果中。 接下来的字符是 ‘,’，这是一个非字母字符，直接将其添加到结果中。 然后的字符是 ‘t’，在 Trie 中可以找到以 ‘t’ 为起点的最长单词 “the”，所以将 “the” 添加到结果中。 接下来的字符是 ‘w’，在 Trie 中可以找到以 ‘w’ 为起点的最长单词 “word”，所以将 “word” 添加到结果中。 然后的字符是 ‘i’，在 Trie 中可以找到以 ‘i’ 为起点的最长单词 “is”，所以将 “is” 添加到结果中。 接下来的字符是 ‘b’，在 Trie 中可以找到以 ‘b’ 为起点的最长单词 “beauti”，所以将 “beauti” 添加到结果中。 最后的字符是 ‘f’，在 Trie 中可以找到以 ‘f’ 为起点的最长单词 “ful”，所以将 “ful” 添加到结果中。 遍历完句子中的所有字符后，得到的结果是 “i,love,china,the,word,is,beauti,ful”。\n首先，将字典中的每个单词插入到 Trie 中。这个过程中，Trie 会根据字典中的单词构建出相应的路径。\n然后，开始遍历句子中的每个字符。首先遇到的字符是 ‘i’，在 Trie 中可以找到以 ‘i’ 为起点的单词 “i”，所以将 “i” 添加到结果中。\n接下来的字符是 ‘l’，在 Trie 中可以找到以 ‘l’ 为起点的最长单词 “love”，所以将 “love” 添加到结果中。\n然后的字符是 ‘c’，在 Trie 中可以找到以 ‘c’ 为起点的最长单词 “china”，所以将 “china” 添加到结果中。\n接下来的字符是 ‘,’，这是一个非字母字符，直接将其添加到结果中。\n然后的字符是 ‘t’，在 Trie 中可以找到以 ‘t’ 为起点的最长单词 “the”，所以将 “the” 添加到结果中。\n接下来的字符是 ‘w’，在 Trie 中可以找到以 ‘w’ 为起点的最长单词 “word”，所以将 “word” 添加到结果中。\n然后的字符是 ‘i’，在 Trie 中可以找到以 ‘i’ 为起点的最长单词 “is”，所以将 “is” 添加到结果中。\n接下来的字符是 ‘b’，在 Trie 中可以找到以 ‘b’ 为起点的最长单词 “beauti”，所以将 “beauti” 添加到结果中。\n最后的字符是 ‘f’，在 Trie 中可以找到以 ‘f’ 为起点的最长单词 “ful”，所以将 “ful” 添加到结果中。\n遍历完句子中的所有字符后，得到的结果是 “i,love,china,the,word,is,beauti,ful”。\n所以，这个程序的输出应该是 “i,love,china,the,word,is,beauti,ful”。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    // 定义 TrieNode 类，每个节点包含一个布尔值 isWord 和一个 TrieNode 类型的数组 children\n    static class TrieNode {\n        boolean isWord;\n        TrieNode[] children = new TrieNode[26];\n    }\n\n    // 创建 Trie 的根节点\n    static TrieNode root = new TrieNode();\n\n    // 插入方法，用于向 Trie 中插入一个单词\n    public static void insert(String word) {\n        TrieNode node = root;\n        // 遍历单词中的每个字符\n        for (int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            // 如果当前字符对应的子节点为空，则创建一个新的子节点\n            if (node.children[c - 'a'] == null) {\n                node.children[c - 'a'] = new TrieNode();\n            }\n            // 移动到下一个子节点\n            node = node.children[c - 'a'];\n        }\n        // 标记当前节点为一个单词的结束\n        node.isWord = true;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // 读取输入的句子，并将其转换为小写\n        String sentence = scanner.nextLine().toLowerCase();\n        // 读取输入的字典，字典中的单词以逗号分隔\n        String[] dictionary = scanner.nextLine().split(\",\");\n        // 将字典中的每个单词插入到 Trie 中\n        for (String word : dictionary) {\n            insert(word.toLowerCase());\n        }\n\n        List<String> result = new ArrayList<>();\n        int i = 0;\n        // 遍历句子中的每个字符\n        while (i < sentence.length()) {\n            // 如果当前字符不是字母，则直接将其添加到结果中\n            if (sentence.charAt(i) < 'a' || sentence.charAt(i) > 'z') {\n                result.add(sentence.substring(i, i + 1));\n                i++;\n                continue;\n            }\n            int j = sentence.length();\n            // 从句子的末尾开始，寻找以 i 为起点的最长的在字典中存在的单词\n            while (j > i) {\n                TrieNode node = root;\n                boolean isWord = true;\n                for (int k = i; k < j; k++) {\n                    // 如果当前字符不是字母，或者在 Trie 中不存在对应的子节点，则说明当前的字符串不是一个单词\n                    if (sentence.charAt(k) < 'a' || sentence.charAt(k) > 'z' || node.children[sentence.charAt(k) - 'a'] == null) {\n                        isWord = false;\n                        break;\n                    }\n                    // 移动到下一个子节点\n                    node = node.children[sentence.charAt(k) - 'a'];\n                }\n                // 如果找到了一个单词，则结束循环\n                if (isWord && node.isWord) {\n                    break;\n                }\n                // 如果没有找到单词，则缩短当前的字符串\n                j--;\n            }\n            // 如果没有找到单词，则将当前字符作为一个单独的单词添加到结果中\n            if (j == i) {\n                result.add(sentence.substring(i, i + 1));\n                i++;\n            } else {\n                // 如果找到了单词，则将该单词添加到结果中\n                result.add(sentence.substring(i, j));\n                i = j;\n            }\n        }\n\n        // 输出结果，单词之间以逗号分隔\n        System.out.println(String.join(\",\", result));\n    }\n}",
      "python": "# 定义 TrieNode 类，每个节点包含一个布尔值 is_word 和一个 TrieNode 类型的数组 children\nclass TrieNode:\n    def __init__(self):\n        self.is_word = False  # 标记该节点是否为一个单词的结束\n        self.children = [None] * 26  # 存储子节点的数组，每个元素对应一个字母\n\n# 创建 Trie 的根节点\nroot = TrieNode()\n\n# 插入方法，用于向 Trie 中插入一个单词\ndef insert(word):\n    node = root  # 从根节点开始\n    for c in word:\n        index = ord(c) - ord('a')  # 计算当前字符对应的索引\n        # 如果当前字符对应的子节点为空，则创建一个新的子节点\n        if node.children[index] is None:\n            node.children[index] = TrieNode()\n        # 移动到下一个子节点\n        node = node.children[index]\n    # 标记当前节点为一个单词的结束\n    node.is_word = True\n\n# 输入句子，并将其转换为小写\nsentence = input().lower()\n# 输入字典，字典中的单词以逗号分隔\ndictionary = input().split(\",\")\nfor word in dictionary:\n    insert(word.lower())  # 将字典中的每个单词插入到 Trie 中\n\nresult = []  # 存储结果\ni = 0\n# 遍历句子中的每个字符\nwhile i < len(sentence):\n    # 如果当前字符不是字母，则直接将其添加到结果中\n    if not sentence[i].isalpha():\n        result.append(sentence[i])\n        i += 1\n        continue\n    j = len(sentence)\n    # 从句子的末尾开始，寻找以 i 为起点的最长的在字典中存在的单词\n    while j > i:\n        node = root\n        is_word = True\n        for k in range(i, j):\n            # 如果当前字符不是字母，或者在 Trie 中不存在对应的子节点，则说明当前的字符串不是一个单词\n            if not sentence[k].isalpha() or node.children[ord(sentence[k]) - ord('a')] is None:\n                is_word = False\n                break\n            # 移动到下一个子节点\n            node = node.children[ord(sentence[k]) - ord('a')]\n        # 如果找到了一个单词，则结束循环\n        if is_word and node.is_word:\n            break\n        # 如果没有找到单词，则缩短当前的字符串\n        j -= 1\n    # 如果没有找到单词，则将当前字符作为一个单独的单词添加到结果中\n    if j == i:\n        result.append(sentence[i])\n        i += 1\n    else:\n        # 如果找到了单词，则将该单词添加到结果中\n        result.append(sentence[i:j])\n        i = j\n\n# 输出结果，单词之间以逗号分隔\nprint(\",\".join(result))",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm> // 添加这一行\n\nusing namespace std;\n\n// 定义 TrieNode 类，每个节点包含一个布尔值 isWord 和一个 TrieNode 类型的数组 children\nstruct TrieNode {\n    bool isWord;\n    TrieNode* children[26];\n\n    TrieNode() {\n        isWord = false;\n        for (int i = 0; i < 26; i++) {\n            children[i] = nullptr;\n        }\n    }\n};\n\n// 创建 Trie 的根节点\nTrieNode* root = new TrieNode();\n\n// 插入方法，用于向 Trie 中插入一个单词\nvoid insert(string word) {\n    TrieNode* node = root;\n    // 遍历单词中的每个字符\n    for (char c : word) {\n        // 如果当前字符对应的子节点为空，则创建一个新的子节点\n        if (node->children[c - 'a'] == nullptr) {\n            node->children[c - 'a'] = new TrieNode();\n        }\n        // 移动到下一个子节点\n        node = node->children[c - 'a'];\n    }\n    // 标记当前节点为一个单词的结束\n    node->isWord = true;\n}\n\nint main() {\n    // 读取输入的句子，并将其转换为小写\n    string sentence;\n    getline(cin, sentence);\n    transform(sentence.begin(), sentence.end(), sentence.begin(), ::tolower);\n\n    // 读取输入的字典，字典中的单词以逗号分隔\n    string dictionary;\n    getline(cin, dictionary);\n    stringstream ss(dictionary);\n    string word;\n    while (getline(ss, word, ',')) {\n        insert(word);\n    }\n\n    vector<string> result;\n    int i = 0;\n    // 遍历句子中的每个字符\n    while (i < sentence.size()) {\n        // 如果当前字符不是字母，则直接将其添加到结果中\n        if (!isalpha(sentence[i])) {\n            result.push_back(sentence.substr(i, 1));\n            i++;\n            continue;\n        }\n        int j = sentence.size();\n        // 从句子的末尾开始，寻找以 i 为起点的最长的在字典中存在的单词\n        while (j > i) {\n            TrieNode* node = root;\n            bool isWord = true;\n            for (int k = i; k < j; k++) {\n                // 如果当前字符不是字母，或者在 Trie 中不存在对应的子节点，则说明当前的字符串不是一个单词\n                if (!isalpha(sentence[k]) || node->children[sentence[k] - 'a'] == nullptr) {\n                    isWord = false;\n                    break;\n                }\n                // 移动到下一个子节点\n                node = node->children[sentence[k] - 'a'];\n            }\n            // 如果找到了一个单词，则结束循环\n            if (isWord && node->isWord) {\n                break;\n            }\n            // 如果没有找到单词，则缩短当前的字符串\n            j--;\n        }\n        // 如果没有找到单词，则将当前字符作为一个单独的单词添加到结果中\n        if (j == i) {\n            result.push_back(sentence.substr(i, 1));\n            i++;\n        } else {\n            // 如果找到了单词，则将该单词添加到结果中\n            result.push_back(sentence.substr(i, j - i));\n            i = j;\n        }\n    }\n\n    // 输出结果，单词之间以逗号分隔\n    for (int i = 0; i < result.size(); i++) {\n        if (i > 0) {\n            cout << \",\";\n        }\n        cout << result[i];\n    }\n    cout << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n// 定义 TrieNode 结构体，每个节点包含一个布尔值 isWord 和一个 TrieNode 类型的数组 children\nstruct TrieNode {\n    int isWord;\n    struct TrieNode* children[26];\n};\n\n// 创建 Trie 的根节点\nstruct TrieNode* root;\n\n// 插入方法，用于向 Trie 中插入一个单词\nvoid insert(char* word) {\n    struct TrieNode* node = root;\n    // 遍历单词中的每个字符\n    for (int i = 0; i < strlen(word); i++) {\n        char c = word[i];\n        // 如果当前字符对应的子节点为空，则创建一个新的子节点\n        if (node->children[c - 'a'] == NULL) {\n            node->children[c - 'a'] = (struct TrieNode*)calloc(1, sizeof(struct TrieNode));\n        }\n        // 移动到下一个子节点\n        node = node->children[c - 'a'];\n    }\n    // 标记当前节点为一个单词的结束\n    node->isWord = 1;\n}\n\nint main() {\n    root = (struct TrieNode*)calloc(1, sizeof(struct TrieNode));\n\n    // 读取输入的句子，并将其转换为小写\n    char sentence[1000];\n    fgets(sentence, 1000, stdin);\n    for (int i = 0; i < strlen(sentence); i++) {\n        sentence[i] = tolower(sentence[i]);\n    }\n\n    // 读取输入的字典，字典中的单词以逗号分隔\n    char dictionary[1000];\n    fgets(dictionary, 1000, stdin);\n    char* word = strtok(dictionary, \",\");\n    while (word != NULL) {\n        insert(word);\n        word = strtok(NULL, \",\");\n    }\n\n    char result[1000] = \"\";\n    int i = 0;\n    // 遍历句子中的每个字符\n    while (i < strlen(sentence)) {\n        // 如果当前字符不是字母，则直接将其添加到结果中\n        if (!isalpha(sentence[i])) {\n            strncat(result, &sentence[i], 1);\n            i++;\n            continue;\n        }\n        int j = strlen(sentence);\n        // 从句子的末尾开始，寻找以 i 为起点的最长的在字典中存在的单词\n        while (j > i) {\n            struct TrieNode* node = root;\n            int isWord = 1;\n            for (int k = i; k < j; k++) {\n                // 如果当前字符不是字母，或者在 Trie 中不存在对应的子节点，则说明当前的字符串不是一个单词\n                if (!isalpha(sentence[k]) || node->children[sentence[k] - 'a'] == NULL) {\n                    isWord = 0;\n                    break;\n                }\n                // 移动到下一个子节点\n                node = node->children[sentence[k] - 'a'];\n            }\n            // 如果找到了一个单词，则结束循环\n            if (isWord && node->isWord) {\n                break;\n            }\n            // 如果没有找到单词，则缩短当前的字符串\n            j--;\n        }\n        // 如果没有找到单词，则将当前字符作为一个单独的单词添加到结果中\n        if (j == i) {\n            strncat(result, &sentence[i], 1);\n            i++;\n        } else {\n            // 如果找到了单词，则将该单词添加到结果中\n            char temp[100];\n            strncpy(temp, &sentence[i], j - i);\n            temp[j - i] = '\\0';\n            strcat(result, temp);\n            i = j;\n        }\n        strcat(result, \",\");\n    }\n\n    // 输出结果，单词之间以逗号分隔\n    printf(\"%s\\n\", result);\n\n    return 0;\n}"
    }
  },
  {
    "id": "116",
    "title": "九宫格按键输入",
    "examType": "A",
    "score": 200,
    "description": "九宫格按键输入，输出显示内容，有英文和数字两个模式，默认是数字模式，数字模式直接输出数字，英文模式连续按同一个按键会依次出现这个按键上的字母，如果输入”/”或者其他字符，则循环中断。\n字符对应关系如图：\n\n要求输入一串按键，输出屏幕显示。\n#用于切换模式，默认是数字模式，执行#后切换为英文模式；/表示延迟，例如在英文模式下，输入 22/222，显示为 bc；英文模式下，多次按同一键，例如输入 22222，显示为 b；",
    "inputDesc": "输入范围为数字 0~9 和字符’#’、’/’，输出屏幕显示，例如，\n在数字模式下，输入 1234，显示 1234 在英文模式下，输入 1234，显示,adg\n在数字模式下，输入 1234，显示 1234\n在英文模式下，输入 1234，显示,adg",
    "outputDesc": "#用于切换模式，默认是数字模式，执行#后切换为英文模式；\n/表示延迟，例如在英文模式下，输入 22/222，显示为 bc；\n英文模式下，多次按同一键，例如输入 22222，显示为 b；",
    "examples": [
      {
        "input": "/22",
        "output": "",
        "explanation": "默认数字模式，字符直接显示，数字模式下/无序"
      },
      {
        "input": "#222235/56",
        "output": "adjjm",
        "explanation": "123,#进入英文模式，连续的数字输入会循环选择字母4个2输出a,35输出dj56输出jm"
      },
      {
        "input": "#2222/22",
        "output": "ab",
        "explanation": "#进入英文模式，连续的数字输入会循环选择字母，直至输入/，故第一段2222输入显示a，第二段22输入显示b"
      },
      {
        "input": "#222233",
        "output": "ae",
        "explanation": "#进入英文模式，连续的数字输入会循环选择字母，直至输入其他数字，故第一段2222输入显示a，第二段33输入显示e"
      }
    ],
    "solution": "这个题目要求将一串按键输入转换为屏幕上显示的内容，类似于老式手机的九宫格输入法。根据题目要求，输入有两种模式：数字模式和英文模式。程序默认从数字模式开始，按下 # 键后切换为英文模式，按 # 键可以在两种模式之间切换。/ 表示延迟操作，在英文模式下，用于区分同一个按键的不同字符输入。\n映射关系：首先要将每个数字键与对应的字符集合建立映射关系。例如，键 2 对应 “abc”，键 3 对应 “def” 等。这些映射关系会用于在英文模式下解数字模式处理： 如果当前是数字模式，直接将数字字符加入到结果中。 英文模式处理： 如果当前是英文模式，遇到数字字符时，判断连续相同的数字出现次数，并根据次数确定对应的字母。例如，连续按 2 三次表示 “c”。如果输入了 /，意味着在当前的英文模式下要延迟处理（即结束当前数字字符的连续输入），但不改变模式。 模式切换： 遇到 # 字符时，切换模式。如果当前是数字模式，切换到英文模式；如果当前是英文模式，切换回数字模式。\n如果当前是数字模式，直接将数字字符加入到结果中。\n如果当前是英文模式，遇到数字字符时，判断连续相同的数字出现次数，并根据次数确定对应的字母。例如，连续按 2 三次表示 “c”。如果输入了 /，意味着在当前的英文模式下要延迟处理（即结束当前数字字符的连续输入），但不改变模式。\n遇到 # 字符时，切换模式。如果当前是数字模式，切换到英文模式；如果当前是英文模式，切换回数字模式。",
    "codes": {
      "java": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String input_str = reader.readLine();\n\n        // 九宫格枚举信息\n        Map<Character, String> char_map = new HashMap<>();\n        char_map.put('0', \" \");\n        char_map.put('1', \",.\");\n        char_map.put('2', \"abc\");\n        char_map.put('3', \"def\");\n        char_map.put('4', \"ghi\");\n        char_map.put('5', \"jkl\");\n        char_map.put('6', \"mno\");\n        char_map.put('7', \"pqrs\");\n        char_map.put('8', \"tuv\");\n        char_map.put('9', \"wxyz\");\n\n        StringBuilder res = new StringBuilder();\n        // 默认是数字模式\n        int mode = 0;\n\n        for (int i = 0; i < input_str.length(); i++) {\n            char c = input_str.charAt(i);\n            if (Character.isDigit(c)) { // 如果是数字\n                if (mode == 0) { // 如果是数字模式，直接加入结果\n                    res.append(c);\n                } else if (mode == 1) { // 如果是字母模式\n                    int j = i;\n                    String tempstr = char_map.get(c);\n                    while (j < input_str.length() && input_str.charAt(j) == c) { // 统计连续出现的数字个数\n                        j++;\n                    }\n                    int index = (j - i - 1) % tempstr.length(); // 计算对应的字母下标\n                    res.append(tempstr.charAt(index)); // 加入结果\n                    i = j - 1; // 跳过已经处理的数字\n                }\n            } else if (c == '#') { // 如果是切换模式符号\n                mode = (mode + 1) % 2; // 切换模式\n            } else if (c == '/') { // 如果是延迟符号，不做处理\n                // 延迟，不做处理\n            } else { // 如果是其他字符，直接退出循环\n                break;\n            }\n        }\n        System.out.println(res.toString()); // 输出结果\n    }\n}",
      "python": "input_str = input().strip()\n\n# 九宫格枚举信息\nchar_map = {\n    '0': ' ',\n    '1': ',.',\n    '2': 'abc',\n    '3': 'def',\n    '4': 'ghi',\n    '5': 'jkl',\n    '6': 'mno',\n    '7': 'pqrs',\n    '8': 'tuv',\n    '9': 'wxyz'\n}\n\nres = \"\"\n# 默认是数字模式\nmode = 0\n\ni = 0\nwhile i < len(input_str):\n    c = input_str[i]\n    if c.isdigit():  # 如果是数字\n        if mode == 0:  # 如果是数字模式，直接加入结果\n            res += c\n        elif mode == 1:  # 如果是字母模式\n            j = i\n            tempstr = char_map[c]\n            while j < len(input_str) and input_str[j] == c:  # 统计连续出现的数字个数\n                j += 1\n            index = (j - i - 1) % len(tempstr)  # 计算对应的字母下标\n            res += tempstr[index]  # 加入结果\n            i = j - 1  # 跳过已经处理的数字\n    elif c == '#':  # 如果是切换模式符号\n        mode = (mode + 1) % 2  # 切换模式\n    elif c == '/':  # 如果是延迟符号，不做处理\n        pass\n    else:  # 如果是其他字符，直接退出循环\n        break\n    i += 1\n\nprint(res)  # 输出结果",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (input_str) => {\n  // 九宫格枚举信息\n  const char_map = new Map();\n  char_map.set('0', ' ');\n  char_map.set('1', ',.');\n  char_map.set('2', 'abc');\n  char_map.set('3', 'def');\n  char_map.set('4', 'ghi');\n  char_map.set('5', 'jkl');\n  char_map.set('6', 'mno');\n  char_map.set('7', 'pqrs');\n  char_map.set('8', 'tuv');\n  char_map.set('9', 'wxyz');\n\n  let res = '';\n  // 默认是数字模式\n  let mode = 0;\n\n  for (let i = 0; i < input_str.length; i++) {\n    const c = input_str.charAt(i);\n    if (/\\d/.test(c)) { // 如果是数字\n      if (mode === 0) { // 如果是数字模式，直接加入结果\n        res += c;\n      } else if (mode === 1) { // 如果是字母模式\n        let j = i;\n        const tempstr = char_map.get(c);\n        while (j < input_str.length && input_str.charAt(j) === c) { // 统计连续出现的数字个数\n          j++;\n        }\n        const index = (j - i - 1) % tempstr.length; // 计算对应的字母下标\n        res += tempstr.charAt(index); // 加入结果\n        i = j - 1; // 跳过已经处理的数字\n      }\n    } else if (c === '#') { // 如果是切换模式符号\n      mode = (mode + 1) % 2; // 切换模式\n    } else if (c === '/') { // 如果是延迟符号，不做处理\n      // 延迟，不做处理\n    } else { // 如果是其他字符，直接退出循环\n      break;\n    }\n  }\n  console.log(res); // 输出结果\n});",
      "cpp": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#include<map>\nusing namespace std;\n \nint main() {\n    string input_str;\n    cin >> input_str;\n    \n    // 九宫格枚举信息\n    map<char, string> char_map;\n    char_map['0'] = \" \";\n    char_map['1'] = \",.\";\n    char_map['2'] = \"abc\";\n    char_map['3'] = \"def\";\n    char_map['4'] = \"ghi\";\n    char_map['5'] = \"jkl\";\n    char_map['6'] = \"mno\";\n    char_map['7'] = \"pqrs\";\n    char_map['8'] = \"tuv\";\n    char_map['9'] = \"wxyz\";\n    \n    string res;\n    // 默认是数字模式\n    int mode = 0;\n    \n    for (int i = 0; i < input_str.size(); i++) {\n        char c = input_str[i];\n        if (isdigit(c)) { // 如果是数字\n            if (mode == 0) { // 如果是数字模式，直接加入结果\n                res.push_back(c);\n            } else if (mode == 1) { // 如果是字母模式\n                int j = i;\n                string tempstr = char_map[c];\n                while (j < input_str.size() && input_str[j] == c) { // 统计连续出现的数字个数\n                    j++;\n                }\n                int index = (j - i - 1) % tempstr.size(); // 计算对应的字母下标\n                res.push_back(tempstr[index]); // 加入结果\n                i = j - 1; // 跳过已经处理的数字\n            }\n        } else if (c == '#') { // 如果是切换模式符号\n            mode = (mode + 1) % 2; // 切换模式\n        } else if (c == '/') { // 如果是延迟符号，不做处理\n            // 延迟，不做处理\n        } else { // 如果是其他字符，直接退出循环\n            break;\n        }\n    }\n    cout << res << endl; // 输出结果\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n// 定义映射的结构体，用于存储数字与对应字符的映射\ntypedef struct {\n    char digit;\n    char *letters;\n} CharMap;\n\n// 主函数\nint main() {\n    char input_str[100];  // 定义输入字符串\n    scanf(\"%s\", input_str);  // 读取用户输入\n    \n    // 九宫格枚举信息，字符映射表\n    CharMap char_map[] = {\n        {'0', \" \"},\n        {'1', \",.\"},\n        {'2', \"abc\"},\n        {'3', \"def\"},\n        {'4', \"ghi\"},\n        {'5', \"jkl\"},\n        {'6', \"mno\"},\n        {'7', \"pqrs\"},\n        {'8', \"tuv\"},\n        {'9', \"wxyz\"}\n    };\n\n    char res[100];  // 存储结果字符串\n    int res_index = 0;  // 结果字符串的当前索引\n    int mode = 0;  // 模式，0表示数字模式，1表示字母模式\n    int input_len = strlen(input_str);  // 获取输入字符串的长度\n    \n    // 遍历输入的每个字符\n    for (int i = 0; i < input_len; i++) {\n        char c = input_str[i];  // 当前字符\n\n        // 判断当前字符是否为数字\n        if (isdigit(c)) {\n            if (mode == 0) {  // 数字模式，直接将字符加入结果\n                res[res_index++] = c;\n            } else if (mode == 1) {  // 字母模式\n                int j = i;\n                char *tempstr = NULL;  // 当前数字对应的字符集\n                for (int k = 0; k < 10; k++) {\n                    if (char_map[k].digit == c) {\n                        tempstr = char_map[k].letters;  // 获取该数字对应的字符集\n                        break;\n                    }\n                }\n                // 统计连续相同数字的个数\n                while (j < input_len && input_str[j] == c) {\n                    j++;\n                }\n                int index = (j - i - 1) % strlen(tempstr);  // 计算字母的索引\n                res[res_index++] = tempstr[index];  // 将对应的字母加入结果\n                i = j - 1;  // 跳过已经处理的字符\n            }\n        } else if (c == '#') {  // 切换模式符号\n            mode = (mode + 1) % 2;  // 切换模式\n        } else if (c == '/') {  // 延迟符号，不做处理\n            // 什么都不做，跳过该字符\n        } else {  // 非法字符，直接退出循环\n            break;\n        }\n    }\n    \n    res[res_index] = '\\0';  // 在结果字符串末尾加上结束符\n    printf(\"%s\\n\", res);  // 输出结果\n    \n    return 0;\n}"
    }
  },
  {
    "id": "117",
    "title": "二叉树计算",
    "examType": "A",
    "score": 200,
    "description": "给出一个二叉树如下图所示：\n\n请由该二叉树生成一个新的二叉树，它满足其树中的每个节点将包含原始树中的左子树和右子树的和。\n\n左子树表示该节点左侧叶子节点为根节点的一颗新树；右子树表示该节点右侧叶子节点为根节点的一颗新树。",
    "inputDesc": "2行整数，第1行表示二叉树的中序遍历，第2行表示二叉树的前序遍历，以空格分割。",
    "outputDesc": "1行整数，表示求和树的中序遍历，以空格分割",
    "examples": [
      {
        "input": "-3 12 6 8 9 -10 -7\n 12 -3 6 -10 9 -7",
        "output": "3 0 7 0 2 0",
        "explanation": ""
      }
    ],
    "solution": "本题主要考察二叉树的还原：根据中序和前序遍历还原。\n请注意：根据中序和前序遍历还原，二叉树可能并不是唯一的，因为如果一个树的节点值不是唯一的，那么可能存在多个有效的二叉树。\n在本题中，并没有说明存在多个值的处理方式，我们默认节点值是唯一的，也就是最终会还原出唯一的二叉树。",
    "codes": {
      "java": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n    // 方法：根据中序和前序遍历构造二叉树\n    // 参数：preorder 前序遍历的结果，inorder 中序遍历的结果\n    public static TreeNode buildTree(int[] preorder, int[] inorder) {\n        // 调用辅助方法，传入遍历结果和对应的开始结束索引\n        return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\n    }\n\n    // 定义树的节点结构\n    private static class TreeNode {\n        int val;  // 节点的值\n        TreeNode left;  // 左子节点\n        TreeNode right;  // 右子节点\n        TreeNode(int x) { val = x; }  // 构造方法\n    }\n\n    // 辅助方法：根据中序和前序遍历的一部分构造子树\n    private static TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {\n        // 如果前序遍历的开始索引大于结束索引，说明这部分遍历结果为空，返回null\n        if (preStart > preEnd) return null;\n        \n        // 创建根节点，值为前序遍历的第一个元素\n        TreeNode root = new TreeNode(preorder[preStart]);\n        int inIndex = 0; // 初始化中序遍历中根节点的索引\n        // 在中序遍历中找到根节点的位置\n        for (int i = inStart; i <= inEnd; i++) {\n            if (inorder[i] == root.val) {\n                inIndex = i;\n                break;\n            }\n        }\n        \n        // 计算左子树的大小\n        int leftTreeSize = inIndex - inStart;\n        \n        // 递归构造左子树和右子树\n        root.left = build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inIndex - 1);\n        root.right = build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inIndex + 1, inEnd);\n        \n        // 返回构造好的根节点\n        return root;\n    }\n\n    // 方法：更新节点值为其所有子节点的和\n    // 参数：node 需要更新的节点\n    private static int updateTree(TreeNode node) {\n        // 如果节点为空，返回0\n        if (node == null) return 0;\n        // 递归更新左子树和右子树，并计算子树的和\n        int leftSum = updateTree(node.left);\n        int rightSum = updateTree(node.right);\n        // 保存当前节点的值\n        int oldVal = node.val;\n        // 更新当前节点的值为子树的和\n        node.val = leftSum + rightSum;\n        // 返回当前子树的和（包括当前节点原来的值）\n        return node.val + oldVal;\n    }\n\n    // 方法：中序遍历\n    // 参数：node 需要遍历的节点，result 保存遍历结果的列表\n    private static void inorderTraversal(TreeNode node, ArrayList<Integer> result) {\n        // 如果节点为空，直接返回\n        if (node == null) return;\n        // 递归遍历左子树\n        inorderTraversal(node.left, result);\n        // 将当前节点的值添加到结果列表\n        result.add(node.val);\n        // 递归遍历右子树\n        inorderTraversal(node.right, result);\n    }\n\n    // 主方法\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        // 读取一行输入，分割成字符串数组，转换为整数数组，作为中序遍历的结果\n        int[] inorder = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 同样处理前序遍历的结果\n        int[] preorder = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 根据中序和前序遍历的结果构造二叉树\n        TreeNode root = buildTree(preorder, inorder);\n        // 更新二叉树的节点值\n        updateTree(root);\n        // 创建列表，保存中序遍历的结果\n        ArrayList<Integer> result = new ArrayList<>();\n        // 中序遍历二叉树，保存结果\n        inorderTraversal(root, result);\n        // 打印遍历结果\n        result.forEach(value -> System.out.print(value + \" \"));\n    }\n}",
      "python": "class TreeNode:\n    def __init__(self, x):\n        self.val = x  # 节点的值\n        self.left = None  # 左子节点\n        self.right = None  # 右子节点\n\ndef build_tree(preorder, inorder):\n    # 根据前序和中序遍历结果构造二叉树\n    if not preorder or not inorder:\n        return None\n    # 前序遍历的第一个值是根节点\n    root = TreeNode(preorder[0])\n    # 在中序遍历中找到根节点的索引\n    mid = inorder.index(preorder[0])\n    # 递归构造左子树和右子树\n    root.left = build_tree(preorder[1:mid+1], inorder[:mid])\n    root.right = build_tree(preorder[mid+1:], inorder[mid+1:])\n    return root\n\ndef update_tree(node):\n    # 更新节点值为其所有子节点的和\n    if not node:\n        return 0\n    left_sum = update_tree(node.left)\n    right_sum = update_tree(node.right)\n    old_val = node.val\n    node.val = left_sum + right_sum\n    return node.val + old_val\n\ndef inorder_traversal(node):\n    # 中序遍历\n    if not node:\n        return []\n    return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right)\n\nif __name__ == '__main__':\n    # 输入中序和前序遍历的结果\n    inorder = list(map(int, input().split()))\n    preorder = list(map(int, input().split()))\n    # 构造二叉树\n    root = build_tree(preorder, inorder)\n    # 更新二叉树的节点值\n    update_tree(root)\n    # 进行中序遍历并打印结果\n    print(' '.join(map(str, inorder_traversal(root))))",
      "javascript": "class TreeNode {\n    constructor(x) {\n        this.val = x;  // 节点的值\n        this.left = null;  // 左子节点\n        this.right = null;  // 右子节点\n    }\n}\n\nfunction buildTree(preorder, inorder) {\n    // 根据前序和中序遍历结果构造二叉树\n    if (!preorder.length || !inorder.length) {\n        return null;\n    }\n    let root = new TreeNode(preorder[0]);\n    let mid = inorder.indexOf(preorder[0]);\n    root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\n    root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\n    return root;\n}\n\nfunction updateTree(node) {\n    // 更新节点值为其所有子节点的和\n    if (!node) {\n        return 0;\n    }\n    let leftSum = updateTree(node.left);\n    let rightSum = updateTree(node.right);\n    let oldVal = node.val;\n    node.val = leftSum + rightSum;\n    return node.val + oldVal;\n}\n\nfunction inorderTraversal(node) {\n    // 中序遍历\n    if (!node) {\n        return [];\n    }\n    return inorderTraversal(node.left).concat([node.val]).concat(inorderTraversal(node.right));\n}\n\nlet readline = require('readline');\nlet rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet lines = [];\nrl.on('line', function (line) {\n    lines.push(line);\n    if (lines.length === 2) {\n        rl.close();\n    }\n});\n\nrl.on('close', function () {\n    let inorder = lines[0].split(' ').map(Number);\n    let preorder = lines[1].split(' ').map(Number);\n    let root = buildTree(preorder, inorder);\n    updateTree(root);\n    console.log(inorderTraversal(root).join(' '));\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n// 定义树的节点结构\nstruct TreeNode {\n    int val;  // 节点的值\n    TreeNode* left;  // 左子节点\n    TreeNode* right;  // 右子节点\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}  // 构造方法\n};\n\n// 辅助函数：根据中序和前序遍历的一部分构造子树\nTreeNode* build(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd) {\n    // 如果前序遍历的开始索引大于结束索引，说明这部分遍历结果为空，返回null\n    if (preStart > preEnd) return nullptr;\n    \n    // 创建根节点，值为前序遍历的第一个元素\n    TreeNode* root = new TreeNode(preorder[preStart]);\n    int inIndex = 0; // 初始化中序遍历中根节点的索引\n    // 在中序遍历中找到根节点的位置\n    for (int i = inStart; i <= inEnd; i++) {\n        if (inorder[i] == root->val) {\n            inIndex = i;\n            break;\n        }\n    }\n    \n    // 计算左子树的大小\n    int leftTreeSize = inIndex - inStart;\n    \n    // 递归构造左子树和右子树\n    root->left = build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inIndex - 1);\n    root->right = build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inIndex + 1, inEnd);\n    \n    // 返回构造好的根节点\n    return root;\n}\n\n// 方法：根据中序和前序遍历构造二叉树\n// 参数：preorder 前序遍历的结果，inorder 中序遍历的结果\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n    // 调用辅助方法，传入遍历结果和对应的开始结束索引\n    return build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);\n}\n\n// 方法：更新节点值为其所有子节点的和\n// 参数：node 需要更新的节点\nint updateTree(TreeNode* node) {\n    // 如果节点为空，返回0\n    if (node == nullptr) return 0;\n    // 递归更新左子树和右子树，并计算子树的和\n    int leftSum = updateTree(node->left);\n    int rightSum = updateTree(node->right);\n    // 保存当前节点的值\n    int oldVal = node->val;\n    // 更新当前节点的值为子树的和\n    node->val = leftSum + rightSum;\n    // 返回当前子树的和（包括当前节点原来的值）\n    return node->val + oldVal;\n}\n\n// 方法：中序遍历\n// 参数：node 需要遍历的节点，result 保存遍历结果的列表\nvoid inorderTraversal(TreeNode* node, vector<int>& result) {\n    // 如果节点为空，直接返回\n    if (node == nullptr) return;\n    // 递归遍历左子树\n    inorderTraversal(node->left, result);\n    // 将当前节点的值添加到结果列表\n    result.push_back(node->val);\n    // 递归遍历右子树\n    inorderTraversal(node->right, result);\n}\n\n// 主函数\nint main() {\n    string line;\n    vector<int> inorder;\n    vector<int> preorder;\n\n    // 读取一行输入，分割成字符串数组，转换为整数数组，作为中序遍历的结果\n    getline(cin, line);\n    istringstream iss(line);\n    int num;\n    while (iss >> num) {\n        inorder.push_back(num);\n    }\n\n    // 同样处理前序遍历的结果\n    getline(cin, line);\n    istringstream iss2(line);\n    while (iss2 >> num) {\n        preorder.push_back(num);\n    }\n\n    // 根据中序和前序遍历的结果构造二叉树\n    TreeNode* root = buildTree(preorder, inorder);\n    // 更新二叉树的节点值\n    updateTree(root);\n    // 创建列表，保存中序遍历的结果\n    vector<int> result;\n    // 中序遍历二叉树，保存结果\n    inorderTraversal(root, result);\n    // 打印遍历结果\n    for (int i : result) {\n        cout << i << \" \";\n    }\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 定义树的节点结构体\ntypedef struct TreeNode {\n    int val;  // 节点的值\n    struct TreeNode* left;  // 左子节点\n    struct TreeNode* right;  // 右子节点\n} TreeNode;\n\n// 创建一个新的树节点\nTreeNode* newTreeNode(int x) {\n    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));  // 分配内存\n    node->val = x;  // 设置节点的值\n    node->left = NULL;  // 设置左子节点为空\n    node->right = NULL;  // 设置右子节点为空\n    return node;  // 返回新创建的节点\n}\n\n// 根据前序和中序遍历结果构建子树\nTreeNode* build(int* preorder, int preStart, int preEnd, int* inorder, int inStart, int inEnd) {\n    if (preStart > preEnd) return NULL;  // 如果前序遍历的开始位置大于结束位置，说明子树为空，返回NULL\n    \n    // 创建根节点，根节点的值就是前序遍历的第一个元素\n    TreeNode* root = newTreeNode(preorder[preStart]);\n    int inIndex = 0;  // 初始化中序遍历中根节点的位置\n    // 在中序遍历中找到根节点的位置\n    for (int i = inStart; i <= inEnd; i++) {\n        if (inorder[i] == root->val) {\n            inIndex = i;\n            break;\n        }\n    }\n    \n    // 计算左子树的大小\n    int leftTreeSize = inIndex - inStart;\n    // 递归构建左子树和右子树\n    root->left = build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inIndex - 1);\n    root->right = build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inIndex + 1, inEnd);\n    \n    return root;  // 返回构建好的子树\n}\n\n// 根据前序和中序遍历结果构建二叉树\nTreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {\n    return build(preorder, 0, preorderSize - 1, inorder, 0, inorderSize - 1);  // 调用build函数\n}\n\n// 更新树的节点值为其子树之和\nint updateTree(TreeNode* node) {\n    if (node == NULL) return 0;  // 如果节点为空，返回0\n    // 递归更新左子树和右子树，并计算子树的和\n    int leftSum = updateTree(node->left);\n    int rightSum = updateTree(node->right);\n    // 保存当前节点的值\n    int oldVal = node->val;\n    // 更新当前节点的值为子树的和\n    node->val = leftSum + rightSum;\n    // 返回当前子树的和（包括当前节点原来的值）\n    return node->val + oldVal;\n}\n\n// 中序遍历\nvoid inorderTraversal(TreeNode* node, int* result, int* resultSize) {\n    if (node == NULL) return;  // 如果节点为空，直接返回\n    // 递归遍历左子树\n    inorderTraversal(node->left, result, resultSize);\n    // 将当前节点的值添加到结果数组\n    result[(*resultSize)++] = node->val;\n    // 递归遍历右子树\n    inorderTraversal(node->right, result, resultSize);\n}\n\n// 主函数\nint main() {\n    int preorderSize = 0, inorderSize = 0;  // 初始化前序和中序遍历结果的大小\n    int preorder[10000], inorder[10000];  // 前序和中序遍历结果数组\n\n    // 读取中序遍历结果\n    while (scanf(\"%d\", &inorder[inorderSize++])) {\n        if (getchar() != ' ') break;  // 如果读取到的不是空格，说明输入结束，跳出循环\n    }\n\n    // 读取前序遍历结果\n    while (scanf(\"%d\", &preorder[preorderSize++])) {\n        if (getchar() != ' ') break;  // 如果读取到的不是空格，说明输入结束，跳出循环\n    }\n\n    // 根据前序和中序遍历结果构建二叉树\n    TreeNode* root = buildTree(preorder, preorderSize, inorder, inorderSize);\n    // 更新二叉树的节点值\n    updateTree(root);\n    // 创建数组，保存中序遍历的结果\n    int result[10000];\n    int resultSize = 0;\n    // 中序遍历二叉树，保存结果\n    inorderTraversal(root, result, &resultSize);\n    // 打印遍历结果\n    for (int i = 0; i < resultSize; i++) {\n        printf(\"%d \", result[i]);\n    }\n\n    // 释放分配的内存（在实际应用中应递归释放整个树的节点）\n    return 0;\n}"
    }
  },
  {
    "id": "118",
    "title": "云短信平台优惠活动",
    "examType": "A",
    "score": 200,
    "description": "某云短信厂商，为庆祝国庆，推出充值优惠活动。 现在给出客户预算，和优惠售价序列，求最多可获得的短信总条数。",
    "inputDesc": "第一行客户预算M，其中 0 ≤ M ≤ 10^6\n第二行给出售价表， P1, P2, … Pn , 其中 1 ≤ n ≤ 100 ,\nPi为充值 i 元获得的短信条数。1 ≤ Pi ≤ 1000 , 1 ≤ n ≤ 100",
    "outputDesc": "最多获得的短信条数",
    "examples": [
      {
        "input": "20 30 40 60",
        "output": "",
        "explanation": "分两次充值最优， 1 元、 5 元各充一次。总条数 10 + 60 = 70"
      },
      {
        "input": "20 30 40 60 60 70 80 90 150",
        "output": "",
        "explanation": "分两次充值最优， 10 元 5 元各充一次，总条数 150 + 60 = 210"
      }
    ],
    "solution": "本题是完全背包问题。\n客户预算M相当于背包的承重，出售价表：\ni 元相当于物品的重量，Pi 短信条数相当于物品的价值",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 处理输入\n        Scanner in = new Scanner(System.in);\n        int money = Integer.parseInt(in.nextLine());\n        int[] topupInfo = Arrays.stream(in.nextLine().split(\" \"))\n                .mapToInt(Integer::parseInt)\n                .toArray();\n\n        int[] dp = new int[money + 1];\n\n        for (int i = 0; i < topupInfo.length; i++) {\n            for (int j = i + 1; j <= money; j++) {\n                dp[j] = Math.max(dp[j], dp[j - (i + 1)] + topupInfo[i]);\n            }\n        }\n        System.out.println(dp[money]);\n    }\n}",
      "python": "def main():\n    # 处理输入\n    money = int(input())\n    topup_info = list(map(int, input().split()))\n\n    dp = [0] * (money + 1)\n\n    for i in range(len(topup_info)):\n        for j in range(i + 1, money + 1):\n            dp[j] = max(dp[j], dp[j - (i + 1)] + topup_info[i])\n\n    print(dp[money])\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (line) => {\n  const inputs = line.split(' ');\n  if (inputs.length === 1) {\n    const money = parseInt(inputs[0]);\n    rl.on('line', (line) => {\n      const topupInfo = line.split(' ').map(Number);\n      const dp = new Array(money + 1).fill(0);\n\n      for (let i = 0; i < topupInfo.length; i++) {\n        for (let j = i + 1; j <= money; j++) {\n          dp[j] = Math.max(dp[j], dp[j - (i + 1)] + topupInfo[i]);\n        }\n      }\n      console.log(dp[money]);\n      rl.close();\n    });\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\nint main() {\n    // 处理输入\n    int money;\n    cin >> money;\n    cin.ignore();\n\n    string line;\n    getline(cin, line);\n    istringstream iss(line);\n    vector<int> topup_info;\n    int value;\n\n    while (iss >> value) {\n        topup_info.push_back(value);\n    }\n\n    vector<int> dp(money + 1, 0);\n\n    for (size_t i = 0; i < topup_info.size(); i++) {\n        for (int j = static_cast<int>(i) + 1; j <= money; j++) {\n            dp[j] = max(dp[j], dp[j - (i + 1)] + topup_info[i]);\n        }\n    }\n    cout << dp[money] << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n \nint main() {\n    int money;\n  \n    scanf(\"%d\", &money);\n\n    // 定义售价表数组，并读取售价表\n    int topupInfo[100];\n    int n = 0;\n    while (scanf(\"%d\", &topupInfo[n]) != EOF) {\n        n++;\n    }\n \n    int dp[1001] = {0};\n\n    // 遍历每一个充值选项\n    for (int i = 0; i < n; i++) {\n        // 从当前预算开始，向后更新 dp 数组\n        for (int j = i + 1; j <= money; j++) {\n            // 更新 dp[j] 为在充值 i+1 元的情况下获得的最大短信数\n            dp[j] = dp[j] > dp[j - (i + 1)] + topupInfo[i] ? dp[j] : dp[j - (i + 1)] + topupInfo[i];\n        }\n    }\n\n    // 输出在预算 money 下最多可获得的短信条数\n    printf(\"%d\\n\", dp[money]);\n\n    return 0;\n}"
    }
  },
  {
    "id": "119",
    "title": "可以处理的最大任务数",
    "examType": "A",
    "score": 200,
    "description": "在某个项目中有多个任务(用tasks数组表示)需要您进行处理，其中tasks[i]=[si,ei],你可以在si <= day <= ei中的任意一天处理该任务，请返回你可以处理的最大任务数",
    "inputDesc": "第一行为任务数量n，1 <=n<= 100000。后面n行表示各个任务的开始时间和终止时间，使用si,ei表示,1 <= si <= ei <= 100000",
    "outputDesc": "输出为一个整数，表示可以处理的最大任务数。\n输入\n输出",
    "examples": [],
    "solution": "贪心算法原则：每一步选择当前情况下最优的选择（这里是选择结束时间最早的任务），以达到全局最优解。这种方法适用于任务调度问题，因为优先完成结束时间早的任务可以为后续任务腾出更多时间。 使用优先队列： 优先队列特性：自动根据任务的结束时间进行排序，保证每次取出的都是结束时间最早的任务。应用：在处理任务时，将所有任务按开始时间存入列表（数组的每个元素是一个列表，对应于该开始时间的所有任务）。然后，遍历每个时间点，将该时间点开始的所有任务加入优先队列。这样，优先队列总是包含当前可执行的任务，且队首是最优先执行的任务。 任务调度： 移除过期任务：在每个时间点，首先检查优先队列中是否有已经结束的任务（即结束时间小于当前时间的任务），将这些任务从队列中移除。这一步确保队列中的任务都是未完成且可执行的。加入新任务：将当前时间点开始的所有任务加入优先队列。这些任务现在是候选任务，准备被执行。执行任务：如果优先队列不为空，说明有可执行的任务。从队列中取出（移除）一个任务执行，即完成一个任务，完成任务的计数加一。按照贪心原则，这个任务是当前所有可执行任务中结束时间最早的。 总结：通过贪心算法选择每一步的最优解（结束时间最早的任务），并利用优先队列自动维护任务的执行顺序，可以有效地解决任务调度问题，最大化完成的任务数量。\n贪心算法原则：每一步选择当前情况下最优的选择（这里是选择结束时间最早的任务），以达到全局最优解。这种方法适用于任务调度问题，因为优先完成结束时间早的任务可以为后续任务腾出更多时间。\n使用优先队列：\n优先队列特性：自动根据任务的结束时间进行排序，保证每次取出的都是结束时间最早的任务。应用：在处理任务时，将所有任务按开始时间存入列表（数组的每个元素是一个列表，对应于该开始时间的所有任务）。然后，遍历每个时间点，将该时间点开始的所有任务加入优先队列。这样，优先队列总是包含当前可执行的任务，且队首是最优先执行的任务。\n任务调度：\n移除过期任务：在每个时间点，首先检查优先队列中是否有已经结束的任务（即结束时间小于当前时间的任务），将这些任务从队列中移除。这一步确保队列中的任务都是未完成且可执行的。加入新任务：将当前时间点开始的所有任务加入优先队列。这些任务现在是候选任务，准备被执行。执行任务：如果优先队列不为空，说明有可执行的任务。从队列中取出（移除）一个任务执行，即完成一个任务，完成任务的计数加一。按照贪心原则，这个任务是当前所有可执行任务中结束时间最早的。\n总结：通过贪心算法选择每一步的最优解（结束时间最早的任务），并利用优先队列自动维护任务的执行顺序，可以有效地解决任务调度问题，最大化完成的任务数量。",
    "codes": {
      "java": "import java.util.*;\n\nclass Main {\n    // 定义一个Task类来存储每个任务的开始时间和结束时间\n    static class Task {\n        int startTime;  // 任务开始时间\n        int endTime;    // 任务结束时间\n\n        // Task类的构造函数，用于初始化任务的开始时间和结束时间\n        Task(int startTime, int endTime) {\n            this.startTime = startTime;\n            this.endTime = endTime;\n        }\n    }\n\n    // 创建一个List数组，用于存储所有的任务，每个时间点对应一个任务列表\n    static List<Task>[] a = new List[100001];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); // 读取任务的总数\n        \n        // 初始化任务列表数组\n        for (int i = 0; i < 100001; i++) {\n            a[i] = new ArrayList<>();\n        }\n\n        // 读取每个任务的开始时间和结束时间，并将其添加到对应的任务列表中\n        for (int i = 0; i < n; i++) { \n            int x = sc.nextInt(); // 任务开始时间\n            int y = sc.nextInt(); // 任务结束时间\n            a[x].add(new Task(x, y)); // 创建任务并添加到任务列表中\n        }\n\n         \n        int ans = 0; // 用于记录能完成的任务数量\n        // 创建一个优先队列，根据任务的结束时间进行排序，确保每次都处理结束时间最早的任务\n        PriorityQueue<Task> pq = new PriorityQueue<>(Comparator.comparingInt(t -> t.endTime));\n\n        // 遍历每个时间点\n        for (int i = 0; i < 100001; i++) {\n            // 如果优先队列不为空且队列顶部的任务结束时间小于当前时间，则将其移除\n            while (!pq.isEmpty() && pq.peek().endTime < i) {\n                pq.poll();\n            }\n\n            // 如果当前时间点有任务\n            if (a[i] != null) {\n                // 将当前时间点的所有任务加入优先队列\n                for (Task task : a[i]) {\n                    pq.add(task);\n                }\n            }\n\n            // 如果优先队列不为空，则从队列中移除一个任务，并将完成任务的数量加一\n            if (!pq.isEmpty()) {\n                ans++;\n                pq.poll();\n            }\n        }\n\n        // 输出能完成的任务数量\n        System.out.println(ans);\n    }\n}",
      "python": "import heapq  # 导入heapq模块用于实现优先队列\n\n# 定义一个Task类来存储每个任务的开始时间和结束时间\nclass Task:\n    def __init__(self, startTime, endTime):\n        self.startTime = startTime  # 任务开始时间\n        self.endTime = endTime      # 任务结束时间\n\n    def __lt__(self, other):\n        # 定义小于操作，用于优先队列中比较Task对象，根据结束时间进行排序\n        return self.endTime < other.endTime\n\n# 创建一个列表，用于存储所有的任务，每个时间点对应一个任务列表\na = [[] for _ in range(100001)]\n\n# 读取任务的总数\nn = int(input())\n\n# 读取每个任务的开始时间和结束时间，并将其添加到对应的任务列表中\nfor _ in range(n):\n    x, y = map(int, input().split())  # 读取任务开始时间和结束时间\n    a[x].append(Task(x, y))  # 创建任务并添加到任务列表中\n\nans = 0  # 用于记录能完成的任务数量\n# 创建一个优先队列，根据任务的结束时间进行排序，确保每次都处理结束时间最早的任务\npq = []\n\n# 遍历每个时间点\nfor i in range(100001):\n    # 如果优先队列不为空且队列顶部的任务结束时间小于当前时间，则将其移除\n    while pq and pq[0].endTime < i:\n        heapq.heappop(pq)\n\n    # 如果当前时间点有任务\n    for task in a[i]:\n        # 将当前时间点的所有任务加入优先队列\n        heapq.heappush(pq, task)\n\n    # 如果优先队列不为空，则从队列中移除一个任务，并将完成任务的数量加一\n    if pq:\n        ans += 1\n        heapq.heappop(pq)\n\n# 输出能完成的任务数量\nprint(ans)",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n// 定义一个Task结构体来存储每个任务的开始时间和结束时间\nstruct Task {\n    int startTime;  // 任务开始时间\n    int endTime;    // 任务结束时间\n\n    // Task结构体的构造函数，用于初始化任务的开始时间和结束时间\n    Task(int start, int end) : startTime(start), endTime(end) {}\n};\n\n// 比较函数，用于优先队列根据任务的结束时间进行排序\nstruct compare {\n    bool operator()(const Task& a, const Task& b) {\n        return a.endTime > b.endTime;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n; // 读取任务的总数\n\n    // 使用vector来动态存储任务列表，每个时间点对应一个任务列表\n    vector<vector<Task>> tasks(100001);\n\n    // 读取每个任务的开始时间和结束时间，并将其添加到对应的任务列表中\n    for (int i = 0; i < n; i++) {\n        int startTime, endTime;\n        cin >> startTime >> endTime;\n        tasks[startTime].emplace_back(startTime, endTime);\n    }\n\n    priority_queue<Task, vector<Task>, compare> pq; // 创建一个优先队列\n\n    int ans = 0; // 用于记录能完成的任务数量\n\n    // 遍历每个时间点\n    for (int i = 0; i < 100001; i++) {\n        // 如果优先队列不为空且队列顶部的任务结束时间小于当前时间，则将其移除\n        while (!pq.empty() && pq.top().endTime < i) {\n            pq.pop();\n        }\n\n        // 将当前时间点的所有任务加入优先队列\n        for (const auto& task : tasks[i]) {\n            pq.push(task);\n        }\n\n        // 如果优先队列不为空，则从队列中移除一个任务，并将完成任务的数量加一\n        if (!pq.empty()) {\n            ans++;\n            pq.pop();\n        }\n    }\n\n    cout << ans << endl; // 输出能完成的任务数量\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 定义任务结构体，用于存储每个任务的开始时间和结束时间\ntypedef struct {\n    int startTime;  // 任务开始时间\n    int endTime;    // 任务结束时间\n} Task;\n\n// 优先队列的比较函数，用于比较两个任务的结束时间\nint cmp(const void *a, const void *b) {\n    Task *taskA = (Task *)a;\n    Task *taskB = (Task *)b;\n    return taskA->endTime - taskB->endTime;\n}\n\n// 定义任务列表，每个时间点对应一个任务列表\nTask *tasks[100001];\nint taskCounts[100001] = {0}; // 存储每个时间点任务的数量\n\nint main() {\n    int n; // 任务总数\n    scanf(\"%d\", &n);\n\n    // 读取每个任务的开始时间和结束时间，并将其添加到对应的任务列表中\n    for (int i = 0; i < n; i++) {\n        int x, y; // 任务开始时间和结束时间\n        scanf(\"%d %d\", &x, &y);\n        Task newTask = {x, y}; // 创建新任务\n        tasks[x] = (Task *)realloc(tasks[x], (taskCounts[x] + 1) * sizeof(Task)); // 为新任务分配空间\n        tasks[x][taskCounts[x]] = newTask; // 将新任务添加到列表中\n        taskCounts[x]++; // 更新任务数量\n    }\n\n    int ans = 0; // 用于记录能完成的任务数量\n    Task pq[100001]; // 创建一个优先队列\n    int pqSize = 0; // 优先队列的大小\n\n    // 遍历每个时间点\n    for (int i = 0; i < 100001; i++) {\n        // 如果优先队列不为空且队列顶部的任务结束时间小于当前时间，则将其移除\n        while (pqSize > 0 && pq[0].endTime < i) {\n            pq[0] = pq[--pqSize]; // 移除队列顶部的任务\n            qsort(pq, pqSize, sizeof(Task), cmp); // 重新排序优先队列\n        }\n\n        // 如果当前时间点有任务\n        if (taskCounts[i] > 0) {\n            // 将当前时间点的所有任务加入优先队列\n            for (int j = 0; j < taskCounts[i]; j++) {\n                pq[pqSize++] = tasks[i][j];\n                qsort(pq, pqSize, sizeof(Task), cmp); // 重新排序优先队列\n            }\n        }\n\n        // 如果优先队列不为空，则从队列中移除一个任务，并将完成任务的数量加一\n        if (pqSize > 0) {\n            ans++;\n            pq[0] = pq[--pqSize]; // 移除队列顶部的任务\n            qsort(pq, pqSize, sizeof(Task), cmp); // 重新排序优先队列\n        }\n    }\n\n    // 输出能完成的任务数量\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
    }
  },
  {
    "id": "120",
    "title": "字符串拼接",
    "examType": "A",
    "score": 200,
    "description": "给定 M（0 < M ≤ 30）个字符（a-z），从中取出任意字符（每个字符只能用一次）拼接成长度为 N（0 < N ≤ 5）的字符串，\n要求相同的字符不能相邻，计算出给定的字符列表能拼接出多少种满足条件的字符串，\n输入非法或者无法拼接出满足条件的字符串则返回0。",
    "inputDesc": "给定的字符列表和结果字符串长度，中间使用空格(\" \")拼接",
    "outputDesc": "满足条件的字符串个数\n输入\n输出\n说明\n只能构成ab,ba。\n输入\n输出\n说明\n可以构成：ab ac ba bc ca cb 。",
    "examples": [],
    "solution": "使用递归和回溯的思想来生成不同的字符串。具体的逻辑如下：\n首先，我们定义一个函数generateDistinctStrings，这个函数接收以下参数：可用字符集s，目标字符串长度length，当前已生成的字符串current，已生成的结果集result，以及一个标记数组used，用来记录每个字符是否已被使用。 在generateDistinctStrings函数中，首先检查当前已生成的字符串current的长度是否等于目标长度length。如果等于，说明我们已经生成了一个满足长度要求的字符串，将其添加到结果集result中，然后返回。 如果当前字符串current的长度还未达到目标长度length，我们就需要继续添加字符。此时，我们遍历可用字符集s中的每一个字符。对于每一个字符，我们首先检查它是否已经被使用（通过查看used数组），以及它是否与current的最后一个字符相同。如果字符已经被使用，或者与current的最后一个字符相同，我们就跳过这个字符，继续检查下一个字符。 如果一个字符未被使用，且与current的最后一个字符不同，我们就将它添加到current的末尾，然后标记这个字符为已使用，接着递归调用generateDistinctStrings函数，以生成下一个字符。 在递归调用返回后，我们需要取消对当前字符的使用标记，以便在后续的遍历中可以再次使用这个字符。这就是回溯的思想，即撤销之前的选择，尝试其他的选择。\n首先，我们定义一个函数generateDistinctStrings，这个函数接收以下参数：可用字符集s，目标字符串长度length，当前已生成的字符串current，已生成的结果集result，以及一个标记数组used，用来记录每个字符是否已被使用。\n在generateDistinctStrings函数中，首先检查当前已生成的字符串current的长度是否等于目标长度length。如果等于，说明我们已经生成了一个满足长度要求的字符串，将其添加到结果集result中，然后返回。\n如果当前字符串current的长度还未达到目标长度length，我们就需要继续添加字符。此时，我们遍历可用字符集s中的每一个字符。对于每一个字符，我们首先检查它是否已经被使用（通过查看used数组），以及它是否与current的最后一个字符相同。如果字符已经被使用，或者与current的最后一个字符相同，我们就跳过这个字符，继续检查下一个字符。\n如果一个字符未被使用，且与current的最后一个字符不同，我们就将它添加到current的末尾，然后标记这个字符为已使用，接着递归调用generateDistinctStrings函数，以生成下一个字符。\n在递归调用返回后，我们需要取消对当前字符的使用标记，以便在后续的遍历中可以再次使用这个字符。这就是回溯的思想，即撤销之前的选择，尝试其他的选择。\n以下是对应的中文伪代码：\n12345678910",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个Scanner对象来读取用户的输入\n        Scanner sc = new Scanner(System.in);\n        // 读取用户输入的字符串\n        String input = sc.nextLine();\n        // 将输入的字符串按空格分割为两部分，分别为字符串和长度\n        String[] parts = input.split(\" \");\n        String str = parts[0]; // 获取输入的字符串\n        int length = Integer.parseInt(parts[1]); // 将输入的长度部分转换为整数\n\n        // 调用countDistinctStrings方法计算满足条件的不同字符串的数量\n        int count = countDistinctStrings(str, length);\n        // 输出计算结果\n        System.out.println(count);\n    }\n\n    // 计算满足条件的不同字符串的数量\n    public static int countDistinctStrings(String str, int length) {\n        // 创建一个HashSet来存储不同的字符串\n        HashSet<String> set = new HashSet<>();\n        // 创建一个boolean数组来标记字符串中的字符是否已经被使用\n        boolean[] used = new boolean[str.length()];\n        // 调用generateDistinctStrings方法生成满足条件的不同字符串\n        generateDistinctStrings(str, length, \"\", set, used);\n        // 打印生成的所有不同的字符串\n        // for(String str1 : set){\n           // System.out.println(str1);\n        // }\n        // 返回不同字符串的数量\n        return set.size();\n    }\n\n    // 递归生成满足条件的不同字符串\n    public static void generateDistinctStrings(String str, int length, String current, HashSet<String> set, boolean[] used) {\n        // 当生成的字符串长度等于指定长度时，将其加入到HashSet中\n        if (current.length() == length) {\n            set.add(current);\n            return;\n        }\n\n        // 遍历字符串中的字符\n        for (int i = 0; i < str.length(); i++) {\n            // 判断字符是否已经被使用，或者当前字符与前一个字符相同\n            if (used[i] || (current.length() > 0 && current.charAt(current.length() - 1) == str.charAt(i))) {\n                continue; // 如果字符已被使用或与前一个字符相同，则跳过当前字符\n            }\n            used[i] = true; // 标记当前字符为已使用\n            // 递归调用生成下一个字符\n            generateDistinctStrings(str, length, current + str.charAt(i), set, used);\n            used[i] = false; // 取消标记当前字符的使用状态，以便下一次遍历\n        }\n    }\n}",
      "python": "# 导入所需的模块\nfrom collections import defaultdict\n\n# 递归生成满足条件的不同字符串\ndef generate_distinct_strings(s, length, current, result, used):\n    # 当生成的字符串长度等于指定长度时，将其加入到结果集中\n    if len(current) == length:\n        result.add(current)\n        return\n\n    # 遍历字符串中的字符\n    for i in range(len(s)):\n        # 判断字符是否已经被使用，或者当前字符与前一个字符相同\n        if used[i] or (len(current) > 0 and current[-1] == s[i]):\n            continue  # 如果字符已被使用或与前一个字符相同，则跳过当前字符\n        used[i] = True  # 标记当前字符为已使用\n        # 递归调用生成下一个字符\n        generate_distinct_strings(s, length, current + s[i], result, used)\n        used[i] = False  # 取消标记当前字符的使用状态，以便下一次遍历\n\n# 计算满足条件的不同字符串的数量\ndef count_distinct_strings(s, length):\n    # 创建一个集合来存储不同的字符串\n    distinct_strings = set()\n    # 创建一个列表来标记字符串中的字符是否已经被使用\n    used = [False] * len(s)\n    # 调用generate_distinct_strings方法生成满足条件的不同字符串\n    generate_distinct_strings(s, length, \"\", distinct_strings, used)\n    # 打印生成的所有不同的字符串\n    # for string in distinct_strings:\n       # print(string)\n    # 返回不同字符串的数量\n    return len(distinct_strings)\n\n# 读取用户输入的字符串\ninput_str = input()\n# 将输入的字符串按空格分割为两部分，分别为字符串和长度\nparts = input_str.split(\" \")\ns = parts[0]  # 获取输入的字符串\nlength = int(parts[1])  # 将输入的长度部分转换为整数\n\n# 调用count_distinct_strings方法计算满足条件的不同字符串的数量\ncount = count_distinct_strings(s, length)\n# 输出计算结果\nprint(count)",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <unordered_set>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\n// 递归生成满足条件的不同字符串\nvoid generateDistinctStrings(string s, int length, string current, unordered_set<string>& result, vector<bool>& used) {\n    // 当生成的字符串长度等于指定长度时，将其加入到结果集中\n    if (current.length() == length) {\n        result.insert(current);\n        return;\n    }\n\n    // 遍历字符串中的字符\n    for (int i = 0; i < s.length(); i++) {\n        // 判断字符是否已经被使用，或者当前字符与前一个字符相同\n        if (used[i] || (current.length() > 0 && current.back() == s[i])) {\n            continue;  // 如果字符已被使用或与前一个字符相同，则跳过当前字符\n        }\n        used[i] = true;  // 标记当前字符为已使用\n        // 递归调用生成下一个字符\n        generateDistinctStrings(s, length, current + s[i], result, used);\n        used[i] = false;  // 取消标记当前字符的使用状态，以便下一次遍历\n    }\n}\n\n// 计算满足条件的不同字符串的数量\nint countDistinctStrings(string s, int length) {\n    // 创建一个集合来存储不同的字符串\n    unordered_set<string> distinctStrings;\n    // 创建一个列表来标记字符串中的字符是否已经被使用\n    vector<bool> used(s.length(), false);\n    // 调用generateDistinctStrings方法生成满足条件的不同字符串\n    generateDistinctStrings(s, length, \"\", distinctStrings, used);\n    // 打印生成的所有不同的字符串\n    // for (auto& str : distinctStrings) {\n       // cout << str << endl;\n    // }\n    // 返回不同字符串的数量\n    return distinctStrings.size();\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n    // 将输入的字符串按空格分割为两部分，分别为字符串和长度\n    string str;\n    int length;\n    istringstream iss(input);\n    iss >> str >> length;\n\n    // 调用countDistinctStrings方法计算满足条件的不同字符串的数量\n    int count = countDistinctStrings(str, length);\n    // 输出计算结果\n    cout <<  count << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 31\n\nchar inputString[MAX_SIZE];  // 存储输入的字符串\nint stringLength;            // 存储输入字符串的长度\nint targetLength;            // 目标排列的长度\nint validCount = 0;          // 符合条件的排列个数\n\n// 比较函数，用于qsort\nint compare(const void *a, const void *b) {\n    return (*(char *)a - *(char *)b);\n}\n\nvoid generateDistinctStrings(int lastUsedIndex, int currentLength, int usedFlags[]) {\n    if (currentLength == targetLength) {\n        validCount++;\n        return;\n    }\n\n    for (int i = 0; i < stringLength; i++) {\n        if (usedFlags[i]) continue;\n        if (lastUsedIndex >= 0 && inputString[i] == inputString[lastUsedIndex]) continue;\n        // 优化的树层去重逻辑\n        if (i > 0 && inputString[i] == inputString[i - 1] && !usedFlags[i - 1]) continue;\n\n        usedFlags[i] = 1;\n        generateDistinctStrings(i, currentLength + 1, usedFlags);\n        usedFlags[i] = 0;\n    }\n}\n\nint main() {\n    scanf(\"%s %d\", inputString, &targetLength);\n    stringLength = strlen(inputString);\n\n    // 对输入字符串排序\n    qsort(inputString, stringLength, sizeof(char), compare);\n\n    int usedFlags[MAX_SIZE] = {0};\n    generateDistinctStrings(-1, 0, usedFlags);\n\n    printf(\"%d\\n\", validCount);\n\n    return 0;\n}"
    }
  },
  {
    "id": "121",
    "title": "宜居星球改造计划",
    "examType": "A",
    "score": 200,
    "description": "2XXX年，人类通过对火星的大气进行宜居改造分析，使得火星已在理论上具备人类宜居的条件；\n由于技术原因，无法一次性将火星大气全部改造，只能通过局部处理形式；\n假设将火星待改造的区域为row * column的网格，每个网格有3个值，宜居区、可改造区、死亡区，使用YES、NO、NA代替，YES表示该网格已经完成大气改造，NO表示该网格未进行改造，后期可进行改造，NA表示死亡区，不作为判断是否改造完的宜居，无法穿过；\n初始化下，该区域可能存在多个宜居区，并目每个宜居区能同时在每个大阳日单位向上下左右四个方向的相邻格子进行扩散，自动将4个方向相邻的真空区改造成宜居区；\n请计算这个待改造区域的网格中，可改造区是否能全部成宜居区，如果可以，则返回改造的大阳日天教，不可以则返回-1",
    "inputDesc": "输入row * column个网格数据，每个网格值枚举值如下: YES，NO，NA；\n样例:、\n123\ngrid[i][j]只有3种情况，YES、NO、NA\nrow == grid.lengthcolumn == grid[i].length1 ≤ row, column ≤ 8",
    "outputDesc": "可改造区是否能全部变成宜居区，如果可以，则返回改造的太阳日天数，不可以则返回-1。",
    "examples": [
      {
        "input": "YES YES NO\nNO NO NO\nYES NO NO",
        "output": "",
        "explanation": "经过 2 个太阳日，完成宜居改造。"
      },
      {
        "input": "YES NO NO NO\nNO NO NO NO\nNO NO NO NO\nNO NO NO NO",
        "output": "",
        "explanation": "经过 6 个太阳日，可完成改造"
      },
      {
        "input": "NO NA",
        "output": "-1",
        "explanation": "无改造初始条件，无法进行改造"
      },
      {
        "input": "YES NO NO YES\nNO NO YES NO\nNO YES NA NA\nYES NO NA NO",
        "output": "-1",
        "explanation": "-1 ，右下角的区域，被周边三个死亡区挡住，无法实现改造"
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<String> lines = new ArrayList<>();\n        \n        // 读取输入，存入列表中\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            lines.add(line);\n        }\n        \n        int rows = lines.size();\n        int cols = lines.get(0).split(\" \").length;\n        \n        String[][] grid = new String[rows][cols];\n        Queue<int[]> q = new LinkedList<>();\n        int toConvert = 0;  // 需要改造的区域数量\n        \n        // 初始化网格和队列\n        for (int r = 0; r < rows; r++) {\n            String[] row = lines.get(r).split(\" \");\n            for (int c = 0; c < cols; c++) {\n                grid[r][c] = row[c];\n                if (row[c].equals(\"YES\")) {\n                    q.add(new int[]{r, c});\n                } else if (row[c].equals(\"NO\")) {\n                    toConvert++;\n                }\n            }\n        }\n        \n        // 无初始改造点或全不可改造\n        if (q.isEmpty()) {\n            System.out.println(-1);\n            return;\n        }\n        \n        // 方向数组（上下左右）\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        int days = 0;  // 改造天数\n        \n        // 广度优先搜索\n        while (!q.isEmpty() && toConvert > 0) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int[] pos = q.poll();\n                for (int[] dir : dirs) {\n                    int newRow = pos[0] + dir[0];\n                    int newCol = pos[1] + dir[1];\n                    \n                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].equals(\"NO\")) {\n                        grid[newRow][newCol] = \"YES\";\n                        q.add(new int[]{newRow, newCol});\n                        toConvert--;\n                    }\n                }\n            }\n            days++;\n        }\n        \n        System.out.println(toConvert == 0 ? days : -1);\n    }\n}",
      "python": "import sys\n\ngrid = []  # 网格\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        break\n    else:\n        row = line.split()\n        grid.append(row)\n\nrows = len(grid)\ncols = len(grid[0])\n\nq = []  # 存储已经改造的位置\ntoConvert = 0  # 需要改造的位置数\n\nfor r in range(rows):\n    for c in range(cols):\n        val = grid[r][c]\n        if val == \"YES\":\n            q.append([r, c])\n        elif val == \"NO\":\n            toConvert += 1\n\nif not q:  # 如果没有已经改造的位置，则无法继续改造\n    print(-1)\n    sys.exit()\nif len(q) == rows * cols:  # 如果所有位置都已经改造，则不需要继续改造\n    print(0)\n    sys.exit()\n\ndays = 0  # 改造天数\ndirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]  # 上下左右四个方向\n\nwhile q and toConvert > 0:  # 只要还有需要改造的位置，就继续改造\n    new_q = []  # 存储新改造的位置\n\n    for pos in q:\n        x, y = pos\n        for dir in dirs:\n            new_x = x + dir[0]\n            new_y = y + dir[1]\n\n            if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == \"NO\":  # 如果新位置可以改造，就改造它\n                grid[new_x][new_y] = \"YES\"\n                new_q.append([new_x, new_y])\n                toConvert -= 1\n\n    days += 1  # 改造天数加一\n    q = new_q  # 更新已经改造的位置\n\nif toConvert == 0:\n    print(days)  # 如果所有位置都已经改造，则返回改造的天数\nelse:\n    print(-1)  # 否则返回-1",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet grid = []; // 网格\nrl.on('line', (line) => {\n  if (line === '') {\n    rl.close();\n  } else {\n    let row = [];\n    let start = 0, end = 0;\n    while (end !== -1) {\n      end = line.indexOf(' ', start);\n      row.push(line.substring(start, end !== -1 ? end : undefined));\n      start = end + 1;\n    }\n    grid.push(row);\n  }\n}).on('close', () => {\n  let rows = grid.length;\n  let cols = grid[0].length;\n\n  let q = []; // 存储已经改造的位置\n  let toConvert = 0; // 需要改造的位置数\n\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      let val = grid[r][c];\n      if (val === 'YES') {\n        q.push([r, c]);\n      } else if (val === 'NO') {\n        toConvert++;\n      }\n    }\n  }\n\n  if (q.length === 0) { // 如果没有已经改造的位置，则无法继续改造\n    console.log(-1);\n    process.exit(0);\n  }\n  if (q.length === rows * cols) { // 如果所有位置都已经改造，则不需要继续改造\n    console.log(0);\n    process.exit(0);\n  }\n\n  let days = 0; // 改造天数\n  let dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 上下左右四个方向\n\n  while (q.length > 0 && toConvert > 0) { // 只要还有需要改造的位置，就继续改造\n    let new_q = []; // 存储新改造的位置\n\n    for (let pos of q) {\n      let x = pos[0], y = pos[1];\n      for (let dir of dirs) {\n        let new_x = x + dir[0];\n        let new_y = y + dir[1];\n\n        if (new_x >= 0 && new_x < rows && new_y >= 0 && new_y < cols && grid[new_x][new_y] === 'NO') { // 如果新位置可以改造，就改造它\n          grid[new_x][new_y] = 'YES';\n          new_q.push([new_x, new_y]);\n          toConvert--;\n        }\n      }\n    }\n\n    days++; // 改造天数加一\n    q = new_q; // 更新已经改造的位置\n  }\n\n  if (toConvert === 0) console.log(days); // 如果所有位置都已经改造，则返回改造的天数\n  else console.log(-1); // 否则返回-1\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    vector<vector<string>> grid; // 网格\n    string line;\n    while (getline(cin, line)) {\n        if (line.empty()) {\n            break;\n        } else {\n            vector<string> row;\n            size_t start = 0, end = 0;\n            while (end != string::npos) {\n                end = line.find(' ', start);\n                row.push_back(line.substr(start, end - start));\n                start = end + 1;\n            }\n            grid.push_back(row);\n        }\n    }\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n \n    vector<vector<int>> q; // 存储已经改造的位置\n    int toConvert = 0; // 需要改造的位置数\n \n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            string val = grid[r][c];\n            if (val == \"YES\") {\n                q.push_back({r, c});\n            } else if (val == \"NO\") {\n                toConvert++;\n            }\n        }\n    }\n \n    if (q.empty()) { // 如果没有已经改造的位置，则无法继续改造\n        cout << -1 << endl;\n        return 0;\n    }\n    if (q.size() == rows * cols) { // 如果所有位置都已经改造，则不需要继续改造\n        cout << 0 << endl;\n        return 0;\n    }\n \n    int days = 0; // 改造天数\n    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 上下左右四个方向\n \n    while (!q.empty() && toConvert > 0) { // 只要还有需要改造的位置，就继续改造\n        vector<vector<int>> new_q; // 存储新改造的位置\n \n        for (vector<int> pos : q) {\n            int x = pos[0], y = pos[1];\n            for (vector<int> dir : dirs) {\n                int new_x = x + dir[0];\n                int new_y = y + dir[1];\n \n                if (new_x >= 0\n                    && new_x < rows\n                    && new_y >= 0\n                    && new_y < cols\n                    && grid[new_x][new_y] == \"NO\") { // 如果新位置可以改造，就改造它\n                    grid[new_x][new_y] = \"YES\";\n                    new_q.push_back({new_x, new_y});\n                    toConvert--;\n                }\n            }\n        }\n \n        days++; // 改造天数加一\n        q = new_q; // 更新已经改造的位置\n    }\n \n    if (toConvert == 0) cout << days << endl; // 如果所有位置都已经改造，则返回改造的天数\n    else cout << -1 << endl; // 否则返回-1\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n\n// 队列数据结构\nint queue[MAX_ROWS * MAX_COLS][2];\nint front = 0, rear = 0;\n\n// 简单的方向数组（上、下、左、右）\nint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n// 检查队列是否为空\nint isQueueEmpty() {\n    return front == rear;\n}\n\n// 入队操作\nvoid enqueue(int row, int col) {\n    queue[rear][0] = row;\n    queue[rear][1] = col;\n    rear++;\n}\n\n// 出队操作\nvoid dequeue(int* row, int* col) {\n    *row = queue[front][0];\n    *col = queue[front][1];\n    front++;\n}\n\nint main() {\n    char grid[MAX_ROWS][MAX_COLS][4]; // 网格字符串\n    char line[256];\n    int rows = 0, cols = 0;\n    int toConvert = 0; // 需要改造的区域数量\n    int days = 0;      // 改造天数\n\n    // 读取输入并初始化网格\n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n') break; // 结束输入\n        char *token = strtok(line, \" \");\n        int col = 0;\n        while (token) {\n            strcpy(grid[rows][col], token);\n            token = strtok(NULL, \" \");\n            col++;\n        }\n        cols = col; // 记录列数\n        rows++;\n    }\n\n    // 初始化网格并查找初始的 \"YES\" 和 \"NO\" 位置\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            if (strcmp(grid[r][c], \"YES\") == 0) {\n                enqueue(r, c); // 将 \"YES\" 位置加入队列\n            } else if (strcmp(grid[r][c], \"NO\") == 0) {\n                toConvert++; // 统计需要改造的 \"NO\" 区域数量\n            }\n        }\n    }\n\n    // 如果没有初始的 \"YES\" 或者没有需要改造的 \"NO\"，则输出 -1\n    if (isQueueEmpty()) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    // 广度优先搜索 (BFS) 开始改造\n    while (!isQueueEmpty() && toConvert > 0) {\n        int size = rear - front; // 当前队列中的元素数量\n        for (int i = 0; i < size; i++) {\n            int row, col;\n            dequeue(&row, &col);\n            for (int j = 0; j < 4; j++) {\n                int newRow = row + dirs[j][0];\n                int newCol = col + dirs[j][1];\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols &&\n                    strcmp(grid[newRow][newCol], \"NO\") == 0) {\n                    strcpy(grid[newRow][newCol], \"YES\"); // 将 \"NO\" 改为 \"YES\"\n                    enqueue(newRow, newCol);             // 将新改造的点加入队列\n                    toConvert--;                        // 剩余待改造的区域减1\n                }\n            }\n        }\n        days++; // 每一轮结束，增加一天\n    }\n\n    // 输出结果\n    printf(\"%d\\n\", toConvert == 0 ? days : -1);\n\n    return 0;\n}"
    }
  },
  {
    "id": "122",
    "title": "寻找符合要求的最长子串",
    "examType": "A",
    "score": 200,
    "description": "给定一个字符串s，找出这样一个子串：\n该子串中任意一个字符最多出现2次该子串不包含指定某个字符\n请你找出满足该条件的最长子串的长度",
    "inputDesc": "第一行为：要求不包含的指定字符，为单个字符，取值范围[0-9a-zA-Z]\n第二行为：字符串s，每个字符范围[0-9a-zA-Z]，长度范围[1, 10000]",
    "outputDesc": "第一行为：要求不包含的指定字符，为单个字符，取值范围[0-9a-zA-Z]\n第二行为：字符串s，每个字符范围[0-9a-zA-Z]，长度范围[1, 10000]",
    "examples": [
      {
        "input": "D\nABC123",
        "output": "",
        "explanation": "无"
      },
      {
        "input": "D\nABACA123D",
        "output": "",
        "explanation": "无"
      },
      {
        "input": "D\nABACA123D",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "题目要求我们从给定的字符串 s 中找出一个满足以下两个条件的最长子串：\n任意一个字符最多出现2次： 子串中的每个字符在子串中出现的次数不能超过2次。子串不包含指定字符： 子串不能包含输入的指定字符。\n输出的是满足以上条件的最长子串的长度。如果没有符合条件的子串，则返回0。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 输入exclude和s\n        String exclude = scanner.next();\n        String s = scanner.next();\n\n        // 获取要排除的字符\n        char excludeChar = exclude.charAt(0);\n\n        // 存储每个字符出现的下标\n        Map<Character, List<Integer>> charIndexMap = new HashMap<>();\n\n        // 定义左右指针\n        int left = 0, right = 0;\n\n        // 定义最长子串长度\n        int maxLength = 0;\n\n        // 遍历字符串\n        while (right < s.length()) {\n            char currentChar = s.charAt(right);\n\n            // 如果当前字符是要排除的字符\n            if (excludeChar == currentChar) {\n                // 如果左右指针不在同一位置，说明存在符合条件的子串\n                if (right > left) {\n                    maxLength = Math.max(maxLength, right - left);\n                }\n                // 将左右指针都移动到下一个位置\n                right++;\n                left = right;\n            } else {\n                // 如果当前字符不是要排除的字符\n                // 先将当前字符在map中初始化\n                charIndexMap.computeIfAbsent(currentChar, k -> new ArrayList<>());\n                List<Integer> charIndexes = charIndexMap.get(currentChar);\n                // 如果当前字符的出现次数已经超过2次\n                if (charIndexes.size() == 2) {\n                    // 更新最长子串长度\n                    maxLength = Math.max(maxLength, right - left);\n                    // 将左指针移动到当前字符上一次出现的位置的下一个位置\n                    left = charIndexes.get(0) + 1;\n                    // 删除当前字符在map中的第一个下标\n                    charIndexes.remove(0);\n                }\n                // 将当前字符的下标加入map中\n                charIndexes.add(right);\n                // 右指针向后移动\n                right++;\n            }\n        }\n\n        // 检查最后一个子串是否符合条件\n        maxLength = Math.max(maxLength, right - left);\n\n        // 输出最长子串长度\n        System.out.println(maxLength);\n    }\n}",
      "python": "from collections import defaultdict\n\n# 输入exclude和s\nexclude = input()\ns = input()\n# 获取要排除的字符\nexcludeChar = exclude[0]\n\n# 存储每个字符出现的下标\ncharIndexMap = defaultdict(list)\n\n# 定义左右指针\nleft = 0\nright = 0\n\n# 定义最长子串长度\nmaxLength = 0\n\n# 遍历字符串\nwhile right < len(s):\n    currentChar = s[right]\n\n    # 如果当前字符是要排除的字符\n    if excludeChar == currentChar:\n        # 如果左右指针不在同一位置，说明存在符合条件的子串\n        if right > left:\n            maxLength = max(maxLength, right - left)\n        # 将左右指针都移动到下一个位置\n        right += 1\n        left = right\n    else:\n        # 如果当前字符不是要排除的字符\n        # 先将当前字符在map中初始化\n        charIndexMap[currentChar]\n        charIndexes = charIndexMap[currentChar]\n        # 如果当前字符的出现次数已经超过2次\n        if len(charIndexes) == 2:\n            # 更新最长子串长度\n            maxLength = max(maxLength, right - left)\n            # 将左指针移动到当前字符上一次出现的位置的下一个位置\n            left = charIndexes[0] + 1\n            # 删除当前字符在map中的第一个下标\n            charIndexes.pop(0)\n        # 将当前字符的下标加入map中\n        charIndexes.append(right)\n        # 右指针向后移动\n        right += 1\n\n# 检查最后一个子串是否符合条件\nmaxLength = max(maxLength, right - left)\n\n# 输出最长子串长度\nprint(maxLength)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet exclude = '';\nlet s = '';\n\nrl.on('line', (input) => {\n  if (!exclude) {\n    exclude = input;\n  } else {\n    s = input;\n\n    // 获取要排除的字符\n    const excludeChar = exclude[0];\n\n    // 存储每个字符出现的下标\n    const charIndexMap = {};\n\n    // 定义左右指针\n    let left = 0;\n    let right = 0;\n\n    // 定义最长子串长度\n    let maxLength = 0;\n\n    // 遍历字符串\n    while (right < s.length) {\n      const currentChar = s[right];\n\n      // 如果当前字符是要排除的字符\n      if (excludeChar === currentChar) {\n        // 如果左右指针不在同一位置，说明存在符合条件的子串\n        if (right > left) {\n          maxLength = Math.max(maxLength, right - left);\n        }\n        // 将左右指针都移动到下一个位置\n        right++;\n        left = right;\n      } else {\n        // 如果当前字符不是要排除的字符\n        // 先将当前字符在map中初始化\n        charIndexMap[currentChar] = charIndexMap[currentChar] || [];\n        const charIndexes = charIndexMap[currentChar];\n        // 如果当前字符的出现次数已经超过2次\n        if (charIndexes.length === 2) {\n          // 更新最长子串长度\n          maxLength = Math.max(maxLength, right - left);\n          // 将左指针移动到当前字符上一次出现的位置的下一个位置\n          left = charIndexes[0] + 1;\n          // 删除当前字符在map中的第一个下标\n          charIndexes.shift();\n        }\n        // 将当前字符的下标加入map中\n        charIndexes.push(right);\n        // 右指针向后移动\n        right++;\n      }\n    }\n\n    // 检查最后一个子串是否符合条件\n    maxLength = Math.max(maxLength, right - left);\n\n    // 输出最长子串长度\n    console.log(maxLength);\n\n    rl.close();\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    // 输入exclude和s\n    string exclude, s;\n    cin >> exclude >> s;\n    // 获取要排除的字符\n    char excludeChar = exclude[0];\n\n    // 存储每个字符出现的下标\n    unordered_map<char, vector<int>> charIndexMap;\n\n    // 定义左右指针\n    int left = 0, right = 0;\n\n    // 定义最长子串长度\n    int maxLength = 0;\n\n    // 遍历字符串\n    while (right < s.length()) {\n        char currentChar = s[right];\n\n        // 如果当前字符是要排除的字符\n        if (excludeChar == currentChar) {\n            // 如果左右指针不在同一位置，说明存在符合条件的子串\n            if (right > left) {\n                maxLength = max(maxLength, right - left);\n            }\n            // 将左右指针都移动到下一个位置\n            right++;\n            left = right;\n        } else {\n            // 如果当前字符不是要排除的字符\n            // 先将当前字符在map中初始化\n            charIndexMap[currentChar];\n            vector<int>& charIndexes = charIndexMap[currentChar];\n            // 如果当前字符的出现次数已经超过2次\n            if (charIndexes.size() == 2) {\n                // 更新最长子串长度\n                maxLength = max(maxLength, right - left);\n                // 将左指针移动到当前字符上一次出现的位置的下一个位置\n                left = charIndexes[0] + 1;\n                // 删除当前字符在map中的第一个下标\n                charIndexes.erase(charIndexes.begin());\n            }\n            // 将当前字符的下标加入map中\n            charIndexes.push_back(right);\n            // 右指针向后移动\n            right++;\n        }\n    }\n\n    // 检查最后一个子串是否符合条件\n    maxLength = max(maxLength, right - left);\n\n    // 输出最长子串长度\n    cout << maxLength << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LENGTH 10000\n\n// 用于存储每个字符的出现下标\nint charIndexMap[128][3];\n\nint main() {\n    char excludeChar;\n    char s[MAX_LENGTH + 1];\n\n    // 读取排除字符和字符串\n    scanf(\"%c\", &excludeChar);\n    scanf(\"%s\", s);\n\n    // 初始化存储字符下标的数组\n    for (int i = 0; i < 128; i++) {\n        charIndexMap[i][0] = charIndexMap[i][1] = -1;\n    }\n\n    int left = 0, right = 0;\n    int maxLength = 0;\n    int length = strlen(s);\n\n    // 遍历字符串\n    while (right < length) {\n        char currentChar = s[right];\n\n        // 如果当前字符是要排除的字符\n        if (currentChar == excludeChar) {\n            if (right > left) {\n                maxLength = right - left > maxLength ? right - left : maxLength;\n            }\n            right++;\n            left = right;\n        } else {\n            // 如果当前字符不是要排除的字符\n            int* charIndexes = charIndexMap[currentChar];\n\n            // 如果当前字符的出现次数已经超过2次\n            if (charIndexes[1] != -1) {\n                maxLength = right - left > maxLength ? right - left : maxLength;\n                left = charIndexes[0] + 1;\n                charIndexes[0] = charIndexes[1];\n                charIndexes[1] = -1;\n            }\n\n            // 将当前字符的下标加入到数组中\n            if (charIndexes[0] == -1) {\n                charIndexes[0] = right;\n            } else {\n                charIndexes[1] = right;\n            }\n\n            // 右指针向后移动\n            right++;\n        }\n    }\n\n    // 检查最后一个子串是否符合条件\n    maxLength = right - left > maxLength ? right - left : maxLength;\n\n    // 输出最长子串长度\n    printf(\"%d\\n\", maxLength);\n\n    return 0;\n}"
    }
  },
  {
    "id": "123",
    "title": "战场索敌",
    "examType": "A",
    "score": 200,
    "description": "有一个大小是N*M的战场地图，被墙壁 ‘#’ 分隔成大小不同的区域，上下左右四个方向相邻的空地 ‘.’ 属于同一个区域，只有空地上可能存在敌人’E”，\n请求出地图上总共有多少区域里的敌人数小于K。",
    "inputDesc": "第一行输入为N,M,K；\nN表示地图的行数，M表示地图的列数， K表示目标敌人数量N，M<=100\n之后为一个NxM大小的字符数组。",
    "outputDesc": "敌人数小于K的区域数量",
    "examples": [
      {
        "input": "5 2\n..#EE\nE.#E.\n###..",
        "output": "",
        "explanation": "地图被墙壁分为两个区域，左边区域有1个敌人，右边区域有3个敌人，符合条件的区域数量是1"
      }
    ],
    "solution": "整体思路是，遍历地图中的每个位置，如果该位置未被访问过且不是墙壁，则调用dfs函数计算以该位置为起点的区域中敌人的数量，如果该数量小于目标敌人数量k，则将区域数量加1。最后，输出区域数量。\n我们将地图矩阵存储在一个二维字符数组matrix中。\n接下来，我们需要初始化一个二维布尔数组visited，用于标记地图中的每个位置是否已经被访问过。初始化visited为false。\n然后，我们定义一个深度优先搜索函数dfs，用于计算以位置(i, j)为起点的区域中敌人的数量。在dfs函数中，我们首先将位置(i, j)标记为已访问，并根据该位置的值判断是否为敌人，如果是，则将计数器count加1。然后，我们使用一个栈来保存待访问的位置。在每一次循环中，我们从栈中取出一个位置(pos)，并遍历其上下左右四个相邻位置。如果相邻位置在地图范围内、未被访问过且不是墙壁，则将其标记为已访问，并根据其值判断是否为敌人，如果是，则将计数器count加1，并将该位置加入到栈中。最后，返回计数器count。\n接下来，我们定义主函数main。在主函数中，我们首先读取地图的行数n、列数m和目标敌人数量k。然后，根据地图的行数n和列数m初始化visited和matrix数组。接下来，我们遍历地图中的每个位置，如果该位置已经被访问过或者是墙壁，则跳过。否则，调用dfs函数计算以该位置为起点的区域中敌人的数量，如果该数量小于目标敌人数量k，则将区域数量加1。最后，输出区域数量。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    // 定义地图的行数、列数和目标敌人数量\n    private static int n, m, k;\n    // 定义存储地图的二维字符数组\n    private static char[][] matrix;\n    // 定义标记访问状态的二维数组\n    private static int[][] visited;\n    // 记录当前区域的敌人数量\n    private static int enemyCount;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // 读取地图的行数n、列数m和目标敌人数量k\n        n = scanner.nextInt();\n        m = scanner.nextInt();\n        k = scanner.nextInt();\n\n        // 初始化地图矩阵和访问标记数组\n        matrix = new char[n][m];\n        visited = new int[n][m];\n\n        // 读取地图矩阵数据\n        for (int i = 0; i < n; i++) {\n            String row = scanner.next();\n            for (int j = 0; j < m; j++) {\n                matrix[i][j] = row.charAt(j); // 逐字符读取地图\n            }\n        }\n\n        int ans = 0; // 初始化符合条件的区域计数\n\n        // 遍历地图中的每个位置\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                // 如果当前格子已经访问过或是墙壁，跳过\n                if (visited[i][j] != 0 || matrix[i][j] == '#') {\n                    continue;\n                }\n                enemyCount = 0; // 初始化当前区域的敌人计数\n                dfs(i, j); // 深度优先搜索该区域\n                // 如果该区域的敌人数小于k，则该区域符合条件\n                ans += enemyCount < k ? 1 : 0;\n            }\n        }\n\n        // 输出符合条件的区域数量\n        System.out.println(ans);\n    }\n\n    // 深度优先搜索函数，从(i, j)位置开始计算敌人数\n    public static void dfs(int i, int j) {\n        visited[i][j] = 1; // 将当前位置标记为已访问\n\n        // 如果当前位置是敌人，增加敌人计数\n        if (matrix[i][j] == 'E') {\n            enemyCount++;\n        }\n\n        // 定义四个方向的偏移量：上、下、左、右\n        int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        // 遍历四个相邻方向\n        for (int[] offset : offsets) {\n            int newX = i + offset[0];\n            int newY = j + offset[1];\n\n            // 检查相邻位置是否在地图范围内，未访问过且不是墙壁\n            if (newX >= 0 && newX < n && newY >= 0 && newY < m && visited[newX][newY] == 0 && matrix[newX][newY] != '#') {\n                dfs(newX, newY); // 递归访问相邻位置\n            }\n        }\n    }\n}",
      "python": "import sys\n\ndef dfs(i, j):\n    visited[i][j] = 1  # 标记当前位置已访问\n\n    if matrix[i][j] == 'E':  # 如果当前位置是敌人，增加敌人数量\n        global enemyCount\n        enemyCount += 1\n\n    offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]]  # 定义上下左右四个方向\n\n    # 遍历四个方向，检查相邻格子\n    for offset in offsets:\n        newX = i + offset[0]\n        newY = j + offset[1]\n\n        # 检查相邻格子是否在范围内、未访问且不是墙壁\n        if newX >= 0 and newX < n and newY >= 0 and newY < m and visited[newX][newY] == 0 and matrix[newX][newY] != '#':\n            dfs(newX, newY)  # 递归访问相邻格子\n\n# 读取地图行数、列数和目标敌人数量\nn, m, k = map(int, input().split())\n\nmatrix = []  # 初始化地图矩阵\nvisited = [[0] * m for _ in range(n)]  # 初始化访问标记数组\n\n# 读取地图数据\nfor _ in range(n):\n    row = input()\n    matrix.append(list(row))\n\nans = 0  # 初始化符合条件的区域计数\n\n# 遍历地图的每个格子\nfor i in range(n):\n    for j in range(m):\n        # 如果该格子已访问或是墙壁，跳过\n        if visited[i][j] != 0 or matrix[i][j] == '#':\n            continue\n        enemyCount = 0  # 初始化敌人数量\n        dfs(i, j)  # 深度优先搜索\n        # 如果该区域敌人数小于k，则符合条件\n        ans += 1 if enemyCount < k else 0\n\n# 输出符合条件的区域数量\nprint(ans)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet n, m, k;\nlet matrix = [];\nlet visited = [];\n\nrl.on('line', (line) => {\n  if (!n) {\n    [n, m, k] = line.split(' ').map(Number);  // 读取地图行数、列数和敌人数量\n    visited = Array.from({ length: n }, () => Array(m).fill(false));  // 初始化访问标记数组\n  } else {\n    matrix.push(line.split(''));  // 读取地图矩阵\n  }\n}).on('close', () => {\n  const enemyCount = { count: 0 };  // 用于记录敌人数量的对象\n\n  // 深度优先搜索函数\n  function dfs(i, j) {\n    visited[i][j] = true;  // 标记为已访问\n\n    if (matrix[i][j] === 'E') {\n      enemyCount.count++;  // 如果是敌人，增加计数\n    }\n\n    const offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]];  // 定义四个方向\n\n    // 遍历四个相邻方向\n    for (const offset of offsets) {\n      const newX = i + offset[0];\n      const newY = j + offset[1];\n\n      // 检查是否在地图范围内且未访问\n      if (newX >= 0 && newX < n && newY >= 0 && newY < m && !visited[newX][newY] && matrix[newX][newY] !== '#') {\n        dfs(newX, newY);  // 递归搜索\n      }\n    }\n  }\n\n  let ans = 0;  // 记录符合条件的区域数量\n\n  // 遍历地图的每个格子\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (visited[i][j] || matrix[i][j] === '#') {\n        continue;  // 如果已访问或是墙壁，跳过\n      }\n      enemyCount.count = 0;  // 初始化敌人计数\n      dfs(i, j);  // 深度优先搜索\n      ans += enemyCount.count < k ? 1 : 0;  // 判断是否符合条件\n    }\n  }\n\n  console.log(ans);  // 输出结果\n});",
      "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n, m, k;  // 地图行数、列数和目标敌人数量\nvector<vector<char>> matrix;  // 存储地图的二维数组\nvector<vector<int>> visited;  // 标记访问状态的二维数组\nint enemyCount;  // 记录当前区域敌人的数量\n\n// 深度优先搜索函数，从(i, j)开始计算该区域的敌人数\nvoid dfs(int i, int j) {\n    visited[i][j] = 1;  // 标记当前位置为已访问\n    \n    if (matrix[i][j] == 'E') {\n        enemyCount++;  // 如果当前位置是敌人，增加计数\n    }\n    \n    vector<vector<int>> offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // 定义四个方向\n\n    // 遍历相邻的四个方向\n    for (vector<int> offset : offsets) {\n        int newX = i + offset[0];\n        int newY = j + offset[1];\n        \n        // 检查新位置是否在地图范围内，且未访问过且不是墙壁\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && visited[newX][newY] == 0 && matrix[newX][newY] != '#') {\n            dfs(newX, newY);  // 递归访问相邻位置\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m >> k;  // 读取地图行数、列数和目标敌人数量\n    \n    matrix.resize(n, vector<char>(m));  // 初始化地图矩阵\n    visited.resize(n, vector<int>(m));  // 初始化访问标记数组\n    \n    // 读取地图数据\n    for (int i = 0; i < n; i++) {\n        string row;\n        cin >> row;\n        for (int j = 0; j < m; j++) {\n            matrix[i][j] = row[j];  // 将地图数据存入矩阵\n        }\n    }\n    \n    int ans = 0;  // 记录符合条件的区域数量\n    \n    // 遍历地图的每个格子\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (visited[i][j] != 0 || matrix[i][j] == '#') {\n                continue;  // 如果已经访问或是墙壁，跳过\n            }\n            enemyCount = 0;  // 初始化敌人计数\n            dfs(i, j);  // 深度优先搜索\n            ans += enemyCount < k ? 1 : 0;  // 判断该区域是否符合条件\n        }\n    }\n    \n    cout << ans << endl;  // 输出符合条件的区域数量\n    \n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint n, m, k;  // 地图行数、列数和目标敌人数量\nchar **matrix;  // 存储地图的二维数组\nint **visited;  // 标记访问状态的二维数组\nint enemyCount;  // 记录当前区域敌人的数量\n\n// 深度优先搜索函数，从(i, j)开始计算该区域的敌人数\nvoid dfs(int i, int j) {\n    visited[i][j] = 1;  // 标记当前位置为已访问\n\n    if (matrix[i][j] == 'E') {\n        enemyCount++;  // 如果当前位置是敌人，增加计数\n    }\n\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // 定义四个方向\n\n    // 遍历相邻的四个方向\n    for (int d = 0; d < 4; d++) {\n        int newX = i + offsets[d][0];\n        int newY = j + offsets[d][1];\n\n        // 检查新位置是否在地图范围内，且未访问过且不是墙壁\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && visited[newX][newY] == 0 && matrix[newX][newY] != '#') {\n            dfs(newX, newY);  // 递归访问相邻位置\n        }\n    }\n}\n\nint main() {\n    // 读取地图行数、列数和目标敌人数量\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    // 初始化地图矩阵\n    matrix = (char **)malloc(n * sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        matrix[i] = (char *)malloc((m + 1) * sizeof(char));  // 额外分配1个字符存储字符串终止符\n    }\n\n    // 初始化访问标记数组\n    visited = (int **)malloc(n * sizeof(int *));\n    for (int i = 0; i < n; i++) {\n        visited[i] = (int *)malloc(m * sizeof(int));\n    }\n\n    // 读取地图数据\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", matrix[i]);  // 直接读取一整行字符串\n    }\n\n    int ans = 0;  // 记录符合条件的区域数量\n\n    // 遍历地图的每个格子\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (visited[i][j] != 0 || matrix[i][j] == '#') {\n                continue;  // 如果已经访问或是墙壁，跳过\n            }\n            enemyCount = 0;  // 初始化敌人计数\n            dfs(i, j);  // 深度优先搜索\n            ans += (enemyCount < k) ? 1 : 0;  // 判断该区域是否符合条件\n        }\n    }\n\n    printf(\"%d\\n\", ans);  // 输出符合条件的区域数量\n\n    // 释放动态分配的内存\n    for (int i = 0; i < n; i++) {\n        free(matrix[i]);\n        free(visited[i]);\n    }\n    free(matrix);\n    free(visited);\n\n    return 0;\n}"
    }
  },
  {
    "id": "124",
    "title": "打印任务排序",
    "examType": "A",
    "score": 200,
    "description": "某个打印机根据打印队列执行打印任务。打印任务分为九个优先级，分别用数字1-9表示，数字越大优先级越高。打印机每次从队列头部取出第一个任务A，\n然后检查队列余下任务中有没有比A优先级更高的任务，如果有比A优先级高的任务，则将任务A放到队列尾部，否则就执行任务A的打印。\n请编写一个程序，根据输入的打印队列，输出实际的打印顺序。",
    "inputDesc": "输入一行，为每个任务的优先级，优先级之间用逗号隔开，优先级取值范围是1~9。",
    "outputDesc": "输出一行，为每个任务的打印顺序，打印顺序从0开始，用逗号隔开",
    "examples": [
      {
        "input": ",3,5",
        "output": ",2,1",
        "explanation": "队列头部任务的优先级为9，最先打印，故序号为0； 接着队列头部任务优先级为3，队列中还有优先级为5的任务，优先级3任务被移到队列尾部； 接着打印优先级为5的任务，故其序号为1； 最后优先级为3的任务的序号为2。"
      },
      {
        "input": ",2,2",
        "output": ",0,1",
        "explanation": "队列头部任务的优先级为1，被移到队列尾部；接着顺序打印两个优先级为2的任务，故其序号分别为0和1；最后打印剩下的优先级为1的任务，其序号为2"
      }
    ],
    "solution": "本题描述了一个打印机按照一定的规则处理打印任务的场景，打印任务的优先级会影响其被打印的顺序。规则如下：\n任务优先级：任务有1到9个优先级，数字越大优先级越高。检查任务：每次从队列头部取出任务A，检查队列中是否还有比A优先级高的任务： 如果有更高优先级的任务，任务A会被移到队列尾部。如果没有更高优先级的任务，任务A将被打印。 任务序号：打印任务时，记录下任务的初始位置，最终输出的打印顺序为任务的初始序号顺序。\n如果有更高优先级的任务，任务A会被移到队列尾部。如果没有更高优先级的任务，任务A将被打印。\n初始任务队列：[9, 3, 5]，对应的初始序号：[0, 1, 2] 取出队列头部任务优先级9，队列中没有比9优先级高的任务，直接打印任务9，顺序记录为0。取出队列头部任务优先级3，队列中有优先级5的任务，优先级3的任务被移到队列尾部，队列变为：[5, 3]。取出优先级5的任务，队列中没有比5优先级高的任务，直接打印任务5，顺序记录为2。最后打印剩下的优先级3任务，顺序记录为1。 最终输出为0,2,1。\n初始任务队列：[9, 3, 5]，对应的初始序号：[0, 1, 2]\n取出队列头部任务优先级9，队列中没有比9优先级高的任务，直接打印任务9，顺序记录为0。取出队列头部任务优先级3，队列中有优先级5的任务，优先级3的任务被移到队列尾部，队列变为：[5, 3]。取出优先级5的任务，队列中没有比5优先级高的任务，直接打印任务5，顺序记录为2。最后打印剩下的优先级3任务，顺序记录为1。\n最终输出为0,2,1。\n初始任务队列：[1, 2, 2]，对应的初始序号：[0, 1, 2] 取出队列头部任务优先级1，队列中有两个优先级为2的任务，优先级1的任务被移到队列尾部，队列变为：[2, 2, 1]。取出队列头部任务优先级2，队列中没有比2优先级高的任务，直接打印任务2，顺序记录为1。继续取出优先级2的任务，队列中没有比2优先级高的任务，直接打印任务2，顺序记录为2。最后打印优先级1的任务，顺序记录为0。 最终输出为2,0,1。\n初始任务队列：[1, 2, 2]，对应的初始序号：[0, 1, 2]\n取出队列头部任务优先级1，队列中有两个优先级为2的任务，优先级1的任务被移到队列尾部，队列变为：[2, 2, 1]。取出队列头部任务优先级2，队列中没有比2优先级高的任务，直接打印任务2，顺序记录为1。继续取出优先级2的任务，队列中没有比2优先级高的任务，直接打印任务2，顺序记录为2。最后打印优先级1的任务，顺序记录为0。\n最终输出为2,0,1。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n \n        String input = scanner.nextLine();\n        \n        // 将输入的字符串按逗号分隔，转换为字符串数组\n        String[] priorityListString = input.split(\",\");\n        \n        // 将字符串数组转换为整型数组，存储每个任务的优先级\n        int[] priorityList = new int[priorityListString.length];\n        for (int i = 0; i < priorityListString.length; i++) {\n            priorityList[i] = Integer.parseInt(priorityListString[i]);\n        }\n        \n        // 创建一个列表，存储任务的初始索引和优先级\n        List<int[]> taskList = new ArrayList<>();\n        for (int i = 0; i < priorityList.length; i++) {\n            taskList.add(new int[]{i, priorityList[i]});  // 任务格式为 {索引, 优先级}\n        }\n        \n        // 按照优先级从大到小排序任务，优先级高的任务在前面\n        taskList.sort(Comparator.comparingInt(x -> -x[1]));\n        \n        // currentTask 变量用于记录当前处理的任务序号\n        int currentTask = 0;\n        List<Integer> printOrder = new ArrayList<>();\n        \n        // 按任务顺序检查并记录每个任务的打印顺序\n        while (currentTask < taskList.size()) {\n            for (int i = 0; i < taskList.size(); i++) {\n                if (taskList.get(i)[0] == currentTask) {  // 如果找到任务的原始索引等于当前处理的任务\n                    printOrder.add(i);  // 将任务在排序后的位置记录为打印顺序\n                }\n            }\n            currentTask++;  // 处理下一个任务\n        }\n        \n        // 构建输出字符串，将每个打印顺序用逗号隔开输出\n        String output = \"\";\n        for (int i = 0; i < printOrder.size(); i++) {\n            output += printOrder.get(i);\n            if (i < printOrder.size() - 1) {\n                output += \",\";\n            }\n        }\n        \n        // 输出最终的打印顺序\n        System.out.println(output);\n    }\n}",
      "python": "priority_list = list(map(int, input().split(',')))\n\n# 创建任务列表，每个任务用 (原始索引, 优先级) 表示\ntask_list = [(i, priority_list[i]) for i in range(len(priority_list))]\n\n# 按照任务的优先级从大到小排序，优先级高的排在前面\ntask_list.sort(key=lambda x: -x[1])\n\n# 初始化当前任务索引，记录打印顺序\ncurrent_task = 0\nprint_order = []\n\n# 遍历任务列表，按照当前任务的原始索引找到其在排序后的位置\nwhile current_task < len(task_list):\n    for i in range(len(task_list)):\n        if task_list[i][0] == current_task:  # 如果找到原始索引等于当前任务\n            print_order.append(i)  # 记录排序后的任务位置\n    current_task += 1  # 处理下一个任务\n\n# 将打印顺序列表转换为逗号分隔的字符串输出\nprint(','.join(map(str, print_order)))",
      "javascript": "const readline = require('readline');\n\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n \nrl.on('line', (input) => {\n  // 将输入的字符串按逗号分隔并转换为数字列表\n  const priority_list = input.split(',').map(Number);\n\n  // 创建任务列表，包含任务的原始索引和优先级\n  const task_list = priority_list.map((priority, index) => [index, priority]);\n\n  // 按照优先级从高到低排序任务\n  task_list.sort((a, b) => b[1] - a[1]);\n\n  let current_task = 0;\n  const print_order = [];\n\n  // 遍历任务列表，按照原始顺序查找任务的打印顺序\n  while (current_task < task_list.length) {\n    for (let i = 0; i < task_list.length; i++) {\n      if (task_list[i][0] === current_task) {  // 找到原始索引为当前任务的\n        print_order.push(i);  // 记录其在排序后的位置\n      }\n    }\n    current_task++;  // 处理下一个任务\n  }\n\n  // 打印最终的打印顺序，使用逗号分隔\n  console.log(print_order.join(','));\n\n  // 关闭输入接口\n  rl.close()\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string input;\n    getline(cin, input);  // 读取用户输入的任务优先级字符串\n    \n    vector<int> priority_list;  // 用于存储任务优先级的列表\n    size_t pos = 0;\n    string token;\n\n    // 将输入的字符串按照逗号分隔，依次存入 priority_list 中\n    while ((pos = input.find(',')) != string::npos) {\n        token = input.substr(0, pos);\n        priority_list.push_back(stoi(token));  // 转换为整数并存入列表\n        input.erase(0, pos + 1);\n    }\n    priority_list.push_back(stoi(input));  // 最后一个任务的优先级加入列表\n    \n    // 创建任务列表，包含任务的原始索引和优先级\n    vector<pair<int, int>> task_list;\n    for (int i = 0; i < priority_list.size(); i++) {\n        task_list.push_back(make_pair(i, priority_list[i]));\n    }\n\n    // 按优先级从大到小排序任务列表\n    sort(task_list.begin(), task_list.end(), [](pair<int, int> a, pair<int, int> b) {\n        return a.second > b.second;\n    });\n    \n    int current_task = 0;  // 当前要处理的任务索引\n    vector<int> print_order;  // 存储打印顺序\n\n    // 查找排序后每个任务的打印顺序\n    while (current_task < task_list.size()) {\n        for (int i = 0; i < task_list.size(); i++) {\n            if (task_list[i].first == current_task) {  // 找到原始索引为当前任务的\n                print_order.push_back(i);  // 记录排序后的位置\n            }\n        }\n        current_task++;  // 处理下一个任务\n    }\n    \n \n    for (int i = 0; i < print_order.size(); i++) {\n        cout << print_order[i];\n        if (i != print_order.size() - 1) {\n            cout << \",\";\n        }\n    }\n    \n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 比较函数，用于按照优先级从大到小排序\nint compare(const void *a, const void *b) {\n    // 将参数强制转换为指向整数数组的指针\n    int *taskA = *(int **)a;\n    int *taskB = *(int **)b;\n    return taskB[1] - taskA[1];  // 按照优先级从大到小排序\n}\n\nint main() {\n    char input[256];\n    \n \n    fgets(input, sizeof(input), stdin);\n\n    // 去除输入中的换行符\n    input[strcspn(input, \"\\n\")] = '\\0';\n\n    // 按照逗号分割输入字符串，计算优先级个数\n    char *token = strtok(input, \",\");\n    int count = 0;\n    int *priorityList = NULL;\n\n    // 分割并转换为整数，存储到priorityList数组中\n    while (token != NULL) {\n        priorityList = realloc(priorityList, sizeof(int) * (count + 1));\n        priorityList[count] = atoi(token);  // 将字符串转换为整数\n        count++;\n        token = strtok(NULL, \",\");\n    }\n\n    // 创建一个二维数组，存储每个任务的初始索引和优先级\n    int **taskList = (int **)malloc(count * sizeof(int *));\n    for (int i = 0; i < count; i++) {\n        taskList[i] = (int *)malloc(2 * sizeof(int));\n        taskList[i][0] = i;             // 存储任务的初始索引\n        taskList[i][1] = priorityList[i]; // 存储任务的优先级\n    }\n\n    // 使用qsort对任务列表按照优先级从大到小进行排序\n    qsort(taskList, count, sizeof(int *), compare);\n\n    // currentTask 变量用于记录当前处理的任务序号\n    int currentTask = 0;\n    int *printOrder = (int *)malloc(count * sizeof(int)); // 用于存储最终的打印顺序\n    int orderIndex = 0;\n\n    // 按任务顺序检查并记录每个任务的打印顺序\n    while (currentTask < count) {\n        for (int i = 0; i < count; i++) {\n            if (taskList[i][0] == currentTask) {  // 如果找到任务的原始索引等于当前处理的任务\n                printOrder[orderIndex++] = i;     // 将任务在排序后的位置记录为打印顺序\n                break;\n            }\n        }\n        currentTask++;  // 处理下一个任务\n    }\n\n    // 输出最终的打印顺序\n    for (int i = 0; i < orderIndex; i++) {\n        printf(\"%d\", printOrder[i]);\n        if (i < orderIndex - 1) {\n            printf(\",\");  // 用逗号分隔\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
    }
  },
  {
    "id": "125",
    "title": "推荐多样性",
    "examType": "A",
    "score": 200,
    "description": "推荐多样性需要从多个列表中选择元素，一次性要返回 N 屏数据（窗口数量），每屏展示 K 个元素（窗口大小），选择策略：\n各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推 每个列表的元素尽量均分为 N 份，如果不够 N 个，也要全部分配完，参考样例图： （1）从第一个列表中选择 4 条 0 1 2 3，分别放到 4 个窗口中 （2）从第二个列表中选择 4 条 10 11 12 13，分别放到 4 个窗口中 （3）从第三个列表中选择 4 条 20 21 22 23，分别放到 4 个窗口中 （4）再从第一个列表中选择 4 条 4 5 6 7，分别放到 4 个窗口中 … （5）再从第一个列表中选择，由于数量不足 4 条，取剩下的 2 条，放到 窗口1 和 窗口2 （6）再从第二个列表中选择，由于数量不足 4 条并且总的元素数达到窗口要求，取 18 19 放到 窗口3 和 窗口4\n各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推\n每个列表的元素尽量均分为 N 份，如果不够 N 个，也要全部分配完，参考样例图：\n（1）从第一个列表中选择 4 条 0 1 2 3，分别放到 4 个窗口中\n（2）从第二个列表中选择 4 条 10 11 12 13，分别放到 4 个窗口中\n（3）从第三个列表中选择 4 条 20 21 22 23，分别放到 4 个窗口中\n（4）再从第一个列表中选择 4 条 4 5 6 7，分别放到 4 个窗口中\n…\n（5）再从第一个列表中选择，由于数量不足 4 条，取剩下的 2 条，放到 窗口1 和 窗口2\n（6）再从第二个列表中选择，由于数量不足 4 条并且总的元素数达到窗口要求，取 18 19 放到 窗口3 和 窗口4\n",
    "inputDesc": "第一行输入为 N，表示需要输出的窗口数量，取值范围 [1, 10]\n第二行输入为 K，表示每个窗口需要的元素数量，取值范围 [1, 100]\n之后的行数不定（行数取值范围 [1, 10]），表示每个列表输出的元素列表。元素之间以空格隔开，已经过排序处理，每个列表输出的元素数量取值范围 [1, 100]",
    "outputDesc": "输出元素列表，元素数量 = 窗口数量 * 窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例：\n先输出窗口1的元素列表，再输出窗口2的元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表\n输入\n输出",
    "examples": [],
    "solution": "题目描述的核心是实现一个特定的元素选择和分配策略，以确保从多个列表中选取的元素能够满足给定的输出要求。具体来说，需要从多个输入列表中选择元素，将这些元素分配到指定数量的窗口中，每个窗口展示固定数量的元素。选择和分配元素时，需要遵循以下规则：\n穿插处理：元素的选择需要按照列表的顺序依次进行，即先从第一个列表中选择元素填充到每个窗口中，然后是第二个列表，以此类推。这样做的目的是确保输出的元素列表能够反映出输入列表的多样性。 均分元素：每个列表中的元素需要尽可能均匀地分配到所有窗口中。如果某个列表的元素不足以在所有窗口中均匀分配，那么这些元素仍然需要全部被分配出去，直到该列表的元素耗尽。 保持顺序：在选择和分配元素时，需要保持每个列表中元素的原始顺序不变。这意味着不能对列表中的元素进行排序或重新排列。 满足窗口要求：最终输出的元素数量等于窗口数量乘以每个窗口的大小。输出的元素列表是通过将所有窗口的元素合并成一个列表来实现的，且需要按照窗口的顺序进行合并。\n穿插处理：元素的选择需要按照列表的顺序依次进行，即先从第一个列表中选择元素填充到每个窗口中，然后是第二个列表，以此类推。这样做的目的是确保输出的元素列表能够反映出输入列表的多样性。\n均分元素：每个列表中的元素需要尽可能均匀地分配到所有窗口中。如果某个列表的元素不足以在所有窗口中均匀分配，那么这些元素仍然需要全部被分配出去，直到该列表的元素耗尽。\n保持顺序：在选择和分配元素时，需要保持每个列表中元素的原始顺序不变。这意味着不能对列表中的元素进行排序或重新排列。\n满足窗口要求：最终输出的元素数量等于窗口数量乘以每个窗口的大小。输出的元素列表是通过将所有窗口的元素合并成一个列表来实现的，且需要按照窗口的顺序进行合并。\n首先读取窗口数量和每个窗口的大小，然后读取每个列表的元素并将其存储在队列中。接着，代码通过循环遍历队列列表，按照规定的规则从队列中选择元素并将它们分配到一个数组中。这个数组最终被用来构建和输出最终的元素列表。在选择和分配过程中，代码确保了元素的选择是穿插进行的，每个列表中的元素被均匀分配，且保持了元素的原始顺序。最终，代码输出的元素列表满足了题目的所有要求。",
    "codes": {
      "java": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取窗口数量N\n        int numberOfRows = Integer.parseInt(scanner.nextLine());\n        // 读取每个窗口需要的元素数量K\n        int numberOfColumns = Integer.parseInt(scanner.nextLine());\n\n        // 创建队列列表，用于存储每个列表的元素\n        List<Queue<Integer>> queueList = new ArrayList<>();\n\n        // 循环读取输入的每个列表，并将其转换为队列存储在queueList中\n        while (scanner.hasNextLine()) {\n            String inputLine = scanner.nextLine();\n            Queue<Integer> numberQueue = Arrays.stream(inputLine.split(\" \"))\n                                               .map(Integer::parseInt)\n                                               .collect(Collectors.toCollection(LinkedList::new));\n\n            queueList.add(numberQueue);\n        }\n\n        // 创建一个数组，用于存储最终的元素排列\n        int[] matrix = new int[numberOfColumns * numberOfRows];\n        int matrixIndex = 0; // 用于标记当前填充到matrix数组中的位置\n        int queueIndex = 0; // 用于标记当前处理的队列索引\n\n        // 循环，直到matrix数组被完全填满\n        while (matrixIndex < matrix.length) {\n            boolean didRemoveQueue = false; // 标记本轮循环中是否有队列被移除\n\n            // 遍历每个窗口，并尝试从当前队列中为每个窗口提取一个元素\n            for (int i = 0; i < numberOfRows && !queueList.isEmpty(); i++) {\n                // 如果当前队列为空，则移除该队列\n                if (queueList.get(queueIndex).isEmpty()) {\n                    queueList.remove(queueIndex);\n                    if (queueList.isEmpty()) break; // 如果所有队列都已处理完毕，则退出循环\n                    queueIndex %= queueList.size(); // 调整队列索引，防止索引越界\n                    didRemoveQueue = true;\n                }\n                // 如果当前队列不为空，则从队列中取出一个元素填充到matrix数组中\n                if (!queueList.get(queueIndex).isEmpty()) {\n                    matrix[matrixIndex++] = queueList.get(queueIndex).poll();\n                    if (matrixIndex >= matrix.length) break; // 如果matrix数组已填满，则退出循环\n                }\n            }\n\n            // 如果本轮循环没有队列被移除，并且队列列表不为空，则处理下一个队列\n            if (!didRemoveQueue && !queueList.isEmpty()) {\n                queueIndex = (queueIndex + 1) % queueList.size();\n            }\n        }\n\n        // 使用StringBuilder构建最终的输出字符串\n        StringBuilder sb = new StringBuilder();\n        // 遍历matrix数组，按照窗口顺序构建输出字符串\n        for (int row = 0; row < numberOfRows; row++) {\n            for (int col = 0; col < numberOfColumns; col++) {\n                sb.append(matrix[col * numberOfRows + row]).append(\" \");\n            }\n        }\n\n        // 输出最终的元素排列，去除末尾的空格\n        System.out.println(sb.toString().trim());\n    }\n}",
      "python": "import sys\n\n\n# 读取窗口数量N\nnumberOfRows = int(input())\n# 读取每个窗口需要的元素数量K\nnumberOfColumns = int(input())\n\n# 创建队列列表，用于存储每个列表的元素\nqueueList = []\nwhile True:\n    try:\n        queueList.append(list(map(int, input().split())))\n    except:\n        break\n \n\n# 创建一个列表，用于存储最终的元素排列\nmatrix = [0] * (numberOfColumns * numberOfRows)\nmatrixIndex = 0  # 用于标记当前填充到matrix列表中的位置\nqueueIndex = 0  # 用于标记当前处理的队列索引\n\n# 循环，直到matrix列表被完全填满\nwhile matrixIndex < len(matrix):\n    didRemoveQueue = False  # 标记本轮循环中是否有队列被移除\n\n    # 遍历每个窗口，并尝试从当前队列中为每个窗口提取一个元素\n    for i in range(numberOfRows):\n        if not queueList:  # 如果所有队列都已处理完毕，则退出循环\n            break\n        # 如果当前队列为空，则移除该队列\n        if not queueList[queueIndex]:\n            queueList.pop(queueIndex)\n            if not queueList:\n                break\n            queueIndex %= len(queueList)\n            didRemoveQueue = True\n        # 如果当前队列不为空，则从队列中取出一个元素填充到matrix列表中\n        if queueList and queueList[queueIndex]:\n            matrix[matrixIndex] = queueList[queueIndex].pop(0)\n            matrixIndex += 1\n            if matrixIndex >= len(matrix):\n                break\n\n    # 如果本轮循环没有队列被移除，并且队列列表不为空，则处理下一个队列\n    if not didRemoveQueue and queueList:\n        queueIndex = (queueIndex + 1) % len(queueList)\n\n# 按照窗口顺序构建输出字符串\nfor row in range(numberOfRows):\n    for col in range(numberOfColumns):\n        print(matrix[col * numberOfRows + row], end=\" \")",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <sstream>\n#include <string>\n\nusing namespace std;\nint main() {\n    int numberOfRows, numberOfColumns;\n    cin >> numberOfRows >> numberOfColumns;\n    cin.ignore(); // 忽略换行符\n\n    vector<queue<int>> queueList;\n    string inputLine;\n\n    // 循环读取输入，每次读取一行，直到输入结束\n    while (getline(cin, inputLine) && !inputLine.empty()) {\n        istringstream iss(inputLine);\n        queue<int> numberQueue;\n        int number;\n\n        // 将一行中的数分割并加入到队列中\n        while (iss >> number) {\n            numberQueue.push(number);\n        }\n\n        queueList.push_back(numberQueue);\n    }\n\n    vector<int> matrix(numberOfColumns * numberOfRows, 0);\n    int matrixIndex = 0;\n    int queueIndex = 0;\n\n    // 循环，直到所有元素被分配完毕\n    while (matrixIndex < matrix.size()) {\n        bool didRemoveQueue = false;\n\n        for (int i = 0; i < numberOfRows && !queueList.empty(); ++i) {\n            if (queueList[queueIndex].empty()) {\n                queueList.erase(queueList.begin() + queueIndex);\n                if (queueList.empty()) break;\n                queueIndex %= queueList.size();\n                didRemoveQueue = true;\n            }\n\n            if (!queueList[queueIndex].empty()) {\n                matrix[matrixIndex++] = queueList[queueIndex].front();\n                queueList[queueIndex].pop();\n                if (matrixIndex >= matrix.size()) break;\n            }\n        }\n\n        if (!didRemoveQueue && !queueList.empty()) {\n            queueIndex = (queueIndex + 1) % queueList.size();\n        }\n    }\n\n    // 按顺序输出结果\n    for (int row = 0; row < numberOfRows; ++row) {\n        for (int col = 0; col < numberOfColumns; ++col) {\n            cout << matrix[col * numberOfRows + row] << \" \";\n        }\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h> // 引入limits.h以使用INT_MIN\n\n#define MAX_QUEUE 100 // 定义最大队列数量\n#define MAX_LENGTH 1000 // 定义每行最大长度\n\n// 队列结构体定义\ntypedef struct {\n    int *items; // 队列元素数组\n    int front, rear, size, capacity; // 队列的前端、后端、当前大小和容量\n} Queue;\n\n// 创建队列的函数，参数为队列容量\nQueue* createQueue(int capacity) {\n    Queue* queue = (Queue*)malloc(sizeof(Queue)); // 动态分配队列结构体内存\n    queue->capacity = capacity; // 设置队列容量\n    queue->front = queue->size = 0; // 初始化队列大小和队列前端索引\n    queue->rear = capacity - 1; // 初始化队列后端索引\n    queue->items = (int*)malloc(queue->capacity * sizeof(int)); // 动态分配队列元素数组内存\n    return queue;\n}\n\n// 检查队列是否已满\nint isFull(Queue* queue) {\n    return (queue->size == queue->capacity);\n}\n\n// 检查队列是否为空\nint isEmpty(Queue* queue) {\n    return (queue->size == 0);\n}\n\n// 向队列中添加元素\nvoid enqueue(Queue* queue, int item) {\n    if (isFull(queue))\n        return;\n    queue->rear = (queue->rear + 1) % queue->capacity; // 循环队列中rear的更新\n    queue->items[queue->rear] = item; // 在rear位置添加元素\n    queue->size = queue->size + 1; // 更新队列大小\n}\n\n// 从队列中移除元素\nint dequeue(Queue* queue) {\n    if (isEmpty(queue))\n        return INT_MIN; // 如果队列为空，返回INT_MIN\n    int item = queue->items[queue->front]; // 获取队列前端元素\n    queue->front = (queue->front + 1) % queue->capacity; // 循环队列中front的更新\n    queue->size = queue->size - 1; // 更新队列大小\n    return item;\n}\n\n// 获取队列的前端元素\nint front(Queue* queue) {\n    if (isEmpty(queue))\n        return INT_MIN; // 如果队列为空，返回INT_MIN\n    return queue->items[queue->front]; // 返回队列前端元素\n}\n\nint main() {\n    int numberOfRows, numberOfColumns;\n    scanf(\"%d %d\", &numberOfRows, &numberOfColumns); // 读取行数和列数\n\n    Queue* queueList[MAX_QUEUE]; // 队列数组\n    int queueCount = 0; // 实际队列数量\n    char inputLine[MAX_LENGTH]; // 输入行缓冲\n\n    getchar(); // 清空输入缓冲区\n\n    // 循环读取输入\n    while (fgets(inputLine, MAX_LENGTH, stdin) && inputLine[0] != '\\n') {\n        queueList[queueCount] = createQueue(MAX_LENGTH); // 创建新队列\n        char* token = strtok(inputLine, \" \"); // 分割输入行\n        while (token != NULL) {\n            enqueue(queueList[queueCount], atoi(token)); // 将数值加入队列\n            token = strtok(NULL, \" \"); // 继续分割\n        }\n        queueCount++; // 更新队列数量\n    }\n\n    int* matrix = (int*)malloc(numberOfColumns * numberOfRows * sizeof(int)); // 分配矩阵内存\n    int matrixIndex = 0; // 矩阵索引\n    int queueIndex = 0; // 队列索引\n\n    // 循环，直到所有元素被分配完毕\n    while (matrixIndex < numberOfColumns * numberOfRows) {\n        int didRemoveQueue = 0; // 标记是否移除了队列\n\n        for (int i = 0; i < numberOfRows && queueCount > 0; ++i) {\n            if (isEmpty(queueList[queueIndex])) { // 如果当前队列为空\n                free(queueList[queueIndex]->items); // 释放队列元素数组内存\n                free(queueList[queueIndex]); // 释放队列结构体内存\n                // 移除空队列\n                for (int j = queueIndex; j < queueCount - 1; ++j) {\n                    queueList[j] = queueList[j + 1];\n                }\n                queueCount--; // 更新队列数量\n                if (queueCount == 0) break; // 如果没有队列了，退出循环\n                queueIndex %= queueCount; // 更新队列索引\n                didRemoveQueue = 1; // 标记已移除队列\n            }\n\n            if (!isEmpty(queueList[queueIndex])) { // 如果当前队列不为空\n                matrix[matrixIndex++] = dequeue(queueList[queueIndex]); // 从队列中取出元素并放入矩阵\n                if (matrixIndex >= numberOfColumns * numberOfRows) break; // 如果矩阵已满，退出循环\n            }\n        }\n\n        if (!didRemoveQueue && queueCount > 0) { // 如果没有移除队列且还有队列\n            queueIndex = (queueIndex + 1) % queueCount; // 循环更新队列索引\n        }\n    }\n\n    // 按顺序输出结果\n    for (int row = 0; row < numberOfRows; ++row) {\n        for (int col = 0; col < numberOfColumns; ++col) {\n            printf(\"%d \", matrix[col * numberOfRows + row]);\n        }\n     }\n\n    // 释放内存\n    for (int i = 0; i < queueCount; ++i) {\n        free(queueList[i]->items); // 释放队列元素数组内存\n        free(queueList[i]); // 释放队列结构体内存\n    }\n    free(matrix); // 释放矩阵内存\n\n    return 0;\n}"
    }
  },
  {
    "id": "126",
    "title": "数字游戏",
    "examType": "A",
    "score": 200,
    "description": "小明玩一个游戏。\n系统发1+n张牌，每张牌上有一个整数。\n第一张给小明，后n张按照发牌顺序排成连续的一行。\n需要小明判断，后n张牌中，是否存在连续的若干张牌，其和可以整除小明手中牌上的数字。",
    "inputDesc": "输入数据有多组，每组输入数据有两行，输入到文件结尾结束。\n第一行有两个整数n和m，空格隔开。m代表发给小明牌上的数字。\n第二行有n个数，代表后续发的n张牌上的数字，以空格隔开。\n1 ≤ n ≤ 10001 ≤ 牌上的整数 ≤ 400000输入的组数，不多于1000用例确保输入都正确，不需要考虑非法情况。",
    "outputDesc": "对每组输入，如果存在满足条件的连续若干张牌，则输出1;否则，输出0",
    "examples": [
      {
        "input": "7\n 12 6 3 5 5\n 11\n 1 1 1 1 1 1 1 1 1",
        "output": "",
        "explanation": "第一组小明牌的数字为7，再发了6张牌。第1、2两张牌教字和为14，可以整除7，输出1，第二组小明牌的教字为11，再发了10张牌，这10张牌数字和为10，无法整除11，输出0。"
      }
    ],
    "solution": "题目描述可以理解为，小明玩一个游戏，游戏中系统会发1+n张牌，其中第一张牌给小明，后续的n张牌排成一行。小明需要判断在这n张牌中，是否存在连续的若干张牌，其数字之和可以被小明手中牌上的数字整除。\n系统发1+n张牌，第一张牌上的数字是小明手中的牌上的数字，称为m。剩下的n张牌按照发牌顺序排成一行，并且每张牌上也有一个整数。任务是要找到这些n张牌中的连续若干张牌，使得它们的数字之和能够被小明手中牌上的数字m整除。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNextLine()) {\n            // 读取输入的n和m，n代表牌的数量，m代表小明手中牌上的数字\n            String[] input = scanner.nextLine().split(\" \");\n            int n = Integer.parseInt(input[0]);\n            int m = Integer.parseInt(input[1]);\n\n            // 读取后续发的n张牌的数字\n            int[] cardNumbers = new int[n];\n            String[] numStrings = scanner.nextLine().split(\" \");\n            for (int i = 0; i < n; i++) {\n                cardNumbers[i] = Integer.parseInt(numStrings[i]);\n            }\n\n            // 使用boolean数组来记录余数的出现情况\n            boolean[] remainderExists = new boolean[m];\n\n            int sum = 0;\n            boolean found = false;\n            for (int cardNumber : cardNumbers) {\n                sum += cardNumber; // 将当前牌的数字累加到sum中\n                int remainder = sum % m; // 计算当前和的余数\n                if (remainderExists[remainder]) { // 如果之前已经存在相同的余数，说明存在连续的若干张牌和可以整除m\n                    found = true;\n                    break;\n                } else {\n                    remainderExists[remainder] = true; // 将当前余数标记为已存在\n                }\n            }\n            System.out.println(found ? 1 : 0);\n        }\n    }\n}",
      "python": "import sys\n\nfor line in sys.stdin:\n    # 读取输入的n和m，n代表牌的数量，m代表小明手中牌上的数字\n    n, m = map(int, line.split())\n\n    # 读取后续发的n张牌的数字\n    cardNumbers = list(map(int, input().split()))\n\n    # 使用列表来记录余数的出现情况\n    remainderExists = [False] * m\n\n    sum = 0\n    found = False\n    for cardNumber in cardNumbers:\n        sum += cardNumber  # 将当前牌的数字累加到sum中\n        remainder = sum % m  # 计算当前和的余数\n        if remainderExists[remainder]:  # 如果之前已经存在相同的余数，说明存在连续的若干张牌和可以整除m\n            found = True\n            break\n        else:\n            remainderExists[remainder] = True  # 将当前余数标记为已存在\n\n    print(1 if found else 0)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet isFirstLine = true;\nlet n, m, cardNumbers;\n\nrl.on('line', (line) => {\n  if (isFirstLine) {\n    // 读取输入的n和m，n代表牌的数量，m代表小明手中牌上的数字\n    [n, m] = line.split(' ').map(Number);\n    isFirstLine = false;\n  } else {\n    // 读取后续发的n张牌的数字\n    cardNumbers = line.split(' ').map(Number);\n\n    // 使用数组来记录余数的出现情况\n    const remainderExists = new Array(m).fill(false);\n\n    let sum = 0;\n    let found = false;\n    for (let i = 0; i < n; i++) {\n      const cardNumber = cardNumbers[i];\n      sum += cardNumber;  // 将当前牌的数字累加到sum中\n      const remainder = sum % m;  // 计算当前和的余数\n      if (remainderExists[remainder]) {  // 如果之前已经存在相同的余数，说明存在连续的若干张牌和可以整除m\n        found = true;\n        break;\n      } else {\n        remainderExists[remainder] = true;  // 将当前余数标记为已存在\n      }\n    }\n\n    console.log(found ? 1 : 0);\n\n    isFirstLine = true;\n  }\n});",
      "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n\nint main() {\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        std::istringstream iss(line);\n\n        // 读取输入的n和m，n代表牌的数量，m代表小明手中牌上的数字\n        int n, m;\n        iss >> n >> m;\n\n        // 读取后续发的n张牌的数字\n        std::vector<int> cardNumbers(n);\n        std::getline(std::cin, line);\n        iss.str(line);\n        iss.clear();\n        for (int i = 0; i < n; i++) {\n            iss >> cardNumbers[i];\n        }\n\n        // 使用bool数组来记录余数的出现情况\n        std::vector<bool> remainderExists(m, false);\n\n        int sum = 0;\n        bool found = false;\n        for (int cardNumber : cardNumbers) {\n            sum += cardNumber; // 将当前牌的数字累加到sum中\n            int remainder = sum % m; // 计算当前和的余数\n            if (remainderExists[remainder]) { // 如果之前已经存在相同的余数，说明存在连续的若干张牌和可以整除m\n                found = true;\n                break;\n            } else {\n                remainderExists[remainder] = true; // 将当前余数标记为已存在\n            }\n        }\n\n        std::cout << (found ? 1 : 0) << std::endl;\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint main() {\n    int n, m; // 定义两个整数变量n和m，n代表牌的数量，m代表小明手中牌上的数字\n\n    // 使用while循环读取输入，当输入不是文件结束符EOF时继续执行\n    while (scanf(\"%d %d\", &n, &m) != EOF) {\n        int cardNumbers[n]; // 定义一个数组来存储n张牌的数字\n\n        // 读取n个牌的数字\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &cardNumbers[i]); // 从输入中读取每个牌的数字并存入数组\n        }\n\n        // 定义一个布尔数组用于记录余数的出现情况，初始值全部为false\n        bool remainderExists[m]; \n        for (int i = 0; i < m; i++) {\n            remainderExists[i] = false; // 初始化布尔数组\n        }\n\n        int sum = 0; // 用于存储牌数字的累加和\n        bool found = false; // 标记是否找到满足条件的连续牌\n\n        // 遍历每张牌的数字，计算累加和并求余数\n        for (int i = 0; i < n; i++) {\n            sum += cardNumbers[i]; // 将当前牌的数字累加到sum中\n            int remainder = sum % m; // 计算当前和的余数\n\n            // 如果当前余数为0，或者之前已经存在相同的余数，说明存在满足条件的连续牌\n            if (remainder == 0 || remainderExists[remainder]) {\n                found = true; // 设置found为true表示找到满足条件的连续牌\n                break; // 跳出循环\n            } else {\n                remainderExists[remainder] = true; // 将当前余数标记为已存在\n            }\n        }\n\n        // 输出结果，1表示找到满足条件的连续牌，0表示没有找到\n        printf(\"%d\\n\", found ? 1 : 0);\n    }\n\n    return 0; // 返回0表示程序正常结束\n}"
    }
  },
  {
    "id": "127",
    "title": "智能驾驶",
    "examType": "A",
    "score": 200,
    "description": "有一辆汽车需要从 m * n 的地图左上角（起点）开往地图的右下角（终点），去往每一个地区都需要消耗一定的油量，加油站可进行加油。\n请你计算汽车确保从从起点到达终点时所需的最少初始油量。\n说明：\n智能汽车可以上下左右四个方向移动地图上的数字取值是 0 或 -1 或 正整数： -1 ：表示加油站，可以加满油，汽车的油箱容量最大为100；0 ：表示这个地区是障碍物，汽车不能通过正整数：表示汽车走过这个地区的耗油量 如果汽车无论如何都无法到达终点，则返回 -1\n-1 ：表示加油站，可以加满油，汽车的油箱容量最大为100；0 ：表示这个地区是障碍物，汽车不能通过正整数：表示汽车走过这个地区的耗油量",
    "inputDesc": "第一行为两个数字，M，N，表示地图的大小为 M * N\n0 < M,N ≤ 200\n后面一个 M * N 的矩阵，其中的值是 0 或 -1 或正整数，加油站的总数不超过 200 个",
    "outputDesc": "如果汽车无论如何都无法到达终点，则返回 -1\n如果汽车可以到达终点，则返回最少的初始油量",
    "examples": [
      {
        "input": ",2\n,20\n,40",
        "output": "",
        "explanation": "行走的路线为：右→下"
      },
      {
        "input": ",4\n,30,30,20\n,30,-1,10\n,20,20,40\n,-1,30,40",
        "output": "",
        "explanation": "行走的路线为：右→右→下→下→下→右"
      },
      {
        "input": ",5\n,0,30,-1,10\n,0,20,0,20\n,0,10,0,30\n,-1,30,0,10",
        "output": "",
        "explanation": "行走的路线为：下→下→下→右→右→上→上→上→右→右→下→下→下"
      },
      {
        "input": ",4\n,30,30,20\n,30,20,10\n,20,10,40\n,20,30,40",
        "output": "-1",
        "explanation": "无论如何都无法到达终点"
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    // 定义常量，表示汽车油箱的最大容量\n    private static final int MAX_FUEL = 100; \n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in).useDelimiter(\",|\\\\s+\");\n        // 读取地图的行数和列数\n        int numRows = scanner.nextInt();\n        int numCols = scanner.nextInt();\n        // 创建地图数组\n        int[][] map = new int[numRows][numCols];\n\n        // 填充地图数组，读取每个单元的值\n        for (int i = 0; i < numRows; i++) {\n            for (int j = 0; j < numCols; j++) {\n                map[i][j] = scanner.nextInt();\n            }\n        }\n\n        // 计算并获取最小初始油量\n        int minFuel = findMinimumInitialFuel(map, numRows, numCols);\n        // 输出计算结果\n        System.out.println(minFuel);\n    }\n\n    // 使用二分查找方法确定从起点到终点所需的最小初始油量\n    private static int findMinimumInitialFuel(int[][] map, int numRows, int numCols) {\n        int low = 0, high = MAX_FUEL, optimalFuel = -1; // 初始化二分查找的上下界及结果\n\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            // 判断当前中值油量是否足以到达终点\n            if (canReachDestination(map, mid, numRows, numCols)) {\n                optimalFuel = mid; // 更新找到的可行油量\n                high = mid - 1; // 尝试寻找更小的可行油量\n            } else {\n                low = mid + 1; // 增加油量尝试\n            }\n        }\n        return optimalFuel; // 返回最小初始油量，如果无法到达则返回-1\n    }\n\n    // 检查给定起始油量是否足以从起点到达终点\n    private static boolean canReachDestination(int[][] map, int startFuel, int numRows, int numCols) {\n        if (map[0][0] == 0) return false; // 起点如果是障碍物，则无法出发\n\n        // 初始化每个位置的剩余油量数组\n        int[][] remainingFuel = new int[numRows][numCols];\n        for (int[] row : remainingFuel) {\n            Arrays.fill(row, -1);\n        }\n        // 设置起点的初始油量\n        remainingFuel[0][0] = map[0][0] == -1 ? MAX_FUEL : startFuel - map[0][0];\n        if (remainingFuel[0][0] < 0) return false; // 如果起始油量不足以离开起点，返回false\n\n        // 使用优先队列按照油量从大到小进行搜索\n        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> b[2] - a[2]);\n        priorityQueue.offer(new int[]{0, 0, remainingFuel[0][0]});\n        int[] dx = {0, 1, 0, -1}; // 搜索方向数组x\n        int[] dy = {1, 0, -1, 0}; // 搜索方向数组y\n\n        // BFS搜索\n        while (!priorityQueue.isEmpty()) {\n            int[] current = priorityQueue.poll();\n            int currentRow = current[0], currentCol = current[1], fuel = current[2];\n\n            if (currentRow == numRows - 1 && currentCol == numCols - 1) return true; // 如果到达终点，则返回true\n\n            // 检查四个方向\n            for (int direction = 0; direction < 4; direction++) {\n                int newRow = currentRow + dx[direction], newCol = currentCol + dy[direction];\n                if (isValid(newRow, newCol, numRows, numCols, map)) { // 检查新位置是否有效\n                    int newFuel = map[newRow][newCol] == -1 ? MAX_FUEL : fuel - map[newRow][newCol];\n                    if (newFuel > remainingFuel[newRow][newCol]) {\n                        remainingFuel[newRow][newCol] = newFuel;\n                        priorityQueue.offer(new int[]{newRow, newCol, newFuel});\n                    }\n                }\n            }\n        }\n        return false; // 如果无法到达终点，则返回false\n    }\n\n    // 判断指定位置是否有效（不越界，非障碍物）\n    private static boolean isValid(int row, int col, int numRows, int numCols, int[][] map) {\n        return row >= 0 && row < numRows && col >= 0 && col < numCols && map[row][col] != 0;\n    }\n}",
      "python": "import heapq\n\n# 定义常量，表示汽车油箱的最大容量\nMAX_FUEL = 100\n\ndef main():\n    # 从标准输入读取行数和列数，并以逗号分隔\n    numRows, numCols = map(int, input().split(\",\"))\n    # 读取地图数据，每一行通过逗号分隔，对于每行输入，读取numRows行\n    map_data = [list(map(int, input().split(\",\"))) for _ in range(numRows)]\n\n    # 计算并获取最小初始油量\n    min_fuel = find_minimum_initial_fuel(map_data, numRows, numCols)\n    # 输出计算得到的最小初始油量\n    print(min_fuel)\n\ndef find_minimum_initial_fuel(map_data, numRows, numCols):\n    # 初始化二分查找的边界\n    low, high = 0, MAX_FUEL\n    optimal_fuel = -1  # 最优的油量值，默认为-1表示未找到\n\n    # 二分查找确定合适的起始油量\n    while low <= high:\n        mid = (low + high) // 2\n        # 检查中值油量是否可以从起点到达终点\n        if can_reach_destination(map_data, mid, numRows, numCols):\n            optimal_fuel = mid  # 更新找到的最小可行油量\n            high = mid - 1  # 尝试更小的油量\n        else:\n            low = mid + 1  # 增加油量尝试\n    \n    return optimal_fuel\n\ndef can_reach_destination(map_data, start_fuel, numRows, numCols):\n    # 如果起点是障碍物，则无法出发\n    if map_data[0][0] == 0:\n        return False\n\n    # 初始化存储每个单元格剩余油量的二维列表\n    remaining_fuel = [[-1 for _ in range(numCols)] for _ in range(numRows)]\n    # 设置起点的初始油量，考虑起点可能为负值消耗的情况\n    remaining_fuel[0][0] = MAX_FUEL if map_data[0][0] == -1 else start_fuel - map_data[0][0]\n    if remaining_fuel[0][0] < 0:\n        return False  # 起始油量不足以离开起点\n\n    # 使用优先队列，以最大剩余油量优先处理\n    priority_queue = []\n    heapq.heappush(priority_queue, (-remaining_fuel[0][0], 0, 0))\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 定义上下左右四个方向\n\n    # 使用优先队列执行BFS\n    while priority_queue:\n        current_fuel, current_row, current_col = heapq.heappop(priority_queue)\n        current_fuel = -current_fuel  # 因为用了负值来实现最大堆\n        \n        # 到达终点检查\n        if current_row == numRows - 1 and current_col == numCols - 1:\n            return True\n        \n        # 检查四个可能的移动方向\n        for dx, dy in directions:\n            new_row, new_col = current_row + dx, current_col + dy\n            if is_valid(new_row, new_col, numRows, numCols, map_data):\n                new_fuel = MAX_FUEL if map_data[new_row][new_col] == -1 else current_fuel - map_data[new_row][new_col]\n                if new_fuel > remaining_fuel[new_row][new_col]:\n                    remaining_fuel[new_row][new_col] = new_fuel\n                    heapq.heappush(priority_queue, (-new_fuel, new_row, new_col))\n                    \n    return False  # 如果没有找到到达终点的路径则返回False\n\ndef is_valid(row, col, numRows, numCols, map_data):\n    # 检查位置是否有效（不越界且不是障碍物）\n    return 0 <= row < numRows and 0 <= col < numCols and map_data[row][col] != 0\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "const readline = require('readline');\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n  terminal: false \n});\nconst MAX_FUEL = 100; // 设置最大油量常量\nconst lines = []; // 创建一个数组来存储从控制台读取的每行数据\n// 当读取到一行数据时触发，将数据存入 lines 数组\nrl.on('line', function(line) {\n  lines.push(line);\n});\n\n// 当所有输入都读取完毕时触发\nrl.on('close', function() {\n  // 解析第一行数据为地图的行数和列数\n  const [numRows, numCols] = lines[0].split(\",\").map(Number);\n  const map = []; // 初始化地图数组\n  // 根据行数解析后续输入数据填充地图\n  for (let i = 1; i <= numRows; i++) {\n    map.push(lines[i].split(\",\").map(Number));\n  }\n  // 计算最小初始油量\n  const minFuel = findMinimumInitialFuel(map, numRows, numCols);\n  // 输出结果\n  console.log(minFuel);\n});\n\n// 判断是否可以到达目的地的函数\nfunction canReachDestination(map, startFuel, numRows, numCols) {\n  if (map[0][0] === 0) return false; // 如果起点是不可通行的，则直接返回 false\n\n  // 初始化剩余油量的二维数组\n  const remainingFuel = Array.from({ length: numRows }, () => Array(numCols).fill(-1));\n  // 设置起点的初始油量\n  remainingFuel[0][0] = map[0][0] === -1 ? MAX_FUEL : startFuel - map[0][0];\n  if (remainingFuel[0][0] < 0) return false; // 如果起点油量不足，返回 false\n\n  // 初始化队列并将起点加入队列\n  const queue = [[0, 0, remainingFuel[0][0]]];\n  // 定义移动方向的数组\n  const dx = [0, 1, 0, -1];\n  const dy = [1, 0, -1, 0];\n\n  // 广度优先搜索遍历地图\n  while (queue.length > 0) {\n    const [currentRow, currentCol, fuel] = queue.shift();\n\n    // 判断是否到达终点\n    if (currentRow === numRows - 1 && currentCol === numCols - 1) return true;\n\n    // 遍历四个可能的移动方向\n    for (let direction = 0; direction < 4; direction++) {\n      const newRow = currentRow + dx[direction];\n      const newCol = currentCol + dy[direction];\n      // 检查新位置是否有效\n      if (isValid(newRow, newCol, numRows, numCols, map)) {\n        // 计算新位置的剩余油量\n        const newFuel = map[newRow][newCol] === -1 ? MAX_FUEL : fuel - map[newRow][newCol];\n        // 如果新位置的剩余油量大于之前记录的值，更新并将其加入队列\n        if (newFuel > remainingFuel[newRow][newCol]) {\n          remainingFuel[newRow][newCol] = newFuel;\n          queue.push([newRow, newCol, newFuel]);\n        }\n      }\n    }\n  }\n\n  return false; // 如果没有到达终点，则返回 false\n}\n\n// 检查指定位置是否有效\nfunction isValid(row, col, numRows, numCols, map) {\n  return row >= 0 && row < numRows && col >= 0 && col < numCols && map[row][col] !== 0;\n}\n\n// 使用二分搜索确定最小的初始油量的函数\nfunction findMinimumInitialFuel(map, numRows, numCols) {\n  let low = 0, high = MAX_FUEL, optimalFuel = -1;\n  while (low <= high) {\n    const mid = Math.floor((low + high) / 2);\n    // 判断中间值油量是否足够\n    if (canReachDestination(map, mid, numRows, numCols)) {\n      optimalFuel = mid;\n      high = mid - 1;\n    } else {\n      low = mid + 1;\n    }\n  }\n  return optimalFuel; // 返回找到的最小初始油量\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\n// 定义常量，表示汽车油箱的最大容量\nconst int MAX_FUEL = 100;\n\n// 函数声明\nbool canReachDestination(const vector<vector<int>>& mapData, int startFuel, int numRows, int numCols);\nbool isValid(int row, int col, int numRows, int numCols, const vector<vector<int>>& mapData);\n\n// 寻找从起点到终点所需要的最小初始油量的函数\nint findMinimumInitialFuel(const vector<vector<int>>& mapData, int numRows, int numCols) {\n    int low = 0, high = MAX_FUEL, optimalFuel = -1;  // 初始化二分查找的上下界和最优解变量\n\n    while (low <= high) {  // 进行二分查找\n        int mid = (low + high) / 2;\n        if (canReachDestination(mapData, mid, numRows, numCols)) {\n            optimalFuel = mid;  // 如果可以到达终点，更新最优解\n            high = mid - 1;     // 尝试寻找更小的初始油量\n        } else {\n            low = mid + 1;      // 如果不可以到达终点，增加初始油量的下限\n        }\n    }\n\n    return optimalFuel;  // 返回找到的最小初始油量\n}\n\n// 判断给定起始油量能否从起点到达终点的函数\nbool canReachDestination(const vector<vector<int>>& mapData, int startFuel, int numRows, int numCols) {\n    if (mapData[0][0] == 0) return false;  // 如果起点是障碍物，直接返回false\n\n    vector<vector<int>> remainingFuel(numRows, vector<int>(numCols, -1));  // 初始化每个点的剩余油量数组\n    remainingFuel[0][0] = (mapData[0][0] == -1) ? MAX_FUEL : startFuel - mapData[0][0];  // 设置起点的初始油量\n    if (remainingFuel[0][0] < 0) return false;  // 如果起点的初始油量就不足，返回false\n\n    priority_queue<tuple<int, int, int>> priorityQueue;  // 使用优先队列存储待处理的点\n    priorityQueue.push({remainingFuel[0][0], 0, 0});\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};  // 可以移动的四个方向\n\n    while (!priorityQueue.empty()) {\n        auto [currentFuel, currentRow, currentCol] = priorityQueue.top();  // 取出当前油量最大的点\n        priorityQueue.pop();\n\n        if (currentRow == numRows - 1 && currentCol == numCols - 1) return true;  // 如果到达终点，返回true\n\n        // 遍历四个可能的方向\n        for (auto& dir : directions) {\n            int newRow = currentRow + dir.first;\n            int newCol = currentCol + dir.second;\n            if (isValid(newRow, newCol, numRows, numCols, mapData)) {  // 检查新位置是否有效\n                int newFuel = (mapData[newRow][newCol] == -1) ? MAX_FUEL : currentFuel - mapData[newRow][newCol];\n                if (newFuel > remainingFuel[newRow][newCol]) {\n                    remainingFuel[newRow][newCol] = newFuel;  // 更新剩余油量\n                    priorityQueue.push({newFuel, newRow, newCol});  // 将新点加入优先队列\n                }\n            }\n        }\n    }\n\n    return false;  // 如果遍历完成后没有找到可到达终点的路径，返回false\n}\n\n// 检查位置是否有效的函数\nbool isValid(int row, int col, int numRows, int numCols, const vector<vector<int>>& mapData) {\n    return row >= 0 && row < numRows && col >= 0 && col < numCols && mapData[row][col] != 0;  // 确保不越界且不是障碍物\n}\n\nint main() {\n    int numRows, numCols;\n    char comma;\n\n    cin >> numRows >> comma >> numCols;  // 读取行数和列数\n    vector<vector<int>> mapData(numRows, vector<int>(numCols));\n\n    for (int i = 0; i < numRows; ++i) {  // 读取地图数据\n        for (int j = 0; j < numCols; ++j) {\n            if (j < numCols - 1) {\n                cin >> mapData[i][j] >> comma;  // 读取每一行的数据，并处理逗号\n            } else {\n                cin >> mapData[i][j];\n            }\n        }\n    }\n\n    int minFuel = findMinimumInitialFuel(mapData, numRows, numCols);  // 计算最小初始油量\n    cout << minFuel << endl;  // 输出结果\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FUEL 100  // 定义最大油量常量\n\n// 函数声明\nint canReachDestination(int **map, int startFuel, int numRows, int numCols);\nint isValid(int row, int col, int numRows, int numCols, int **map);\nint findMinimumInitialFuel(int **map, int numRows, int numCols);\n\nint main() {\n    int numRows, numCols;  // 定义行数和列数变量\n    int **map;  // 定义一个二维数组指针，用于存储地图数据\n    int i, j;\n\n    // 从标准输入读取地图的行数和列数\n    scanf(\"%d,%d\", &numRows, &numCols);\n\n    // 为地图分配内存空间\n    map = (int **)malloc(numRows * sizeof(int *));\n    for (i = 0; i < numRows; i++) {\n        map[i] = (int *)malloc(numCols * sizeof(int));\n    }\n\n    // 从标准输入读取地图数据\n    for (i = 0; i < numRows; i++) {\n        for (j = 0; j < numCols; j++) {\n            if (j < numCols - 1)\n                scanf(\"%d,\", &map[i][j]);  // 读取每行中间的数值\n            else\n                scanf(\"%d\", &map[i][j]);  // 读取每行最后一个数值\n        }\n    }\n\n    // 计算并返回最小初始油量\n    int minFuel = findMinimumInitialFuel(map, numRows, numCols);\n    printf(\"%d\\n\", minFuel);  // 输出计算结果\n\n    // 释放地图内存空间\n    for (i = 0; i < numRows; i++) {\n        free(map[i]);\n    }\n    free(map);\n\n    return 0;\n}\n\n// 判断是否可以到达终点的函数\nint canReachDestination(int **map, int startFuel, int numRows, int numCols) {\n    if (map[0][0] == 0) return 0;  // 起点不可通行则返回0\n\n    // 初始化剩余油量的二维数组\n    int **remainingFuel = (int **)malloc(numRows * sizeof(int *));\n    for (int i = 0; i < numRows; i++) {\n        remainingFuel[i] = (int *)malloc(numCols * sizeof(int));\n        for (int j = 0; j < numCols; j++) {\n            remainingFuel[i][j] = -1;  // 初始化为-1\n        }\n    }\n    remainingFuel[0][0] = (map[0][0] == -1) ? MAX_FUEL : startFuel - map[0][0];\n    if (remainingFuel[0][0] < 0) return 0;  // 起点油量不足返回0\n\n    // 使用队列进行广度优先搜索\n    int queue[10000][3], front = 0, rear = 0;  // 定义队列及其指针\n    queue[rear][0] = 0;\n    queue[rear][1] = 0;\n    queue[rear][2] = remainingFuel[0][0];\n    rear++;\n\n    int dx[4] = {0, 1, 0, -1};\n    int dy[4] = {1, 0, -1, 0};\n\n    // 遍历队列中的元素\n    while (front < rear) {\n        int currentRow = queue[front][0];\n        int currentCol = queue[front][1];\n        int fuel = queue[front][2];\n        front++;\n\n        // 到达终点检查\n        if (currentRow == numRows - 1 && currentCol == numCols - 1) return 1;\n\n        // 检查四个方向的可行性\n        for (int direction = 0; direction < 4; direction++) {\n            int newRow = currentRow + dx[direction];\n            int newCol = currentCol + dy[direction];\n            if (isValid(newRow, newCol, numRows, numCols, map)) {\n                int newFuel = (map[newRow][newCol] == -1) ? MAX_FUEL : fuel - map[newRow][newCol];\n                if (newFuel > remainingFuel[newRow][newCol]) {\n                    remainingFuel[newRow][newCol] = newFuel;\n                    queue[rear][0] = newRow;\n                    queue[rear][1] = newCol;\n                    queue[rear][2] = newFuel;\n                    rear++;\n                }\n            }\n        }\n    }\n\n    // 释放剩余油量数组内存空间\n    for (int i = 0; i < numRows; i++) {\n        free(remainingFuel[i]);\n    }\n    free(remainingFuel);\n\n    return 0;  // 无法到达终点返回0\n}\n\n// 检查指定位置是否有效的函数\nint isValid(int row, int col, int numRows, int numCols, int **map) {\n    return row >= 0 && row < numRows && col >= 0 && col < numCols && map[row][col] != 0;\n}\n\n// 使用二分搜索确定最小初始油量的函数\nint findMinimumInitialFuel(int **map, int numRows, numCols) {\n    int low = 0, high = MAX_FUEL, optimalFuel = -1;  // 初始化二分搜索边界和结果\n    while (low <= high) {\n        int mid = (low + high) / 2;  // 计算中点\n        if (canReachDestination(map, mid, numRows, numCols)) {\n            optimalFuel = mid;  // 更新找到的最小油量\n            high = mid - 1;  // 继续在更低的范围内搜索\n        } else {\n            low = mid + 1;  // 在更高的范围内搜索\n        }\n    }\n    return optimalFuel;  // 返回找到的最小初始油量\n}"
    }
  },
  {
    "id": "128",
    "title": "最佳对手实力差距最小总和",
    "examType": "A",
    "score": 200,
    "description": "游戏里面，队伍通过匹配实力相近的对手进行对战。但是如果匹配的队伍实力相差太大，对于双方游戏体验都不会太好。\n给定n个队伍的实力值，对其进行两两实力匹配，两支队伍实例差距在允许的最大差距d内，则可以匹配。 要求在匹配队伍最多的情况下匹配出的各组实力差距的总和最小。",
    "inputDesc": "第一行，n，d。队伍个数n。允许的最大实力差距d。\n2<=n <=500<=d<=100\n第二行，n个队伍的实力值空格分割。\n0<=各队伍实力值<=100",
    "outputDesc": "匹配后，各组对战的实力差值的总和。若没有队伍可以匹配，则输出-1。",
    "examples": [
      {
        "input": "30\n 87 47 59 81 18",
        "output": "",
        "explanation": "18与47配对，实力差距29 59与81配对，实力差距22 81与87配对，实力差距6 总实力差距29+22+6=57"
      },
      {
        "input": "20\n 87 47 59 81 18",
        "output": "",
        "explanation": "最多能匹配成功4支队伍。 47与59配对，实力差距12， 81与81配对，实力差距0。 总实力差距12+0=12"
      },
      {
        "input": "10\n 51 62 73",
        "output": "-1",
        "explanation": "实力差距都在10以上， 没有队伍可以匹配成功。"
      }
    ],
    "solution": "给定 n 个队伍的实力值和一个允许的最大实力差距 d，要求将队伍进行两两配对，满足每对队伍的实力差距不超过 d，并且在尽可能多的匹配情况下，使所有匹配的实力差距的总和最小。如果没有符合条件的匹配，则输出 -1。\n状态定义： pairs[i]：前 i 个队伍中最多能匹配的队伍对数。min_sum[i]：前 i 个队伍的最小实力差距总和。 状态转移： 对于每一个队伍 i，考虑是否将第 i 和第 i-1 个队伍配对。如果配对成立（差距在允许范围内），则更新 pairs[i] 和 min_sum[i]，确保匹配数最多且差距总和最小。 转移规则： 对每一组队伍，从第 2 组开始遍历，尝试将相邻的队伍进行配对。如果配对后能增加匹配数量或使差距总和更小，则更新状态。 边界处理： 如果最终没有任何队伍能匹配，则输出 -1。否则输出 min_sum[n]，即最小的实力差距总和。\npairs[i]：前 i 个队伍中最多能匹配的队伍对数。min_sum[i]：前 i 个队伍的最小实力差距总和。\n对于每一个队伍 i，考虑是否将第 i 和第 i-1 个队伍配对。如果配对成立（差距在允许范围内），则更新 pairs[i] 和 min_sum[i]，确保匹配数最多且差距总和最小。\n对每一组队伍，从第 2 组开始遍历，尝试将相邻的队伍进行配对。如果配对后能增加匹配数量或使差距总和更小，则更新状态。\n如果最终没有任何队伍能匹配，则输出 -1。否则输出 min_sum[n]，即最小的实力差距总和。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // 读取队伍数量 n 和最大允许差距 d\n        int n = scanner.nextInt();  \n        int d = scanner.nextInt();  \n        \n        // 用来存储各队伍的实力值\n        List<Integer> nums = new ArrayList<>();  \n        \n        // 读取每个队伍的实力值并添加到 nums 列表中\n        for (int i = 0; i < n; i++) {  \n            int num = scanner.nextInt();\n            nums.add(num);\n        }\n        \n        // 对队伍实力值进行升序排序，方便后续贪心和动态规划处理\n        Collections.sort(nums);  \n\n        // 初始化 pairs 列表，存储能匹配的对的数量，n+1个元素，初始值为 0\n        List<Integer> pairs = new ArrayList<>(Collections.nCopies(n+1, 0));  \n        \n        // 初始化 min_sum 列表，存储最小的差值总和，n+1个元素，初始值为 0\n        List<Integer> min_sum = new ArrayList<>(Collections.nCopies(n+1, 0));  \n\n        // 从第3个元素开始考虑配对（因为要两两配对，所以从2开始）\n        for (int i = 2; i < n+1; i++) {\n            int tmp = 0;\n            \n            // 如果当前两支队伍的实力差距在允许范围内，tmp置为1，表示可以匹配\n            if (nums.get(i-1) - nums.get(i-2) <= d) {\n                tmp += 1;\n            }\n\n            // 比较是否选择配对前两支队伍能获得更多的匹配数量\n            if (pairs.get(i-2) + tmp > pairs.get(i-1)) {\n                // 如果配对前两支队伍能得到更多的配对数量，更新 pairs 和 min_sum\n                pairs.set(i, pairs.get(i-2) + tmp);  \n                min_sum.set(i, min_sum.get(i-2) + nums.get(i-1) - nums.get(i-2));  \n            }\n            // 如果不配对前两支队伍能保持或增加匹配数量，则选择不配对\n            else if (pairs.get(i-2) + tmp < pairs.get(i-1)) {\n                // 配对数量不增加，保持原有的状态\n                pairs.set(i, pairs.get(i-1));  \n                min_sum.set(i, min_sum.get(i-1));  \n            }\n            // 如果配对数量相同，则选择差距更小的配对策略\n            else {\n                if (tmp == 1) {\n                    // 如果配对，选择较小的差值总和\n                    min_sum.set(i, Math.min(min_sum.get(i-1), min_sum.get(i-2) + nums.get(i-1) - nums.get(i-2)));  \n                }\n                else {\n                    // 如果不配对，选择保持原有的差值总和\n                    min_sum.set(i, Math.min(min_sum.get(i-1), min_sum.get(i-2)));  \n                }\n                pairs.set(i, pairs.get(i-1));  // 匹配数量保持不变\n            }\n        }\n\n        // 最终结果：如果没有任何队伍配对成功，输出 -1，否则输出最小的差值总和\n        if (pairs.get(n) == 0) {\n            System.out.println(-1);  // 无法配对\n        } else {\n            System.out.println(min_sum.get(n));  // 输出最小的差值总和\n        }\n    }\n}",
      "python": "n, d = map(int, input().split())\nnums = list(map(int, input().split()))\nnums.sort()\n\npairs = [0] * (n+1)\nmin_sum = [0] * (n+1)\n\nfor i in range(2, n+1):\n    tmp = 0\n    if nums[i-1] - nums[i-2] <= d:\n        tmp += 1\n    if pairs[i-2] + tmp > pairs[i-1]:\n        pairs[i] = pairs[i-2] + tmp\n        min_sum[i] = min_sum[i-2] + nums[i-1] - nums[i-2]\n    elif pairs[i-2] + tmp < pairs[i-1]:\n        pairs[i] = pairs[i-1]\n        min_sum[i] = min_sum[i-1]\n    else:\n        if tmp == 1:\n            min_sum[i] = min(min_sum[i-1], min_sum[i-2] + nums[i-1] - nums[i-2])\n        else:\n            min_sum[i] = min(min_sum[i-1], min_sum[i-2])\n        pairs[i] = pairs[i-1]\n\nif pairs[n] == 0:\n    print(-1)\nelse:\n    print(min_sum[n])",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet input = [];\nrl.on('line', (line) => {\n  input.push(line);\n  if(input.length === 2){\n    const [n, d] = input[0].split(' ').map(Number);\n    const nums = input[1].split(' ').map(Number).sort((a, b) => a - b);\n\n    //pair个数\n    const pairs = new Array(n+1).fill(0);\n    //最小和\n    const min_sum = new Array(n+1).fill(0);\n\n    // 动态规划求解最小和\n    for (let i = 2; i < n+1; i++){\n        let tmp = 0;\n        // 如果两个队伍之间的实力差距小于等于d，则它们可以匹配\n        if (nums[i-1] - nums[i-2] <= d)\n            tmp += 1;\n\n        // 如果匹配i-1个队伍的最小和小于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-2个队伍的最小和加上i-1和i队伍的实力差距\n        if (pairs[i-2] + tmp > pairs[i-1]){\n            pairs[i] = pairs[i-2] + tmp;\n            min_sum[i] = min_sum[i-2] + nums[i-1] - nums[i-2];\n        }\n        // 如果匹配i-1个队伍的最小和大于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-1个队伍的最小和\n        else if (pairs[i-2] + tmp < pairs[i-1]){\n            pairs[i] = pairs[i-1];\n            min_sum[i] = min_sum[i-1];\n        }\n        // 如果匹配i-1个队伍的最小和等于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-1个队伍的最小和和匹配i-2个队伍的最小和加上i-1和i队伍的实力差距的最小值\n        else{\n            if (tmp == 1)\n                min_sum[i] = Math.min(min_sum[i-1], min_sum[i-2] + nums[i-1] - nums[i-2]);\n            else\n                min_sum[i] = Math.min(min_sum[i-1], min_sum[i-2]);\n            pairs[i] = pairs[i-1];\n        }\n    }\n\n    // 如果没有队伍可以匹配，则输出-1\n    if (pairs[n] == 0)\n        console.log(-1);\n    else\n        console.log(min_sum[n]);\n\n    rl.close();\n  }\n});",
      "cpp": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main() {\n    // 处理输入\n    int n, d; \n    cin >> n >> d;\n    vector<int> nums;\n    for(int i = 0; i < n; i++){\n        int num;\n        cin >> num;\n        nums.push_back(num);\n    }\n    // 按照大小排序\n    sort(nums.begin(), nums.end());\n\n    //pair个数\n    vector<int> pairs (n+1, 0);\n    //最小和\n    vector<int> min_sum (n+1, 0);\n\n    // 动态规划求解最小和\n    for (int i = 2; i < n+1; i++){\n        int tmp = 0;\n        // 如果两个队伍之间的实力差距小于等于d，则它们可以匹配\n        if (nums[i-1] - nums[i-2] <= d)\n            tmp += 1;\n\n        // 如果匹配i-1个队伍的最小和小于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-2个队伍的最小和加上i-1和i队伍的实力差距\n        if (pairs[i-2] + tmp > pairs[i-1]){\n            pairs[i] = pairs[i-2] + tmp;\n            min_sum[i] = min_sum[i-2] + nums[i-1] - nums[i-2];\n        }\n        // 如果匹配i-1个队伍的最小和大于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-1个队伍的最小和\n        else if (pairs[i-2] + tmp < pairs[i-1]){\n            pairs[i] = pairs[i-1];\n            min_sum[i] = min_sum[i-1];\n        }\n        // 如果匹配i-1个队伍的最小和等于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-1个队伍的最小和和匹配i-2个队伍的最小和加上i-1和i队伍的实力差距的最小值\n        else{\n            if (tmp == 1)\n                min_sum[i] = min(min_sum[i-1], min_sum[i-2] + nums[i-1] - nums[i-2]);\n            else\n                min_sum[i] = min(min_sum[i-1], min_sum[i-2]);\n            pairs[i] = pairs[i-1];\n        }\n    }\n\n    // 如果没有队伍可以匹配，则输出-1\n    if (pairs[n] == 0)\n        cout << -1;\n    else\n        cout << min_sum[n];\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 比较函数，用于升序排序\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint main() {\n    int n, d;\n    \n    // 读取队伍数量 n 和最大允许差距 d\n    scanf(\"%d %d\", &n, &d);\n    \n    // 动态分配数组 nums，用于存储队伍的实力值\n    int *nums = (int *)malloc(n * sizeof(int));\n    \n    // 读取每个队伍的实力值并存储到 nums 数组中\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &nums[i]);\n    }\n    \n    // 对队伍实力值进行升序排序\n    qsort(nums, n, sizeof(int), compare);\n    \n    // 动态分配数组 pairs，用于存储能匹配的对的数量，初始化为 0\n    int *pairs = (int *)calloc(n + 1, sizeof(int));\n    \n    // 动态分配数组 min_sum，用于存储最小的差值总和，初始化为 0\n    int *min_sum = (int *)calloc(n + 1, sizeof(int));\n\n    // 从第3个元素开始考虑配对（因为要两两配对，所以从 i = 2 开始）\n    for (int i = 2; i <= n; i++) {\n        int tmp = 0;\n\n        // 如果当前两支队伍的实力差距在允许范围内，tmp 置为 1，表示可以匹配\n        if (nums[i - 1] - nums[i - 2] <= d) {\n            tmp = 1;\n        }\n\n        // 如果配对前两支队伍的匹配数加上 tmp 比上一支队伍的匹配数更多\n        if (pairs[i - 2] + tmp > pairs[i - 1]) {\n            // 更新 pairs 和 min_sum，记录新的匹配数量和最小差值总和\n            pairs[i] = pairs[i - 2] + tmp;\n            min_sum[i] = min_sum[i - 2] + (nums[i - 1] - nums[i - 2]);\n        }\n        // 如果不配对前两支队伍能保持或增加匹配数量，则选择不配对\n        else if (pairs[i - 2] + tmp < pairs[i - 1]) {\n            pairs[i] = pairs[i - 1];\n            min_sum[i] = min_sum[i - 1];\n        }\n        // 如果配对数量相同，则选择差距更小的配对策略\n        else {\n            if (tmp == 1) {\n                // 如果配对，选择较小的差值总和\n                min_sum[i] = (min_sum[i - 1] < min_sum[i - 2] + (nums[i - 1] - nums[i - 2])) ? min_sum[i - 1] : (min_sum[i - 2] + (nums[i - 1] - nums[i - 2]));\n            } else {\n                // 如果不配对，选择保持原有的差值总和\n                min_sum[i] = (min_sum[i - 1] < min_sum[i - 2]) ? min_sum[i - 1] : min_sum[i - 2];\n            }\n            pairs[i] = pairs[i - 1];\n        }\n    }\n\n    // 最终结果：如果没有任何队伍配对成功，输出 -1，否则输出最小的差值总和\n    if (pairs[n] == 0) {\n        printf(\"-1\\n\");  // 无法配对\n    } else {\n        printf(\"%d\\n\", min_sum[n]);  // 输出最小的差值总和\n    }\n\n    // 释放动态分配的内存\n    free(nums);\n    free(pairs);\n    free(min_sum);\n\n    return 0;\n}"
    }
  },
  {
    "id": "129",
    "title": "最大相连男生数学生方阵",
    "examType": "A",
    "score": 200,
    "description": "学校组织活动，将学生排成一个矩形方阵。\n请在矩形方阵中找到最大的位置相连的男生数量。\n这个相连位置在一个直线上，方向可以是水平的，垂直的，成对角线的或者呈反对角线的。\n注：学生个数不会超过10000",
    "inputDesc": "输入的第一行为矩阵的行数和列数，接下来的n行为矩阵元素，元素间用”,”分隔。",
    "outputDesc": "输出一个整数，表示矩阵中最长的位置相连的男生个数。",
    "examples": [
      {
        "input": ",4\nF,M,M,F\nF,M,M,F\nF,F,F,M",
        "output": "",
        "explanation": ""
      },
      {
        "input": ",4\nF,M,M,F\nF,M,M,F\nF,F,F,M",
        "output": "F M M F\nF M M F\nF F F M",
        "explanation": ""
      }
    ],
    "solution": "题目要求在一个由学生组成的矩形方阵中，找到最大的位置相连的男生数量。这里“相连”是指男生的所在位置可以通过水平、垂直、对角线或反对角线方向连续连接。\n遍历整个方阵中的每个元素，当找到一个男生M时，调用getMaxConnected方法，开始从该位置搜索最长连续的M数量。getMaxConnected方法实现了四个方向的搜索（水平、垂直、对角线、反对角线）： 水平（从左往右）：从当前位置向右方向扫描，计算连续的M数量。垂直（从上往下）：从当前位置向下方向扫描，计算连续的M数量。对角线（左上到右下）：从当前位置向右下方向扫描，计算连续的M数量。反对角线（右上到左下）：从当前位置向左下方向扫描，计算连续的M数量。 每找到一条连续的男生M，将其数量添加到结果列表res中。\n水平（从左往右）：从当前位置向右方向扫描，计算连续的M数量。垂直（从上往下）：从当前位置向下方向扫描，计算连续的M数量。对角线（左上到右下）：从当前位置向右下方向扫描，计算连续的M数量。反对角线（右上到左下）：从当前位置向左下方向扫描，计算连续的M数量。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void getMaxConnected(List<List<String>> students, int row, int column, List<Integer> res) {\n        int len = 1; // 初始化连续的M的个数为1\n        int a = 0, b = 0; // 初始化行和列的索引\n        int m = students.size(), n = students.get(0).size(); // 获取方阵的行数和列数\n        if (column < n) {  // 从左往右搜索\n            a = row;\n            b = column;\n            while (b < n - 1 && students.get(a).get(++b).equals(\"M\")) { // 不越界且下一个元素为M\n                len++; // 连续的M的个数加1\n            }\n            res.add(len); // 把连续的M的个数加入结果数组\n            len = 1; // 重新初始化连续的M的个数为1\n        }\n        if (row < m) {  // 从上往下搜索\n            a = row;\n            b = column;\n            while (a < m - 1 && students.get(++a).get(b).equals(\"M\")) { // 不越界且下一个元素为M\n                len++; // 连续的M的个数加1\n            }\n            res.add(len); // 把连续的M的个数加入结果数组\n            len = 1; // 重新初始化连续的M的个数为1\n        }\n        if (row < m && column < n) {  // 对角线搜索\n            a = row;\n            b = column;\n            while ((a < m - 1 && b < n - 1) && students.get(++a).get(++b).equals(\"M\")) { // 不越界且下一个元素为M\n                len++; // 连续的M的个数加1\n            }\n            res.add(len); // 把连续的M的个数加入结果数组\n            len = 1; // 重新初始化连续的M的个数为1\n        }\n        if (row >= 0 && column < n) {  // 从右往左搜索\n            a = row;\n            b = column;\n            while ((a > 0 && b < n - 1) && students.get(--a).get(++b).equals(\"M\")) { // 不越界且下一个元素为M\n                len++; // 连续的M的个数加1\n            }\n            res.add(len); // 把连续的M的个数加入结果数组\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取矩阵大小\n        String[] dimensions = scanner.nextLine().split(\",\");\n        int row = Integer.parseInt(dimensions[0]);\n        int column = Integer.parseInt(dimensions[1]);\n\n        // 初始化方阵\n        List<List<String>> students = new ArrayList<>();\n        for (int i = 0; i < row; i++) {\n            String[] lineElements = scanner.nextLine().split(\",\");\n            students.add(Arrays.asList(lineElements));\n        }\n        List<Integer> max_res = new ArrayList<>(); // 初始化结果数组\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < column; j++) {\n                // 遇到M则开始找\n                if (students.get(i).get(j).equals(\"M\")) { // 如果当前元素为M\n                    getMaxConnected(students, i, j, max_res); // 在四个方向上搜索连续的M\n                }\n            }\n        }\n        Collections.sort(max_res); // 对结果数组排序\n        System.out.println(max_res.get(max_res.size() - 1)); // 输出最大的连续的M的个数\n\n        scanner.close();\n    }\n}\n\nimport java.util.*;\n\npublic class Main {\n    // 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {1, 1}, {-1, 1}};\n\n    public static void getMaxConnected(List<List<String>> students, int row, int column, List<Integer> res) {\n        int m = students.size(), n = students.get(0).size(); // 获取方阵的行数和列数\n\n        for (int[] dir : DIRECTIONS) {  // 遍历每个方向\n            int len = 1; // 初始化连续的M的个数为1\n            int a = row, b = column; // 初始化起始位置\n\n            // 按当前方向搜索\n            while (a + dir[0] >= 0 && a + dir[0] < m && b + dir[1] >= 0 && b + dir[1] < n\n                    && students.get(a + dir[0]).get(b + dir[1]).equals(\"M\")) {\n                a += dir[0]; // 更新行索引\n                b += dir[1]; // 更新列索引\n                len++; // 连续的M的个数加1\n            }\n\n            res.add(len); // 把连续的M的个数加入结果数组\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取矩阵大小\n        String[] dimensions = scanner.nextLine().split(\",\");\n        int row = Integer.parseInt(dimensions[0]);\n        int column = Integer.parseInt(dimensions[1]);\n\n        // 初始化方阵\n        List<List<String>> students = new ArrayList<>();\n        for (int i = 0; i < row; i++) {\n            String[] lineElements = scanner.nextLine().split(\",\");\n            students.add(Arrays.asList(lineElements));\n        }\n\n        List<Integer> max_res = new ArrayList<>(); // 初始化结果数组\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < column; j++) {\n                // 遇到M则开始找\n                if (students.get(i).get(j).equals(\"M\")) { // 如果当前元素为M\n                    getMaxConnected(students, i, j, max_res); // 在四个方向上搜索连续的M\n                }\n            }\n        }\n        Collections.sort(max_res); // 对结果数组排序\n        System.out.println(max_res.get(max_res.size() - 1)); // 输出最大的连续的M的个数\n\n        scanner.close();\n    }\n}",
      "python": "def get_max_connected(students, row, column, res):\n    length = 1  # 初始化连续的M的个数为1\n    a, b = 0, 0  # 初始化行和列的索引\n    m, n = len(students), len(students[0])  # 获取方阵的行数和列数\n\n    if column < n:  # 从左往右搜索\n        a = row\n        b = column\n        while b < n - 1 and students[a][b + 1] == \"M\":  # 不越界且下一个元素为M\n            b += 1\n            length += 1  # 连续的M的个数加1\n        res.append(length)  # 把连续的M的个数加入结果数组\n        length = 1  # 重新初始化连续的M的个数为1\n\n    if row < m:  # 从上往下搜索\n        a = row\n        b = column\n        while a < m - 1 and students[a + 1][b] == \"M\":  # 不越界且下一个元素为M\n            a += 1\n            length += 1  # 连续的M的个数加1\n        res.append(length)  # 把连续的M的个数加入结果数组\n        length = 1  # 重新初始化连续的M的个数为1\n\n    if row < m and column < n:  # 对角线搜索\n        a = row\n        b = column\n        while a < m - 1 and b < n - 1 and students[a + 1][b + 1] == \"M\":  # 不越界且下一个元素为M\n            a += 1\n            b += 1\n            length += 1  # 连续的M的个数加1\n        res.append(length)  # 把连续的M的个数加入结果数组\n        length = 1  # 重新初始化连续的M的个数为1\n\n    if row >= 0 and column < n:  # 从右往左搜索\n        a = row\n        b = column\n        while a > 0 and b < n - 1 and students[a - 1][b + 1] == \"M\":  # 不越界且下一个元素为M\n            a -= 1\n            b += 1\n            length += 1  # 连续的M的个数加1\n        res.append(length)  # 把连续的M的个数加入结果数组\n\n\nif __name__ == \"__main__\":\n    input_str = input().strip()\n    row, column = map(int, input_str.split(\",\"))\n\n    # 初始化方阵\n    students = []\n    for _ in range(row):\n        student_str = input().strip()\n        students.append(student_str.split(\",\"))\n\n    max_res = []  # 初始化结果数组\n    for i in range(row):\n        for j in range(column):\n            if students[i][j] == \"M\":\n                get_max_connected(students, i, j, max_res)  # 在四个方向上搜索连续的M\n\n    max_res.sort(reverse=True)  # 对结果数组排序\n    print(max_res[0])  # 输出最大的连续的M的个数\n\n\n\nimport sys\n\n# 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\nDIRECTIONS = [\n    (0, 1), (1, 0), (1, 1), (-1, 1)\n]\n\ndef getMaxConnected(students, row, column, res):\n    m = len(students)\n    n = len(students[0])\n\n    for dir in DIRECTIONS:\n        len_m = 1  # 初始化连续的M的个数为1\n        a, b = row, column\n\n        # 按当前方向搜索\n        while (0 <= a + dir[0] < m) and (0 <= b + dir[1] < n) and students[a + dir[0]][b + dir[1]] == \"M\":\n            a += dir[0]  # 更新行索引\n            b += dir[1]  # 更新列索引\n            len_m += 1  # 连续的M的个数加1\n\n        res.append(len_m)  # 把连续的M的个数加入结果数组\n\nif __name__ == \"__main__\":\n    input_str = input().strip()\n    row, column = map(int, input_str.split(\",\"))\n\n    # 初始化方阵\n    students = []\n    for _ in range(row):\n        student_str = input().strip()\n        students.append(student_str.split(\",\"))\n\n    max_res = []  # 初始化结果数组\n    for i in range(row):\n        for j in range(column):\n            if students[i][j] == \"M\":\n                getMaxConnected(students, i, j, max_res)  # 在四个方向上搜索连续的M\n\n    max_res.sort(reverse=True)  # 对结果数组排序\n    print(max_res[0])  # 输出最大的连续的M的个数",
      "javascript": "const readline = require('readline');\n\n// 创建一个接口用于从标准输入输出流读取数据\nconst rl = readline.createInterface({\n  input: process.stdin,  // 输入流为标准输入\n  output: process.stdout // 输出流为标准输出\n});\n\n// 定义一个函数，用于查找从某个点开始的最大连续的'M'数量\nfunction getMaxConnected(students, row, column, res) {\n  let len = 1; // 初始化长度为1（至少包含自身）\n  let a = 0, b = 0; // a和b用于遍历学生方阵\n  const m = students.length, n = students[0].length; // 获取方阵的行数m和列数n\n  \n  // 水平检查：从指定的列位置(column)向右遍历，直到非\"M\"或到达边界\n  if (column < n) {\n    a = row;\n    b = column;\n    while (b < n - 1 && students[a][++b] === \"M\") {\n      len++; // 如果找到\"M\"，长度加1\n    }\n    res.push(len); // 将找到的长度添加到结果数组中\n    len = 1; // 重置长度为1，用于下一次方向检查\n  }\n\n  // 垂直检查：从指定的行位置(row)向下遍历，直到非\"M\"或到达边界\n  if (row < m) {\n    a = row;\n    b = column;\n    while (a < m - 1 && students[++a][b] === \"M\") {\n      len++; // 如果找到\"M\"，长度加1\n    }\n    res.push(len); // 将找到的长度添加到结果数组中\n    len = 1; // 重置长度为1\n  }\n\n  // 对角线检查（左上到右下）：从指定的位置向右下方遍历，直到非\"M\"或到达边界\n  if (row < m && column < n) {\n    a = row;\n    b = column;\n    while ((a < m - 1 && b < n - 1) && students[++a][++b] === \"M\") {\n      len++; // 如果找到\"M\"，长度加1\n    }\n    res.push(len); // 将找到的长度添加到结果数组中\n    len = 1; // 重置长度为1\n  }\n\n  // 反对角线检查（左下到右上）：从指定的位置向右上方遍历，直到非\"M\"或到达边界\n  if (row >= 0 && column < n) {\n    a = row;\n    b = column;\n    while ((a > 0 && b < n - 1) && students[--a][++b] === \"M\") {\n      len++; // 如果找到\"M\"，长度加1\n    }\n    res.push(len); // 将找到的长度添加到结果数组中\n  }\n}\n\n// 监听标准输入的数据，当有输入时触发\nrl.on('line', (input) => {\n  // 解析第一行输入，获取方阵的行数和列数\n  const [row, column] = input.split(\",\").map(Number);\n  const students = []; // 初始化一个二维数组用于存储学生数据\n  \n  // 监听每一行的学生数据输入\n  rl.on('line', (student_str) => {\n    const temp = student_str.split(\",\"); // 将输入按逗号分隔，得到一行学生数据\n    students.push(temp); // 将这一行数据加入students数组\n    \n    // 当读取到的行数等于预期的行数时，开始处理数据\n    if (students.length === row) {\n      let max_res = []; // 初始化结果数组，用于存储每次搜索到的最大长度\n      // 遍历整个方阵\n      for (let i = 0; i < row; i++) {\n        for (let j = 0; j < column; j++) {\n          // 如果当前点是\"M\"，则调用getMaxConnected函数查找\n          if (students[i][j] === \"M\") {\n            getMaxConnected(students, i, j, max_res);\n          }\n        }\n      }\n      // 对找到的所有长度排序，取最大值并输出\n      max_res.sort((a, b) => b - a);\n      console.log(max_res[0]);\n      rl.close(); // 关闭读取接口\n    }\n  });\n});\n\n\nconst readline = require('readline');\n\n// 创建接口以读取输入\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\nconst DIRECTIONS = [\n    [0, 1], [1, 0], [1, 1], [-1, 1]\n];\n\nfunction getMaxConnected(students, row, column, res) {\n    const m = students.length;\n    const n = students[0].length;\n\n    for (const dir of DIRECTIONS) {\n        let len = 1; // 初始化连续的M的个数为1\n        let a = row, b = column;\n\n        // 按当前方向搜索\n        while (a + dir[0] >= 0 && a + dir[0] < m && b + dir[1] >= 0 && b + dir[1] < n\n                && students[a + dir[0]][b + dir[1]] === \"M\") {\n            a += dir[0]; // 更新行索引\n            b += dir[1]; // 更新列索引\n            len++; // 连续的M的个数加1\n        }\n\n        res.push(len); // 把连续的M的个数加入结果数组\n    }\n}\n\nrl.on('line', (input) => {\n    const [row, column] = input.split(\",\").map(Number);\n    const students = [];\n\n    rl.on('line', (student_str) => {\n        const temp = student_str.split(\",\");\n        students.push(temp);\n\n        if (students.length === row) {\n            let max_res = [];\n\n            for (let i = 0; i < row; i++) {\n                for (let j = 0; j < column; j++) {\n                    if (students[i][j] === \"M\") {\n                        getMaxConnected(students, i, j, max_res);\n                    }\n                }\n            }\n\n            max_res.sort((a, b) => b - a);\n            console.log(max_res[0]);\n            rl.close();\n        }\n    });\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n \nvoid getMaxConnected(vector<vector<string>>& students, int row, int column, vector<int>& res) {\n    int len = 1; // 初始化连续的M的个数为1\n    int a = 0, b = 0; // 初始化行和列的索引\n    int m = students.size(), n = students[0].size(); // 获取方阵的行数和列数\n    if (column < n) {  // 从左往右搜索\n        a = row;\n        b = column;\n        while (b < n - 1 && students[a][++b] == \"M\") { // 不越界且下一个元素为M\n            len++; // 连续的M的个数加1\n        }\n        res.push_back(len); // 把连续的M的个数加入结果数组\n        len = 1; // 重新初始化连续的M的个数为1\n    }\n    if (row < m) {  // 从上往下搜索\n        a = row;\n        b = column;\n        while (a < m - 1 && students[++a][b] == \"M\") { // 不越界且下一个元素为M\n            len++; // 连续的M的个数加1\n        }\n        res.push_back(len); // 把连续的M的个数加入结果数组\n        len = 1; // 重新初始化连续的M的个数为1\n    }\n    if (row < m && column < n) {  // 对角线搜索\n        a = row;\n        b = column;\n        while ((a < m - 1 && b < n - 1) && students[++a][++b] == \"M\") { // 不越界且下一个元素为M\n            len++; // 连续的M的个数加1\n        }\n        res.push_back(len); // 把连续的M的个数加入结果数组\n        len = 1; // 重新初始化连续的M的个数为1\n    }\n    if (row >= 0 && column < n) {  // 从右往左搜索\n        a = row;\n        b = column;\n        while ((a > 0 && b < n - 1) && students[--a][++b] == \"M\") { // 不越界且下一个元素为M\n            len++; // 连续的M的个数加1\n        }\n        res.push_back(len); // 把连续的M的个数加入结果数组\n    }\n}\n \nint main() {\n    string input_str;\n    getline(cin, input_str);\n\n    // 解析行数和列数\n    stringstream ss(input_str);\n    string temp;\n    getline(ss, temp, ',');\n    int row = stoi(temp);\n    getline(ss, temp);\n    int column = stoi(temp);\n\n    // 初始化方阵\n    vector<vector<string>> students(row, vector<string>(column));\n    for (int i = 0; i < row; ++i) {\n        getline(cin, input_str);\n        stringstream ss(input_str);\n        for (int j = 0; j < column; ++j) {\n            getline(ss, students[i][j], ',');\n        }\n    }\n\n    \n    vector<int> max_res; // 初始化结果数组\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < column; j++) {\n            //遇到M则开始找\n            if (students[i][j] == \"M\") { // 如果当前元素为M\n                getMaxConnected(students, i, j, max_res); // 在四个方向上搜索连续的M\n            }\n        }\n    }\n    sort(max_res.begin(), max_res.end()); // 对结果数组排序\n    cout << max_res[max_res.size()-1]; // 输出最大的连续的M的个数\n    \n    return 0;\n}\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\nconst vector<vector<int>> DIRECTIONS = {{0, 1}, {1, 0}, {1, 1}, {-1, 1}};\n\nvoid getMaxConnected(const vector<vector<string>>& students, int row, int column, vector<int>& res) {\n    int m = students.size();\n    int n = students[0].size();\n\n    for (const auto& dir : DIRECTIONS) {\n        int len = 1; // 初始化连续的M的个数为1\n        int a = row, b = column;\n\n        // 按当前方向搜索\n        while (a + dir[0] >= 0 && a + dir[0] < m && b + dir[1] >= 0 && b + dir[1] < n\n                && students[a + dir[0]][b + dir[1]] == \"M\") {\n            a += dir[0]; // 更新行索引\n            b += dir[1]; // 更新列索引\n            len++; // 连续的M的个数加1\n        }\n\n        res.push_back(len); // 把连续的M的个数加入结果数组\n    }\n}\n\nint main() {\n    string input_str;\n    getline(cin, input_str);\n\n    // 解析行数和列数\n    stringstream ss(input_str);\n    string temp;\n    getline(ss, temp, ',');\n    int row = stoi(temp);\n    getline(ss, temp);\n    int column = stoi(temp);\n\n    // 初始化方阵\n    vector<vector<string>> students(row, vector<string>(column));\n    for (int i = 0; i < row; ++i) {\n        getline(cin, input_str);\n        stringstream ss(input_str);\n        for (int j = 0; j < column; ++j) {\n            getline(ss, students[i][j], ',');\n        }\n    }\n\n    vector<int> max_res; // 初始化结果数组\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < column; j++) {\n            if (students[i][j] == \"M\") {\n                getMaxConnected(students, i, j, max_res); // 在四个方向上搜索连续的M\n            }\n        }\n    }\n\n    sort(max_res.begin(), max_res.end(), greater<int>()); // 对结果数组排序\n    cout << max_res[0] << endl; // 输出最大的连续的M的个数\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, m; // 定义矩阵的行数和列数\n    scanf(\"%d,%d\\n\", &n, &m); // 读取矩阵的行数和列数\n\n    char students[n][m]; // 定义字符矩阵以存储输入\n    for (int i = 0; i < n; i++) { // 遍历每一行\n        for (int j = 0; j < m; j++) { // 遍历每一列\n            scanf(\"%c\", &students[i][j]); // 读取字符并存入矩阵\n            getchar(); // 吃掉换行符或逗号\n        }\n    }\n\n    int max_res[n * m]; // 用于存储每次搜索到的连续M的个数\n    int res_size = 0; // 记录结果数组的实际大小\n\n    // 遍历整个矩阵，查找连续的M\n    for (int i = 0; i < n; i++) { // 遍历行\n        for (int j = 0; j < m; j++) { // 遍历列\n            if (students[i][j] == 'M') { // 如果当前字符是'M'\n                int len = 1; // 初始化连续M的长度为1\n                int a = 0, b = 0; // 初始化行和列索引\n\n                // 从左往右搜索\n                if (j < m) {\n                    a = i;\n                    b = j;\n                    while (b < m - 1 && students[a][++b] == 'M') { // 不越界且下一个元素为M\n                        len++; // 连续的M的个数加1\n                    }\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                    len = 1; // 重置长度为1\n                }\n\n                // 从上往下搜索\n                if (i < n) {\n                    a = i;\n                    b = j;\n                    while (a < n - 1 && students[++a][b] == 'M') { // 不越界且下一个元素为M\n                        len++; // 连续的M的个数加1\n                    }\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                    len = 1; // 重置长度为1\n                }\n\n                // 对角线搜索（左上到右下）\n                if (i < n && j < m) {\n                    a = i;\n                    b = j;\n                    while (a < n - 1 && b < m - 1 && students[++a][++b] == 'M') { // 不越界且下一个元素为M\n                        len++; // 连续的M的个数加1\n                    }\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                    len = 1; // 重置长度为1\n                }\n\n                // 对角线搜索（左下到右上）\n                if (i >= 0 && j < m) {\n                    a = i;\n                    b = j;\n                    while (a > 0 && b < m - 1 && students[--a][++b] == 'M') { // 不越界且下一个元素为M\n                        len++; // 连续的M的个数加1\n                    }\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                }\n            }\n        }\n    }\n\n    // 对结果数组进行排序，找到最大的连续M的个数\n    int max = max_res[0];\n    for (int i = 1; i < res_size; i++) {\n        if (max_res[i] > max) {\n            max = max_res[i];\n        }\n    }\n\n    // 输出最大的连续M的个数\n    printf(\"%d\\n\", max);\n\n    return 0;\n}\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\nconst int DIRECTIONS[4][2] = {{0, 1}, {1, 0}, {1, 1}, {-1, 1}};\n\nint main() {\n    int n, m; // 定义矩阵的行数和列数\n    scanf(\"%d,%d\\n\", &n, &m); // 读取矩阵的行数和列数\n\n    char students[n][m]; // 定义字符矩阵以存储输入\n    for (int i = 0; i < n; i++) { // 遍历每一行\n        for (int j = 0; j < m; j++) { // 遍历每一列\n            scanf(\"%c\", &students[i][j]); // 读取字符并存入矩阵\n            getchar(); // 吃掉换行符或逗号\n        }\n    }\n\n    int max_res[n * m]; // 用于存储每次搜索到的连续M的个数\n    int res_size = 0; // 记录结果数组的实际大小\n\n    // 遍历整个矩阵，查找连续的M\n    for (int i = 0; i < n; i++) { // 遍历行\n        for (int j = 0; j < m; j++) { // 遍历列\n            if (students[i][j] == 'M') { // 如果当前字符是'M'\n                // 在四个方向上搜索\n                for (int d = 0; d < 4; d++) {\n                    int len = 1; // 初始化连续M的长度为1\n                    int a = i, b = j; // 初始化当前的位置\n\n                    // 按当前方向搜索连续的M\n                    while (a + DIRECTIONS[d][0] >= 0 && a + DIRECTIONS[d][0] < n &&\n                           b + DIRECTIONS[d][1] >= 0 && b + DIRECTIONS[d][1] < m &&\n                           students[a + DIRECTIONS[d][0]][b + DIRECTIONS[d][1]] == 'M') {\n                        a += DIRECTIONS[d][0]; // 更新行索引\n                        b += DIRECTIONS[d][1]; // 更新列索引\n                        len++; // 连续的M的个数加1\n                    }\n\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                }\n            }\n        }\n    }\n\n    // 对结果数组进行排序，找到最大的连续M的个数\n    int max = max_res[0];\n    for (int i = 1; i < res_size; i++) {\n        if (max_res[i] > max) {\n            max = max_res[i];\n        }\n    }\n\n    // 输出最大的连续M的个数\n    printf(\"%d\\n\", max);\n\n    return 0;\n}"
    }
  },
  {
    "id": "130",
    "title": "最长子字符串的长度",
    "examType": "A",
    "score": 200,
    "description": "给你一个字符串 s，字符串s首尾相连成一个环形 ，请你在环中找出’l’、‘o’、‘x’ 字符都恰好出现了偶数次最长子字符串的长度。",
    "inputDesc": "输入是一串小写的字母组成的字符串s。\n1 <= s.length <= 5 x 10^5\ns 只包含小写英文字母。",
    "outputDesc": "输出是一个整数\n输入\n输出\n说明：最长子字符串之一是 “alolob”，它包含 ‘l’，'o’各 2 个，以及 0 个 ‘x’ 。\n输入\n输出\n说明\n最长子字符串是 “oxdolxl”，由于是首尾连接在一起的，所以最后一个 ‘x’ 和开头的 'l’是连接在一起的，此字符串包含 2 个 ‘l’ ，2个 ‘o’ ，2个 ‘x’ 。\n输入\n输出\n说明\n字符串 “bcbcbc” 本身就是最长的，因为 ‘l’、‘o’、‘x’ 都出现了 0 次。",
    "examples": [],
    "solution": "外层循环 从字符串的每个字符开始，遍历整个字符串。这个循环的目的是以每个字符作为子字符串的起始点。 内层循环 从外层循环指定的起始点开始，遍历字符串的其余部分。这个循环的目的是检查从当前起始点开始的所有可能的子字符串。对于每个可能的子字符串，计算字符 ‘l’、‘o’ 和 ‘x’ 的出现次数。 条件检查 在内层循环中，检查当前子字符串中字符 ‘l’、‘o’ 和 ‘x’ 出现的次数是否都是偶数。如果都是偶数，则计算当前子字符串的长度，并更新 maxLength，如果它比当前的 maxLength 更大。 返回结果 最后返回 maxLength，即满足条件的最长子字符串的长度。\n外层循环\n从字符串的每个字符开始，遍历整个字符串。这个循环的目的是以每个字符作为子字符串的起始点。\n内层循环\n从外层循环指定的起始点开始，遍历字符串的其余部分。这个循环的目的是检查从当前起始点开始的所有可能的子字符串。对于每个可能的子字符串，计算字符 ‘l’、‘o’ 和 ‘x’ 的出现次数。\n条件检查\n在内层循环中，检查当前子字符串中字符 ‘l’、‘o’ 和 ‘x’ 出现的次数是否都是偶数。如果都是偶数，则计算当前子字符串的长度，并更新 maxLength，如果它比当前的 maxLength 更大。\n返回结果\n最后返回 maxLength，即满足条件的最长子字符串的长度。\n初始化 n = 8 (字符串 “looxdolx” 的长度)。maxLength = 0。 遍历开始 以每个字符为起始点进行遍历。 以第一个字符 ‘l’ 为起始点 遍历所有以 ‘l’ 开始的子字符串，如 “l”, “lo”, “loo”, “loox”, “looxd”, “looxdo”, “looxdol”, “looxdolx”。当遍历到 “loox” 时，计数为：countL = 1, countO = 2, countX = 1。不满足条件，不更新 maxLength。继续遍历直到结束。 以其他字符为起始点 类似地遍历以 ‘o’, ‘o’, ‘x’, ‘d’, ‘o’, ‘l’, ‘x’ 为起始点的所有子字符串。关键是处理字符串如环状，使用 (i + j) % n 来计算当前字符的位置。 找到最长的满足条件的子字符串 当以 ‘o’（第3个字符，下标为2）为起始点时，整个字符串 “oxdolxl” 都被遍历。在这个子字符串中，‘l’、‘o’、‘x’ 的出现次数分别为 2、2、2，都是偶数。所以 maxLength 更新为 8。 完成遍历 遍历完成后，maxLength 是最长的满足条件的子字符串的长度，在这个例子中为7。\n初始化\nn = 8 (字符串 “looxdolx” 的长度)。maxLength = 0。\n遍历开始\n以每个字符为起始点进行遍历。\n以第一个字符 ‘l’ 为起始点\n遍历所有以 ‘l’ 开始的子字符串，如 “l”, “lo”, “loo”, “loox”, “looxd”, “looxdo”, “looxdol”, “looxdolx”。当遍历到 “loox” 时，计数为：countL = 1, countO = 2, countX = 1。不满足条件，不更新 maxLength。继续遍历直到结束。\n以其他字符为起始点\n类似地遍历以 ‘o’, ‘o’, ‘x’, ‘d’, ‘o’, ‘l’, ‘x’ 为起始点的所有子字符串。关键是处理字符串如环状，使用 (i + j) % n 来计算当前字符的位置。\n找到最长的满足条件的子字符串\n当以 ‘o’（第3个字符，下标为2）为起始点时，整个字符串 “oxdolxl” 都被遍历。在这个子字符串中，‘l’、‘o’、‘x’ 的出现次数分别为 2、2、2，都是偶数。所以 maxLength 更新为 8。\n完成遍历\n遍历完成后，maxLength 是最长的满足条件的子字符串的长度，在这个例子中为7。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();\n\n        // 调用findLongestSubstringLength方法计算并返回结果\n        int result = findLongestSubstringLength(s);\n        // 打印结果\n        System.out.println(result);\n    }\n\n    // 定义一个私有静态方法，用于找出满足条件的最长子字符串的长度\n    private static int findLongestSubstringLength(String s) {\n        // 获取输入字符串的长度\n        int n = s.length();\n        // 初始化最长子字符串长度为0\n        int maxLength = 0;\n\n        // 外层循环，从字符串的每一个字符开始检查\n        for (int i = 0; i < n; i++) {\n            // 初始化'l'、'o'和'x'的计数器\n            int countL = 0, countO = 0, countX = 0;\n\n            // 内层循环，从当前字符开始，遍历整个字符串\n            for (int j = 0; j < n; j++) {\n                // 计算当前字符的索引，处理环形字符串的情况\n                int index = (i + j) % n;\n                // 获取当前字符\n                char ch = s.charAt(index);\n\n                // 根据当前字符增加相应字符的计数\n                if (ch == 'l') countL++;\n                else if (ch == 'o') countO++;\n                else if (ch == 'x') countX++;\n\n                // 如果'l'、'o'和'x'出现的次数都是偶数\n                if (countL % 2 == 0 && countO % 2 == 0 && countX % 2 == 0) {\n                    // 更新最长子字符串的长度\n                    maxLength = Math.max(maxLength, j + 1);\n                }\n            }\n        }\n\n        // 返回最长子字符串的长度\n        return maxLength;\n    }\n}",
      "python": "# 定义一个函数，用于找出满足条件的最长子字符串的长度\ndef find_longest_substring_length(s):\n    # 获取输入字符串的长度\n    n = len(s)\n    # 初始化最长子字符串长度为 0\n    max_length = 0\n\n    # 外层循环，从字符串的每一个字符开始检查\n    for i in range(n):\n        # 初始化 'l'、'o' 和 'x' 的计数器\n        count_l = 0\n        count_o = 0\n        count_x = 0\n\n        # 内层循环，从当前字符开始，遍历整个字符串\n        for j in range(n):\n            # 计算当前字符的索引，处理环形字符串的情况\n            index = (i + j) % n\n            # 获取当前字符\n            ch = s[index]\n\n            # 根据当前字符增加相应字符的计数\n            if ch == 'l':\n                count_l += 1\n            elif ch == 'o':\n                count_o += 1\n            elif ch == 'x':\n                count_x += 1\n\n            # 如果 'l'、'o' 和 'x' 出现的次数都是偶数\n            if count_l % 2 == 0 and count_o % 2 == 0 and count_x % 2 == 0:\n                # 更新最长子字符串的长度\n                max_length = max(max_length, j + 1)\n\n    # 返回最长子字符串的长度\n    return max_length\n\n# 主函数\nif __name__ == '__main__':\n    # 从标准输入读取字符串\n    s = input()\n    # 调用 find_longest_substring_length 函数计算并返回结果\n    result = find_longest_substring_length(s)\n    # 打印结果\n    print(result)",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <string>\n#include <algorithm> // 用于std::max函数\n\n\n\n// 定义一个函数，用于找出满足条件的最长子字符串的长度\nint findLongestSubstringLength(const std::string &s) {\n    // 获取输入字符串的长度\n    int n = s.length();\n    // 初始化最长子字符串长度为0\n    int maxLength = 0;\n\n    // 外层循环，从字符串的每一个字符开始检查\n    for (int i = 0; i < n; i++) {\n        // 初始化'l'、'o'和'x'的计数器\n        int countL = 0, countO = 0, countX = 0;\n\n        // 内层循环，从当前字符开始，遍历整个字符串\n        for (int j = 0; j < n; j++) {\n            // 计算当前字符的索引，处理环形字符串的情况\n            int index = (i + j) % n;\n            // 获取当前字符\n            char ch = s[index];\n\n            // 根据当前字符增加相应字符的计数\n            if (ch == 'l') countL++;\n            else if (ch == 'o') countO++;\n            else if (ch == 'x') countX++;\n\n            // 如果'l'、'o'和'x'出现的次数都是偶数\n            if (countL % 2 == 0 && countO % 2 == 0 && countX % 2 == 0) {\n                // 更新最长子字符串的长度\n                maxLength = std::max(maxLength, j + 1);\n            }\n        }\n    }\n\n    // 返回最长子字符串的长度\n    return maxLength;\n}\n\n// 主函数\nint main() {\n    std::string s;\n    // 从标准输入读取字符串\n    std::cin >> s;\n\n    // 调用findLongestSubstringLength函数计算并返回结果\n    int result = findLongestSubstringLength(s);\n    // 打印结果\n    std::cout << result << std::endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h> // 用于strlen函数\n\n// 定义一个函数，用于找出满足条件的最长子字符串的长度\nint findLongestSubstringLength(const char *s) {\n    // 获取输入字符串的长度\n    int n = strlen(s);\n    // 初始化最长子字符串长度为0\n    int maxLength = 0;\n\n    // 外层循环，从字符串的每一个字符开始检查\n    for (int i = 0; i < n; i++) {\n        // 初始化'l'、'o'和'x'的计数器\n        int countL = 0, countO = 0, countX = 0;\n\n        // 内层循环，从当前字符开始，遍历整个字符串\n        for (int j = 0; j < n; j++) {\n            // 计算当前字符的索引，处理环形字符串的情况\n            int index = (i + j) % n;\n            // 获取当前字符\n            char ch = s[index];\n\n            // 根据当前字符增加相应字符的计数\n            if (ch == 'l') countL++;\n            else if (ch == 'o') countO++;\n            else if (ch == 'x') countX++;\n\n            // 如果'l'、'o'和'x'出现的次数都是偶数\n            if (countL % 2 == 0 && countO % 2 == 0 && countX % 2 == 0) {\n                // 更新最长子字符串的长度\n                int currentLength = j + 1;\n                maxLength = (maxLength > currentLength) ? maxLength : currentLength;\n            }\n        }\n    }\n\n    // 返回最长子字符串的长度\n    return maxLength;\n}\n\n// 主函数\nint main() {\n    char s[1001]; // 假设字符串长度不超过1000\n    // 从标准输入读取字符串\n    scanf(\"%s\", s);\n\n    // 调用findLongestSubstringLength函数计算并返回结果\n    int result = findLongestSubstringLength(s);\n    // 打印结果\n    printf(\"%d\\n\", result);\n\n    return 0;\n}"
    }
  },
  {
    "id": "131",
    "title": "树状结构查询",
    "examType": "A",
    "score": 200,
    "description": "通常使用多行的节点、父节点表示一棵树，比如\n西安 陕西 陕西 中国 江西 中国 中国 亚洲 泰国 亚洲\n输入一个节点之后，请打印出来树中他的所有下层节点",
    "inputDesc": "第一行输入行数，下面是多行数据，每行以空格区分节点和父节点\n接着是查询节点",
    "outputDesc": "输出查询节点的所有下层节点。以字典序排序",
    "examples": [
      {
        "input": "b a\nc a\nd c\ne c\nf d\nc",
        "output": "d\ne\nf",
        "explanation": ""
      },
      {
        "input": "b a\nc a\nd c\ne c\nf d\nc",
        "output": "a\n       / \\\n      b   c\n         / \\\n        d   e\n       /\n      f",
        "explanation": ""
      }
    ],
    "solution": "这个题目描述了一棵树的结构，并要求我们找到一个给定节点的所有下层节点（即该节点的所有子节点及其后代节点）。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt(); // 输入行数\n\n    HashMap<String, HashSet<String>> tree = new HashMap<>(); // 创建一个HashMap用于存储树的关系\n\n    // 读取输入的树的关系，并将子节点和父节点存入HashMap中\n    for (int i = 0; i < n; i++) {\n      String childNode = sc.next(); // 子节点\n      String parentNode = sc.next(); // 父节点\n\n      tree.computeIfAbsent(parentNode, k -> new HashSet<>()).add(childNode); // 将子节点添加到父节点的集合中\n    }\n\n    String targetNode = sc.next(); // 输入要查询的节点\n\n    if (!tree.containsKey(targetNode)) { // 如果树中不包含要查询的节点，则输出空行并结束程序\n      System.out.println(\"\");\n      return;\n    }\n\n    LinkedList<String> queue = new LinkedList<>(tree.get(targetNode)); // 创建一个队列，用于存储要遍历的节点\n\n    ArrayList<String> result = new ArrayList<>(); // 创建一个ArrayList，用于存储查询节点的所有下层节点\n\n    // 遍历队列，将节点添加到结果集中，并将该节点的子节点添加到队列中\n    while (!queue.isEmpty()) {\n      String node = queue.removeFirst(); // 从队列中取出节点\n      result.add(node); // 将节点添加到结果集中\n\n      if (tree.containsKey(node)) { // 如果节点在树中有子节点，则将子节点添加到队列中\n        queue.addAll(tree.get(node));\n      }\n    }\n\n    result.sort(String::compareTo); // 对结果集进行排序\n\n    result.forEach(System.out::println); // 打印结果集中的每个节点\n  }\n}",
      "python": "n = int(input())  # 输入行数\n\ntree = {}  # 创建一个字典用于存储树的关系\n\n# 读取输入的树的关系，并将子节点和父节点存入字典中\nfor _ in range(n):\n    childNode, parentNode = input().split()  # 子节点和父节点\n\n    if parentNode not in tree:\n        tree[parentNode] = set()  # 如果父节点不在字典中，则创建一个空集合\n\n    tree[parentNode].add(childNode)  # 将子节点添加到父节点的集合中\n\ntargetNode = input()  # 输入要查询的节点\n\nif targetNode not in tree:  # 如果字典中不包含要查询的节点，则输出空行并结束程序\n    print(\"\")\n    exit()\n\nqueue = list(tree[targetNode])  # 创建一个队列，用于存储要遍历的节点\n\nresult = []  # 创建一个列表，用于存储查询节点的所有下层节点\n\n# 遍历队列，将节点添加到结果集中，并将该节点的子节点添加到队列中\nwhile queue:\n    node = queue.pop(0)  # 从队列中取出节点\n    result.append(node)  # 将节点添加到结果集中\n\n    if node in tree:  # 如果节点在字典中有子节点，则将子节点添加到队列中\n        queue.extend(tree[node])\n\nresult.sort()  # 对结果集进行排序\n\nfor node in result:  # 打印结果集中的每个节点\n    print(node)",
      "javascript": "const readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = []; // 存储输入的所有行数据\nlet n; // 树的行数\n\nrl.on(\"line\", (line) => { // 监听每一行的输入\n  lines.push(line); // 将输入的行添加到lines数组中\n\n  if (lines.length == 1) { // 如果lines数组中只有一行数据，表示树的行数\n    n = parseInt(lines[0]); // 将树的行数转换为整数并赋值给n\n  }\n\n  if (n && lines.length === n + 2) { // 当树的行数和输入的行数匹配时，进行处理\n    lines.shift(); // 移除第一行树的行数\n    const target = lines.pop(); // 弹出最后一行作为查询的节点\n\n    const tree = {}; // 存储树的结构，使用对象表示，key为父节点，value为子节点的集合\n    for (let str of lines) { // 遍历除了树的行数和查询节点之外的行\n      const [node, parent] = str.split(\" \"); // 将每一行以空格分割成节点和父节点\n      if (!tree[parent]) tree[parent] = new Set(); // 如果父节点不存在于树结构中，则创建一个新的集合\n      tree[parent].add(node); // 将节点添加到父节点的集合中\n    }\n\n    if (!tree[target]) return console.log(\"\"); // 如果查询的节点不存在于树结构中，直接输出空字符串\n\n    const queue = [...tree[target]]; // 将查询的节点的子节点集合放入队列中\n\n    const result = []; // 存储查询节点的所有下层节点\n    while (queue.length > 0) { // 当队列不为空时，进行循环\n      const node = queue.shift(); // 弹出队列中的第一个节点\n      result.push(node); // 将节点添加到结果数组中\n\n      if (tree[node]) { // 如果节点存在子节点\n        queue.push(...tree[node]); // 将子节点添加到队列中\n      }\n    }\n\n    result.sort().forEach((v) => console.log(v)); // 对结果数组进行字典序排序，并逐行输出\n\n   }\n});",
      "cpp": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n; // 输入行数\n\n  unordered_map<string, unordered_set<string>> tree; // 创建一个unordered_map用于存储树的关系\n\n  // 读取输入的树的关系，并将子节点和父节点存入unordered_map中\n  for (int i = 0; i < n; i++) {\n    string childNode, parentNode;\n    cin >> childNode >> parentNode; // 子节点和父节点\n\n    tree[parentNode].insert(childNode); // 将子节点添加到父节点的集合中\n  }\n\n  string targetNode;\n  cin >> targetNode; // 输入要查询的节点\n\n  if (tree.find(targetNode) == tree.end()) { // 如果树中不包含要查询的节点，则输出空行并结束程序\n    cout << endl;\n    return 0;\n  }\n\n  queue<string> q;\n  for (const string& node : tree[targetNode]) {\n    q.push(node); // 将要遍历的节点添加到队列中\n  }\n\n  vector<string> result; // 创建一个vector，用于存储查询节点的所有下层节点\n\n  // 遍历队列，将节点添加到结果集中，并将该节点的子节点添加到队列中\n  while (!q.empty()) {\n    string node = q.front(); // 从队列中取出节点\n    q.pop();\n\n    result.push_back(node); // 将节点添加到结果集中\n\n    if (tree.find(node) != tree.end()) { // 如果节点在树中有子节点，则将子节点添加到队列中\n      for (const string& child : tree[node]) {\n        q.push(child);\n      }\n    }\n  }\n\n  sort(result.begin(), result.end()); // 对结果集进行排序\n\n  for (const string& node : result) {\n    cout << node << endl; // 打印结果集中的每个节点\n  }\n\n  return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_NODES 100\n#define MAX_NAME_LEN 100\n\n// 定义一个结构体来表示树的关系，每个父节点及其子节点\nstruct Tree {\n    char parent[MAX_NAME_LEN];  // 父节点名称\n    char child[MAX_NAME_LEN];   // 子节点名称\n};\n\n// 定义一个二维数组来存储每个节点的子节点\nchar children[MAX_NODES][MAX_NAME_LEN][MAX_NAME_LEN]; // 每个节点的子节点\nint children_count[MAX_NODES];  // 记录每个节点有多少个子节点\n\n// 存储所有节点的名称，避免查找时每次都从输入的字符中查找\nchar nodes[MAX_NODES][MAX_NAME_LEN]; \nint node_count = 0;  // 节点总数\n\n// 存储查询结果的数组\nchar result[MAX_NODES][MAX_NAME_LEN];\nint result_count = 0;  // 记录结果集中节点的个数\n\n// 查找节点名称是否存在，如果存在返回索引，不存在则添加新节点并返回新索引\nint find_or_add_node(char *name) {\n    for (int i = 0; i < node_count; i++) {\n        if (strcmp(nodes[i], name) == 0) {\n            return i;  // 如果找到了，返回该节点的索引\n        }\n    }\n    strcpy(nodes[node_count], name);  // 如果没有找到，添加新节点\n    return node_count++;  // 返回新节点的索引，并增加节点总数\n}\n\n// 使用深度优先搜索（DFS）遍历树，收集目标节点的所有子节点\nvoid dfs(int index) {\n    for (int i = 0; i < children_count[index]; i++) {\n        int child_index = find_or_add_node(children[index][i]);\n        // 将子节点添加到结果集中\n        strcpy(result[result_count++], nodes[child_index]);\n        // 递归遍历子节点的子节点\n        dfs(child_index);\n    }\n}\n\n// 比较函数，用于qsort的字典序排序\nint compare(const void *a, const void *b) {\n    return strcmp((char *)a, (char *)b);\n}\n\n// 主函数\nint main() {\n    int n;  // 输入的行数\n    scanf(\"%d\", &n);  // 读取行数\n\n    struct Tree tree[MAX_NODES];  // 存储树的父子节点关系\n\n    // 读取输入的节点关系\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s %s\", tree[i].child, tree[i].parent);  // 读取子节点和父节点\n    }\n\n    // 建立节点关系\n    for (int i = 0; i < n; i++) {\n        // 获取父节点和子节点的索引\n        int parent_index = find_or_add_node(tree[i].parent);\n        int child_index = find_or_add_node(tree[i].child);\n        // 将子节点加入父节点的子节点列表\n        strcpy(children[parent_index][children_count[parent_index]++], tree[i].child);\n    }\n\n    char target_node[MAX_NAME_LEN];  // 目标节点\n    scanf(\"%s\", target_node);  // 读取查询的目标节点\n\n    int target_index = find_or_add_node(target_node);  // 找到目标节点的索引\n\n    // 使用DFS收集所有下层节点\n    dfs(target_index);\n\n    // 对结果集中收集的节点进行字典序排序\n    qsort(result, result_count, MAX_NAME_LEN, compare);\n\n    // 输出排序后的所有下层节点\n    for (int i = 0; i < result_count; i++) {\n        printf(\"%s\\n\", result[i]);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "132",
    "title": "模拟目录管理功能",
    "examType": "A",
    "score": 200,
    "description": "实现一个模拟目录管理功能的软件，输入一个命令序列，输出最后一条命令运行结果。\n支持命令：\n创建目录命令：mkdir 目录名称，如 mkdir abc 为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作。此命令无输出。进入目录命令：cd 目录名称，如 cd abc 为进入abc目录，特别地，cd … 为返回上级目录，如果目录不存在则不执行任何操作。此命令无输出。查看当前所在路径命令：pwd，输出当前路径字符串。\n约束：\n目录名称仅支持小写字母；mkdir 和 cd 命令的参数仅支持单个目录，如：mkdir abc 和 cd abc；不支持嵌套路径和绝对路径，如 mkdir abc/efg，cd abc/efg，mkdir /abc/efg，cd /abc/efg 是不支持的。目录符号为/，根目录/作为初始目录。任何不符合上述定义的无效命令不做任何处理并且无输出。",
    "inputDesc": "输入 N 行字符串，每一行字符串是一条命令。\n命令行数限制100行以内，目录名称限制10个字符以内。",
    "outputDesc": "输出最后一条命令运行结果字符串。\n输入\n输出\n说明\n在根目录创建一个abc的目录并进入abc目录中查看当前目录路径，输出当前路径/abc/。",
    "examples": [],
    "solution": "定义一个节点类（Node），用于表示文件系统中的每个目录。该类包含路径信息和一个映射，映射存储子目录和对应的节点对象。 创建一个根节点实例，代表文件系统的根目录。根目录没有父目录。 读取用户输入，根据输入的命令和参数执行相应的操作。 如果输入的是创建目录的命令（例如，“mkdir”），检查目录名是否有效，然后在当前节点下创建新的子目录节点。如果输入的是切换目录的命令（例如，“cd”），检查目标目录是否存在，如果存在，则更新当前节点为目标节点。如果输入的是打印当前目录路径的命令（例如，“pwd”），则输出当前节点的路径信息。 循环读取输入直到结束，并在结束时输出最后的路径信息。\n定义一个节点类（Node），用于表示文件系统中的每个目录。该类包含路径信息和一个映射，映射存储子目录和对应的节点对象。\n创建一个根节点实例，代表文件系统的根目录。根目录没有父目录。\n读取用户输入，根据输入的命令和参数执行相应的操作。\n如果输入的是创建目录的命令（例如，“mkdir”），检查目录名是否有效，然后在当前节点下创建新的子目录节点。如果输入的是切换目录的命令（例如，“cd”），检查目标目录是否存在，如果存在，则更新当前节点为目标节点。如果输入的是打印当前目录路径的命令（例如，“pwd”），则输出当前节点的路径信息。\n循环读取输入直到结束，并在结束时输出最后的路径信息。",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n    // 定义一个内部类Node，用于表示文件系统中的每个目录\n    static class Node {\n        String path; // 目录的路径\n        Map<String, Node> next = new HashMap<>(); // 存储当前目录下的子目录，键为目录名，值为对应的Node对象\n\n        // Node类的构造方法ac\n        Node(String path, Node parent) {\n            this.path = path; // 设置当前节点的路径\n            // 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n            if (parent != null) {\n                this.next.put(\"..\", parent);\n            }\n        }\n    }\n\n    // 程序的主入口点\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in); // 创建Scanner对象来读取用户的输入\n        Node root = new Node(\"/\", null); // 创建根目录节点，根目录没有父目录，所以第二个参数为null\n        Node currentNode = root; // 初始化当前目录为根目录\n        String lastOutput = \"\"; // 用于存储最后输出的路径\n\n        // 循环读取用户输入的命令\n        while (scanner.hasNextLine()) {\n            String input = scanner.nextLine().trim(); // 读取一行输入并去除前后空格\n            if (input.isEmpty()) break; // 如果输入为空，则退出循环\n\n            String[] parts = input.split(\" \"); // 将输入的命令按空格分割为命令和参数\n            String command = parts[0]; // 获取命令部分\n\n            // 处理mkdir命令，用于创建新的子目录\n            if (\"mkdir\".equals(command) && parts.length == 2 && isValidDirectoryName(parts[1])) {\n                // 如果目录名有效并且不存在，则创建一个新的目录节点，并将其添加到当前目录的子目录映射中\n                currentNode.next.putIfAbsent(parts[1], new Node(currentNode.path + parts[1] + \"/\", currentNode));\n            } else if (\"cd\".equals(command) && parts.length == 2 && isValidChangeDirectory(parts[1])) {\n                // 处理cd命令，用于改变当前目录\n                Node nextNode = currentNode.next.get(parts[1]); // 从子目录映射中获取要切换的目录节点\n                if (nextNode != null) {\n                    currentNode = nextNode; // 如果目录存在，则将当前目录切换为该目录\n                }\n            } else if (\"pwd\".equals(command) && parts.length == 1) {\n                // 处理pwd命令，用于打印当前目录的路径\n                lastOutput = currentNode.path; // 将当前目录的路径保存到lastOutput变量中\n            }\n        }\n\n        System.out.println(lastOutput); // 循环结束后，打印最后保存的路径\n    }\n\n    // 检查目录名是否有效的方法，目录名只能包含小写字母\n    private static boolean isValidDirectoryName(String name) {\n        for (char c : name.toCharArray()) {\n            if (c < 'a' || c > 'z') {\n                return false; // 如果目录名中包含非小写字母的字符，则返回false\n            }\n        }\n        return true; // 如果目录名全部由小写字母组成，则返回true\n    }\n\n    // 检查是否可以切换到指定的目录的方法，目录名要么是有效的，要么是\"..\"表示上级目录\n    private static boolean isValidChangeDirectory(String name) {\n        return \"..\".equals(name) || isValidDirectoryName(name); // 如果是\"..\"或者是有效的目录名，则返回true\n    }\n}",
      "python": "# 定义一个类Node，用于表示文件系统中的每个目录\nclass Node:\n    def __init__(self, path, parent):\n        self.path = path  # 目录的路径\n        self.next = {}  # 存储当前目录下的子目录，键为目录名，值为对应的Node对象\n        if parent:\n            self.next['..'] = parent  # 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n\n# 检查目录名是否有效的函数，目录名只能包含小写字母\ndef is_valid_directory_name(name):\n    return name.islower() and name.isalpha()  # 如果目录名全部由小写字母组成，则返回true\n\n# 检查是否可以切换到指定的目录的函数，目录名要么是有效的，要么是\"..\"表示上级目录\ndef is_valid_change_directory(name):\n    return name == '..' or is_valid_directory_name(name)  # 如果是\"..\"或者是有效的目录名，则返回true\n\nroot = Node('/', None)  # 创建根目录节点，根目录没有父目录，所以第二个参数为None\ncurrent_node = root  # 初始化当前目录为根目录\nlast_output = ''  # 用于存储最后输出的路径\n\n# 循环读取用户输入的命令\ntry:\n    while True:\n        input_command = input().strip()  # 读取一行输入并去除前后空格\n        if not input_command:\n            break\n        parts = input_command.split(' ')  # 将输入的命令按空格分割为命令和参数\n        command = parts[0]  # 获取命令部分\n\n        if command == 'mkdir' and len(parts) == 2 and is_valid_directory_name(parts[1]):\n            # 处理mkdir命令，用于创建新的子目录\n            if parts[1] not in current_node.next:\n                current_node.next[parts[1]] = Node(current_node.path + parts[1] + '/', current_node)\n        elif command == 'cd' and len(parts) == 2 and is_valid_change_directory(parts[1]):\n            # 处理cd命令，用于改变当前目录\n            next_node = current_node.next.get(parts[1])\n            if next_node:\n                current_node = next_node  # 如果目录存在，则将当前目录切换为该目录\n        elif command == 'pwd' and len(parts) == 1:\n            # 处理pwd命令，用于打印当前目录的路径\n            last_output = current_node.path  # 将当前目录的路径保存到last_output变量中\nexcept EOFError:\n    pass\n\nprint(last_output)  # 打印最后保存的路径",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nusing namespace std;\n// 定义一个类Node，用于表示文件系统中的每个目录\nclass Node {\npublic:\n    string path; // 目录的路径\n    unordered_map<string, Node*> next; // 存储当前目录下的子目录，键为目录名，值为对应的Node指针\n\n    // Node类的构造方法\n    Node(string path, Node* parent) : path(path) {\n        // 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n        if (parent != nullptr) {\n            this->next[\"..\"] = parent;\n        }\n    }\n};\n\n// 检查目录名是否有效的函数，目录名只能包含小写字母\nbool isValidDirectoryName(const string& name) {\n    for (char c : name) {\n        if (c < 'a' || c > 'z') {\n            return false; // 如果目录名中包含非小写字母的字符，则返回false\n        }\n    }\n    return true; // 如果目录名全部由小写字母组成，则返回true\n}\n\n// 检查是否可以切换到指定的目录的函数，目录名要么是有效的，要么是\"..\"表示上级目录\nbool isValidChangeDirectory(const string& name) {\n    return name == \"..\" || isValidDirectoryName(name); // 如果是\"..\"或者是有效的目录名，则返回true\n}\n\nint main() {\n    Node* root = new Node(\"/\", nullptr); // 创建根目录节点，根目录没有父目录，所以第二个参数为nullptr\n    Node* currentNode = root; // 初始化当前目录为根目录\n    string lastOutput; // 用于存储最后输出的路径\n\n    // 循环读取用户输入的命令\n    string input;\n    while (getline(cin, input)) {\n        istringstream iss(input);\n        string command, arg;\n        iss >> command;\n\n        if (command == \"mkdir\") {\n            iss >> arg;\n            if (isValidDirectoryName(arg)) {\n                // 如果目录名有效并且不存在，则创建一个新的目录节点，并将其添加到当前目录的子目录映射中\n                if (currentNode->next.find(arg) == currentNode->next.end()) {\n                    currentNode->next[arg] = new Node(currentNode->path + arg + \"/\", currentNode);\n                }\n            }\n        } else if (command == \"cd\") {\n            iss >> arg;\n            if (isValidChangeDirectory(arg)) {\n                // 处理cd命令，用于改变当前目录\n                auto it = currentNode->next.find(arg);\n                if (it != currentNode->next.end()) {\n                    currentNode = it->second; // 如果目录存在，则将当前目录切换为该目录\n                }\n            }\n        } else if (command == \"pwd\") {\n            // 处理pwd命令，用于打印当前目录的路径\n            lastOutput = currentNode->path; // 将当前目录的路径保存到lastOutput变量中\n        }\n    }\n\n    cout << lastOutput << endl; // 循环结束后，打印最后保存的路径\n\n  \n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_CHILDREN 128  // 假设每个目录最多可以有128个子目录\n\n// 定义一个结构体Node，用于表示文件系统中的每个目录\ntypedef struct Node {\n    char path[1024]; // 目录的完整路径\n    struct Node* children[MAX_CHILDREN]; // 存储指向子目录的指针数组\n    char* childNames[MAX_CHILDREN]; // 存储子目录名的数组\n    int childCount; // 实际子目录的数量\n    struct Node* parent; // 指向父目录的指针\n} Node;\n\n// 创建新目录节点的函数，接受目录路径和父节点作为参数\nNode* createNode(const char* path, Node* parent) {\n    Node* newNode = (Node*)malloc(sizeof(Node)); // 分配内存\n    strcpy(newNode->path, path); // 设置目录路径\n    memset(newNode->children, 0, sizeof(newNode->children)); // 初始化子目录指针数组\n    memset(newNode->childNames, 0, sizeof(newNode->childNames)); // 初始化子目录名数组\n    newNode->childCount = 0; // 初始化子目录计数\n    newNode->parent = parent; // 设置父目录\n    return newNode; // 返回新创建的节点\n}\n\n// 检查目录名是否仅包含小写字母\nint isValidDirectoryName(const char* name) {\n    for (int i = 0; name[i] != '\\0'; i++) {\n        if (!islower(name[i])) {\n            return 0; // 如果含有非小写字母，则返回0\n        }\n    }\n    return 1; // 全部是小写字母，则返回1\n}\n\n// 向特定父目录添加一个新的子目录\nvoid addDirectory(Node* parent, const char* name, Node* child) {\n    if (parent->childCount < MAX_CHILDREN) { // 检查是否还有空间添加子目录\n        parent->children[parent->childCount] = child; // 添加子目录指针\n        parent->childNames[parent->childCount] = strdup(name); // 并存储子目录名\n        parent->childCount++; // 子目录计数增加\n    }\n}\n\n// 根据目录名在父目录中查找子目录\nNode* findDirectory(Node* parent, const char* name) {\n    for (int i = 0; i < parent->childCount; i++) {\n        if (strcmp(parent->childNames[i], name) == 0) {\n            return parent->children[i]; // 找到匹配的子目录后返回其指针\n        }\n    }\n    return NULL; // 未找到返回NULL\n}\n\nint main() {\n    Node* root = createNode(\"/\", NULL); // 创建根目录节点\n    Node* currentNode = root; // 初始当前目录为根目录\n    char input[1024], lastOutput[1024] = \"/\"; // 输入缓冲区和最终输出缓冲区\n\n    while (fgets(input, sizeof(input), stdin)) { // 读取命令行输入\n        char* command = strtok(input, \" \\n\"); // 分割出命令\n        char* arg = strtok(NULL, \" \\n\"); // 分割出参数\n\n        if (strcmp(command, \"mkdir\") == 0 && arg && isValidDirectoryName(arg)) {\n            if (findDirectory(currentNode, arg) == NULL) { // 检查目录是否已存在\n                char newPath[1024];\n                sprintf(newPath, \"%s%s/\", currentNode->path, arg); // 构建新目录的完整路径\n                Node* newNode = createNode(newPath, currentNode); // 创建新目录节点\n                addDirectory(currentNode, arg, newNode); // 将新目录添加到当前节点的子目录中\n            }\n        } else if (strcmp(command, \"cd\") == 0 && arg) {\n            if (strcmp(arg, \"..\") == 0 && currentNode->parent) { // 返回上一级目录\n                currentNode = currentNode->parent;\n            } else if (isValidDirectoryName(arg)) { // 改变当前目录到指定的子目录\n                Node* foundNode = findDirectory(currentNode, arg);\n                if (foundNode) {\n                    currentNode = foundNode;\n                }\n            }\n        } else if (strcmp(command, \"pwd\") == 0) { // 输出当前目录的路径\n            strcpy(lastOutput, currentNode->path);\n        }\n    }\n\n    printf(\"%s\\n\", lastOutput); // 打印最后记录的路径\n \n    return 0;\n}"
    }
  },
  {
    "id": "133",
    "title": "特殊的加密算法",
    "examType": "A",
    "score": 200,
    "description": "有一种特殊的加密算法，明文为一段数字串，经过密码本查找转换，生成另一段密文数字串。\n规则如下：\n明文为一段数字串由 0~9 组成 密码本为数字 0~9 组成的二维数组 需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成，上下和左右是相邻的，注意：对角线不相邻，同一个单元格的数字不能重复使用。 每一位明文对应密文即为密码本中找到的单元格所在的行和列序号（序号从0开始）组成的两个数宇。 如明文第 i 位 Data[i] 对应密码本单元格为 Book[x][y]，则明文第 i 位对应的密文为X Y，X和Y之间用空格隔开。\n明文为一段数字串由 0~9 组成\n密码本为数字 0~9 组成的二维数组\n需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成，上下和左右是相邻的，注意：对角线不相邻，同一个单元格的数字不能重复使用。\n每一位明文对应密文即为密码本中找到的单元格所在的行和列序号（序号从0开始）组成的两个数宇。\n如明文第 i 位 Data[i] 对应密码本单元格为 Book[x][y]，则明文第 i 位对应的密文为X Y，X和Y之间用空格隔开。\n如果有多条密文，返回字符序最小的密文。\n如果密码本无法匹配，返回\"error\"。\n请你设计这个加密程序。\n示例1：\n密码本：\n0 0 2\n1 3 4\n6 6 4\n明文：“3”，密文：“1 1”\n示例2：\n密码本：\n0 0 2\n1 3 4\n6 6 4\n明文：“0 3”，密文：“0 1 1 1”\n示例3：\n密码本：\n0 0 2 4\n1 3 4 6\n3 4 1 5\n6 6 6 5\n明文：“0 0 2 4”，密文：“0 0 0 1 0 2 0 3” 和 “0 0 0 1 0 2 1 2”，返回字典序最小的\"0 0 0 1 0 2 0 3\"\n明文：“8 2 2 3”，密文：“error”，密码本中无法匹配",
    "inputDesc": "第一行输入 1 个正整数 N，代表明文的长度（1 ≤ N ≤ 200）\n第二行输入 N 个明文组成的序列 Data[i]（0 ≤ Data[i] ≤ 9）\n第三行输入 1 个正整数 M，代表密文的长度\n接下来 M 行，每行 M 个数，代表密文矩阵",
    "outputDesc": "输出字典序最小密文，如果无法匹配，输出\"error\"\n输入\n输出\n输入\n输出\n说明\n找不到 0 5 的序列，返回error",
    "examples": [],
    "solution": "核心解题思路是通过深度优先搜索（DFS）在一个给定的密码本（二维数组）中找到一条路径，使得这条路径上的数字序列与给定的明文数字序列相匹配，并且在所有可能的匹配路径中选择一条字典序最小的作为密文路径输出。具体步骤如下：\n初始化变量： n 和 m 分别存储明文的长度和密码本的尺寸。book 二维数组存储密码本内容。directions 数组表示搜索的四个方向（右、下、左、上）。minPath 字符串用于存储找到的字典序最小的密文路径。found 布尔变量标记是否找到至少一种加密方式。 搜索准备： 创建一个 visited 布尔二维数组来标记密码本中的数字是否已被访问，以避免重复搜索。 开始搜索： 遍历密码本的每个数字，当找到一个数字与明文的第一个数字相匹配时，从该位置开始使用深度优先搜索（DFS）。 深度优先搜索（DFS）： 递归地搜索所有可能的路径。对于当前位置，如果满足以下条件之一，则继续搜索： 当前位置的数字与明文的当前索引指向的数字相匹配。已到达明文的末尾，且路径符合条件（字典序最小或找到的第一条路径）。 在每个位置，尝试向四个方向移动，并递归调用 dfs 方法继续搜索。搜索过程中，使用 visited 数组标记当前位置已访问，以避免循环访问。 回溯与更新： 每当找到一条完整的匹配路径时，比较并更新 minPath 为字典序最小的路径。完成当前路径的搜索后，回溯（撤销当前位置的访问标记），尝试其他可能的路径。 输出结果： 如果找到至少一条匹配的路径（即 found 为 true），则输出字典序最小的密文路径。否则，输出 \"error\" 表示无法在密码本中找到与明文完全匹配的路径。\nn 和 m 分别存储明文的长度和密码本的尺寸。book 二维数组存储密码本内容。directions 数组表示搜索的四个方向（右、下、左、上）。minPath 字符串用于存储找到的字典序最小的密文路径。found 布尔变量标记是否找到至少一种加密方式。\n创建一个 visited 布尔二维数组来标记密码本中的数字是否已被访问，以避免重复搜索。\n遍历密码本的每个数字，当找到一个数字与明文的第一个数字相匹配时，从该位置开始使用深度优先搜索（DFS）。\n递归地搜索所有可能的路径。对于当前位置，如果满足以下条件之一，则继续搜索： 当前位置的数字与明文的当前索引指向的数字相匹配。已到达明文的末尾，且路径符合条件（字典序最小或找到的第一条路径）。 在每个位置，尝试向四个方向移动，并递归调用 dfs 方法继续搜索。搜索过程中，使用 visited 数组标记当前位置已访问，以避免循环访问。\n当前位置的数字与明文的当前索引指向的数字相匹配。已到达明文的末尾，且路径符合条件（字典序最小或找到的第一条路径）。\n每当找到一条完整的匹配路径时，比较并更新 minPath 为字典序最小的路径。完成当前路径的搜索后，回溯（撤销当前位置的访问标记），尝试其他可能的路径。\n如果找到至少一条匹配的路径（即 found 为 true），则输出字典序最小的密文路径。否则，输出 \"error\" 表示无法在密码本中找到与明文完全匹配的路径。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    static int n, m; // 分别用于存储明文的长度和密码本的尺寸\n    static int[][] book; // 用于存储密码本，是一个二维数组\n    static int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 表示四个搜索方向：右、下、左、上\n    static String minPath = \"\"; // 用于存储找到的字典序最小的密文路径\n    static boolean found = false; // 标记是否找到了至少一种加密方式\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt(); // 读取明文的长度\n        int[] data = new int[n]; // 创建数组存储明文数字\n        for (int i = 0; i < n; i++) {\n            data[i] = scanner.nextInt(); // 读取每个明文数字\n        }\n\n        m = scanner.nextInt(); // 读取密码本的尺寸\n        book = new int[m][m]; // 初始化密码本数组\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                book[i][j] = scanner.nextInt(); // 填充密码本内容\n            }\n        }\n\n        boolean[][] visited = new boolean[m][m]; // 标记密码本中的数字是否已经被访问过\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                if (book[i][j] == data[0]) { // 从找到的第一个数字开始搜索\n                    dfs(data, 0, i, j, visited, \"\"); // 使用深度优先搜索找到所有可能的加密路径\n                }\n            }\n        }\n\n        System.out.println(found ? minPath.trim() : \"error\"); // 如果找到至少一种加密方式，输出最小字典序的密文；否则，输出\"error\"\n    }\n\n    public static void dfs(int[] data, int index, int x, int y, boolean[][] visited, String path) {\n        if (index == n) { // 如果已经处理完所有明文数字\n            if (!found || path.compareTo(minPath) < 0) { // 如果找到的是第一种加密方式，或者字典序比之前的小\n                minPath = path; // 更新最小字典序密文路径\n            }\n            found = true; // 标记找到了加密方式\n            return;\n        }\n\n        if (x < 0 || y < 0 || x >= m || y >= m || visited[x][y] || book[x][y] != data[index]) {\n            // 如果坐标越界，或该位置已访问，或该位置数字与明文不匹配，则返回\n            return;\n        }\n\n        visited[x][y] = true; // 标记当前位置已访问\n        String newPath = path + x + \" \" + y + \" \"; // 更新路径字符串\n\n        if (index == n - 1 || book[x][y] == data[index]) {\n            dfs(data, index + 1, x, y, visited, newPath); // 继续搜索下一个明文数字\n        }\n\n        for (int[] dir : directions) { // 遍历四个方向\n            int newX = x + dir[0];\n            int newY = y + dir[1];\n            dfs(data, index + 1, newX, newY, visited, newPath); // 在新方向上搜索下一个明文数字\n        }\n\n        visited[x][y] = false; // 回溯，撤销当前位置的访问标记\n    }\n}",
      "python": "import sys\n\n# 读取输入\nn = int(input())\ndata = list(map(int, input().split()))\nm = int(input())\nbook = [list(map(int, input().split())) for _ in range(m)]\n\ndirections = [(0, 1), (1, 0), (-1, 0), (0, -1)]  # 四个搜索方向：右、下、左、上\nmin_path = None  # 存储找到的字典序最小的密文路径\nfound = False  # 标记是否找到至少一种加密方式\n\ndef dfs(data, index, x, y, visited, path):\n    global min_path, found\n    if index == len(data):  # 如果已经处理完所有明文数字\n        if not found or path < min_path:  # 如果找到的是第一种加密方式，或者字典序比之前的小\n            min_path = path  # 更新最小字典序密文路径\n        found = True\n        return\n\n    if x < 0 or y < 0 or x >= m or y >= m or visited[x][y] or book[x][y] != data[index]:\n        # 如果坐标越界，或该位置已访问，或该位置数字与明文不匹配，则返回\n        return\n\n    visited[x][y] = True  # 标记当前位置已访问\n    new_path = path + f\"{x} {y} \"  # 更新路径字符串\n\n    for dir in directions:  # 遍历四个方向\n        newX, newY = x + dir[0], y + dir[1]\n        dfs(data, index + 1, newX, newY, visited, new_path)  # 在新方向上搜索下一个明文数字\n\n    visited[x][y] = False  # 回溯，撤销当前位置的访问标记\n\nvisited = [[False for _ in range(m)] for _ in range(m)]  # 标记密码本中的数字是否已经被访问过\nfor i in range(m):\n    for j in range(m):\n        if book[i][j] == data[0]:  # 从找到的第一个数字开始搜索\n            dfs(data, 0, i, j, visited, \"\")  # 使用深度优先搜索找到所有可能的加密路径\n\nprint(min_path.strip() if found else \"error\")  # 如果找到至少一种加密方式，输出最小字典序的密文；否则，输出\"error\"",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// 全局变量定义\nstatic int n, m; // 分别用于存储明文的长度和密码本的尺寸\nvector<vector<int>> book; // 用于存储密码本，是一个二维向量\nvector<vector<int>> directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 表示四个搜索方向：右、下、左、上\nstring minPath = \"\"; // 用于存储找到的字典序最小的密文路径\nbool found = false; // 标记是否找到了至少一种加密方式\n\n// 深度优先搜索函数声明\nvoid dfs(const vector<int>& data, int index, int x, int y, vector<vector<bool>>& visited, string path);\n\nint main() {\n    cin >> n; // 读取明文的长度\n    vector<int> data(n); // 创建向量存储明文数字\n    for (int i = 0; i < n; ++i) {\n        cin >> data[i]; // 读取每个明文数字\n    }\n\n    cin >> m; // 读取密码本的尺寸\n    book.resize(m, vector<int>(m)); // 初始化密码本向量\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> book[i][j]; // 填充密码本内容\n        }\n    }\n\n    vector<vector<bool>> visited(m, vector<bool>(m, false)); // 标记密码本中的数字是否已经被访问过\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (book[i][j] == data[0]) { // 从找到的第一个数字开始搜索\n                dfs(data, 0, i, j, visited, \"\"); // 使用深度优先搜索找到所有可能的加密路径\n            }\n        }\n    }\n\n    cout << (found ? minPath : \"error\") << endl; // 如果找到至少一种加密方式，输出最小字典序的密文；否则，输出\"error\"\n    return 0;\n}\n\nvoid dfs(const vector<int>& data, int index, int x, int y, vector<vector<bool>>& visited, string path) {\n    if (index == n) { // 如果已经处理完所有明文数字\n        if (!found || path < minPath) { // 如果找到的是第一种加密方式，或者字典序比之前的小\n            minPath = path; // 更新最小字典序密文路径\n        }\n        found = true; // 标记找到了加密方式\n        return;\n    }\n\n    if (x < 0 || y < 0 || x >= m || y >= m || visited[x][y] || book[x][y] != data[index]) {\n        // 如果坐标越界，或该位置已访问，或该位置数字与明文不匹配，则返回\n        return;\n    }\n\n    visited[x][y] = true; // 标记当前位置已访问\n    string newPath = path + to_string(x) + \" \" + to_string(y) + \" \"; // 更新路径字符串\n\n    // 遍历四个方向\n    for (const auto& dir : directions) {\n        int newX = x + dir[0];\n        int newY = y + dir[1];\n        dfs(data, index + 1, newX, newY, visited, newPath); // 在新方向上搜索下一个明文数字\n    }\n\n    visited[x][y] = false; // 回溯，撤销当前位置的访问标记\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100 //  密码本的最大尺寸\n#define PATH_LEN 1000 //  路径字符串的最大长度\n\nint n, m; // 明文长度和密码本尺寸\nint book[MAX_SIZE][MAX_SIZE]; // 密码本\nint directions[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 搜索方向：右、下、左、上\nchar minPath[PATH_LEN] = \"\"; // 最小字典序密文路径\nbool found = false; // 是否找到至少一种加密方式\n\nvoid dfs(int data[], int index, int x, int y, bool visited[MAX_SIZE][MAX_SIZE], char path[PATH_LEN]) {\n    if (index == n) { // 处理完所有明文数字\n        if (!found || strcmp(path, minPath) < 0) {\n            strcpy(minPath, path); // 更新最小字典序密文路径\n        }\n        found = true;\n        return;\n    }\n\n    if (x < 0 || y < 0 || x >= m || y >= m || visited[x][y] || book[x][y] != data[index]) {\n        return; // 坐标越界或位置已访问或数字不匹配\n    }\n\n    visited[x][y] = true;\n    char newPath[PATH_LEN];\n    strcpy(newPath, path); // 当前路径\n    char temp[20]; // 临时字符串存储当前位置\n    sprintf(temp, \"%d %d \", x, y);\n    strcat(newPath, temp); // 更新路径\n\n    for (int i = 0; i < 4; i++) { // 遍历四个方向\n        int newX = x + directions[i][0];\n        int newY = y + directions[i][1];\n        dfs(data, index + 1, newX, newY, visited, newPath);\n    }\n\n    visited[x][y] = false; // 回溯\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    int data[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &data[i]);\n    }\n\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            scanf(\"%d\", &book[i][j]);\n        }\n    }\n\n    bool visited[MAX_SIZE][MAX_SIZE] = {false};\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (book[i][j] == data[0]) {\n                char path[PATH_LEN] = \"\";\n                dfs(data, 0, i, j, visited, path);\n            }\n        }\n    }\n\n    if (found) {\n        printf(\"%s\\n\", minPath);\n    } else {\n        printf(\"error\\n\");\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "134",
    "title": "电脑病毒感染",
    "examType": "A",
    "score": 200,
    "description": "一个局域网内有很多台电脑，分别标注为 0 ~ N-1 的数字。相连接的电脑距离不一样，所以感染时间不一样，感染时间用 t 表示。\n其中网络内一台电脑被病毒感染，求其感染网络内所有的电脑最少需要多长时间。如果最后有电脑不会感染，则返回-1。\n给定一个数组 times 表示一台电脑把相邻电脑感染所用的时间。\n如图：path[i] = {i, j, t} 表示：电脑 i->j，电脑 i 上的病毒感染 j，需要时间 t。",
    "inputDesc": "第一行输入一个整数N ，表示局域网内电脑个数 N ，1 ≤ N ≤ 200 ;\n第二行输入一个整数M ,表示有 M 条网络连接；\n接下来M行 ,每行输入为 i , j , t 。表示电脑 i 感染电脑j 需要时间 t 。（1 ≤ i , j ≤ N）\n最后一行为病毒所在的电脑编号。",
    "outputDesc": "输出最少需要多少时间才能感染全部电脑，如果不存在输出 -1",
    "examples": [],
    "solution": "Bellman-Ford算法是一种用于在加权图中找到从单个源点到所有其他顶点的最短路径的算法。它能够处理带有负权边的图，这是它与Dijkstra算法的主要区别。然而，如果图中存在负权回路，即一个总权重为负的环路，Bellman-Ford算法可以检测到这种情况。\n算法的工作原理如下：\n初始化距离数组：算法开始时，除了源点（在上面的代码中是变量K）的距离被初始化为0以外，所有顶点的距离都被设置为无穷大（在上面的代码中是INF）。 松弛操作：算法会进行N-1次迭代，其中N是图中顶点的数量。在每次迭代中，算法会遍历所有的边，并尝试更新每条边的目标顶点的距离。如果通过当前边到达目标顶点的距离小于已知的最短距离，则更新该顶点的最短距离。这个过程称为松弛操作。 检测负权回路：在N-1次迭代之后，算法会再次遍历所有的边，检查是否还能进行松弛操作。如果可以，这意味着图中存在负权回路，因为最短路径应该已经在前面的N-1次迭代中被确定下来。\n初始化距离数组：算法开始时，除了源点（在上面的代码中是变量K）的距离被初始化为0以外，所有顶点的距离都被设置为无穷大（在上面的代码中是INF）。\n松弛操作：算法会进行N-1次迭代，其中N是图中顶点的数量。在每次迭代中，算法会遍历所有的边，并尝试更新每条边的目标顶点的距离。如果通过当前边到达目标顶点的距离小于已知的最短距离，则更新该顶点的最短距离。这个过程称为松弛操作。\n检测负权回路：在N-1次迭代之后，算法会再次遍历所有的边，检查是否还能进行松弛操作。如果可以，这意味着图中存在负权回路，因为最短路径应该已经在前面的N-1次迭代中被确定下来。\n在下面的代码中，networkDelayTime函数实现了Bellman-Ford算法：\ntimes数组包含了图中所有的边，其中每个元素是一个三元组[u, v, w]，表示从顶点u到顶点v的边，其权重为w。dist数组用于存储从源点K到每个顶点的最短距离。在for循环中，算法遍历所有边，并对每条边执行松弛操作。如果dist[u] + w < dist[v]，则更新dist[v]为dist[u] + w。在所有顶点的最短距离被计算出来后，算法找出最长的最短距离，即maxWait，这是感染所有电脑所需的最少时间。如果有顶点的距离仍然是无穷大，这意味着有些顶点无法从源点K到达，函数返回-1。\nBellman-Ford算法的时间复杂度是O(VE)，其中V是顶点的数量，E是边的数量。这使得它在稠密图中效率较低，但它是处理带有负权边的图的有效算法。",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt(); // 电脑的数量\n        int connections = sc.nextInt(); // 网络连接的数量\n        int[][] times = new int[connections][3]; // 存储每个连接和对应的感染时间\n        for (int i = 0; i < connections; i++) {\n            // 读取每个连接的信息，将电脑编号减1转换为从0开始的索引\n            times[i][0] = sc.nextInt() - 1; // 感染源电脑编号\n            times[i][1] = sc.nextInt() - 1; // 被感染电脑编号\n            times[i][2] = sc.nextInt(); // 感染所需时间\n        }\n        int initial = sc.nextInt() - 1; // 初始被感染的电脑编号，转换为从0开始的索引\n        sc.close(); // 关闭输入流\n\n        // 输出感染所有电脑所需的最少时间\n        System.out.println(networkDelayTime(times, N, initial));\n    }\n\n    // 计算感染所有电脑所需的最少时间的函数\n    public static int networkDelayTime(int[][] times, int N, int K) {\n        final int INF = Integer.MAX_VALUE / 2; // 定义无穷大的值，用于初始化距离数组\n        int[] dist = new int[N]; // 存储从源电脑到其他所有电脑的最短感染时间\n        Arrays.fill(dist, INF); // 初始化所有感染时间为无穷大\n        dist[K] = 0; // 源电脑的感染时间为0\n\n        // 使用Bellman-Ford算法更新所有电脑的最短感染时间\n        for (int i = 0; i < N; i++) {\n            for (int[] time : times) {\n                int u = time[0], v = time[1], w = time[2];\n                // 如果可以通过电脑u感染到电脑v，并且时间更短，则更新电脑v的感染时间\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                }\n            }\n        }\n\n        // 找出所有电脑中最长的感染时间\n        int maxWait = 0;\n        for (int i = 0; i < N; i++) {\n            // 如果有电脑的感染时间仍为无穷大，表示该电脑不可被感染，返回-1\n            if (dist[i] == INF) return -1;\n            // 更新最长的感染时间\n            maxWait = Math.max(maxWait, dist[i]);\n        }\n\n        // 返回感染所有电脑所需的最少时间\n        return maxWait;\n    }\n}",
      "python": "import sys\n\n# 计算感染所有电脑所需的最少时间的函数\ndef network_delay_time(times, N, K):\n    INF = float('inf')  # 定义无穷大的值，用于初始化距离数组\n    dist = [INF] * N  # 存储从源电脑到其他所有电脑的最短感染时间\n    dist[K] = 0  # 源电脑的感染时间为0\n\n    # 使用Bellman-Ford算法更新所有电脑的最短感染时间\n    for _ in range(N):\n        for u, v, w in times:\n            # 如果可以通过电脑u感染到电脑v，并且时间更短，则更新电脑v的感染时间\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n\n    # 找出所有电脑中最长的感染时间\n    max_wait = max(dist)\n    # 如果有电脑的感染时间仍为无穷大，表示该电脑不可被感染，返回-1\n    return max_wait if max_wait < INF else -1\n\n \nN = int(input())\nconnections = int(input()) # 电脑的数量和网络连接的数量\ntimes = []  # 存储每个连接和对应的感染时间\nfor _ in range(connections):\n    # 读取每个连接的信息，将电脑编号减1转换为从0开始的索引\n    u, v, w = map(int, input().split())\n    times.append((u - 1, v - 1, w))  # 感染源电脑编号，被感染电脑编号，感染所需时间\ninitial = int(input()) - 1  # 初始被感染的电脑编号，转换为从0开始的索引\n\n# 输出感染所有电脑所需的最少时间\nprint(network_delay_time(times, N, initial))",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n// 计算感染所有电脑所需的最少时间的函数\nint networkDelayTime(vector<vector<int>>& times, int N, int K) {\n    const int INF = INT_MAX / 2; // 定义无穷大的值，用于初始化距离数组\n    vector<int> dist(N, INF); // 存储从源电脑到其他所有电脑的最短感染时间\n    dist[K] = 0; // 源电脑的感染时间为0\n\n    // 使用Bellman-Ford算法更新所有电脑的最短感染时间\n    for (int i = 0; i < N; ++i) {\n        for (const auto& time : times) {\n            int u = time[0], v = time[1], w = time[2];\n            // 如果可以通过电脑u感染到电脑v，并且时间更短，则更新电脑v的感染时间\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n\n    // 找出所有电脑中最长的感染时间\n    int maxWait = 0;\n    for (int i = 0; i < N; ++i) {\n        // 如果有电脑的感染时间仍为无穷大，表示该电脑不可被感染，返回-1\n        if (dist[i] == INF) return -1;\n        // 更新最长的感染时间\n        maxWait = max(maxWait, dist[i]);\n    }\n\n    // 返回感染所有电脑所需的最少时间\n    return maxWait;\n}\n\nint main() {\n    int N, connections;\n    cin >> N >> connections; // 电脑的数量和网络连接的数量\n    vector<vector<int>> times(connections, vector<int>(3)); // 存储每个连接和对应的感染时间\n    for (int i = 0; i < connections; ++i) {\n        // 读取每个连接的信息，将电脑编号减1转换为从0开始的索引\n        cin >> times[i][0] >> times[i][1] >> times[i][2];\n        times[i][0]--; // 感染源电脑编号\n        times[i][1]--; // 被感染电脑编号\n    }\n    int initial;\n    cin >> initial; // 初始被感染的电脑编号，转换为从0开始的索引\n    initial--;\n\n    // 输出感染所有电脑所需的最少时间\n    cout << networkDelayTime(times, N, initial) << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h> // 引入INT_MAX\n\n#define INF (INT_MAX / 2) // 定义无穷大的值\n\n// 计算感染所有电脑所需的最少时间\nint networkDelayTime(int times[][3], int connections, int N, int K) {\n    int dist[N]; // 存储从源电脑到其他所有电脑的最短感染时间\n    for (int i = 0; i < N; i++) {\n        dist[i] = INF; // 初始化所有感染时间为无穷大\n    }\n    dist[K] = 0; // 源电脑的感染时间设为0\n\n    // 使用Bellman-Ford算法更新所有电脑的最短感染时间\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < connections; j++) {\n            int u = times[j][0], v = times[j][1], w = times[j][2];\n            // 如果可以通过电脑u感染到电脑v，并且时间更短，则更新电脑v的感染时间\n            if (dist[u] != INF && dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n\n    // 找出所有电脑中最长的感染时间\n    int maxWait = 0;\n    for (int i = 0; i < N; i++) {\n        // 如果有电脑的感染时间仍为无穷大，表示该电脑不可被感染，返回-1\n        if (dist[i] == INF) return -1;\n        // 更新最长的感染时间\n        if (dist[i] > maxWait) {\n            maxWait = dist[i];\n        }\n    }\n\n    // 返回感染所有电脑所需的最少时间\n    return maxWait;\n}\n\nint main() {\n    int N, connections; // 电脑的数量和网络连接的数量\n    scanf(\"%d\", &N );\n    scanf(\"%d\",  &connections);\n\n    int times[connections][3]; // 存储每个连接和对应的感染时间\n\n    // 读取网络连接信息\n    for (int i = 0; i < connections; i++) {\n        scanf(\"%d %d %d\", &times[i][0], &times[i][1], &times[i][2]);\n        times[i][0]--; // 将电脑编号转换为从0开始的索引\n        times[i][1]--;\n    }\n\n    int initial; // 初始被感染的电脑编号\n    scanf(\"%d\", &initial);\n    initial--; // 转换为从0开始的索引\n\n    // 输出感染所有电脑所需的最少时间\n    printf(\"%d\\n\", networkDelayTime(times, connections, N, initial));\n\n    return 0;\n}"
    }
  },
  {
    "id": "135",
    "title": "矩阵匹配",
    "examType": "A",
    "score": 200,
    "description": "从一个 N * M（N ≤ M）的矩阵中选出 N 个数，任意两个数字不能在同一行或同一列，求选出来的 N 个数中第 K 大的数字的最小值是多少。",
    "inputDesc": "输入矩阵要求：1 ≤ K ≤ N ≤ M ≤ 150\n输入格式：\nN M K\nN*M矩阵",
    "outputDesc": "N*M 的矩阵中可以选出 M! / N! 种组合数组，每个组合数组种第 K 大的数中的最小值。无需考虑重复数字，直接取字典排序结果即可。\n注意：结果是第 K 大的数字的最小值\n输入\n输出\nN*M的矩阵中可以选出 M！/ N！种组合数组，每个组合数组种第 K 大的数中的最小值； 上述输入中选出数组组合为： 1,3,6; 1,3,3; 1,4,8; 1,4,3; … 上述输入样例中选出的组合数组有24种，最小数组为1,3,3，则第2大的最小值为3",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    static int n, m, k;  // n、m、k 分别表示矩阵的行数、列数和要求的第K大数\n    static int[][] matrix;  // matrix 用于存储输入的矩阵\n    static int[] match;  // match 数组用于存储匹配信息，match[j] = i 表示第j列与第i行匹配\n    static boolean[] vis;  // vis 数组用于标记每一列在当前增广路中是否被访问过\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();  // 读取行数\n        m = sc.nextInt();  // 读取列数\n        k = sc.nextInt();  // 读取k值\n\n        int min = 1, max = Integer.MIN_VALUE;  // 初始化二分查找的上下界\n        matrix = new int[n][m];  // 初始化矩阵\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                matrix[i][j] = sc.nextInt();  // 读取矩阵元素\n                max = Math.max(max, matrix[i][j]);  // 更新矩阵元素的最大值，作为二分查找的上界\n            }\n        }\n\n        // 二分查找确定第K大的数的最小可能值\n        while (min <= max) {\n            int mid = (min + max) / 2;  // 取中间值\n            if (check(mid)) {\n                max = mid - 1;  // 如果当前中间值满足条件，则尝试寻找更小的值\n            } else {\n                min = mid + 1;  // 如果不满足条件，则尝试寻找更大的值\n            }\n        }\n        System.out.println(min);  // 输出最终结果\n    }\n\n    // 检查当前值是否满足条件\n    public static boolean check(int currentVal) {\n        match = new int[m];  // 初始化匹配数组\n        Arrays.fill(match, -1);  // 将所有列初始化为未匹配状态\n        vis = new boolean[m];  // 初始化访问标记数组\n        int smallerCount = 0;  // 统计满足条件的数量\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(vis, false);  // 每次搜索前重置访问标记\n            if (dfs(i, currentVal)) {\n                smallerCount++;  // 如果找到增广路径，则计数增加\n            }\n        }\n        return smallerCount >= n - k + 1;  // 检查是否有足够的小于等于currentVal的数\n    }\n\n    // 深度优先搜索寻找增广路径\n    public static boolean dfs(int i, int currentVal) {\n        for (int j = 0; j < m; j++) {\n            // 检查列j是否未被访问过且第i行第j列的值小于等于currentVal\n            if (!vis[j] && matrix[i][j] <= currentVal) {\n                vis[j] = true;  // 标记列j为已访问\n                // 如果列j未匹配或者列j的匹配行可以匹配到其他列\n                if (match[j] == -1 || dfs(match[j], currentVal)) {\n                    match[j] = i;  // 将列j与行i匹配\n                    return true;  // 找到增广路径\n                }\n            }\n        }\n        return false;  // 没有找到增广路径\n    }\n}",
      "python": "import sys\n\ndef dfs(i, current_val):\n    \"\"\"\n    深度优先搜索寻找增广路径\n    :param i: 当前正在处理的行索引\n    :param current_val: 当前考虑的值\n    :return: 如果找到增广路径，返回True；否则返回False\n    \"\"\"\n    for j in range(m):\n        # 检查第j列是否未被访问过且第i行第j列的值小于等于current_val\n        if not vis[j] and matrix[i][j] <= current_val:\n            vis[j] = True  # 标记第j列为已访问\n            # 如果第j列未匹配或其匹配的行可以找到其他匹配列\n            if match[j] == -1 or dfs(match[j], current_val):\n                match[j] = i  # 将第j列与第i行匹配\n                return True\n    return False\n\ndef check(current_val):\n    \"\"\"\n    检查当前值是否满足条件\n    :param current_val: 当前考虑的值\n    :return: 如果满足条件，返回True；否则返回False\n    \"\"\"\n    global match, vis\n    match = [-1] * m  # 初始化匹配数组，所有列都标记为未匹配\n    vis = [False] * m  # 初始化访问标记数组\n    smaller_count = 0  # 统计满足条件的数量\n\n    for i in range(n):\n        vis = [False] * m  # 每次搜索前重置访问标记\n        if dfs(i, current_val):\n            smaller_count += 1  # 如果找到增广路径，则计数增加\n\n    return smaller_count >= n - k + 1  # 检查是否有足够的小于等于current_val的数\n\n# 读取输入\nn, m, k = map(int, input().split())  # 读取行数、列数和k值\n\n# 初始化矩阵\nmatrix = []\nfor _ in range(n):\n    matrix.append(list(map(int, input().split())))\n\n# 初始化二分查找的上下界\nmin_val, max_val = 1, -sys.maxsize\n\n# 更新矩阵元素的最大值，作为二分查找的上界\nfor row in matrix:\n    max_val = max(max_val, max(row))\n\n# 二分查找确定第K大的数的最小可能值\nwhile min_val <= max_val:\n    mid = (min_val + max_val) // 2\n    if check(mid):\n        max_val = mid - 1\n    else:\n        min_val = mid + 1\n\n# 输出最终结果\nprint(min_val)",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint n, m, k;  // n、m、k 分别表示矩阵的行数、列数和要求的第K大数\nvector<vector<int>> matrix;  // matrix 用于存储输入的矩阵\nvector<int> match;  // match 数组用于存储匹配信息，match[j] = i 表示第j列与第i行匹配\nvector<bool> vis;  // vis 数组用于标记每一列在当前增广路中是否被访问过\n\n// 深度优先搜索寻找增广路径\nbool dfs(int i, int currentVal) {\n    for (int j = 0; j < m; j++) {\n        // 检查列j是否未被访问过且第i行第j列的值小于等于currentVal\n        if (!vis[j] && matrix[i][j] <= currentVal) {\n            vis[j] = true;  // 标记列j为已访问\n            // 如果列j未匹配或者列j的匹配行可以匹配到其他列\n            if (match[j] == -1 || dfs(match[j], currentVal)) {\n                match[j] = i;  // 将列j与行i匹配\n                return true;  // 找到增广路径\n            }\n        }\n    }\n    return false;  // 没有找到增广路径\n}\n\n// 检查当前值是否满足条件\nbool check(int currentVal) {\n    match.assign(m, -1);  // 初始化匹配数组\n    vis.assign(m, false);  // 初始化访问标记数组\n    int smallerCount = 0;  // 统计满足条件的数量\n    for (int i = 0; i < n; i++) {\n        fill(vis.begin(), vis.end(), false);  // 每次搜索前重置访问标记\n        if (dfs(i, currentVal)) {\n            smallerCount++;  // 如果找到增广路径，则计数增加\n        }\n    }\n    return smallerCount >= n - k + 1;  // 检查是否有足够的小于等于currentVal的数\n}\n\nint main() {\n    cin >> n >> m >> k;  // 读取行数、列数和k值\n\n    int min = 1, maxT = INT_MIN;  // 初始化二分查找的上下界\n    matrix.assign(n, vector<int>(m));  // 初始化矩阵\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> matrix[i][j];  // 读取矩阵元素\n            maxT = max(maxT, matrix[i][j]);  // 更新矩阵元素的最大值，作为二分查找的上界\n        }\n    }\n\n    // 二分查找确定第K大的数的最小可能值\n    while (min <= maxT) {\n        int mid = (min + maxT) / 2;  // 取中间值\n        if (check(mid)) {\n            maxT = mid - 1;  // 如果当前中间值满足条件，则尝试寻找更小的值\n        } else {\n            min = mid + 1;  // 如果不满足条件，则尝试寻找更大的值\n        }\n    }\n    cout << min << endl;  // 输出最终结果\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_N 200  \n#define MAX_M 200  \n\nint n, m, k;  // n、m、k 分别表示矩阵的行数、列数和要求的第K大数\nint matrix[MAX_N][MAX_M];  // matrix 用于存储输入的矩阵\nint match[MAX_M];  // match 数组用于存储匹配信息\nbool vis[MAX_M];  // vis 数组用于标记每一列在当前增广路中是否被访问过\n\nbool dfs(int i, int current_val) {\n    for (int j = 0; j < m; j++) {\n        if (!vis[j] && matrix[i][j] <= current_val) {\n            vis[j] = true;\n            if (match[j] == -1 || dfs(match[j], current_val)) {\n                match[j] = i;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool check(int current_val) {\n    for (int j = 0; j < m; j++) {\n        match[j] = -1;  // 初始化匹配数组\n    }\n\n    int smaller_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            vis[j] = false;  // 初始化访问标记数组\n        }\n        if (dfs(i, current_val)) {\n            smaller_count++;\n        }\n    }\n    return smaller_count >= n - k + 1;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &k);  // 读取行数、列数和k值\n\n    // 初始化矩阵\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n\n    // 初始化二分查找的上下界\n    int min_val = 1, max_val = INT_MIN;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (matrix[i][j] > max_val) {\n                max_val = matrix[i][j];  // 更新矩阵元素的最大值\n            }\n        }\n    }\n\n    // 二分查找确定第K大的数的最小可能值\n    while (min_val <= max_val) {\n        int mid = (min_val + max_val) / 2;\n        if (check(mid)) {\n            max_val = mid - 1;\n        } else {\n            min_val = mid + 1;\n        }\n    }\n\n    // 输出最终结果\n    printf(\"%d\\n\", min_val);\n\n    return 0;\n}"
    }
  },
  {
    "id": "136",
    "title": "荒岛求生",
    "examType": "A",
    "score": 200,
    "description": "一个荒岛上有若干人，岛上只有一条路通往岛屿两端的港口，大家需要逃往两端的港口才可逃生。\n假定每个人移动的速度一样，且只可选择向左或向右逃生。\n若两个人相遇，则进行决斗，战斗力强的能够活下来，并损失掉与对方相同的战斗力；若战斗力相同，则两人同归于尽。",
    "inputDesc": "给定一行非 0 整数数组，元素个数不超过30000；\n正负表示逃生方向（正表示向右逃生，负表示向左逃生），绝对值表示战斗力，越左边的数字表示里左边港口越近，逃生方向相同的人永远不会发生决斗。",
    "outputDesc": "能够逃生的人总数，没有人逃生输出0，输入异常时输出-1。",
    "examples": [
      {
        "input": "10 8 -8 -5",
        "output": "",
        "explanation": "第3个人和第4个人同归于尽，第2个人杀死第5个人并剩余5战斗力，第1个人没有遇到敌人。"
      }
    ],
    "solution": "原题：[735. 行星碰撞](https://leetcode.cn/problems/asteroid-collision/) 唯一的区别，就是本题会自减对方的战斗力。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    // 定义一个名为asteroidCollision的方法，接受一个整数列表作为参数\n    public static int asteroidCollision(List<Integer> people) {\n        // 创建一个新的ArrayList，用于存储幸存者\n        List<Integer> survivors = new ArrayList<>();\n        \n        // 遍历输入的整数列表\n        for (int person : people) {\n            // 如果person等于0，则返回-1\n            if (person == 0) {\n                return -1;\n            }\n            \n            // 初始化一个布尔变量alive为true\n            boolean alive = true;\n            \n            // 当alive为true且person小于0，且survivors不为空，且survivors列表中最后一个元素大于0时，执行循环\n            while (alive && person < 0 && !survivors.isEmpty() && survivors.get(survivors.size() - 1) > 0) {\n                // 更新alive的值，判断当前person是否比survivors列表中最后一个元素的相反数大\n                alive = survivors.get(survivors.size() - 1) < -person;\n                \n                // 如果survivors列表中最后一个元素小于等于person的相反数，则移除该元素\n                if (survivors.get(survivors.size() - 1) <= -person) {\n                \tperson = person + \t survivors.get(survivors.size() - 1);\n                    survivors.remove(survivors.size() - 1);\n                }\n            }\n            \n            // 如果alive为true，则将person添加到survivors列表中\n            if (alive) {\n                survivors.add(person);\n            }\n        }\n        \n        // 返回survivors列表的大小\n        return survivors.size();\n    }\n\n     public static void main(String[] args) {\n         Scanner scanner = new Scanner(System.in);\n        \n        // 读取一行输入，并使用空格分隔字符串\n        String[] input = scanner.nextLine().split(\" \");\n        \n        // 创建一个整数列表，用于存储输入的整数\n        List<Integer> people = new ArrayList<>();\n        \n        // 将输入的字符串数组转换为整数，并添加到people列表中\n        for (String s : input) {\n            people.add(Integer.parseInt(s));\n        }\n\n        // 如果people列表的大小大于30000，则输出-1\n        if (people.size() > 30000) {\n            System.out.println(-1);\n        } else {\n            // 调用asteroidCollision方法，并将结果输出\n            int result = asteroidCollision(people);\n            System.out.println(result);\n        }\n    }\n}",
      "python": "def asteroidCollision(people: list[int]) -> int:\n    survivors = []\n    for person in people:\n        if person == 0:\n            return -1\n        alive = True\n        # 当前人向左逃生，且有人向右逃生时进行决斗\n        while alive and person < 0 and survivors and survivors[-1] > 0:\n            # 决斗结果：当前人战斗力大于对手\n            alive = survivors[-1] < - person\n             # 如果战斗力相等或当前人战斗力更大，移除对手\n            if survivors[-1] <= -person:\n                person = person + survivors[-1] \n\n                survivors.pop()\n            else:\n                survivors[-1] = survivors[-1] + person\n                print(survivors[-1])\n        # 如果当前人仍然存活，将其添加到逃生者列表\n        if alive:\n            survivors.append(person)\n    return len(survivors)\n\ntry:\n    # 从输入获取人员列表\n    people = list(map(int, input().split()))\n\n    # 检查输入是否异常\n    if len(people) > 30000:\n        raise ValueError(\"输入异常\")\n\n    # 调用函数并输出结果\n    result = asteroidCollision(people)\n    print(result)\nexcept ValueError as e:\n    print(-1)",
      "javascript": "function asteroidCollision(people) {\n    // 创建一个空数组，用于存储幸存者\n    const survivors = [];\n    \n    // 遍历输入的整数数组\n    for (let person of people) {\n        // 如果person等于0，则返回-1\n        if (person === 0) {\n            return -1;\n        }\n        \n        // 初始化一个布尔变量alive为true\n        let alive = true;\n        \n        // 当alive为true且person小于0，且survivors长度大于0，且survivors数组中最后一个元素大于0时，执行循环\n        while (alive && person < 0 && survivors.length > 0 && survivors[survivors.length - 1] > 0) {\n            // 更新alive的值，判断当前person是否比survivors数组中最后一个元素的相反数大\n            alive = survivors[survivors.length - 1] < -person;\n            \n            // 如果survivors数组中最后一个元素小于等于person的相反数，则移除该元素\n            if (survivors[survivors.length - 1] <= -person) {\n            person =  person + survivors[survivors.length - 1]\n                survivors.pop();\n            }\n        }\n        \n        // 如果alive为true，则将person添加到survivors数组中\n        if (alive) {\n            survivors.push(person);\n        }\n    }\n    \n    // 返回survivors数组的长度\n    return survivors.length;\n}\n\n// 导入readline模块\nconst readline = require('readline');\n// 创建一个readline接口实例\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 当接收到一行输入时，执行以下操作\nrl.on('line', (input) => {\n    // 将输入的字符串以空格分隔，并将每个子字符串转换为数字，存储在people数组中\n    const people = input.split(' ').map(Number);\n\n    // 如果people数组的长度大于30000，则输出-1\n    if (people.length > 30000) {\n        console.log(-1);\n    } else {\n        // 调用asteroidCollision函数，并将结果输出\n        const result = asteroidCollision(people);\n        console.log(result);\n    }\n\n    // 关闭readline接口\n    rl.close();\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// 定义一个名为asteroidCollision的函数，接受一个整数向量作为参数\nint asteroidCollision(vector<int>& people) {\n    // 创建一个新的vector，用于存储幸存者\n    vector<int> survivors;\n\n    // 遍历输入的整数向量\n    for (int person : people) {\n        // 如果person等于0，则返回-1\n        if (person == 0) {\n            return -1;\n        }\n\n        // 初始化一个布尔变量alive为true\n        bool alive = true;\n\n        // 当alive为true且person小于0，且survivors不为空，且survivors向量中最后一个元素大于0时，执行循环\n        while (alive && person < 0 && !survivors.empty() && survivors.back() > 0) {\n            // 更新alive的值，判断当前person是否比survivors向量中最后一个元素的相反数大\n            alive = survivors.back() < -person;\n\n            // 如果survivors向量中最后一个元素小于等于person的相反数，则移除该元素\n            if (survivors.back() <= -person) {\n                person = person + survivors.back();\n                survivors.pop_back();\n            }\n        }\n\n        // 如果alive为true，则将person添加到survivors向量中\n        if (alive) {\n            survivors.push_back(person);\n        }\n    }\n\n    // 返回survivors向量的大小\n    return survivors.size();\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n    stringstream ss(input);\n\n    // 创建一个整数向量，用于存储输入的整数\n    vector<int> people;\n    int num;\n\n    // 将输入的字符串转换为整数，并添加到people向量中\n    while (ss >> num) {\n        people.push_back(num);\n    }\n\n    // 如果people向量的大小大于30000，则输出-1\n    if (people.size() > 30000) {\n        cout << -1 << endl;\n    } else {\n        // 调用asteroidCollision函数，并将结果输出\n        int result = asteroidCollision(people);\n        cout << result << endl;\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PEOPLE 30000\n\n// 定义一个方法 asteroidCollision，接受一个整数数组 people 及其大小 n 作为参数\nint asteroidCollision(int *people, int n) {\n    // 定义一个数组 survivors 来存储幸存者\n    int survivors[MAX_PEOPLE];\n    int survivors_size = 0; // 幸存者列表的大小\n\n    // 遍历输入的整数数组\n    for (int i = 0; i < n; i++) {\n        int person = people[i];\n\n        // 如果 person 等于 0，返回 -1，表示输入异常\n        if (person == 0) {\n            return -1;\n        }\n\n        bool alive = true;\n\n        // 当 alive 为 true 且 person 小于 0 且 survivors 不为空且 survivors 列表中最后一个元素大于 0 时，执行循环\n        while (alive && person < 0 && survivors_size > 0 && survivors[survivors_size - 1] > 0) {\n            // 更新 alive 的值，判断当前 person 是否比 survivors 列表中最后一个元素的相反数大\n            alive = survivors[survivors_size - 1] < -person;\n\n            // 如果 survivors 列表中最后一个元素小于等于 person 的相反数，则移除该元素\n            if (survivors[survivors_size - 1] <= -person) {\n                person += survivors[survivors_size - 1]; // 更新 person 的战斗力\n                survivors_size--; // 移除最后一个幸存者\n            }\n        }\n\n        // 如果 alive 为 true，则将 person 添加到 survivors 列表中\n        if (alive) {\n            survivors[survivors_size++] = person;\n        }\n    }\n\n    // 返回 survivors 列表的大小\n    return survivors_size;\n}\n\nint main() {\n    char input[500000]; // 假设输入的最大长度不超过 500000 个字符\n    int people[MAX_PEOPLE];\n    int count = 0;\n\n    // 读取一行输入\n    if (fgets(input, sizeof(input), stdin) == NULL) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    // 将输入字符串分割为整数并存储在 people 数组中\n    char *token = strtok(input, \" \");\n    while (token != NULL && count < MAX_PEOPLE) {\n        people[count++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    // 如果输入的数量超过 30000，输出 -1\n    if (count > MAX_PEOPLE) {\n        printf(\"-1\\n\");\n    } else {\n        // 调用 asteroidCollision 方法，并将结果输出\n        int result = asteroidCollision(people, count);\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "137",
    "title": "观看文艺汇演问题",
    "examType": "A",
    "score": 200,
    "description": "为了庆祝中国共产党成立100周年，某公园将举行多场文艺表演，很多演出都是同时进行，一个人只能同时观看一场演出，且不能迟到早退，由于演出分布在不同的演出场地，所以连续观看的演出最少有15分钟的时间间隔，\n小明是一个狂热的文艺迷，想观看尽可能多的演出， 现给出演出时间表，请帮小明计算他最多能观看几场演出。",
    "inputDesc": "第一行为一个数 N，表示演出场数\n1 ≤ N ≤ 1000\n接下来 N 行，每行有被空格分割的整数，第一个整数 T 表示演出的开始时间，第二个整数 L 表示演出的持续时间\nT 和 L 的单位为分钟0 ≤ T ≤ 14400 < L ≤ 180",
    "outputDesc": "输出最多能观看的演出场数。",
    "examples": [
      {
        "input": "120\n 120",
        "output": "",
        "explanation": ""
      },
      {
        "input": "60\n 60",
        "output": "",
        "explanation": ""
      },
      {
        "input": "输入:\n 120\n 120",
        "output": "输入:\n 60\n 60",
        "explanation": ""
      }
    ],
    "solution": "这道题目要求我们帮小明计算他最多可以观看的文艺演出场数，给定多个演出时间表，每个演出有开始时间和持续时间，但小明有两个限制条件：\n小明不能迟到或早退，意味着他必须完整观看演出。连续观看的演出之间至少需要有 15 分钟的间隔，因为演出场地分布在不同地方，前往下一个演出场地需要时间。\n这道题本质上是一个「区间调度问题」，需要我们在多个重叠的区间中，尽可能选择最多的不冲突区间。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        // 输入演出场数\n        int n = in.nextInt();\n\n        // 创建一个列表来存储演出时间表\n        List<List<Integer>> schedule = new ArrayList<>();\n        \n        // 循环读取每个演出的开始时间和持续时间，并将其添加到演出时间表中\n        for (int i = 0; i < n; i++) {\n            int startTime = in.nextInt();\n            int endTime = startTime + in.nextInt();\n            schedule.add(List.of(startTime, endTime));\n        }\n        \n        // 将演出时间表按照结束时间进行排序\n        schedule.sort(Comparator.comparingInt(a -> a.get(1)));\n\n        // 获取第一个演出的结束时间和初始化观看的演出场数\n        int firstEndTime = schedule.get(0).get(1);\n        int numShows = 1;\n\n        // 遍历演出时间表中的每个演出时间段\n        for (List<Integer> interval : schedule) {\n            int startTime = interval.get(0);\n            int endTime = interval.get(1);\n\n            // 如果当前演出的开始时间与前一个演出的结束时间间隔大于等于15分钟，则可以观看该演出\n            if (startTime - firstEndTime >= 15) {\n                numShows++;\n                firstEndTime = endTime;\n            }\n        }\n\n        // 输出最多能观看的演出场数\n        System.out.println(numShows);\n    }\n}",
      "python": "import sys\n\n# 输入演出场数\nn = int(input())\n\n# 创建一个列表来存储演出时间表\nschedule = []\n\n# 循环读取每个演出的开始时间和持续时间，并将其添加到演出时间表中\nfor i in range(n):\n    time = input()\n    startTime = int(time.split()[0])\n    endTime = startTime + int(time.split()[1])\n    schedule.append([startTime, endTime])\n\n# 将演出时间表按照结束时间进行排序\nschedule.sort(key=lambda x: x[1])\n\n# 获取第一个演出的结束时间和初始化观看的演出场数\nfirstEndTime = schedule[0][1]\nnumShows = 1\n\n# 遍历演出时间表中的每个演出时间段\nfor interval in schedule:\n    startTime = interval[0]\n    endTime = interval[1]\n\n    # 如果当前演出的开始时间与前一个演出的结束时间间隔大于等于15分钟，则可以观看该演出\n    if startTime - firstEndTime >= 15:\n        numShows += 1\n        firstEndTime = endTime\n\n# 输出最多能观看的演出场数\nprint(numShows)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\nlet n;\n  let schedule = [];\n \n\nrl.on('line', (input) => {\n  if (!n) {\n    n = parseInt(input);\n  } else {\n    let [start, end] = input.split(' ').map(Number);\n    schedule.push([start, start + end]);\n    if (schedule.length === n) {\n          // 将演出时间表按照结束时间进行排序\n      schedule.sort((a, b) => a[1] - b[1]);\n\n      // 获取第一个演出的结束时间和初始化观看的演出场数\n      let firstEndTime = schedule[0][1];\n      let numShows = 1;\n\n      // 遍历演出时间表中的每个演出时间段\n      for (let i = 1; i < n; i++) {\n        const [startTime, endTime] = schedule[i];\n\n        // 如果当前演出的开始时间与前一个演出的结束时间间隔大于等于15分钟，则可以观看该演出\n        if (startTime - firstEndTime >= 15) {\n          numShows++;\n          firstEndTime = endTime;\n        }\n      }\n    console.log(numShows);\n    }\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    // 读取演出场次的数量\n    cin >> n;\n\n    // 定义一个二维向量，用于存储每场演出的开始时间和结束时间\n    vector<vector<int>> schedule;\n\n    // 读取每场演出的开始时间和持续时间，并计算结束时间\n    for (int i = 0; i < n; i++) {\n        int startTime, duration;\n        // 读取每场演出的开始时间和持续时间\n        cin >> startTime >> duration;\n        // 计算演出的结束时间\n        int endTime = startTime + duration;\n        // 将开始时间和结束时间存入schedule向量中\n        schedule.push_back({startTime, endTime});\n    }\n\n    // 对所有演出按照结束时间进行排序，确保优先选择结束时间较早的演出\n    sort(schedule.begin(), schedule.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    // 记录第一场选择的演出的结束时间\n    int firstEndTime = schedule[0][1];\n    // 记录小明可以观看的演出场次，初始为1（选择了第一场）\n    int numShows = 1;\n\n    // 遍历每一场演出，判断能否在当前时间后观看\n    for (const vector<int>& interval : schedule) {\n        int startTime = interval[0];  // 当前演出的开始时间\n        int endTime = interval[1];    // 当前演出的结束时间\n\n        // 如果当前演出的开始时间与上一个观看的演出结束时间之间有至少15分钟的间隔\n        if (startTime - firstEndTime >= 15) {\n            numShows++;  // 小明可以观看这场演出，增加计数\n            firstEndTime = endTime;  // 更新为当前演出的结束时间，作为下次判断的依据\n        }\n    }\n\n    // 输出小明最多可以观看的演出场次\n    cout << numShows << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 1000\n\n// 定义一个结构体，用于存储每场演出的开始时间和结束时间\ntypedef struct {\n    int startTime;  // 演出的开始时间\n    int endTime;    // 演出的结束时间\n} Show;\n\n// 比较函数，用于qsort对演出按结束时间进行排序\nint compare(const void *a, const void *b) {\n    Show *showA = (Show *)a;\n    Show *showB = (Show *)b;\n    return showA->endTime - showB->endTime;  // 按结束时间升序排列\n}\n\nint main() {\n    int n;\n    // 读取演出场次的数量\n    scanf(\"%d\", &n);\n\n    // 定义一个数组，用于存储每场演出的开始时间和结束时间\n    Show schedule[MAX_N];\n\n    // 读取每场演出的开始时间和持续时间，并计算结束时间\n    for (int i = 0; i < n; i++) {\n        int startTime, duration;\n        // 读取每场演出的开始时间和持续时间\n        scanf(\"%d %d\", &startTime, &duration);\n        // 计算演出的结束时间，并存储在结构体数组中\n        schedule[i].startTime = startTime;\n        schedule[i].endTime = startTime + duration;\n    }\n\n    // 使用qsort函数对所有演出按照结束时间进行排序\n    qsort(schedule, n, sizeof(Show), compare);\n\n    // 记录第一场选择的演出的结束时间\n    int firstEndTime = schedule[0].endTime;\n    // 记录小明可以观看的演出场次，初始为1（选择了第一场）\n    int numShows = 1;\n\n    // 遍历剩下的每一场演出，判断能否在当前时间后观看\n    for (int i = 1; i < n; i++) {\n        int startTime = schedule[i].startTime;  // 当前演出的开始时间\n        int endTime = schedule[i].endTime;      // 当前演出的结束时间\n\n        // 如果当前演出的开始时间与上一个观看的演出结束时间之间有至少15分钟的间隔\n        if (startTime - firstEndTime >= 15) {\n            numShows++;  // 小明可以观看这场演出，增加计数\n            firstEndTime = endTime;  // 更新为当前演出的结束时间，作为下次判断的依据\n        }\n    }\n\n    // 输出小明最多可以观看的演出场次\n    printf(\"%d\\n\", numShows);\n\n    return 0;\n}"
    }
  },
  {
    "id": "138",
    "title": "解压报文压缩报文还原",
    "examType": "A",
    "score": 200,
    "description": "为了提升数据传输的效率，会对传输的报文进行压缩处理。\n输入一个压缩后的报文，请返回它解压后的原始报文。\n压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。\n注意 n 为正整数（0 < n <= 100），str只包含小写英文字母，不考虑异常情况。",
    "inputDesc": "输入压缩后的报文：\n1）不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的；\n2）原始报文不包含数字，所有的数字只表示重复的次数 n ，例如不会出现像 5b 或 3[8] 的输入；",
    "outputDesc": "解压后的原始报文\n注：原始报文长度不会超过1000，不考虑异常的情况",
    "examples": [
      {
        "input": "[k]2[mn]",
        "output": "kkkmnmn",
        "explanation": "k 重复3次，mn 重复2次，最终得到 kkkmnmn"
      },
      {
        "input": "[m2[c]]",
        "output": "mccmccmcc",
        "explanation": "m2[c] 解压缩后为 mcc，重复三次为 mccmccmcc"
      }
    ],
    "solution": "压缩报文的格式为：n[str]，其中 n 是一个表示重复次数的正整数，str 是需要重复的字符串部分，且 str 只包含小写字母。题目要求我们将这种格式的报文解压，得到原始报文。\n报文中的 n[str] 表示 str 字符串需要重复 n 次。例如： 3[k] 表示字符串 k 需要重复 3 次，解压后为 kkk。2[mn] 表示字符串 mn 需要重复 2 次，解压后为 mnmn。\n3[k] 表示字符串 k 需要重复 3 次，解压后为 kkk。2[mn] 表示字符串 mn 需要重复 2 次，解压后为 mnmn。\n栈的使用：这是一个经典的用栈解决的题目。我们可以用栈来处理嵌套的结构，比如 n[str] 这样的结构，先解压括号内部的内容，然后再处理外部的结构。 主要步骤： 遍历字符串，如果遇到数字（表示重复次数 n），将数字读取出来。遇到 [ 时，开始记录括号内的字符串，直到遇到对应的 ]，此时将前面的字符串部分和数字进行拼接。将结果拼接到最终的解压字符串中。\n栈的使用：这是一个经典的用栈解决的题目。我们可以用栈来处理嵌套的结构，比如 n[str] 这样的结构，先解压括号内部的内容，然后再处理外部的结构。\n主要步骤：\n遍历字符串，如果遇到数字（表示重复次数 n），将数字读取出来。遇到 [ 时，开始记录括号内的字符串，直到遇到对应的 ]，此时将前面的字符串部分和数字进行拼接。将结果拼接到最终的解压字符串中。",
    "codes": {
      "java": "import java.util.Scanner;\nimport java.util.Stack;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String compressed_string = scanner.next();\n\n        Stack<List<String>> stack = new Stack<>();\n        stack.push(new ArrayList<>(List.of(\"\", \"1\", \"\"))); // 使用栈来存储解压后的字符串和重复次数\n\n        String current_str = \"\"; // 当前字符\n        String current_num = \"\"; // 当前重复次数\n\n        for (char c : compressed_string.toCharArray()) {\n            if (Character.isLetter(c)) { // 如果是字母\n                current_str += c;\n            } else if (Character.isDigit(c)) { // 如果是数字\n                current_num += c;\n            } else if (c == '[') { // 如果是左括号\n                stack.push(new ArrayList<>(List.of(current_str, current_num, \"\"))); // 将当前字符和重复次数入栈\n                current_str = current_num = \"\"; // 重置当前字符和重复次数\n            } else { // 如果是右括号\n                List<String> prev = stack.pop();\n                String prev_str = prev.get(0);\n                int times = Integer.parseInt(prev.get(1));\n                String prev_result = prev.get(2);\n\n                String repeated_str = \"\";\n                for (int i = 0; i < times; i++) {\n                    repeated_str += prev_result + current_str;\n                }\n\n                stack.peek().set(2, stack.peek().get(2) + prev_str + repeated_str); // 更新栈顶元素的结果\n                current_str = \"\"; // 重置当前字符\n            }\n        }\n\n        String result = stack.peek().get(2) + current_str; // 返回最终的结果\n        System.out.println(result);\n    }\n}",
      "python": "compressed_string = input()\nstack = [['', 1, '']]  # 使用栈来存储解压后的字符串和重复次数\ncurrent_str = ''  # 当前字符\ncurrent_num = ''  # 当前重复次数\nfor c in compressed_string:\n    if c.isalpha():  # 如果是字母\n        current_str += c\n    elif c.isdigit():  # 如果是数字\n        current_num += c\n    elif c == '[':  # 如果是左括号\n        stack.append([current_str, int(current_num), ''])  # 将当前字符和重复次数入栈\n        current_str = current_num = ''  # 重置当前字符和重复次数\n    else:  # 如果是右括号\n        prev_str, times, prev_result = stack.pop()  # 弹出栈顶元素\n        stack[-1][-1] += prev_str + times * (prev_result + current_str)  # 更新栈顶元素的结果\n        current_str = ''  # 重置当前字符\nresult = stack.pop()[-1] + current_str  # 返回最终的结果\nprint(result)",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet compressed_string = \"\";\n\nrl.on(\"line\", (input) => {\n  compressed_string = input;\n\n  const stack = [];\n  stack.push([\"\", \"1\", \"\"]); // 使用数组来模拟栈，存储解压后的字符串和重复次数\n\n  let current_str = \"\"; // 当前字符\n  let current_num = \"\"; // 当前重复次数\n\n  for (const c of compressed_string) {\n    if (/[a-zA-Z]/.test(c)) { // 如果是字母\n      current_str += c;\n    } else if (/[0-9]/.test(c)) { // 如果是数字\n      current_num += c;\n    } else if (c === '[') { // 如果是左括号\n      stack.push([current_str, current_num, \"\"]); // 将当前字符和重复次数入栈\n      current_str = current_num = \"\"; // 重置当前字符和重复次数\n    } else { // 如果是右括号\n      const prev = stack.pop();\n      const prev_str = prev[0];\n      const times = parseInt(prev[1]);\n      const prev_result = prev[2];\n\n      let repeated_str = \"\";\n      for (let i = 0; i < times; i++) {\n        repeated_str += prev_result + current_str;\n      }\n\n      stack[stack.length - 1][2] += prev_str + repeated_str; // 更新栈顶元素的结果\n      current_str = \"\"; // 重置当前字符\n    }\n  }\n\n  const result = stack[stack.length - 1][2] + current_str; // 返回最终的结果\n  console.log(result);\n\n  rl.close();\n});",
      "cpp": "#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\n\nint main() {\n    std::string compressed_string;\n    std::cin >> compressed_string;\n\n    std::stack<std::vector<std::string>> stack;\n    stack.push({\"\", \"1\", \"\"}); // 使用栈来存储解压后的字符串和重复次数\n\n    std::string current_str = \"\"; // 当前字符\n    std::string current_num = \"\"; // 当前重复次数\n\n    for (char c : compressed_string) {\n        if (isalpha(c)) { // 如果是字母\n            current_str += c;\n        } else if (isdigit(c)) { // 如果是数字\n            current_num += c;\n        } else if (c == '[') { // 如果是左括号\n            stack.push({current_str, current_num, \"\"}); // 将当前字符和重复次数入栈\n            current_str = current_num = \"\"; // 重置当前字符和重复次数\n        } else { // 如果是右括号\n            std::vector<std::string> prev = stack.top();\n            stack.pop();\n            std::string prev_str = prev[0];\n            int times = std::stoi(prev[1]);\n            std::string prev_result = prev[2];\n\n            std::string repeated_str = \"\";\n            for (int i = 0; i < times; i++) {\n                repeated_str += prev_result + current_str;\n            }\n\n            stack.top()[2] += prev_str + repeated_str; // 更新栈顶元素的结果\n            current_str = \"\"; // 重置当前字符\n        }\n    }\n\n    std::string result = stack.top()[2] + current_str; // 返回最终的结果\n    std::cout << result << std::endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX 1000 // 栈的最大长度\n#define MAX_STR_LEN 1000 // 每个字符串的最大长度\n\n// 模拟栈的结构\ntypedef struct {\n    char str[MAX][MAX_STR_LEN]; // 字符串\n    int num[MAX];               // 重复次数\n    char result[MAX][MAX_STR_LEN]; // 解压后的字符串\n    int top;                    // 栈顶指针\n} Stack;\n\n// 初始化栈\nvoid initStack(Stack *stack) {\n    stack->top = -1;\n}\n\n// 压栈\nvoid push(Stack *stack, const char *str, const char *num, const char *result) {\n    if (stack->top + 1 < MAX) {\n        stack->top++;\n        strcpy(stack->str[stack->top], str);\n        stack->num[stack->top] = atoi(num); // 将字符串数字转换为整数\n        strcpy(stack->result[stack->top], result);\n    }\n}\n\n// 出栈\nvoid pop(Stack *stack, char *str, int *num, char *result) {\n    if (stack->top >= 0) {\n        strcpy(str, stack->str[stack->top]);\n        *num = stack->num[stack->top];\n        strcpy(result, stack->result[stack->top]);\n        stack->top--;\n    }\n}\n\nint main() {\n    char compressed_string[MAX_STR_LEN];\n \n    scanf(\"%s\", compressed_string);\n\n    Stack stack;\n    initStack(&stack);\n    push(&stack, \"\", \"1\", \"\"); // 初始化栈，使用空字符串和默认重复次数1\n\n    char current_str[MAX_STR_LEN] = \"\"; // 当前的解压字符串\n    char current_num[MAX_STR_LEN] = \"\"; // 当前的重复次数\n\n    for (int i = 0; i < strlen(compressed_string); i++) {\n        char c = compressed_string[i];\n\n        if (isalpha(c)) { // 如果是字母\n            int len = strlen(current_str);\n            current_str[len] = c;\n            current_str[len + 1] = '\\0';\n        } else if (isdigit(c)) { // 如果是数字\n            int len = strlen(current_num);\n            current_num[len] = c;\n            current_num[len + 1] = '\\0';\n        } else if (c == '[') { // 如果是左括号\n            push(&stack, current_str, current_num, \"\"); // 将当前字符串和重复次数压栈\n            strcpy(current_str, \"\"); // 重置当前字符串\n            strcpy(current_num, \"\"); // 重置当前次数\n        } else if (c == ']') { // 如果是右括号\n            char prev_str[MAX_STR_LEN];\n            int times;\n            char prev_result[MAX_STR_LEN];\n\n            pop(&stack, prev_str, &times, prev_result); // 弹出栈顶元素\n\n            char repeated_str[MAX_STR_LEN] = \"\";\n            for (int j = 0; j < times; j++) { // 根据次数生成重复的字符串\n                strcat(repeated_str, prev_result);\n                strcat(repeated_str, current_str);\n            }\n\n            strcpy(current_str, prev_str); // 拼接上先前的字符串\n            strcat(current_str, repeated_str); // 拼接重复的结果\n        }\n    }\n\n    printf(\"%s\\n\", current_str);\n\n    return 0;\n}"
    }
  },
  {
    "id": "139",
    "title": "计算网络信号信号强度",
    "examType": "A",
    "score": 200,
    "description": "网络信号经过传递会逐层衰减，且遇到阻隔物无法直接穿透，在此情况下需要计算某个位置的网络信号值。 注意:网络信号可以绕过阻隔物。\narray[m][n] 的二维数组代表网格地图，array[i][j] = 0代表i行j列是空旷位置;array[i][j] = x(x为正整数)代表i行j列是信号源，信号强度是x;array[i][j] = -1代表i行j列是阻隔物。信号源只有1个，阻隔物可能有0个或多个网络信号衰减是上下左右相邻的网格衰减1\n现要求输出对应位置的网络信号值。",
    "inputDesc": "输入为三行，\n第一行为 m 、n ，代表输入是一个 m × n 的数组。第二行是一串 m × n 个用空格分隔的整数。每连续 n 个数代表一行，再往后 n 个代表下一行，以此类推。对应的值代表对应的网格是空旷位置，还是信号源，还是阻隔物。第三行是 i 、 j，代表需要计算array[i][j]的网络信号值。\n注意：此处 i 和 j 均从 0 开始，即第一行 i 为 0。\n123\n代表如下地图\n\n需要输出第1行第4列的网络信号值，值为2。\n",
    "outputDesc": "输出对应位置的网络信号值，如果网络信号未覆盖到，也输出0。\n一个网格如果可以途径不同的传播衰减路径传达，取较大的值作为其信号值。",
    "examples": [
      {
        "input": "5\n 0 0 -1 0 0 0 0 0 0 0 0 -1 4 0 0 0 0 0 0 0 0 0 0 -1 0 0 0 0 0\n 4",
        "output": "",
        "explanation": ""
      },
      {
        "input": "5\n 0 0 -1 0 0 0 0 0 0 0 0 -1 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\n 1",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "在用例1中。有一个信号源：\n需要求的是（1，4）位置的强度，请注意行列是从0开始的。\n\n根据衰减原理，最后的结果是2\n这道题可以使用广度优先搜索（BFS）来解决。我们可以先找到信号源的位置，将其加入队列中，然后不断从队列中取出位置，向四个方向传播信号，如果某个位置的信号强度为 0，则说明可以传播到该位置，将其加入队列，并将其信号强度设为当前位置的信号强度减 1。当某个位置的信号强度为 1 时，说明不需要再传播了，后面的位置肯定都是 0。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n\n        // 创建一个大小为 rows*cols 的数组，存储矩阵中每个位置的信号强度\n        int[] signalStrength = new int[rows * cols];\n        // 创建一个队列，存储所有信号源的位置\n        Queue<int[]> sourcePositions = new LinkedList<>();\n\n        // 读入矩阵并找到信号源位置\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                signalStrength[i * cols + j] = scanner.nextInt();\n                // 如果该位置的信号强度大于 0，说明这是一个信号源的位置，将其加入队列\n                if (signalStrength[i * cols + j] > 0) {\n                    sourcePositions.offer(new int[]{i, j});\n                }\n            }\n        }\n\n        // 广度优先搜索传播信号\n        while (!sourcePositions.isEmpty()) {\n            // 取出队列头部的位置\n            int[] pos = sourcePositions.poll();\n            int i = pos[0], j = pos[1];\n\n            // 如果信号强度为1，则不需要再传播了，后面肯定都是0\n            if (signalStrength[i * cols + j] == 1) {\n                break;\n            }\n\n            // 信号可以上下左右传播，存储四个方向的偏移量\n            int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n            // 遍历四个方向\n            for (int[] direction : directions) {\n                // 计算新位置的坐标\n                int newI = i + direction[0], newJ = j + direction[1];\n                // 如果新位置在矩阵范围内，且该位置的信号强度为0，说明可以传播到该位置\n                if (newI >= 0 && newI < rows && newJ >= 0 && newJ < cols && signalStrength[newI * cols + newJ] == 0) {\n                    // 将该位置的信号强度设为当前位置的信号强度减1，并将其加入队列\n                    signalStrength[newI * cols + newJ] = signalStrength[i * cols + j] - 1;\n                    sourcePositions.offer(new int[]{newI, newJ});\n                }\n            }\n        }\n\n        // 输出目标位置的信号强度\n        int targetRow = scanner.nextInt(), targetCol = scanner.nextInt();\n        System.out.println(signalStrength[targetRow * cols + targetCol]);\n    }\n}",
      "python": "# 输入获取，读入网格地图大小、地图数据和目标位置\nnum_rows, num_cols = map(int, input().split())\ngrid_map = list(map(int, input().split()))\ntarget_pos = list(map(int, input().split()))\n\n# 算法入口\ndef get_signal_strength(map_array, num_rows, num_cols, target_pos):\n    # 初始化队列，将所有信号源位置加入队列\n    queue = [[i, j] for j in range(num_cols) for i in range(num_rows) if map_array[i*num_cols+j] > 0]\n    # 定义四个方向偏移量\n    directions = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    # 广度优先搜索\n    while queue:\n        new_queue = []\n        for i, j in queue:\n            signal_strength = map_array[i*num_cols+j] - 1  # 计算信号强度\n            for dx, dy in directions:\n                new_i, new_j = i+dx, j+dy  # 计算新位置\n                if 0 <= new_i < num_rows and 0 <= new_j < num_cols and map_array[new_i*num_cols+new_j] == 0:\n                    # 如果新位置在地图内且为空旷位置，则更新该位置信号强度并将其加入队列\n                    map_array[new_i*num_cols+new_j] = signal_strength\n                    new_queue.append([new_i, new_j])\n        queue = new_queue\n        \n    # 返回目标位置的信号强度（如果未被覆盖到则返回0）\n    target_row, target_col = target_pos\n    return max(0, map_array[target_row*num_cols+target_col])\n\n# 算法调用，输出结果\nprint(get_signal_strength(grid_map, num_rows, num_cols, target_pos))",
      "javascript": "// 创建 readline 接口\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet m, n;\nlet matrix = []; // 保存输入的二维数组\nlet posQueue = []; // 保存信号源的位置\n\n// 监听命令行输入\nrl.on('line', (line) => {\n    if (!m) { // 第一行为矩阵行列数\n        [m, n] = line.trim().split(' ').map(Number);\n    } else if (matrix.length < m * n) { // 保存输入的二维数组\n        matrix.push(...line.trim().split(' ').map(Number));\n        if (matrix.length === m * n) { // 找出所有信号源的位置\n            for (let i = 0; i < m; i++) {\n                for (let j = 0; j < n; j++) {\n                    if (matrix[i * n + j] > 0) {\n                        posQueue.push([i, j]);\n                    }\n                }\n            }\n        }\n    } else { // 处理需要计算的位置\n        const [target_i, target_j] = line.trim().split(' ').map(Number);\n        while (posQueue.length > 0) { // 广度优先搜索信号源的传播路径\n            const [i, j] = posQueue.shift();\n            if (matrix[i * n + j] === 1) { // 当前是信号源，不再向外扩散\n                break;\n            }\n            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 四个方向\n            for (const [dx, dy] of directions) { // 向四个方向扩散\n                const new_i = i + dx, new_j = j + dy;\n                if (new_i >= 0 && new_i < m && new_j >= 0 && new_j < n && matrix[new_i * n + new_j] === 0) { // 可以传播到该位置\n                    matrix[new_i * n + new_j] = matrix[i * n + j] - 1; // 计算信号值\n                    posQueue.push([new_i, new_j]); // 将该位置加入队列\n                }\n            }\n        }\n        console.log(matrix[target_i * n + target_j]); // 输出目标位置的信号值\n        rl.close(); // 关闭 readline 接口\n    }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n\n    // 创建一个大小为 rows*cols 的 vector，存储矩阵中每个位置的信号强度\n    vector<int> signal_strength(rows * cols);\n    // 创建一个队列，存储所有信号源的位置\n    queue<pair<int, int>> source_positions;\n\n    // 读入矩阵并找到信号源位置\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cin >> signal_strength[i * cols + j];\n            // 如果该位置的信号强度大于 0，说明这是一个信号源的位置，将其加入队列\n            if (signal_strength[i * cols + j] > 0) {\n                source_positions.push({i, j});\n            }\n        }\n    }\n\n    // 广度优先搜索传播信号\n    while (!source_positions.empty()) {\n        // 取出队列头部的位置\n        auto [i, j] = source_positions.front();\n        source_positions.pop();\n\n        // 如果信号强度为1，则不需要再传播了，后面肯定都是0\n        if (signal_strength[i * cols + j] == 1) {\n            break;\n        }\n\n        // 信号可以上下左右传播，存储四个方向的偏移量\n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        // 遍历四个方向\n        for (auto [dx, dy] : directions) {\n            // 计算新位置的坐标\n            int new_i = i + dx, new_j = j + dy;\n            // 如果新位置在矩阵范围内，且该位置的信号强度为0，说明可以传播到该位置\n            if (new_i >= 0 && new_i < rows && new_j >= 0 && new_j < cols && signal_strength[new_i * cols + new_j] == 0) {\n                // 将该位置的信号强度设为当前位置的信号强度减1，并将其加入队列\n                signal_strength[new_i * cols + new_j] = signal_strength[i * cols + j] - 1;\n                source_positions.push({new_i, new_j});\n            }\n        }\n    }\n\n    // 输出目标位置的信号强度\n    int target_row, target_col;\n    cin >> target_row >> target_col;\n    cout << signal_strength[target_row * cols + target_col] << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int m, n;\n\n    // 读取矩阵的行数和列数\n    scanf(\"%d %d\", &m, &n);\n\n    // 创建一个大小为 m*n 的数组，用于存储矩阵的信号强度\n    int *matrix = (int *)malloc(m * n * sizeof(int));\n    \n    // 创建两个数组来充当队列，分别存储信号源的行坐标和列坐标\n    int *queueX = (int *)malloc(m * n * sizeof(int));\n    int *queueY = (int *)malloc(m * n * sizeof(int));\n    int front = 0, rear = 0;  // 队列的头和尾索引\n\n    // 读入矩阵并找到所有信号源的位置\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &matrix[i * n + j]);\n            // 如果该位置的信号强度大于 0，说明这是一个信号源，将其加入队列\n            if (matrix[i * n + j] > 0) {\n                queueX[rear] = i;  // 存储行坐标\n                queueY[rear] = j;  // 存储列坐标\n                rear++;  // 队尾后移\n            }\n        }\n    }\n\n    // 读取目标位置\n    int target_i, target_j;\n    scanf(\"%d %d\", &target_i, &target_j);\n\n    // 广度优先搜索（BFS）传播信号\n    while (front < rear) {  // 当队列不为空时\n        int i = queueX[front];\n        int j = queueY[front];\n        front++;  // 队头前移\n\n        // 如果当前位置的信号强度为1，则不再向外扩散\n        if (matrix[i * n + j] == 1) {\n            continue;\n        }\n\n        // 信号可以向上下左右传播，定义四个方向的偏移量\n        int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        // 遍历四个方向，检查信号传播的可能性\n        for (int d = 0; d < 4; d++) {\n            int new_i = i + directions[d][0];\n            int new_j = j + directions[d][1];\n\n            // 检查新位置是否在矩阵范围内，并且信号强度为0，说明可以传播到该位置\n            if (new_i >= 0 && new_i < m && new_j >= 0 && new_j < n && matrix[new_i * n + new_j] == 0) {\n                // 将该位置的信号强度设为当前位置的信号强度减1，并将其加入队列\n                matrix[new_i * n + new_j] = matrix[i * n + j] - 1;\n                queueX[rear] = new_i;\n                queueY[rear] = new_j;\n                rear++;  // 队尾后移\n            }\n        }\n    }\n\n    // 输出目标位置的信号强度\n    printf(\"%d\\n\", matrix[target_i * n + target_j]);\n\n    // 释放动态分配的内存\n    free(matrix);\n    free(queueX);\n    free(queueY);\n\n    return 0;\n}"
    }
  },
  {
    "id": "140",
    "title": "跳房子I",
    "examType": "A",
    "score": 200,
    "description": "跳房子，也叫跳飞机，是一种世界性的儿童游戏。\n游戏参与者需要分多个回合按顺序跳到第1格直到房子的最后一格。\n跳房子的过程中，可以向前跳，也可以向后跳。\n假设房子的总格数是count，小红每回合可能连续跳的步教都放在数组steps中，请问数组中是否有一种步数的组合，可以让小红两个回合跳到量后一格?\n如果有，请输出索引和最小的步数组合。\n注意：\n数组中的步数可以重复，但数组中的元素不能重复使用。提供的数据保证存在满足题目要求的组合，且索引和最小的步数组合是唯一的。",
    "inputDesc": "第一行输入为每回合可能连续跳的步数，它是int整数数组类型。\n第二行输入为房子总格数count，它是int整数类型。\ncount ≤ 10000 ≤ steps.length ≤ 5000-100000000 ≤ steps ≤ 100000000",
    "outputDesc": "返回索引和最小的满足要求的步数组合（顺序保持steps中原有顺序）",
    "examples": [
      {
        "input": "[1,4,5,2,2]",
        "output": "[5, 2]",
        "explanation": ""
      },
      {
        "input": "[-1,2,4,9,6]",
        "output": "[-1, 9]",
        "explanation": "此样例有多种组合满足两回合跳到最后，譬如：[-1,9]，[2,6]，其中[-1,9]的索引和为0+3=3，[2,6]的索和为1+4=5，所以索引和最小的步数组合[-1,9]"
      }
    ],
    "solution": "这道题目要求从一个给定的步数数组中找到一个步数组合，使得小红能够通过两次跳跃从第1格跳到第count格，并且这个组合在原数组中的索引和是最小的。输出是该步数组合中的两个步数，顺序保持与steps数组中的顺序一致。\n再说的明白一点，在steps数组中选两个数，使其之和等于count，并且这两个数在原数组中的索引和是最小的\n与下面这题基本一致：\nhttps://leetcode.cn/problems/two-sum/description/",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建Scanner对象用于读取输入\n        Scanner sc = new Scanner(System.in);\n\n        // 读取一行输入，将其转换为int数组steps\n        String tmp = sc.nextLine();\n        int[] steps =\n                Arrays.stream(tmp.substring(1, tmp.length() - 1).split(\",\"))\n                        .mapToInt(Integer::parseInt)\n                        .toArray();\n\n        // 读取房子总格数count\n        int count = Integer.parseInt(sc.nextLine());\n\n        // 初始化最小索引和为最大整数值\n        int minIdxSum = Integer.MAX_VALUE;\n        // 初始化答案为空字符串\n        String ans = \"\";\n\n        // 使用两层循环遍历数组中的所有可能的组合\n        for (int idx1 = 0; idx1 < steps.length; idx1++) {\n            for (int idx2 = idx1 + 1; idx2 < steps.length; idx2++) {\n                // 获取两个步数\n                int step1 = steps[idx1];\n                int step2 = steps[idx2];\n\n                // 如果两个步数之和等于count\n                if (step1 + step2 == count) {\n                    // 计算当前组合的索引和\n                    int idxSum = idx1 + idx2;\n                    // 如果当前组合的索引和小于已找到的最小索引和\n                    if (idxSum < minIdxSum) {\n                        // 更新最小索引和\n                        minIdxSum = idxSum;\n                        // 更新答案\n                        ans = \"[\" + step1 + \", \" + step2 + \"]\";\n                    }\n                    // 找到满足条件的组合后，跳出内层循环\n                    break;\n                }\n            }\n        }\n\n        // 输出结果\n        System.out.println(ans);\n    }\n}",
      "python": "def main():\n    # 读取一行输入，将其转换为 int 列表 steps\n    steps = list(map(int, input()[1:-1].split(',')))\n\n    # 读取房子总格数 count\n    count = int(input())\n\n    # 初始化最小索引和为最大整数值\n    min_idx_sum = float('inf')\n    # 初始化答案为空字符串\n    ans = \"\"\n\n    # 使用两层循环遍历数组中的所有可能的组合\n    for idx1 in range(len(steps)):\n        for idx2 in range(idx1 + 1, len(steps)):\n            # 获取两个步数\n            step1 = steps[idx1]\n            step2 = steps[idx2]\n\n            # 如果两个步数之和等于 count\n            if step1 + step2 == count:\n                # 计算当前组合的索引和\n                idx_sum = idx1 + idx2\n                # 如果当前组合的索引和小于已找到的最小索引和\n                if idx_sum < min_idx_sum:\n                    # 更新最小索引和\n                    min_idx_sum = idx_sum\n                    # 更新答案\n                    ans = [step1, step2]\n                # 找到满足条件的组合后，跳出内层循环\n                break\n\n    # 输出结果\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst inputLines = [];\n\n// 读取输入行\nrl.on('line', (line) => {\n  inputLines.push(line);\n  if (inputLines.length === 2) {\n    rl.close();\n  }\n});\n\nrl.on('close', () => {\n  // 解析输入的步数数组和房子总格数\n  const steps = JSON.parse(inputLines[0]);\n  const count = parseInt(inputLines[1], 10);\n\n  let minIdxSum = Number.MAX_VALUE;\n  let ans = '';\n\n  // 遍历数组中的所有可能的组合\n  for (let idx1 = 0; idx1 < steps.length; idx1++) {\n    for (let idx2 = idx1 + 1; idx2 < steps.length; idx2++) {\n      const step1 = steps[idx1];\n      const step2 = steps[idx2];\n\n      // 如果两个步数之和等于房子总格数\n      if (step1 + step2 === count) {\n        const idxSum = idx1 + idx2;\n        // 如果当前组合的索引和小于已找到的最小索引和\n        if (idxSum < minIdxSum) {\n          // 更新最小索引和\n          minIdxSum = idxSum;\n          // 更新答案\n          ans = `[${step1}, ${step2}]`;\n        }\n        // 找到满足条件的组合后，跳出内层循环\n        break;\n      }\n    }\n  }\n\n  // 输出结果\n  console.log(ans);\n});",
      "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <limits>\n#include <algorithm>\nusing namespace std;\nint main() {\n    // 读取一行输入，将其转换为 int 数组 steps\n    string tmp;\n    getline(cin, tmp);\n    tmp = tmp.substr(1, tmp.length() - 2);\n    istringstream iss(tmp);\n    vector<int> steps;\n    string token;\n    while (getline(iss, token, ',')) {\n        steps.push_back(stoi(token));\n    }\n\n    // 读取房子总格数 count\n    int count;\n    cin >> count;\n\n    // 初始化最小索引和为最大整数值\n    int minIdxSum = numeric_limits<int>::max();\n    // 初始化答案为空字符串\n    string ans = \"\";\n\n    // 使用两层循环遍历数组中的所有可能的组合\n    for (size_t idx1 = 0; idx1 < steps.size(); idx1++) {\n        for (size_t idx2 = idx1 + 1; idx2 < steps.size(); idx2++) {\n            // 获取两个步数\n            int step1 = steps[idx1];\n            int step2 = steps[idx2];\n\n            // 如果两个步数之和等于 count\n            if (step1 + step2 == count) {\n                // 计算当前组合的索引和\n                int idxSum = static_cast<int>(idx1 + idx2);\n                // 如果当前组合的索引和小于已找到的最小索引和\n                if (idxSum < minIdxSum) {\n                    // 更新最小索引和\n                    minIdxSum = idxSum;\n                    // 更新答案\n                    ans = \"[\" + to_string(step1) + \", \" + to_string(step2) + \"]\";\n                }\n                // 找到满足条件的组合后，跳出内层循环\n                break;\n            }\n        }\n    }\n\n    // 输出结果\n    cout << ans << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nint main() {\n    // 定义一个字符数组用于存储输入的步数\n    char tmp[10000];\n    \n    // 读取一行输入，将其存储在tmp中\n    fgets(tmp, 10000, stdin);\n\n    // 去掉首尾的方括号，并通过逗号分隔输入，转换为整数数组steps\n    int steps[5000];  // 假设步数的最大长度不会超过5000\n    int stepCount = 0; // 实际步数的数量\n    char *token = strtok(tmp + 1, \",\"); // 从第二个字符开始（跳过左方括号）\n    while (token != NULL && *token != ']') {\n        steps[stepCount++] = atoi(token); // 将分割出的每个字符串转换为整数并存入steps数组\n        token = strtok(NULL, \",\");\n    }\n\n    // 读取房子总格数count\n    int count;\n    scanf(\"%d\", &count);\n\n    // 初始化最小索引和为最大整数值\n    int minIdxSum = INT_MAX;\n    // 初始化答案为两个步数的值\n    int ans1 = 0, ans2 = 0;\n\n    // 使用两层循环遍历数组中的所有可能的组合\n    for (int idx1 = 0; idx1 < stepCount; idx1++) {\n        for (int idx2 = idx1 + 1; idx2 < stepCount; idx2++) {\n            // 获取两个步数\n            int step1 = steps[idx1];\n            int step2 = steps[idx2];\n\n            // 如果两个步数之和等于count\n            if (step1 + step2 == count) {\n                // 计算当前组合的索引和\n                int idxSum = idx1 + idx2;\n                // 如果当前组合的索引和小于已找到的最小索引和\n                if (idxSum < minIdxSum) {\n                    // 更新最小索引和\n                    minIdxSum = idxSum;\n                    // 更新答案步数\n                    ans1 = step1;\n                    ans2 = step2;\n                }\n                // 找到满足条件的组合后，跳出内层循环\n                break;\n            }\n        }\n    }\n\n    // 输出结果，格式为\"[step1, step2]\"\n    printf(\"[%d, %d]\\n\", ans1, ans2);\n\n    return 0;\n}"
    }
  },
  {
    "id": "141",
    "title": "跳格子3",
    "examType": "A",
    "score": 200,
    "description": "小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数 score = [1, -1, -6, 7, -17, 7]，\n从起点score[0]开始，每次最大的步长为k，请你返回小明跳到终点 score[n-1] 时，能得到的最大得分。",
    "inputDesc": "第一行输入总的格子数量 n\n第二行输入每个格子的分数 score[i]\n第三行输入最大跳的步长 k\n格子的总长度 n 和步长 k 的区间在 [1, 100000] 每个格子的分数 score[i] 在 [-10000, 10000] 区间中\n格子的总长度 n 和步长 k 的区间在 [1, 100000]\n每个格子的分数 score[i] 在 [-10000, 10000] 区间中",
    "outputDesc": "输出最大得分",
    "examples": [
      {
        "input": "-1 -6 7 -17 7",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "在给定的跳格子游戏中，我们使用动态规划方法来计算每个格子可能达到的最大得分。动态规划的核心在于解决子问题并利用这些子问题的解来解决整个问题。\n设 dp[i] 表示到达第 i 个格子时能得到的最大分数，则 dp[i] 可以通过以下方式计算：\n1\n这里，max(0, i-k) 到 i-1 表示从当前位置 i 往回看，最远可以从 i-k 跳到 i。如果 k 大于 i，则从 0 开始。换句话说，dp[i] 是当前格子的分数加上能跳到这个格子的最大分数。\n因为 ( k ) 可能非常大，直接计算每个 ( dp[i] ) 需要 ( O(k) ) 的时间复杂度，总的时间复杂度是 ( O(nk) )，这可能非常耗时。为了优化这一过程，我们使用一个双端队列来维护 ( dp ) 值的索引，并且保持队列中的 ( dp ) 值是单调递减的，这样队列的首元素始终是最大值。\n通过这种方法，每个元素最多只被队列添加和删除各一次，因此更新 ( dp ) 数组的过程的时间复杂度降低到 ( O(n) )。",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args)  {\n        Scanner sc = new Scanner(System.in);\n \n        int n = Integer.parseInt(sc.nextLine());\n        int[] scores = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int k = Integer.parseInt(sc.nextLine());\n    \n\n        // 特殊情况处理：如果格子数量为1，直接输出该格子的分数\n        if (n == 1) {\n            System.out.println(scores[0]);\n            return;\n        }\n\n        // 动态规划数组，dp[i]存储到达第i个格子时能得到的最大分数\n        int[] dp = new int[n];\n        dp[0] = scores[0]; // 初始化，起点的最大分数就是起点的分数\n\n        // 使用双端队列来维护窗口内的最大dp值的索引\n        Deque<Integer> deque = new LinkedList<>();\n        deque.add(0);\n\n        for (int i = 1; i < n; i++) {\n            // 如果队列不为空且队列头部的索引已经超出了跳跃范围，从队列中移除头部\n            if (!deque.isEmpty() && deque.peekFirst() < i - k) {\n                deque.pollFirst();\n            }\n\n            // 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n            dp[i] = scores[i] + (deque.isEmpty() ? 0 : dp[deque.peekFirst()]);\n\n            // 维护队列，保持队列为递减，新的最大值需要添加到队尾\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n                deque.pollLast();\n            }\n\n            // 将当前索引加到队列尾部\n            deque.addLast(i);\n        }\n\n        // 输出到达最后一个格子时能得到的最大分数\n        System.out.println(dp[n - 1]);\n    }\n}",
      "python": "from collections import deque\n\nn = int(input().strip())\nscores = list(map(int, input().strip().split()))\nk = int(input().strip())\n\n# 特殊情况处理：如果格子数量为1，直接输出该格子的分数\nif n == 1:\n    print(scores[0])\n    exit()\n\n# 动态规划数组，dp[i]存储到达第i个格子时能得到的最大分数\ndp = [0] * n\ndp[0] = scores[0]  # 初始化，起点的最大分数就是起点的分数\n\n# 使用双端队列来维护窗口内的最大dp值的索引\ndeque = deque([0])\n\nfor i in range(1, n):\n    # 如果队列不为空且队列头部的索引已经超出了跳跃范围，从队列中移除头部\n    if deque and deque[0] < i - k:\n        deque.popleft()\n\n    # 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n    dp[i] = scores[i] + (dp[deque[0]] if deque else 0)\n\n    # 维护队列，保持队列为递减，新的最大值需要添加到队尾\n    while deque and dp[deque[-1]] <= dp[i]:\n        deque.pop()\n\n    # 将当前索引加到队列尾部\n    deque.append(i)\n\n# 输出到达最后一个格子时能得到的最大分数\nprint(dp[-1])",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst inputs = [];\nrl.on('line', function(line) {\n    inputs.push(line);\n}).on('close', function() {\n    const n = parseInt(inputs[0]); // 读取第一行输入，格子的数量\n    const scores = inputs[1].split(' ').map(Number); // 读取第二行输入，并转化为整数数组\n    const k = parseInt(inputs[2]); // 读取第三行输入，跳跃的最大范围\n\n    // 特殊情况处理：如果格子数量为1，直接输出该格子的分数\n    if (n === 1) {\n        console.log(scores[0]);\n        return;\n    }\n\n    // 动态规划数组，dp[i]存储到达第i个格子时能得到的最大分数\n    const dp = Array(n).fill(0);\n    dp[0] = scores[0]; // 初始化，起点的最大分数就是起点的分数\n\n    // 使用双端队列来维护窗口内的最大dp值的索引\n    const deque = [];\n    deque.push(0);\n\n    for (let i = 1; i < n; i++) {\n        // 如果队列不为空且队列头部的索引已经超出了跳跃范围，从队列中移除头部\n        while (deque.length > 0 && deque[0] < i - k) {\n            deque.shift();\n        }\n\n        // 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n        dp[i] = scores[i] + (deque.length === 0 ? 0 : dp[deque[0]]);\n\n        // 维护队列，保持队列为递减，新的最大值需要添加到队尾\n        while (deque.length > 0 && dp[deque[deque.length - 1]] <= dp[i]) {\n            deque.pop();\n        }\n\n        // 将当前索引加到队列尾部\n        deque.push(i);\n    }\n\n    // 输出到达最后一个格子时能得到的最大分数\n    console.log(dp[n - 1]);\n    \n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n;\n    cin.ignore(); // 忽略换行符，以便读取下一行分数\n\n    string line;\n    getline(cin, line);\n    stringstream ss(line);\n    vector<int> scores(n);\n    for (int &score : scores) {\n        ss >> score;\n    }\n    cin >> k;\n\n    // 特殊情况处理：如果格子数量为1，直接输出该格子的分数\n    if (n == 1) {\n        cout << scores[0] << endl;\n        return 0;\n    }\n\n    // 动态规划数组，dp[i]存储到达第i个格子时能得到的最大分数\n    vector<int> dp(n);\n    dp[0] = scores[0]; // 初始化，起点的最大分数就是起点的分数\n\n    // 使用双端队列来维护窗口内的最大dp值的索引\n    deque<int> deque;\n    deque.push_back(0);\n\n    for (int i = 1; i < n; i++) {\n        // 如果队列不为空且队列头部的索引已经超出了跳跃范围，从队列中移除头部\n        if (!deque.empty() && deque.front() < i - k) {\n            deque.pop_front();\n        }\n\n        // 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n        dp[i] = scores[i] + (deque.empty() ? 0 : dp[deque.front()]);\n\n        // 维护队列，保持队列为递减，新的最大值需要添加到队尾\n        while (!deque.empty() && dp[deque.back()] <= dp[i]) {\n            deque.pop_back();\n        }\n\n        // 将当前索引加到队列尾部\n        deque.push_back(i);\n    }\n\n    // 输出到达最后一个格子时能得到的最大分数\n    cout << dp[n - 1] << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d\", &n); // 读取格子的数量\n\n    int scores[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &scores[i]); // 读取每个格子的分数\n    }\n    scanf(\"%d\", &k); // 读取跳跃的最大范围\n\n    // 特殊情况处理：如果格子数量为1，直接输出该格子的分数\n    if (n == 1) {\n        printf(\"%d\\n\", scores[0]);\n        return 0;\n    }\n\n    int dp[n];\n    dp[0] = scores[0]; // 初始化，起点的最大分数就是起点的分数\n\n    // 使用数组模拟窗口内最大dp值的索引\n    int window[n];\n    int start = 0, end = 0; // 窗口的起始和终止位置\n    window[end++] = 0;\n\n    for (int i = 1; i < n; i++) {\n        // 如果窗口的第一个元素已经超出了跳跃范围，从窗口中移除该元素\n        if (window[start] < i - k) {\n            start++;\n        }\n\n        // 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n        dp[i] = scores[i] + dp[window[start]];\n\n        // 维护窗口，保持窗口内为递减，新的最大值需要添加到窗口尾部\n        while (start < end && dp[window[end - 1]] <= dp[i]) {\n            end--;\n        }\n\n        // 将当前索引加到窗口尾部\n        window[end++] = i;\n    }\n\n    // 输出到达最后一个格子时能得到的最大分数\n    printf(\"%d\\n\", dp[n - 1]);\n    return 0;\n}"
    }
  },
  {
    "id": "142",
    "title": "转骰子",
    "examType": "A",
    "score": 200,
    "description": "骰子是一个立方体，每个面一个数字，初始为左1，右2，前3(观察者方向)，后4，上5，下6，用123456表示这个状态，放置在平面上，\n可以向左翻转(用L表示向左翻转1次)，可以向右翻转(用R表示向右翻转1次)，可以向前翻转(用F表示向前翻转1次)，可以向后翻转(用B表示向后翻转1次)，可以逆时针旋转(用A表示逆时针旋转90度)，可以顺时针旋转(用C表示顺时针旋转90度)，\n现从123456这个初始状态开始，根据输入的动作序列，计算得到最终的状态。\n骰子的初始状态和初始状态转动后的状态如图所示。\n",
    "inputDesc": "输入一行，为只包含LRFBAC的字母序列，最大长度为50，字母可重复。",
    "outputDesc": "输出最终状态",
    "examples": [
      {
        "input": "LR",
        "output": "",
        "explanation": "骰子先向左翻转，再向右翻转回来，故还是原来的状态123456"
      },
      {
        "input": "FCR",
        "output": "",
        "explanation": "骰子向前翻转，状态变为125643，再顺时针旋转，状态变为651243，最后向右翻转，状态变为342156"
      }
    ],
    "solution": "本题没啥难度，主要就是模拟！",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n\n    /**\n     * 通用的旋转方法，用于交换骰子上四个面的值。\n     * 此方法用于实现骰子翻转的各个方向变化，通过传入四个索引，按顺序交换这四个面的位置。\n     *\n     * @param state 当前骰子的六个面数组，依次表示 左、右、前、后、上、下。\n     * @param a     要交换的第一个面索引\n     * @param b     要交换的第二个面索引\n     * @param c     要交换的第三个面索引\n     * @param d     要交换的第四个面索引\n     */\n    public static void rotate(int[] state, int a, int b, int c, int d) {\n        int temp = state[a];  // 临时保存第一个面的值\n        state[a] = state[b];  // 第二个面的值赋给第一个面\n        state[b] = state[c];  // 第三个面的值赋给第二个面\n        state[c] = state[d];  // 第四个面的值赋给第三个面\n        state[d] = temp;      // 第一个面的值赋给第四个面\n    }\n\n    /**\n     * 向左翻转 (L)：\n     * 将上面的面变为左边，左面的面变为下面，下面的面变为右边，右面的面变为上面。\n     * 通过左->上->右->下的顺序交换四个面的值。\n     *\n     */\n    public static void turnL(int[] state) {\n        rotate(state, 0, 4, 1, 5); // 左->上->右->下->左\n    }\n\n    /**\n     * 向右翻转 (R)：\n     * 将上面的面变为右边，右面的面变为下面，下面的面变为左边，左面的面变为上面。\n     * 通过左->下->右->上的顺序交换四个面的值。\n     *\n     */\n    public static void turnR(int[] state) {\n        rotate(state, 0, 5, 1, 4); // 左->下->右->上->左\n    }\n\n    /**\n     * 向前翻转 (F)：\n     * 将上面的面变为前面，前面的面变为下面，下面的面变为后面，后面的面变为上面。\n     * 通过前->上->后->下的顺序交换四个面的值。\n     *\n     */\n    public static void turnF(int[] state) {\n        rotate(state, 2, 4, 3, 5); // 前->上->后->下->前\n    }\n\n    /**\n     * 向后翻转 (B)：\n     * 将上面的面变为后面，后面的面变为下面，下面的面变为前面，前面的面变为上面。\n     * 通过前->下->后->上的顺序交换四个面的值。\n     */\n    public static void turnB(int[] state) {\n        rotate(state, 2, 5, 3, 4); // 前->下->后->上->前\n    }\n\n    /**\n     * 逆时针旋转 (A)：\n     * 将前面的面变为右边，右面的面变为后面，后面的面变为左边，左面的面变为前面。\n     * 通过左->后->右->前的顺序交换四个面的值。\n     */\n    public static void turnA(int[] state) {\n        rotate(state, 0, 3, 1, 2); // 左->后->右->前->左\n    }\n\n    /**\n     * 顺时针旋转 (C)：\n     * 将前面的面变为左边，左面的面变为后面，后面的面变为右边，右面的面变为前面。\n     * 通过左->前->右->后的顺序交换四个面的值。\n     *\n     */\n    public static void turnC(int[] state) {\n        rotate(state, 0, 2, 1, 3); // 左->前->右->后->左\n    }\n\n    public static void main(String[] args) {\n        // 创建一个扫描器对象，用于读取用户输入的指令序列\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.next();  // 从输入中读取一串动作指令\n\n        // 初始状态：骰子各个面的编号，依次表示 左、右、前、后、上、下。\n        int[] state = {1, 2, 3, 4, 5, 6};  // 初始状态: 左1，右2，前3，后4，上5，下6\n\n        // 遍历输入的每一个字符，根据指令执行相应的操作\n        for (char ch : s.toCharArray()) {\n            switch (ch) {\n                case 'L': turnL(state); break;  // 执行左翻转\n                case 'R': turnR(state); break;  // 执行右翻转\n                case 'F': turnF(state); break;  // 执行前翻转\n                case 'B': turnB(state); break;  // 执行后翻转\n                case 'A': turnA(state); break;  // 执行逆时针旋转\n                case 'C': turnC(state); break;  // 执行顺时针旋转\n            }\n        }\n\n        // 输出最终骰子的六个面状态，按照左、右、前、后、上、下的顺序\n        for (int num : state) {\n            System.out.print(num);\n        }\n    }\n}",
      "python": "# 定义一个通用的旋转函数，用于交换骰子上四个面的值\ndef rotate(state, a, b, c, d):\n    temp = state[a]  # 临时保存第一个面的值\n    state[a] = state[b]  # 第二个面的值赋给第一个面\n    state[b] = state[c]  # 第三个面的值赋给第二个面\n    state[c] = state[d]  # 第四个面的值赋给第三个面\n    state[d] = temp  # 第一个面的值赋给第四个面\n\n# 定义向左翻转函数 (L)\ndef turnL(state):\n    rotate(state, 0, 4, 1, 5)  # 左->上->右->下->左\n\n# 定义向右翻转函数 (R)\ndef turnR(state):\n    rotate(state, 0, 5, 1, 4)  # 左->下->右->上->左\n\n# 定义向前翻转函数 (F)\ndef turnF(state):\n    rotate(state, 2, 4, 3, 5)  # 前->上->后->下->前\n\n# 定义向后翻转函数 (B)\ndef turnB(state):\n    rotate(state, 2, 5, 3, 4)  # 前->下->后->上->前\n\n# 定义逆时针旋转函数 (A)\ndef turnA(state):\n    rotate(state, 0, 3, 1, 2)  # 左->后->右->前->左\n\n# 定义顺时针旋转函数 (C)\ndef turnC(state):\n    rotate(state, 0, 2, 1, 3)  # 左->前->右->后->左\n\n# 主程序\nif __name__ == \"__main__\":\n    # 从输入中获取用户指令\n    s = input()  # 用户输入一串动作指令\n\n    # 初始状态：左1，右2，前3，后4，上5，下6\n    state = [1, 2, 3, 4, 5, 6]\n\n    # 遍历输入的每一个字符，根据指令执行相应的翻转或旋转操作\n    for ch in s:\n        if ch == 'L':\n            turnL(state)\n        elif ch == 'R':\n            turnR(state)\n        elif ch == 'F':\n            turnF(state)\n        elif ch == 'B':\n            turnB(state)\n        elif ch == 'A':\n            turnA(state)\n        elif ch == 'C':\n            turnC(state)\n\n    # 输出最终骰子的六个面状态\n    print(\"\".join(map(str, state)))",
      "javascript": "// 定义一个通用的旋转函数，用于交换骰子上四个面的值\nfunction rotate(state, a, b, c, d) {\n    let temp = state[a];  // 临时保存第一个面的值\n    state[a] = state[b];  // 第二个面的值赋给第一个面\n    state[b] = state[c];  // 第三个面的值赋给第二个面\n    state[c] = state[d];  // 第四个面的值赋给第三个面\n    state[d] = temp;      // 第一个面的值赋给第四个面\n}\n\n// 定义向左翻转函数 (L)\nfunction turnL(state) {\n    rotate(state, 0, 4, 1, 5);  // 左->上->右->下->左\n}\n\n// 定义向右翻转函数 (R)\nfunction turnR(state) {\n    rotate(state, 0, 5, 1, 4);  // 左->下->右->上->左\n}\n\n// 定义向前翻转函数 (F)\nfunction turnF(state) {\n    rotate(state, 2, 4, 3, 5);  // 前->上->后->下->前\n}\n\n// 定义向后翻转函数 (B)\nfunction turnB(state) {\n    rotate(state, 2, 5, 3, 4);  // 前->下->后->上->前\n}\n\n// 定义逆时针旋转函数 (A)\nfunction turnA(state) {\n    rotate(state, 0, 3, 1, 2);  // 左->后->右->前->左\n}\n\n// 定义顺时针旋转函数 (C)\nfunction turnC(state) {\n    rotate(state, 0, 2, 1, 3);  // 左->前->右->后->左\n}\n\n// 主程序\nconst readline = require('readline').createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nreadline.on('line', s => {\n    // 初始状态：左1，右2，前3，后4，上5，下6\n    let state = [1, 2, 3, 4, 5, 6];\n\n    // 遍历输入的每一个字符，根据指令执行相应的翻转或旋转操作\n    for (let ch of s) {\n        if (ch === 'L') turnL(state);\n        else if (ch === 'R') turnR(state);\n        else if (ch === 'F') turnF(state);\n        else if (ch === 'B') turnB(state);\n        else if (ch === 'A') turnA(state);\n        else if (ch === 'C') turnC(state);\n    }\n\n    // 输出最终骰子的六个面状态\n    console.log(state.join(''));\n\n    readline.close();\n});",
      "cpp": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n// 定义一个通用的旋转函数，用于交换骰子上四个面的值\nvoid rotate(int state[], int a, int b, int c, int d) {\n    int temp = state[a];  // 临时保存第一个面的值\n    state[a] = state[b];  // 第二个面的值赋给第一个面\n    state[b] = state[c];  // 第三个面的值赋给第二个面\n    state[c] = state[d];  // 第四个面的值赋给第三个面\n    state[d] = temp;      // 第一个面的值赋给第四个面\n}\n\n// 定义向左翻转函数 (L)\nvoid turnL(int state[]) {\n    rotate(state, 0, 4, 1, 5);  // 左->上->右->下->左\n}\n\n// 定义向右翻转函数 (R)\nvoid turnR(int state[]) {\n    rotate(state, 0, 5, 1, 4);  // 左->下->右->上->左\n}\n\n// 定义向前翻转函数 (F)\nvoid turnF(int state[]) {\n    rotate(state, 2, 4, 3, 5);  // 前->上->后->下->前\n}\n\n// 定义向后翻转函数 (B)\nvoid turnB(int state[]) {\n    rotate(state, 2, 5, 3, 4);  // 前->下->后->上->前\n}\n\n// 定义逆时针旋转函数 (A)\nvoid turnA(int state[]) {\n    rotate(state, 0, 3, 1, 2);  // 左->后->右->前->左\n}\n\n// 定义顺时针旋转函数 (C)\nvoid turnC(int state[]) {\n    rotate(state, 0, 2, 1, 3);  // 左->前->右->后->左\n}\n\nint main() {\n    string s;\n    cin >> s;  // 从输入中获取用户指令\n\n    // 初始状态：左1，右2，前3，后4，上5，下6\n    int state[6] = {1, 2, 3, 4, 5, 6};\n\n    // 遍历输入的每一个字符，根据指令执行相应的翻转或旋转操作\n    for (char ch : s) {\n        if (ch == 'L') turnL(state);\n        else if (ch == 'R') turnR(state);\n        else if (ch == 'F') turnF(state);\n        else if (ch == 'B') turnB(state);\n        else if (ch == 'A') turnA(state);\n        else if (ch == 'C') turnC(state);\n    }\n\n    // 输出最终骰子的六个面状态\n    for (int i = 0; i < 6; ++i) {\n        cout << state[i];\n    }\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n\n// 定义一个通用的旋转函数，用于交换骰子上四个面的值\nvoid rotate(int state[], int a, int b, int c, int d) {\n    int temp = state[a];  // 临时保存第一个面的值\n    state[a] = state[b];  // 第二个面的值赋给第一个面\n    state[b] = state[c];  // 第三个面的值赋给第二个面\n    state[c] = state[d];  // 第四个面的值赋给第三个面\n    state[d] = temp;      // 第一个面的值赋给第四个面\n}\n\n// 定义向左翻转函数 (L)\nvoid turnL(int state[]) {\n    rotate(state, 0, 4, 1, 5);  // 左->上->右->下->左\n}\n\n// 定义向右翻转函数 (R)\nvoid turnR(int state[]) {\n    rotate(state, 0, 5, 1, 4);  // 左->下->右->上->左\n}\n\n// 定义向前翻转函数 (F)\nvoid turnF(int state[]) {\n    rotate(state, 2, 4, 3, 5);  // 前->上->后->下->前\n}\n\n// 定义向后翻转函数 (B)\nvoid turnB(int state[]) {\n    rotate(state, 2, 5, 3, 4);  // 前->下->后->上->前\n}\n\n// 定义逆时针旋转函数 (A)\nvoid turnA(int state[]) {\n    rotate(state, 0, 3, 1, 2);  // 左->后->右->前->左\n}\n\n// 定义顺时针旋转函数 (C)\nvoid turnC(int state[]) {\n    rotate(state, 0, 2, 1, 3);  // 左->前->右->后->左\n}\n\nint main() {\n    char s[100];\n    scanf(\"%s\", s);  // 从输入中获取用户指令\n\n    // 初始状态：左1，右2，前3，后4，上5，下6\n    int state[6] = {1, 2, 3, 4, 5, 6};\n\n    // 遍历输入的每一个字符，根据指令执行相应的翻转或旋转操作\n    for (int i = 0; i < strlen(s); ++i) {\n        if (s[i] == 'L') turnL(state);\n        else if (s[i] == 'R') turnR(state);\n        else if (s[i] == 'F') turnF(state);\n        else if (s[i] == 'B') turnB(state);\n        else if (s[i] == 'A') turnA(state);\n        else if (s[i] == 'C') turnC(state);\n    }\n\n    // 输出最终骰子的六个面状态\n    for (int i = 0; i < 6; ++i) {\n        printf(\"%d\", state[i]);\n    }\n\n    return 0;\n}"
    }
  },
  {
    "id": "143",
    "title": "周末爬山",
    "examType": "A",
    "score": 200,
    "description": "周末小明准备去爬山锻炼，0代表平地，山的高度使用1到9来表示，小明每次爬山或下山高度只能相差k及k以内，每次只能上下左右一个方向上移动一格，小明从左上角(0,0)位置出发",
    "inputDesc": "第一行输入m n k(空格分隔)\n代表m*n的二维山地图，k为小明每次爬山或下山高度差的最大值，\n然后接下来输入山地图，一共m行n列，均以空格分隔。取值范围：\n0 < m ≤ 5000< n ≤ 5000 < k < 5\n所有用例输入均为正确格式，且在取值范围内，考生不需要考虑不合法的输入格式。",
    "outputDesc": "请问小明能爬到的最高峰多高，到该最高峰的最短步数，输出以空格分隔。\n同高度的山峰输出较短步数。\n如果没有可以爬的山峰，则高度和步数都返回0。",
    "examples": [
      {
        "input": "4 1\n 1 2 0\n 0 0 0\n 0 1 2\n 3 1 0\n 0 0 9",
        "output": "2",
        "explanation": "根据山地图可知，能爬到的最高峰在(0,2)位置，高度为2，最短路径为(0,0)-(0,1)-(0,2)，最短步数为2。"
      },
      {
        "input": "4 3\n 0 0 0\n 0 0 0\n 9 0 0\n 0 0 0\n 0 0 9",
        "output": "0",
        "explanation": "根据山地图可知，每次爬山距离3，无法爬到山峰上，步数为0。"
      }
    ],
    "solution": "这个问题的解题思路是使用深度优先搜索（DFS）算法来解决小明爬山的问题。\n定义一个常量数组 OFFSETS，表示上下左右四个方向的偏移量。这将帮助我们在搜索过程中遍历相邻的位置。 实现一个深度优先搜索函数 dfs，它接收以下参数：当前位置的坐标 (x, y)，当前步数 step，一个哈希表 min_step_to_height 用于存储到达不同高度的最短步数，山地图矩阵 matrix，矩阵的行数 m 和列数 n，允许的最大高度差 k，一个记忆化数组 memo 用于记录已经访问过的位置和步数，以及一个布尔数组 visited 用于记录已经访问过的位置。 在 dfs 函数中，首先获取当前位置的高度。 遍历四个方向（上下左右），计算新的位置，并检查新位置是否在矩阵范围内。 获取新位置的高度，并检查两个位置的高度差是否在 k 以内。如果高度差在 k 以内，执行以下操作： a. 增加步数。 b. 更新到达新高度的最短步数。如果当前高度不在 min_step_to_height 中，或者当前步数小于已记录的最短步数，更新 min_step_to_height。 c. 检查记忆化数组，避免重复计算。如果当前位置没有被访问过，或者已访问过但当前步数小于已记录的步数，执行以下操作： i. 更新记忆化数组。 ii. 标记当前位置为已访问。 iii. 递归调用 dfs 函数，继续搜索。 iv. 回溯时，将当前位置标记为未访问。 d. 减少步数。\n定义一个常量数组 OFFSETS，表示上下左右四个方向的偏移量。这将帮助我们在搜索过程中遍历相邻的位置。\n实现一个深度优先搜索函数 dfs，它接收以下参数：当前位置的坐标 (x, y)，当前步数 step，一个哈希表 min_step_to_height 用于存储到达不同高度的最短步数，山地图矩阵 matrix，矩阵的行数 m 和列数 n，允许的最大高度差 k，一个记忆化数组 memo 用于记录已经访问过的位置和步数，以及一个布尔数组 visited 用于记录已经访问过的位置。\n在 dfs 函数中，首先获取当前位置的高度。\n遍历四个方向（上下左右），计算新的位置，并检查新位置是否在矩阵范围内。\n获取新位置的高度，并检查两个位置的高度差是否在 k 以内。如果高度差在 k 以内，执行以下操作：\na. 增加步数。\nb. 更新到达新高度的最短步数。如果当前高度不在 min_step_to_height 中，或者当前步数小于已记录的最短步数，更新 min_step_to_height。\nc. 检查记忆化数组，避免重复计算。如果当前位置没有被访问过，或者已访问过但当前步数小于已记录的步数，执行以下操作：\ni. 更新记忆化数组。\nii. 标记当前位置为已访问。\niii. 递归调用 dfs 函数，继续搜索。\niv. 回溯时，将当前位置标记为未访问。\nd. 减少步数。",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n    // 定义一个常量数组，表示上下左右四个方向的偏移量\n    private static final int[][] OFFSETS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 读取输入的m, n, k\n        int m = sc.nextInt();\n        int n = sc.nextInt();\n        int k = sc.nextInt();\n\n        // 初始化山地图矩阵\n        int[][] matrix = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = sc.nextInt();\n            }\n        }\n\n        // 初始化一个哈希表，用于存储到达不同高度的最短步数\n        HashMap<Integer, Integer> minStepToHeight = new HashMap<>();\n        minStepToHeight.put(matrix[0][0], 0);\n\n        // 初始化一个记忆化数组，用于记录已经访问过的位置和步数\n        int[][] memo = new int[m][n];\n        // 初始化一个布尔数组，用于记录已经访问过的位置\n        boolean[][] visited = new boolean[m][n];\n        // 调用深度优先搜索函数\n        dfs(0, 0, 0, minStepToHeight, matrix, m, n, k, memo, visited);\n\n        // 计算最高峰的高度和最短步数\n        int maxHeight = minStepToHeight.keySet().stream().max((a, b) -> a - b).orElse(0);\n        int minStep = minStepToHeight.get(maxHeight);\n\n        // 输出结果\n        System.out.println(maxHeight + \" \" + minStep);\n    }\n\n    // 深度优先搜索函数\n    public static void dfs(int x, int y, int step, HashMap<Integer, Integer> minStepToHeight, int[][] matrix, int m, int n, int k, int[][] memo, boolean[][] visited) {\n        // 获取当前位置的高度\n        int lastHeight = matrix[x][y];\n\n        // 遍历四个方向\n        for (int[] offset : OFFSETS) {\n            // 计算新的位置\n            int newX = x + offset[0];\n            int newY = y + offset[1];\n\n            // 检查新位置是否在矩阵范围内\n            if (newX < 0 || newX >= m || newY < 0 || newY >= n) continue;\n\n            // 获取新位置的高度\n            int curHeight = matrix[newX][newY];\n\n            // 检查两个位置的高度差是否在k以内\n            if (Math.abs(curHeight - lastHeight) <= k) {\n                // 增加步数\n                step++;\n\n                // 更新到达新高度的最短步数\n                if (!minStepToHeight.containsKey(curHeight) || minStepToHeight.get(curHeight) > step) {\n                    minStepToHeight.put(curHeight, step);\n                }\n\n                // 检查记忆化数组，避免重复计算\n                if (memo[newX][newY] == 0 || memo[newX][newY] > step) {\n                    // 更新记忆化数组\n                    memo[newX][newY] = step;\n                    // 标记当前位置为已访问\n                    visited[x][y] = true;\n\n                    // 递归调用深度优先搜索\n                    dfs(newX, newY, step, minStepToHeight, matrix, m, n, k, memo, visited);\n\n                    // 回溯时，将当前位置标记为未访问\n                    visited[x][y] = false;\n                }\n\n                // 减少步数\n                step--;\n            }\n        }\n    }\n}",
      "python": "from collections import defaultdict\n\n# 定义一个常量数组，表示上下左右四个方向的偏移量\nOFFSETS = [\n    (-1, 0),\n    (1, 0),\n    (0, -1),\n    (0, 1),\n]\n\n# 深度优先搜索函数\ndef dfs(x, y, step, min_step_to_height, matrix, m, n, k, memo, visited):\n    # 获取当前位置的高度\n    last_height = matrix[x][y]\n\n    # 遍历四个方向\n    for offset in OFFSETS:\n        # 计算新的位置\n        new_x = x + offset[0]\n        new_y = y + offset[1]\n\n        # 检查新位置是否在矩阵范围内\n        if new_x < 0 or new_x >= m or new_y < 0 or new_y >= n:\n            continue\n\n        # 获取新位置的高度\n        cur_height = matrix[new_x][new_y]\n\n        # 检查两个位置的高度差是否在k以内\n        if abs(cur_height - last_height) <= k:\n            # 增加步数\n            step += 1\n\n            # 更新到达新高度的最短步数\n            if cur_height not in min_step_to_height or min_step_to_height[cur_height] > step:\n                min_step_to_height[cur_height] = step\n\n            # 检查记忆化数组，避免重复计算\n            if memo[new_x][new_y] == 0 or memo[new_x][new_y] > step:\n                # 更新记忆化数组\n                memo[new_x][new_y] = step\n                # 标记当前位置为已访问\n                visited[x][y] = True\n\n                # 递归调用深度优先搜索\n                dfs(new_x, new_y, step, min_step_to_height, matrix, m, n, k, memo, visited)\n\n                # 回溯时，将当前位置标记为未访问\n                visited[x][y] = False\n\n            # 减少步数\n            step -= 1\n\n# 主函数\ndef main():\n    # 读取输入的m, n, k\n    m, n, k = map(int, input().split())\n    # 初始化山地图矩阵\n    matrix = [list(map(int, input().split())) for _ in range(m)]\n\n    # 初始化一个哈希表，用于存储到达不同高度的最短步数\n    min_step_to_height = {matrix[0][0]: 0}\n    # 初始化一个记忆化数组，用于记录已经访问过的位置和步数\n    memo = [[0] * n for _ in range(m)]\n    # 初始化一个布尔数组，用于记录已经访问过的位置\n    visited = [[False] * n for _ in range(m)]\n\n    # 调用深度优先搜索函数\n    dfs(0, 0, 0, min_step_to_height, matrix, m, n, k, memo, visited)\n\n    # 计算最高峰的高度和最短步数\n    max_height = max(min_step_to_height.keys())\n    min_step = min_step_to_height[max_height]\n\n    # 输出结果\n    print(max_height, min_step)\n\n# 程序入口\nif __name__ == \"__main__\":\n    main()",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 定义一个常量数组，表示上下左右四个方向的偏移量\nconst OFFSETS = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n];\n\n// 深度优先搜索函数\nfunction dfs(x, y, step, minStepToHeight, matrix, m, n, k, memo, visited) {\n    // 获取当前位置的高度\n    const lastHeight = matrix[x][y];\n\n    // 遍历四个方向\n    for (const offset of OFFSETS) {\n        // 计算新的位置\n        const newX = x + offset[0];\n        const newY = y + offset[1];\n\n        // 检查新位置是否在矩阵范围内\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n) {\n            continue;\n        }\n\n        // 获取新位置的高度\n        const curHeight = matrix[newX][newY];\n\n        // 检查两个位置的高度差是否在k以内\n        if (Math.abs(curHeight - lastHeight) <= k) {\n            // 增加步数\n            step += 1;\n\n            // 更新到达新高度的最短步数\n            if (!(curHeight in minStepToHeight) || minStepToHeight[curHeight] > step) {\n                minStepToHeight[curHeight] = step;\n            }\n\n            // 检查记忆化数组，避免重复计算\n            if (memo[newX][newY] === 0 || memo[newX][newY] > step) {\n                // 更新记忆化数组\n                memo[newX][newY] = step;\n                // 标记当前位置为已访问\n                visited[x][y] = true;\n\n                // 递归调用深度优先搜索\n                dfs(newX, newY, step, minStepToHeight, matrix, m, n, k, memo, visited);\n\n                // 回溯时，将当前位置标记为未访问\n                visited[x][y] = false;\n            }\n\n            // 减少步数\n            step -= 1;\n        }\n    }\n}\nconst inputLines = [];\n\nrl.on('line', input => {\n    inputLines.push(input);\n    if (inputLines.length === parseInt(inputLines[0].split(' ')[0], 10) + 1) {\n        rl.close();\n        const [m, n, k] = inputLines[0].split(' ').map(Number);\n        const matrix = inputLines.slice(1).map(line => line.split(' ').map(Number));\n\n\n        // 初始化一个哈希表，用于存储到达不同高度的最短步数\n        const minStepToHeight = { [matrix[0][0]]: 0 };\n        // 初始化一个记忆化数组，用于记录已经访问过的位置和步数\n        const memo = Array.from({ length: m }, () => Array(n).fill(0));\n        // 初始化一个布尔数组，用于记录已经访问过的位置\n        const visited = Array.from({ length: m }, () => Array(n).fill(false));\n\n        // 调用深度优先搜索函数\n        dfs(0, 0, 0, minStepToHeight, matrix, m, n, k, memo, visited);\n\n        // 计算最高峰的高度和最短步数\n        const max_height = Math.max(...Object.keys(minStepToHeight).map(Number));\n        const min_step = minStepToHeight[max_height];\n\n        // 输出结果\n        console.log(max_height, min_step);\n\n        rl.close();\n    }\n})",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\n// 定义一个常量数组，表示上下左右四个方向的偏移量\nconst vector<vector<int>> OFFSETS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n// 深度优先搜索函数\nvoid dfs(int x, int y, int step, unordered_map<int, int> &minStepToHeight, vector<vector<int>> &matrix, int m, int n, int k, vector<vector<int>> &memo, vector<vector<bool>> &visited) {\n    // 获取当前位置的高度\n    int lastHeight = matrix[x][y];\n\n    // 遍历四个方向\n    for (const auto &offset : OFFSETS) {\n        // 计算新的位置\n        int newX = x + offset[0];\n        int newY = y + offset[1];\n\n        // 检查新位置是否在矩阵范围内\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n) continue;\n\n        // 获取新位置的高度\n        int curHeight = matrix[newX][newY];\n\n        // 检查两个位置的高度差是否在k以内\n        if (abs(curHeight - lastHeight) <= k) {\n            // 增加步数\n            step++;\n\n            // 更新到达新高度的最短步数\n            if (minStepToHeight.find(curHeight) == minStepToHeight.end() || minStepToHeight[curHeight] > step) {\n                minStepToHeight[curHeight] = step;\n            }\n\n            // 检查记忆化数组，避免重复计算\n            if (memo[newX][newY] == 0 || memo[newX][newY] > step) {\n                // 更新记忆化数组\n                memo[newX][newY] = step;\n                // 标记当前位置为已访问\n                visited[x][y] = true;\n\n                // 递归调用深度优先搜索\n                dfs(newX, newY, step, minStepToHeight, matrix, m, n, k, memo, visited);\n\n                // 回溯时，将当前位置标记为未访问\n                visited[x][y] = false;\n            }\n\n            // 减少步数\n            step--;\n        }\n    }\n}\n\nint main() {\n    int m, n, k;\n    cin >> m >> n >> k;\n\n    // 初始化山地图矩阵\n    vector<vector<int>> matrix(m, vector<int>(n));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n\n    // 初始化一个哈希表，用于存储到达不同高度的最短步数\n    unordered_map<int, int> minStepToHeight;\n    minStepToHeight[matrix[0][0]] = 0;\n\n    // 初始化一个记忆化数组，用于记录已经访问过的位置和步数\n    vector<vector<int>> memo(m, vector<int>(n));\n    // 初始化一个布尔数组，用于记录已经访问过的位置\n    vector<vector<bool>> visited(m, vector<bool>(n));\n    // 调用深度优先搜索函数\n    dfs(0, 0, 0, minStepToHeight, matrix, m, n, k, memo, visited);\n\n    // 计算最高峰的高度和最短步数\n    int maxHeight = 0;\n    int minStep = 0;\n    for (const auto &entry : minStepToHeight) {\n        if (entry.first > maxHeight) {\n            maxHeight = entry.first;\n            minStep = entry.second;\n        }\n    }\n\n    // 输出结果\n    cout << maxHeight << \" \" << minStep << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n\n// 定义四个方向的偏移量：上、下、左、右\nint OFFSETS[4][2] = {\n    {-1, 0},  // 上\n    {1, 0},   // 下\n    {0, -1},  // 左\n    {0, 1}    // 右\n};\n\n// 深度优先搜索函数\nvoid dfs(int x, int y, int step, int **minStepToHeight, int **matrix, int m, int n, int k, int **memo, bool **visited) {\n    // 获取当前位置的高度\n    int lastHeight = matrix[x][y];\n\n    // 遍历四个方向\n    for (int i = 0; i < 4; i++) {\n        int newX = x + OFFSETS[i][0];  // 新位置的行坐标\n        int newY = y + OFFSETS[i][1];  // 新位置的列坐标\n\n        // 检查新位置是否在地图范围内\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n) {\n            continue;\n        }\n\n        // 获取新位置的高度\n        int curHeight = matrix[newX][newY];\n\n        // 检查高度差是否在k以内\n        if (abs(curHeight - lastHeight) <= k) {\n            step++;  // 增加步数\n\n            // 更新到达新高度的最短步数\n            if (minStepToHeight[curHeight][0] == 0 || minStepToHeight[curHeight][0] > step) {\n                minStepToHeight[curHeight][0] = step;\n            }\n\n            // 检查记忆数组，避免重复计算\n            if (memo[newX][newY] == 0 || memo[newX][newY] > step) {\n                memo[newX][newY] = step;    // 更新记忆化数组\n                visited[x][y] = true;       // 标记当前位置为已访问\n\n                // 递归调用深度优先搜索\n                dfs(newX, newY, step, minStepToHeight, matrix, m, n, k, memo, visited);\n\n                visited[x][y] = false;      // 回溯时标记当前位置为未访问\n            }\n\n            step--;  // 回溯时步数减少\n        }\n    }\n}\n\nint main() {\n    int m, n, k;\n    scanf(\"%d %d %d\", &m, &n, &k);  // 输入m, n, k的值\n\n    // 动态分配二维数组用于存储山地图\n    int **matrix = (int **)malloc(m * sizeof(int *));\n    for (int i = 0; i < m; i++) {\n        matrix[i] = (int *)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &matrix[i][j]);  // 读取山地图\n        }\n    }\n\n    // 初始化用于存储到达不同高度的最短步数数组\n    int **minStepToHeight = (int **)malloc(10 * sizeof(int *));\n    for (int i = 0; i < 10; i++) {\n        minStepToHeight[i] = (int *)calloc(1, sizeof(int));  // 初始最短步数为0\n    }\n\n    // 初始化记忆化数组，用于记录已经访问过的位置和步数\n    int **memo = (int **)malloc(m * sizeof(int *));\n    for (int i = 0; i < m; i++) {\n        memo[i] = (int *)calloc(n, sizeof(int));\n    }\n\n    // 初始化访问数组，记录已访问位置\n    bool **visited = (bool **)malloc(m * sizeof(bool *));\n    for (int i = 0; i < m; i++) {\n        visited[i] = (bool *)calloc(n, sizeof(bool));\n    }\n\n    // 初始化时从起点 (0,0) 开始\n    minStepToHeight[matrix[0][0]][0] = 0;\n\n    // 调用深度优先搜索\n    dfs(0, 0, 0, minStepToHeight, matrix, m, n, k, memo, visited);\n\n    // 查找能够到达的最高峰及其最短步数\n    int max_height = 0;\n    int min_step = 0;\n\n    for (int i = 0; i < 10; i++) {\n        if (minStepToHeight[i][0] != 0) {\n            max_height = i;      // 更新最高峰高度\n            min_step = minStepToHeight[i][0];  // 获取最短步数\n        }\n    }\n\n    // 输出结果，如果无法到达任何峰值，输出0 0\n    if (max_height == 0) {\n        printf(\"0 0\\n\");\n    } else {\n        printf(\"%d %d\\n\", max_height, min_step);\n    }\n\n    // 释放动态分配的内存\n    for (int i = 0; i < m; i++) {\n        free(matrix[i]);\n        free(memo[i]);\n        free(visited[i]);\n    }\n    free(matrix);\n    free(memo);\n    free(visited);\n\n    for (int i = 0; i < 10; i++) {\n        free(minStepToHeight[i]);\n    }\n    free(minStepToHeight);\n\n    return 0;\n}"
    }
  },
  {
    "id": "144",
    "title": "文本统计分析",
    "examType": "A",
    "score": 200,
    "description": "有一个文件，包含以一定规则写作的文本，请统计文件中包含的文本数量。\n规则如下：\n文本以”;”分隔，最后一条可以没有”;”，但空文本不能算语句，比如”COMMAND A; ;”只能算一条语句。注意，无字符/空白字符/制表符都算作”空”文本； 文本可以跨行，比如下面，是一条文本，而不是三条；\n文本以”;”分隔，最后一条可以没有”;”，但空文本不能算语句，比如”COMMAND A; ;”只能算一条语句。注意，无字符/空白字符/制表符都算作”空”文本；\n文本可以跨行，比如下面，是一条文本，而不是三条；\n123\n文本支持字符串，字符串为成对的单引号(')或者成对的双引号(“)，字符串可能出现用转义字符()处理的单双引号(“your input is””)和转义字符本身，比如\n1\n支持注释，可以出现在字符串之外的任意位置注释以”–“开头，到换行结束，比如：\n123\n注意字符串内的”–“，不是注释。",
    "inputDesc": "文本文件",
    "outputDesc": "包含的文本数量\n输入\n输出\n题目要求编写一个程序来统计一个文本文件中包含的文本数量。这里的“文本”指的是符合一定规则的字符串序列。具体规则如下：\n文本以分号(;)分隔，最后一条文本可以没有分号结尾。\n如果一段文本只包含空白字符（如空格、制表符等），则不算作一条有效文本。例如，\"COMMAND A; ;\"中只有一条有效文本。\"COMMAND A; B;\"为两条有效文本。\n文本可以跨越多行。也就是说，一个文本的内容可以分布在多个连续的行中，这些行合起来算作一条文本。\n文本支持字符串，字符串可以用单引号(')或双引号(\")包裹。字符串内部可能包含转义的引号（例如\"Say \\\"hello\\\"\"）和转义字符本身（例如\\）。\n在单引号和双引号的;,无法作为一条文本结束的标志.\n支持注释，注释以连续的两个减号(--)开头，并且一直延续到当前行的末尾。注释只能出现在字符串之外的位置。在字符串内的减号不算作注释的开始。在注释后面的;,无法作为一条文本结束的标志。\n单引号和双引号内的注释失效\n备注：这里博主默认是注释【后面】的;，是无法作为文本结束的标志。但是有读者提出是不是默认带注释的那一行的分号（即那一行分号的【前面】和【后面】）都无法作为文本结束的标志？机考时如果不是100%通过率，可以试试：带注释的那一行的分号都无法作为文本结束的标志",
    "examples": [],
    "solution": "遍历每一行： 遍历累积的文本中的每一个字符，使用一个计数器来跟踪文本的数量。使用两个布尔变量inString和inComment来分别跟踪当前位置是否在字符串或注释内部。 处理注释： 如果当前字符和下一个字符都是减号-，并且不在字符串内，则标记为注释开始。在注释内部，忽略所有字符直到遇到换行符，然后标记注释结束。 处理字符串： 如果遇到单引号或双引号，并且不在字符串内，标记为字符串开始，并记录使用的分隔符。在字符串内部，如果再次遇到相同的分隔符，检查是否为转义字符（即是否有连续的两个相同分隔符）。如果不是转义字符，则标记字符串结束。 计数文本： 如果遇到分号，并且不在字符串内，且当前文本不为空（即至少有一个非空白字符），则增加计数器，并标记当前文本为空。如果遇到非空白字符，并且不在字符串内，标记当前文本为非空。 处理最后一个文本： 遍历结束后，如果最后一个文本没有闭合的分号，且不为空，则增加计数器。\n遍历累积的文本中的每一个字符，使用一个计数器来跟踪文本的数量。使用两个布尔变量inString和inComment来分别跟踪当前位置是否在字符串或注释内部。\n如果当前字符和下一个字符都是减号-，并且不在字符串内，则标记为注释开始。在注释内部，忽略所有字符直到遇到换行符，然后标记注释结束。\n如果遇到单引号或双引号，并且不在字符串内，标记为字符串开始，并记录使用的分隔符。在字符串内部，如果再次遇到相同的分隔符，检查是否为转义字符（即是否有连续的两个相同分隔符）。如果不是转义字符，则标记字符串结束。\n如果遇到分号，并且不在字符串内，且当前文本不为空（即至少有一个非空白字符），则增加计数器，并标记当前文本为空。如果遇到非空白字符，并且不在字符串内，标记当前文本为非空。\n遍历结束后，如果最后一个文本没有闭合的分号，且不为空，则增加计数器。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建Scanner对象用于获取用户输入\n        Scanner scanner = new Scanner(System.in);\n        // 使用StringBuilder来构建整个输入文本\n        StringBuilder input = new StringBuilder();\n        // 循环读取每一行输入直到没有新的输入\n        while (scanner.hasNextLine()) {\n            // 将读取的每一行追加到StringBuilder对象，并添加换行符\n            input.append(scanner.nextLine()).append(\"\\n\");\n        }\n        // 关闭Scanner对象\n        scanner.close();\n        // 输出文本统计结果\n        System.out.println(countTexts(input.toString()));\n    }\n\n    // 统计文本中的文本数量\n    private static int countTexts(String input) {\n        // 初始化计数器\n        int count = 0;\n        // 标记是否在字符串内部\n        boolean inString = false;\n        // 标记是否在注释内部\n        boolean inComment = false;\n        // 记录字符串分隔符\n        char stringDelimiter = 0;\n        // 标记当前是否为空文本（即没有遇到非空白字符）\n        boolean isEmpty = true;\n\n        // 遍历输入文本的每个字符\n        for (int i = 0; i < input.length(); i++) {\n            // 当前字符\n            char c = input.charAt(i);\n            // 下一个字符（如果存在）\n            char nextChar = (i + 1 < input.length()) ? input.charAt(i + 1) : '\\0';\n\n            // 如果在注释中\n            if (inComment) {\n                // 如果遇到换行符，则注释结束\n                if (c == '\\n') {\n                    inComment = false;\n                }\n                continue;\n            }\n\n            // 如果遇到连续的两个减号，并且不在字符串内，则进入注释状态\n            if (c == '-' && nextChar == '-' && !inString) {\n                inComment = true;\n                continue;\n            }\n\n            // 如果遇到单引号或双引号，并且不在字符串内，则进入字符串状态\n            if ((c == '\\'' || c == '\\\"') && !inString) {\n                inString = true;\n                stringDelimiter = c;\n                isEmpty = false;\n                continue;\n            }\n\n            // 如果在字符串内，并且遇到了相同的分隔符，则检查是否为转义\n            if (c == stringDelimiter && inString) {\n                if (nextChar == stringDelimiter) {\n                    i++; // 跳过转义的引号\n                } else {\n                    inString = false; // 字符串结束\n                }\n                continue;\n            }\n\n            // 如果遇到分号，并且不在字符串内，则增加计数器\n            if (c == ';' && !inString) {\n                if (!isEmpty) {\n                    count++;\n                    isEmpty = true;\n                }\n                continue;\n            }\n\n            // 如果遇到非空白字符，并且不在字符串内，则标记为非空文本\n            if (!Character.isWhitespace(c) && !inString) {\n                isEmpty = false;\n            }\n        }\n\n        // 如果最后一个文本没有闭合的分号，则增加计数器\n        if (!isEmpty) {\n            count++; // 最后一个文本没有闭合分号\n        }\n\n        return count;\n    }\n}",
      "python": "import sys\n\n# 统计文本中的文本数量\ndef count_texts(input):\n    # 初始化计数器\n    count = 0\n    # 标记是否在字符串内部\n    in_string = False\n    # 标记是否在注释内部\n    in_comment = False\n    # 记录字符串分隔符\n    string_delimiter = ''\n    # 标记当前是否为空文本（即没有遇到非空白字符）\n    isEmpty = True\n\n    # 遍历输入文本的每个字符\n    for i, c in enumerate(input):\n        # 下一个字符（如果存在）\n        next_char = input[i + 1] if i + 1 < len(input) else '\\0'\n\n        # 如果在注释中\n        if in_comment:\n            # 如果遇到换行符，则注释结束\n            if c == '\\n':\n                in_comment = False\n            continue\n\n        # 如果遇到连续的两个减号，并且不在字符串内，则进入注释状态\n        if c == '-' and next_char == '-' and not in_string:\n            in_comment = True\n            i += 1  # 跳过下一个减号\n            continue\n\n        # 如果遇到单引号或双引号，并且不在字符串内，则进入字符串状态\n        if (c == '\\'' or c == '\\\"') and not in_string:\n            in_string = True\n            string_delimiter = c\n            isEmpty = False\n            continue\n\n        # 如果在字符串内，并且遇到了相同的分隔符，则检查是否为转义\n        if c == string_delimiter and in_string:\n            if next_char == string_delimiter:\n                i += 1  # 跳过转义的引号\n            else:\n                in_string = False  # 字符串结束\n            continue\n\n        # 如果遇到分号，并且不在字符串内，则增加计数器\n        if c == ';' and not in_string:\n            if not isEmpty:\n                count += 1\n                isEmpty = True\n            continue\n\n        # 如果遇到非空白字符，并且不在字符串内，则标记为非空文本\n        if not c.isspace() and not in_string:\n            isEmpty = False\n\n    # 如果最后一个文本没有闭合的分号，则增加计数器\n    if not isEmpty:\n        count += 1  # 最后一个文本没有闭合分号\n\n    return count\n\n# 主函数\nif __name__ == \"__main__\":\n    # 使用字符串来构建整个输入文本\n    input = sys.stdin.read()\n    # 输出文本统计结果\n    print(count_texts(input))",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <string>\n\n// 统计文本中的文本数量\nint countTexts(const std::string& input) {\n    // 初始化计数器\n    int count = 0;\n    // 标记是否在字符串内部\n    bool inString = false;\n    // 标记是否在注释内部\n    bool inComment = false;\n    // 记录字符串分隔符\n    char stringDelimiter = 0;\n    // 标记当前是否为空文本（即没有遇到非空白字符）\n    bool isEmpty = true;\n\n    // 遍历输入文本的每个字符\n    for (size_t i = 0; i < input.length(); ++i) {\n        // 当前字符\n        char c = input[i];\n        // 下一个字符（如果存在）\n        char nextChar = (i + 1 < input.length()) ? input[i + 1] : '\\0';\n\n        // 如果在注释中\n        if (inComment) {\n            // 如果遇到换行符，则注释结束\n            if (c == '\\n') {\n                inComment = false;\n            }\n            continue;\n        }\n\n        // 如果遇到连续的两个减号，并且不在字符串内，则进入注释状态\n        if (c == '-' && nextChar == '-' && !inString) {\n            inComment = true;\n            i++; // 跳过下一个减号\n            continue;\n        }\n\n        // 如果遇到单引号或双引号，并且不在字符串内，则进入字符串状态\n        if ((c == '\\'' || c == '\\\"') && !inString) {\n            inString = true;\n            stringDelimiter = c;\n            isEmpty = false;\n            continue;\n        }\n\n        // 如果在字符串内，并且遇到了相同的分隔符，则检查是否为转义\n        if (c == stringDelimiter && inString) {\n            if (nextChar == stringDelimiter) {\n                i++; // 跳过转义的引号\n            } else {\n                inString = false; // 字符串结束\n            }\n            continue;\n        }\n\n        // 如果遇到分号，并且不在字符串内，则增加计数器\n        if (c == ';' && !inString) {\n            if (!isEmpty) {\n                count++;\n                isEmpty = true;\n            }\n            continue;\n        }\n\n        // 如果遇到非空白字符，并且不在字符串内，则标记为非空文本\n        if (!isspace(c) && !inString) {\n            isEmpty = false;\n        }\n    }\n\n    // 如果最后一个文本没有闭合的分号，则增加计数器\n    if (!isEmpty) {\n        count++; // 最后一个文本没有闭合分号\n    }\n\n    return count;\n}\n// 主函数\nint main() {\n    // 创建字符串用于获取用户输入\n    std::string input;\n    // 获取用户输入直到EOF\n    for (std::string line; std::getline(std::cin, line);) {\n        // 将读取的每一行追加到input字符串，并添加换行符\n        input += line + \"\\n\";\n    }\n    // 输出文本统计结果\n    std::cout << countTexts(input) << std::endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <ctype.h>\n\n// 定义最大输入长度\n#define MAX_INPUT_LENGTH 10000\n\n// 函数声明：统计文本中的文本数量\nint countTexts(const char *input);\n\nint main() {\n    // 用来存储输入的字符数组\n    char input[MAX_INPUT_LENGTH] = {0};\n    // 临时字符串存储一行输入\n    char temp[256];\n \n \n    // 循环读取输入直到EOF（文件结束标志）\n    while (fgets(temp, sizeof(temp), stdin) != NULL) {\n        // 将临时字符串追加到输入数组中\n        strcat(input, temp);\n    }\n\n    // 输出文本统计结果\n    printf(\"%d\\n\", countTexts(input));\n\n    return 0;\n}\n\n// 实现统计文本数量的函数\nint countTexts(const char *input) {\n    // 初始化计数器\n    int count = 0;\n    // 标记是否在字符串内部\n    bool inString = false;\n    // 标记是否在注释内部\n    bool inComment = false;\n    // 记录字符串分隔符\n    char stringDelimiter = 0;\n    // 标记当前是否为空文本\n    bool isEmpty = true;\n\n    // 遍历输入文本的每个字符\n    for (int i = 0; input[i] != '\\0'; i++) {\n        char c = input[i];\n        char nextChar = input[i + 1];\n\n        // 处理注释\n        if (inComment) {\n            if (c == '\\n') {\n                inComment = false;\n            }\n            continue;\n        }\n\n        // 进入注释状态\n        if (c == '-' && nextChar == '-' && !inString) {\n            inComment = true;\n            i++; // 跳过下一个减号\n            continue;\n        }\n\n        // 进入字符串状态\n        if ((c == '\\'' || c == '\\\"') && !inString) {\n            inString = true;\n            stringDelimiter = c;\n            isEmpty = false;\n            continue;\n        }\n\n        // 结束字符串状态\n        if (c == stringDelimiter && inString) {\n            if (nextChar == stringDelimiter) {\n                i++; // 跳过转义的引号\n            } else {\n                inString = false;\n            }\n            continue;\n        }\n\n        // 处理分号，增加计数\n        if (c == ';' && !inString) {\n            if (!isEmpty) {\n                count++;\n                isEmpty = true;\n            }\n            continue;\n        }\n\n        // 处理非空白字符\n        if (!isspace(c) && !inString) {\n            isEmpty = false;\n        }\n    }\n\n    // 处理没有闭合分号的最后一个文本\n    if (!isEmpty) {\n        count++;\n    }\n\n    return count;\n}"
    }
  },
  {
    "id": "145",
    "title": "项目排期",
    "examType": "A",
    "score": 200,
    "description": "项目组共有N个开发人员，项目经理接到了M个独立的需求，每个需求的工作量不同，且每个需求只能由一个开发人员独立完成，不能多人合作。假定各个需求直接无任何先后依赖关系，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付。",
    "inputDesc": "第一行输入为M个需求的工作量，单位为天，用逗号隔开。\n例如：X1 X2 X3 … Xm 。表示共有M个需求，每个需求的工作量分别为X1天，X2天…Xm天。\n其中0<M<30；0<Xm<200\n第二行输入为项目组人员数量N",
    "outputDesc": "最快完成所有工作的天数\n输入：\n输出：\n说明：\n共有两位员工，其中一位分配需求 6 2 7 7 3 2 1共需要28天完成，另一位分配需求 9 3 11 4 共需要27天完成，故完成所有工作至少需要28天。",
    "examples": [],
    "solution": "给定一系列任务的工作量和一定数量的工人，计算完成所有任务所需的最少天数，使得每个工人分配到的任务总工作量不超过这个天数。这是一个典型的搜索问题，可以通过回溯法和二分查找结合来解决。\n排序和反转任务数组： 使用Arrays.sort(tasks)对任务数组进行升序排序，然后通过一个循环将数组反转，使其成为降序。这样做是为了优先分配工作量大的任务，从而更高效地利用工人的工作时间。 二分查找： 为了找到完成所有任务所需的最少天数，使用二分查找确定这个最小值。设置两个指针l和r，分别表示可能的最短时间的下界和上界。l初始化为数组中的最大值（即最大的单个任务工作量），r初始化为所有任务工作量的总和。在l小于r的条件下进行循环，计算中间值mid，并使用canFinish函数检查是否可以在mid天内完成所有任务。如果可以完成，则将上界r设置为mid，否则将下界l设置为mid + 1。当l和r相遇时，l即为所求的最少天数。 回溯法： canFinish函数使用回溯法来检查在给定的时间限制limit内是否可以完成所有任务。创建一个长度为工人数量k的数组workers，用于记录每个工人的当前工作量。使用backtrack函数递归地尝试为每个任务分配工人，直到所有任务都被分配或者无法在时间限制内完成分配。在backtrack函数中，如果当前工人可以在时间限制内完成当前任务，则将任务分配给他，并递归地尝试分配下一个任务。如果分配成功，则返回true；如果当前路径无法成功分配所有任务，则回溯到上一个状态，尝试其他可能的分配方案。如果所有方案都无法成功，则返回false。\n排序和反转任务数组：\n使用Arrays.sort(tasks)对任务数组进行升序排序，然后通过一个循环将数组反转，使其成为降序。这样做是为了优先分配工作量大的任务，从而更高效地利用工人的工作时间。\n二分查找：\n为了找到完成所有任务所需的最少天数，使用二分查找确定这个最小值。设置两个指针l和r，分别表示可能的最短时间的下界和上界。l初始化为数组中的最大值（即最大的单个任务工作量），r初始化为所有任务工作量的总和。在l小于r的条件下进行循环，计算中间值mid，并使用canFinish函数检查是否可以在mid天内完成所有任务。如果可以完成，则将上界r设置为mid，否则将下界l设置为mid + 1。当l和r相遇时，l即为所求的最少天数。\n回溯法：\ncanFinish函数使用回溯法来检查在给定的时间限制limit内是否可以完成所有任务。创建一个长度为工人数量k的数组workers，用于记录每个工人的当前工作量。使用backtrack函数递归地尝试为每个任务分配工人，直到所有任务都被分配或者无法在时间限制内完成分配。在backtrack函数中，如果当前工人可以在时间限制内完成当前任务，则将任务分配给他，并递归地尝试分配下一个任务。如果分配成功，则返回true；如果当前路径无法成功分配所有任务，则回溯到上一个状态，尝试其他可能的分配方案。如果所有方案都无法成功，则返回false。",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 使用Scanner读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取第一行输入，即需求的工作量，并以空格分隔\n        String[] workloads = scanner.nextLine().split(\" \");\n        // 读取第二行输入，即项目组人员数量\n        int N = Integer.parseInt(scanner.nextLine());\n        // 创建一个数组来存放每个需求的工作量\n        int[] tasks = new int[workloads.length];\n        \n        // 将输入的工作量转换为整数并存入数组\n        for (int i = 0; i < workloads.length; i++) {\n            tasks[i] = Integer.parseInt(workloads[i]);\n        }\n        \n        // 输出最快完成所有工作的天数\n        System.out.println(minimumTimeRequired(tasks, N));\n    }\n    \n    // 计算完成所有任务所需的最少天数\n    public static int minimumTimeRequired(int[] tasks, int k) {\n        // 将任务按工作量升序排序\n        Arrays.sort(tasks);\n        // 将排序后的数组反转，使之成为降序\n        int low = 0, high = tasks.length - 1;\n        while (low < high) {\n            int temp = tasks[low];\n            tasks[low] = tasks[high];\n            tasks[high] = temp;\n            low++;\n            high--;\n        }\n        \n        // 使用二分查找确定完成所有任务的最短时间\n        int l = tasks[0], r = Arrays.stream(tasks).sum();\n        while (l < r) {\n            int mid = (l + r) / 2;\n            // 检查当前时间限制是否足够完成所有任务\n            if (canFinish(tasks, k, mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        \n        // 返回最短完成时间\n        return l;\n    }\n    \n    // 检查是否可以在给定的时间限制内完成所有任务\n    private static boolean canFinish(int[] tasks, int k, int limit) {\n        // 创建一个数组来记录每个员工的工作量\n        int[] workers = new int[k];\n        // 使用回溯法检查是否可以完成\n        return backtrack(tasks, workers, 0, limit);\n    }\n    \n    // 回溯法\n    private static boolean backtrack(int[] tasks, int[] workers, int index, int limit) {\n        // 如果所有任务都已分配，则返回true\n        if (index >= tasks.length) {\n            return true;\n        }\n        \n        // 获取当前任务的工作量\n        int current = tasks[index];\n        // 尝试将当前任务分配给每个员工\n        for (int i = 0; i < workers.length; i++) {\n            // 如果当前员工可以在时间限制内完成这项任务\n            if (workers[i] + current <= limit) {\n                // 分配任务给当前员工\n                workers[i] += current;\n                // 继续尝试分配下一个任务\n                if (backtrack(tasks, workers, index + 1, limit)) {\n                    return true;\n                }\n                // 回溯，取消当前的任务分配\n                workers[i] -= current;\n            }\n            \n            // 如果当前员工没有任务或者加上当前任务刚好达到时间限制，则不需要尝试其他员工\n            if (workers[i] == 0 || workers[i] + current == limit) {\n                break;\n            }\n        }\n        \n        // 如果无法分配当前任务，则返回false\n        return false;\n    }\n}",
      "python": "# Python版本代码\nfrom itertools import combinations\n\ndef minimumTimeRequired(tasks, k):\n    # 将任务按工作量降序排序\n    tasks.sort(reverse=True)\n    \n    # 使用二分查找确定完成所有任务的最短时间\n    l, r = tasks[0], sum(tasks)\n    while l < r:\n        mid = (l + r) // 2\n        # 检查当前时间限制是否足够完成所有任务\n        if canFinish(tasks, k, mid):\n            r = mid\n        else:\n            l = mid + 1\n    \n    # 返回最短完成时间\n    return l\n\ndef canFinish(tasks, k, limit):\n    # 创建一个数组来记录每个员工的工作量\n    workers = [0] * k\n    # 使用回溯法检查是否可以完成\n    return backtrack(tasks, workers, 0, limit)\n\ndef backtrack(tasks, workers, index, limit):\n    # 如果所有任务都已分配，则返回True\n    if index >= len(tasks):\n        return True\n    \n    # 获取当前任务的工作量\n    current = tasks[index]\n    # 尝试将当前任务分配给每个员工\n    for i in range(len(workers)):\n        # 如果当前员工可以在时间限制内完成这项任务\n        if workers[i] + current <= limit:\n            # 分配任务给当前员工\n            workers[i] += current\n            # 继续尝试分配下一个任务\n            if backtrack(tasks, workers, index + 1, limit):\n                return True\n            # 回溯，取消当前的任务分配\n            workers[i] -= current\n        \n        # 如果当前员工没有任务或者加上当前任务刚好达到时间限制，则不需要尝试其他员工\n        if workers[i] == 0 or workers[i] + current == limit:\n            break\n    \n    # 如果无法分配当前任务，则返回False\n    return False\n\nif __name__ == \"__main__\":\n    # 使用input读取输入\n    tasks = list(map(int, input().split()))\n    N = int(input())\n    \n    # 输出最快完成所有工作的天数\n    print(minimumTimeRequired(tasks, N))",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <sstream> \nusing namespace std;\n// 回溯法\nbool backtrack(vector<int>& tasks, vector<int>& workers, int index, int limit) {\n    // 如果所有任务都已分配，则返回true\n    if (index >= tasks.size()) {\n        return true;\n    }\n    \n    // 获取当前任务的工作量\n    int current = tasks[index];\n    // 尝试将当前任务分配给每个员工\n    for (int i = 0; i < workers.size(); i++) {\n        // 如果当前员工可以在时间限制内完成这项任务\n        if (workers[i] + current <= limit) {\n            // 分配任务给当前员工\n            workers[i] += current;\n            // 继续尝试分配下一个任务\n            if (backtrack(tasks, workers, index + 1, limit)) {\n                return true;\n            }\n            // 回溯，取消当前的任务分配\n            workers[i] -= current;\n        }\n        \n        // 如果当前员工没有任务或者加上当前任务刚好达到时间限制，则不需要尝试其他员工\n        if (workers[i] == 0 || workers[i] + current == limit) {\n            break;\n        }\n    }\n    \n    // 如果无法分配当前任务，则返回false\n    return false;\n}\n// 检查是否可以在给定的时间限制内完成所有任务\nbool canFinish(vector<int>& tasks, int k, int limit) {\n    // 创建一个数组来记录每个员工的工作量\n    vector<int> workers(k, 0);\n    // 使用回溯法检查是否可以完成\n    return backtrack(tasks, workers, 0, limit);\n}\n// 计算完成所有任务所需的最少天数\nint minimumTimeRequired(vector<int>& tasks, int k) {\n    // 将任务按工作量降序排序\n    sort(tasks.begin(), tasks.end(), greater<int>());\n    \n    // 使用二分查找确定完成所有任务的最短时间\n    int l = tasks[0], r = accumulate(tasks.begin(), tasks.end(), 0);\n    while (l < r) {\n        int mid = (l + r) / 2;\n        // 检查当前时间限制是否足够完成所有任务\n        if (canFinish(tasks, k, mid)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    \n    // 返回最短完成时间\n    return l;\n}\n\n\n\n\nint main() {\n    // 使用cin读取输入\n    vector<int> tasks;\n    string input;\n    getline(cin, input);\n    istringstream iss(input);\n    int value;\n    while (iss >> value) {\n        tasks.push_back(value);\n    }\n    int N;\n    cin >> N;\n    \n    // 输出最快完成所有工作的天数\n    cout << minimumTimeRequired(tasks, N) << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_TASKS 30 // 定义最大任务数量的常量，用于设置任务数组的最大长度\n\n// 用于qsort函数的比较函数，实现降序排序\nint compare(const void *a, const void *b) {\n    // 将void指针转换为int指针，并解引用获取值进行比较\n    return (*(int*)b - *(int*)a);\n}\n\n// 回溯法分配任务\nint backtrack(int *tasks, int *workers, int index, int limit, int k, int taskSize) {\n    // 检查是否所有任务都已分配\n    if (index >= taskSize) {\n        return 1; // 如果是，返回1表示成功\n    }\n\n    // 获取当前要分配的任务\n    int current = tasks[index];\n    // 遍历所有员工\n    for (int i = 0; i < k; i++) {\n        // 检查当前员工是否可以在时间限制内完成这个任务\n        if (workers[i] + current <= limit) {\n            // 如果可以，分配任务并递归尝试分配下一个任务\n            workers[i] += current;\n            if (backtrack(tasks, workers, index + 1, limit, k, taskSize)) {\n                return 1;\n            }\n            // 如果不成功，回溯，即撤销这次任务分配\n            workers[i] -= current;\n        }\n\n        // 如果当前员工没有任务或者加上当前任务刚好达到时间限制，则不需要尝试其他员工\n        if (workers[i] == 0 || workers[i] + current == limit) {\n            break;\n        }\n    }\n\n    // 如果无法分配当前任务，返回0表示失败\n    return 0;\n}\n\n// 检查是否能在指定时间内完成所有任务\nint canFinish(int *tasks, int k, int limit, int taskSize) {\n    // 初始化一个记录员工当前任务量的数组\n    int workers[MAX_TASKS] = {0};\n    // 调用回溯法尝试分配任务\n    return backtrack(tasks, workers, 0, limit, k, taskSize);\n}\n\n// 计算完成所有任务的最短时间\nint minimumTimeRequired(int *tasks, int k, int taskSize) {\n    // 先对任务进行降序排序\n    qsort(tasks, taskSize, sizeof(int), compare);\n\n    // 二分查找的左右边界，左边界为最大单个任务时间，右边界为所有任务时间总和\n    int l = tasks[0], r = 0;\n    for (int i = 0; i < taskSize; i++) {\n        r += tasks[i];\n    }\n\n    // 二分查找最短完成时间\n    while (l < r) {\n        int mid = l + (r - l) / 2;\n        // 检查是否能在mid时间内完成所有任务\n        if (canFinish(tasks, k, mid, taskSize)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n\n    // 返回最短完成时间\n    return l;\n}\n\nint main() {\n    // 存储任务的数组和任务数量\n    int tasks[MAX_TASKS], taskSize = 0;\n    // 读取一行输入作为任务工作量\n    char input[200];\n    fgets(input, 200, stdin);\n    // 使用strtok分割字符串，将分割后的数字转换为int存入任务数组\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        tasks[taskSize++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    // 读取员工数量\n    int N;\n    scanf(\"%d\", &N);\n\n    // 计算并输出完成所有任务的最短时间\n    printf(\"%d\\n\", minimumTimeRequired(tasks, N, taskSize));\n    return 0;\n}"
    }
  },
  {
    "id": "146",
    "title": "不含101的数",
    "examType": "A",
    "score": 200,
    "description": "小明在学习二进制时，发现了一类不含 101的数，也就是：\n将数字用二进制表示，不能出现 101 。 现在给定一个整数区间 [l,r] ，请问这个区间包含了多少个不含 101 的数？\n",
    "inputDesc": "输入的唯一一行包含两个正整数 l， r（ 1 ≤ l ≤ r ≤ 10^9）。\n",
    "outputDesc": "输出的唯一一行包含一个整数，表示在 [l,r] 区间内一共有几个不含 101 的数。\n\n本题如果用暴力法求解，很简单\n但是本题的1 ≤ l ≤ r ≤ 10^9，也就是说区间范围最大是 1 ~ 10^9，那么上面O(n)时间复杂度的算法会超时。\n因此，我们需要找到一个性能更优的算法。\n本题需要使用数位DP算法，具体逻辑原理请看\n数位DP - 带3的数_伏城之外的博客-CSDN博客\n数位DP - 带49的数_伏城之外的博客-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int L = sc.nextInt();\n    int R = sc.nextInt();\n    int count = digitSearch(R) - digitSearch(L - 1);\n    System.out.println(count);\n  }\n\n  public static int digitSearch(int num) {\n    Integer[] arr =\n        Arrays.stream(Integer.toBinaryString(num).split(\"\"))\n            .map(Integer::parseInt)\n            .toArray(Integer[]::new);\n\n    int[][][] f = new int[arr.length][2][2];\n\n    return dfs(0, true, f, arr, 0, 0);\n  }\n\n  public static int dfs(int p, boolean limit, int[][][] f, Integer[] arr, int pre, int prepre) {\n    if (p == arr.length) return 1;\n\n    if (!limit && f[p][pre][prepre] != 0) return f[p][pre][prepre];\n\n    int max = limit ? arr[p] : 1;\n    int count = 0;\n\n    for (int i = 0; i <= max; i++) {\n      if (i == 1 && pre == 0 && prepre == 1) continue;\n      count += dfs(p + 1, limit && i == max, f, arr, i, pre);\n    }\n\n    if (!limit) f[p][pre][prepre] = count;\n\n    return count;\n  }\n}",
      "python": "# 算法实现\ndef dfs(p, limit, f, arr, pre, prepre):\n    if p == len(arr):\n        return 1\n\n    if not limit and f[p][pre][prepre] > 0:\n        return f[p][pre][prepre]\n\n    maxV = arr[p] if limit else 1\n    count = 0\n\n    for i in range(maxV + 1):\n        if i == 1 and pre == 0 and prepre == 1:\n            continue\n        count += dfs(p + 1, limit and i == maxV, f, arr, i, pre)\n\n    if not limit:\n        f[p][pre][prepre] = count\n\n    return count\n\n\ndef digitSearch(num):\n    arr = list(map(int, list(format(num, 'b'))))\n    f = [[[0 for k in range(2)] for j in range(2)] for i in range(len(arr))]\n    return dfs(0, True, f, arr, 0, 0)\n\n\n# 输入获取\nL, R = map(int, input().split())\n\n# 算法调用\nprint(digitSearch(R) - digitSearch(L - 1))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const [L, R] = line.split(\" \").map(Number);\n  const count = digitSearch(R) - digitSearch(L - 1);\n\n  console.log(count);\n});\n\nfunction digitSearch(num) {\n  const arr = num.toString(2).split(\"\").map(Number);\n  const f = new Array(arr.length)\n    .fill(0)\n    .map(() => new Array(2).fill(0).map(() => new Array(2)));\n\n  return dfs(0, true, f, arr, 0, 0);\n}\n\nfunction dfs(p, limit, f, arr, pre, prepre) {\n  if (p === arr.length) return 1;\n\n  if (!limit && f[p][pre][prepre]) return f[p][pre][prepre];\n\n  const max = limit ? arr[p] : 1;\n  let count = 0;\n\n  for (let i = 0; i <= max; i++) {\n    if (i === 1 && pre === 0 && prepre === 1) continue;\n    count += dfs(p + 1, limit && i === max, f, arr, i, pre);\n  }\n\n  if (!limit) f[p][pre][prepre] = count;\n\n  return count;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "147",
    "title": "书籍叠放",
    "examType": "A",
    "score": 200,
    "description": "书籍的长、宽都是整数对应 (l,w)。如果书A的长宽度都比B长宽大时，则允许将B排列放在A上面。现在有一组规格的书籍，书籍叠放时要求书籍不能做旋转，请计算最多能有多少个规格书籍能叠放在一起。\n",
    "inputDesc": "输入：books = [[20,16],[15,11],[10,10],[9,10]]\n说明：总共4本书籍，第一本长度为20宽度为16；第二本书长度为15宽度为11，依次类推，最后一本书长度为9宽度为10.\n",
    "outputDesc": "输出：3\n说明: 最多3个规格的书籍可以叠放到一起, 从下到上依次为: [20,16],[15,11],[10,10]\n\n\n本题就是LeetCode - 354 俄罗斯套娃信封问题_伏城之外的博客-CSDN博客\n可以采用耐心排序+二分查找，实现O(nlgn)时间复杂度的算法。\n具体解题思路请看上面博客。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String input = sc.nextLine();\n\n    // (?<=]),(?=\\[) 正则表达式含义是：找这样一个逗号，前面跟着]，后面跟着[\n    // 其中(?<=) 表示前面跟着\n    // 其中(?=) 表示后面跟着\n    Integer[][] books =\n        Arrays.stream(input.substring(1, input.length() - 1).split(\"(?<=]),(?=\\\\[)\"))\n            .map(\n                s ->\n                    Arrays.stream(s.substring(1, s.length() - 1).split(\",\"))\n                        .map(Integer::parseInt)\n                        .toArray(Integer[]::new))\n            .toArray(Integer[][]::new);\n\n    System.out.println(getResult(books));\n  }\n\n  public static int getResult(Integer[][] books) {\n    // 长度升序，若长度相同，则宽度降序\n    Arrays.sort(books, (a, b) -> Objects.equals(a[0], b[0]) ? b[1] - a[1] : a[0] - b[0]);\n    Integer[] widths = Arrays.stream(books).map(book -> book[1]).toArray(Integer[]::new);\n    return getMaxLIS(widths);\n  }\n\n  // 最长递增子序列\n  public static int getMaxLIS(Integer[] nums) {\n    //  dp数组元素dp[i]含义是：长度为i+1的最优子序列的尾数\n    ArrayList<Integer> dp = new ArrayList<>();\n    dp.add(nums[0]);\n\n    for (int i = 1; i < nums.length; i++) {\n      if (nums[i] > dp.get(dp.size() - 1)) {\n        dp.add(nums[i]);\n        continue;\n      }\n\n      if (nums[i] < dp.get(0)) {\n        dp.set(0, nums[i]);\n        continue;\n      }\n\n      int idx = Collections.binarySearch(dp, nums[i]);\n      if (idx < 0) dp.set(-idx - 1, nums[i]);\n    }\n\n    return dp.size();\n  }\n}",
      "python": "# 输入获取\nbooks = eval(input())\n\n\n# 二分查找\ndef binarySearch(arr, key):\n    low = 0\n    high = len(arr) - 1\n\n    while low <= high:\n        mid = (low + high) >> 1\n        midVal = arr[mid]\n\n        if key > midVal:\n            low = mid + 1\n        elif key < midVal:\n            high = mid - 1\n        else:\n            return mid\n\n    return -(low + 1)\n\n\n# 最长递增子序列\ndef getMaxLIS(nums):\n    # dp数组元素dp[i]含义是：长度为i+1的最优子序列的尾数\n    dp = [nums[0]]\n\n    for i in range(1, len(nums)):\n        if nums[i] > dp[-1]:\n            dp.append(nums[i])\n            continue\n\n        if nums[i] < dp[0]:\n            dp[0] = nums[i]\n            continue\n\n        idx = binarySearch(dp, nums[i])\n        if idx < 0:\n            dp[-idx - 1] = nums[i]\n\n    return len(dp)\n\n\n# 算法入口\ndef getResult(books):\n    # 长度升序，若长度相同，则宽度降序\n    books.sort(key=lambda x: (x[0], -x[1]))\n    widths = list(map(lambda x: x[1], books))\n    return getMaxLIS(widths)\n\n\n# 算法调用\nprint(getResult(books))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const books = JSON.parse(line);\n  console.log(getMaxStackCount(books));\n});\n\nfunction getMaxStackCount(books) {\n  // 长度升序，若长度相同，则宽度降序\n  const widths = books\n    .sort((a, b) => (a[0] === b[0] ? b[1] - a[1] : a[0] - b[0]))\n    .map((book) => book[1]);\n\n  return getMaxLIS(widths);\n}\n\n// 最长递增子序列\nfunction getMaxLIS(nums) {\n  // dp数组元素dp[i]含义是：长度为i+1的最优子序列的尾数\n  const dp = [nums[0]];\n\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] > dp[dp.length - 1]) {\n      dp.push(nums[i]);\n      continue;\n    }\n\n    if (nums[i] < dp[0]) {\n      dp[0] = nums[i];\n      continue;\n    }\n\n    const idx = binarySearch(dp, nums[i]);\n    if (idx < 0) dp[-idx - 1] = nums[i];\n  }\n\n  return dp.length;\n}\n\n// 二分查找\nfunction binarySearch(arr, key) {\n  let low = 0;\n  let high = arr.length - 1;\n\n  while (low <= high) {\n    let mid = (low + high) >>> 1;\n    let midVal = arr[mid];\n\n    if (key > midVal) {\n      low = mid + 1;\n    } else if (key < midVal) {\n      high = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n  return -(low + 1);\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "148",
    "title": "任务最优调度",
    "examType": "A",
    "score": 200,
    "description": "给定一个正整数数组表示待系统执行的任务列表，数组的每一个元素代表一个任务，元素的值表示该任务的类型。\n请计算执行完所有任务所需的最短时间。\n任务执行规则如下:\n任务可以按任意顺序执行，且每个任务执行耗时间均为1个时间单位。两个同类型的任务之间必须有长度为N个单位的冷却时间，比如N为2时，在时间K执行了类型3的任务，那么K+1和K+2两个时间不能执行类型3任务。系统在任何一个单位时间内都可以执行一个任务，或者等待状态。\n说明：数组最大长度为1000，数组最大值1000。\n",
    "inputDesc": "第一行记录一个用半角逗号分隔的数组，数组长度不超过1000，数组元素的值不超过1000，第二行记录任务冷却时间，N为正整数，N<=100。\n",
    "outputDesc": "输出为执行完所有任务所需的最短时间。\n\n\n本题考察贪心算法。\n\n我的解题思路如下：\n首先，我们统计出各种任务的数量，并找出数量最多的任务，比如题目用例中：\n其中任务2的数量最多，有3个，我们假设k=3，那么完成所有任务所需时间至少为：\n(k - 1) * (n + 1) + 1\n画图示意如下：\n\n其中n为冷却时间，k为最多任务的数量。\n如果其他任务数量较少的话，可以直接在任务2的冷却时间中运行。比如题目用例运行图如下：\n\n此时，总用时仍然为 (k - 1) * (n + 1) + 1。\n\n理解了上面公式后，我们可以继续看下几种特殊情况：\n1、数量最多的任务有多个，比如用例\n2,2,2,3,3,3\n2\n此时画图示意如下：\n\n此时至少用时为： (k - 1) * (n + 1) + 2\n\n再比如用例\n2,2,2,3,3,3,4,4,4\n2\n\n此时至少用时为： (k - 1) * (n + 1) + 3\n\n可以发现，如果数量最多的任务有多个，假设为p个，则此时至少用时公式应该为：\n(k - 1) * (n + 1) + p\n\n另外，还有一种特殊情况，如下用例\n2,2,2,3,3,3,4,4,4,5,5,5\n2\n此时任务5有两种执行策略：\n策略一如下：\n\n策略二如下：\n\n很明显策略一更加省时。 因为策略一少了任务5的冷却时间。\n可以发现，此时策略一的用时就是：总任务数量（每个任务执行耗时间均为1个时间单位）\n\n因此：\n即取二者较大值。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  // 输入获取\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int[] tasks = Arrays.stream(sc.next().split(\",\")).mapToInt(Integer::parseInt).toArray();\n    int n = sc.nextInt();\n\n    System.out.println(getResult(tasks, n));\n  }\n\n  // 算法入口\n  public static int getResult(int[] tasks, int n) {\n    HashMap<Integer, Integer> cnts = new HashMap<>();\n\n    for (int task : tasks) {\n      cnts.put(task, cnts.getOrDefault(task, 0) + 1);\n    }\n\n    // k表示:最多任务的数量\n    // 比如2,2,2,3， 其中任务2数量最多，有3个，则k = 3\n    int k = cnts.values().stream().max((a, b) -> a - b).orElse(0);\n\n    // p表示:数量为k的任务个数\n    // 比如2,2,2,3,3,3,4， 其中数量为3的任务有2个，分别是任务2，任务3，则p=2\n    int p = 0;\n    for (Integer task : cnts.keySet()) {\n      if (cnts.get(task) == k) p++;\n    }\n\n    return Math.max((k - 1) * (n + 1) + p, tasks.length);\n  }\n}",
      "python": "# 输入获取\ntasks = list(map(int, input().split(\",\")))\nn = int(input())\n\n\n# 算法入口\ndef getResult():\n    cnts = {}\n\n    for task in tasks:\n        cnts[task] = cnts.get(task, 0) + 1\n\n    # k表示: 最多任务的数量\n    # 比如2, 2, 2, 3， 其中任务2数量最多，有3个，则k = 3\n    k = max(cnts.values())\n\n    # p表示: 数量为k的任务个数\n    # 比如2, 2, 2, 3, 3, 3, 4， 其中数量为3的任务有2个，分别是任务2，任务3，则p = 2\n    p = 0\n    for task in cnts:\n        if cnts[task] == k:\n            p += 1\n\n    return max((k - 1) * (n + 1) + p, len(tasks))\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const tasks = lines[0].split(\",\").map(Number);\n    const n = lines[1] - 0;\n\n    console.log(getResult(tasks, n));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(tasks, n) {\n  const cnts = {};\n\n  for (let task of tasks) {\n    cnts[task] ? cnts[task]++ : (cnts[task] = 1);\n  }\n\n  // k表示:最多任务的数量\n  // 比如2,2,2,3， 其中任务2数量最多，有3个，则k = 3\n  const k = Math.max(...Object.values(cnts));\n\n  // p表示:数量为k的任务个数\n  // 比如2,2,2,3,3,3,4， 其中数量为3的任务有2个，分别是任务2，任务3，则p=2\n  let p = 0;\n\n  for (let task in cnts) {\n    if (cnts[task] == k) p++;\n  }\n\n  return Math.max((k - 1) * (n + 1) + p, tasks.length);\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "149",
    "title": "仿LISP运算",
    "examType": "A",
    "score": 200,
    "description": "LISP 语言唯一的语法就是括号要配对。\n形如 (OP P1 P2 …)，括号内元素由单个空格分割。\n其中第一个元素 OP 为操作符，后续元素均为其参数，参数个数取决于操作符类型。\n注意：\n参数 P1, P2 也有可能是另外一个嵌套的 (OP P1 P2 …) ，当前 OP 类型为 add / sub / mul / div（全小写），分别代表整数的加减乘除法，简单起见，所有 OP 参数个数均为 2 。\n举例：\n输入：(mul 3 -7)输出：-21输入：(add 1 2) 输出：3输入：(sub (mul 2 4) (div 9 3)) 输出 ：5输入：(div 1 0) 输出：error\n题目涉及数字均为整数，可能为负；\n不考虑 32 位溢出翻转，计算过程中也不会发生 32 位溢出翻转，\n除零错误时，输出 “error”，\n除法遇除不尽，向下取整，即 3/2 = 1\n",
    "inputDesc": "输入为长度不超过512的字符串，用例保证了无语法错误\n",
    "outputDesc": "输出计算结果或者“error”\n\n(div 12 (sub 45 45))\n\n纯逻辑题，难点在于将括号中的片段截取出来，我的处理方案是，遍历输入的每一个字符，当遇到\")\"时，则在其前面必然存在一个“(”，找到其前面第一个“(”，然后截取“(”和\")\"之间的内容（从栈中截取走），进行计算，将结果回填如栈中。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  public static String getResult(String s) {\n    LinkedList<Character> stack = new LinkedList<>();\n    LinkedList<Integer> leftIdx = new LinkedList<>();\n\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n\n      if (c == ')') {\n        List<Character> fragment = stack.subList(leftIdx.removeLast(), stack.size());\n\n        StringBuilder sb = new StringBuilder();\n        for (int j = 1; j < fragment.size(); j++) sb.append(fragment.get(j));\n\n        fragment.clear();\n\n        String[] tmp = sb.toString().split(\" \");\n\n        String op = tmp[0];\n        int p1 = Integer.parseInt(tmp[1]);\n        int p2 = Integer.parseInt(tmp[2]);\n\n        String res = operate(op, p1, p2);\n        if (\"error\".equals(res)) {\n          return \"error\";\n        } else {\n          for (int k = 0; k < res.length(); k++) stack.add(res.charAt(k));\n        }\n      } else if (c == '(') {\n        leftIdx.add(stack.size());\n        stack.add(c);\n      } else {\n        stack.add(c);\n      }\n    }\n\n    StringBuilder ans = new StringBuilder();\n    for (Character c : stack) ans.append(c);\n    return ans.toString();\n  }\n\n  public static String operate(String op, int p1, int p2) {\n    switch (op) {\n      case \"add\":\n        return p1 + p2 + \"\";\n      case \"sub\":\n        return p1 - p2 + \"\";\n      case \"mul\":\n        return p1 * p2 + \"\";\n      case \"div\":\n        return p2 == 0 ? \"error\" : (int) Math.floor(p1 / (p2 + 0.0)) + \"\";\n      default:\n        return \"error\";\n    }\n  }\n}",
      "python": "import math\n\n# 输入获取\ns = input()\n\n\ndef operate(op, p1, p2):\n    p1 = int(p1)\n    p2 = int(p2)\n    if op == \"add\":\n        return str(p1 + p2)\n    elif op == \"sub\":\n        return str(p1 - p2)\n    elif op == \"mul\":\n        return str(p1 * p2)\n    elif op == \"div\":\n        if p2 == 0:\n            return \"error\"\n        else:\n            return str(int(math.floor(p1 / p2)))\n    else:\n        return \"error\"\n\n\n# 算法入口\ndef getResult():\n    stack = []\n    leftIdx = []\n\n    for i in range(len(s)):\n        if s[i] == ')':\n            l = leftIdx.pop()\n            fragment = stack[l:]\n            del stack[l:]\n\n            op, p1, p2 = \"\".join(fragment[1:]).split(\" \")\n\n            res = operate(op, p1, p2)\n\n            if res == \"error\":\n                return \"error\"\n            else:\n                stack.extend(list(res))\n        elif s[i] == '(':\n            leftIdx.append(len(stack))\n            stack.append(s[i])\n        else:\n            stack.append(s[i])\n\n    return \"\".join(stack)\n\n\n# 调用算法\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "150",
    "title": "会议接待",
    "examType": "A",
    "score": 200,
    "description": "某组织举行会议，来了多个代表团同时到达，接待处只有一辆汽车，可以同时接待多个代表团，为了提高车辆利用率，请帮接待员计算可以坐满车的接待方案，输出方案数量。\n约束:\n一个团只能上一辆车，并且代表团人数 (代表团数量小于30，每个代表团人数小于30)小于汽车容量(汽车容量小于100)需要将车辆坐满\n一个团只能上一辆车，并且代表团人数 (代表团数量小于30，每个代表团人数小于30)小于汽车容量(汽车容量小于100)\n需要将车辆坐满\n",
    "inputDesc": "第一行 代表团人数，英文逗号隔开，代表团数量小于30，每个代表团人数小于30 第二行 汽车载客量，汽车容量小于100\n",
    "outputDesc": "坐满汽车的方案数量 如果无解输出0\n\n\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "​ximport java.util.Arrays;import java.util.Scanner;\npublic class Main {  public static void main(String[] args) {    Scanner sc = new Scanner(System.in);\n    Integer[] nums =        Arrays.stream(sc.nextLine().split(\",\")).map(Integer::parseInt).toArray(Integer[]::new);\n    int bag = Integer.parseInt(sc.nextLine());\n    System.out.println(getResult(nums, bag));  }\n  private static int getResult(Integer[] nums, int bag) {    int n = nums.length;\n    int[][] dp = new int[n + 1][bag + 1];    dp[0][0] = 1;\n    for (int i = 1; i <= n; i++) {      int num = nums[i - 1];      for (int j = 0; j <= bag; j++) {        if (j < num) {          dp[i][j] = dp[i - 1][j];        } else {          dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num];        }      }    }\n    return dp[n][bag];  }}",
      "python": "xxxxxxxxxx# 输入获取nums = list(map(int, input().split(\",\")))bag = int(input())\n\n# 算法入口def getResult():    n = len(nums)\n    dp = [[0] * (bag + 1) for _ in range(n+1)]    dp[0][0] = 1\n    for i in range(1, n + 1):        num = nums[i - 1]        for j in range(bag + 1):            if j < num:                dp[i][j] = dp[i - 1][j]            else:                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - num]\n    return dp[n][bag]\n\n# 算法调用print(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "151",
    "title": "分奖金",
    "examType": "A",
    "score": 200,
    "description": "公司老板做了一笔大生意，想要给每位员工分配一些奖金，想通过游戏的方式来决定每个人分多少钱。 按照员工的工号顺序，每个人随机抽取一个数字。 按照工号的顺序往后排列，遇到第一个数字比自己数字大的，那么，前面的员工就可以获得“距离*数字差值”的奖金。 如果遇不到比自己数字大的，就给自己分配随机数数量的奖金。 例如，按照工号顺序的随机数字是：2,10,3。 那么第2个员工的数字10比第1个员工的数字2大， 所以，第1个员工可以获得1*（10-2）=8。第2个员工后面没有比他数字更大的员工， 所以，他获得他分配的随机数数量的奖金，就是10。 第3个员工是最后一个员工，后面也没有比他更大数字的员工，所以他得到的奖金是3。\n请帮老板计算一下每位员工最终分到的奖金都是多少钱。\n",
    "inputDesc": "第一行n表示员工数量（包含最后一个老板） 第二是每位员工分配的随机数字\n",
    "outputDesc": "最终每位员工分到的奖金数量\n\n注：随机数字不重复，员工数量（包含老板）范围1~10000，随机数范围1~100000\n\n\n本题最简单的思路是双重for，但是时间复杂度是O(m^2)，而m取值1~10000，这个数量级非常有可能超时。\n因此我们需要考虑更优的解法：\n上面算法其实就是找每个数组元素的下一个更大值，因此可以参考\n华为机试 - 找朋友_伏城之外的博客-CSDN博客_找朋友算法\n的解题思路，利用栈结构通过O(n)时间，找出数组每一个元素的下一个更大值。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n\n    int[] arr = new int[m];\n    for (int i = 0; i < m; i++) {\n      arr[i] = sc.nextInt();\n    }\n\n    System.out.println(getResult(arr, m));\n  }\n\n  public static String getResult(int[] arr, int m) {\n    ArrayList<Integer> ans = new ArrayList<>();\n\n    outer:\n    for (int i = 0; i < m; i++) {\n      for (int j = i + 1; j < m; j++) {\n        if (arr[j] > arr[i]) {\n          ans.add((j - i) * (arr[j] - arr[i]));\n          continue outer;\n        }\n      }\n      ans.add(arr[i]);\n    }\n\n    StringJoiner sj = new StringJoiner(\" \");\n    for (Integer an : ans) sj.add(an + \"\");\n    return sj.toString();\n  }\n}",
      "python": "# 输入获取\nm = int(input())\narr = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult(arr, m):\n    ans = []\n    for i in range(m):\n        flag = True\n        for j in range(i+1, m):\n            if arr[j] > arr[i]:\n                flag = False\n                ans.append((j-i) * (arr[j] - arr[i]))\n                break\n\n        if flag:\n            ans.append(arr[i])\n\n    return \" \".join(map(str, ans))\n\n\n# 算法调用\nprint(getResult(arr, m))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const m = lines[0] - 0;\n    const arr = lines[1].split(\" \").map(Number);\n    console.log(getResult(arr, m));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(arr, m) {\n  const ans = [];\n\n  outter: for (let i = 0; i < m; i++) {\n    for (let j = i + 1; j < m; j++) {\n      if (arr[j] > arr[i]) {\n        ans.push((j-i) * (arr[j] - arr[i])); // 距离 * 数字差值\n        continue outter;\n      }\n    }\n    ans.push(arr[i]);\n  }\n\n  return ans.join(\" \");\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "152",
    "title": "学生方阵",
    "examType": "A",
    "score": 200,
    "description": "学校组织活动，将学生排成一个矩形方阵。\n请在矩形方阵中找到最大的位置相连的男生数量。\n这个相连位置在一个直线上，方向可以是水平的，垂直的，成对角线的或者呈反对角线的。\n注：学生个数不会超过10000\n",
    "inputDesc": "输入的第一行为矩阵的行数和列数，接下来的n行为矩阵元素，元素间用”,”分隔。\n",
    "outputDesc": "输出一个整数，表示矩阵中最长的位置相连的男生个数。\n\n\n本题的解题思路其实不难，遍历查找矩阵中每一个M点，然后求该M点的水平、垂直、正对角线、反对角线，四个方向的M点个数，然后保留最大的个数，就是题解。\n\n但是这种方法会存在很多重复的查找，比如\n\n红色M是当前遍历到的M，绿色M是以红色M为原点查找到的M，如上图两个红色M点会重复查找同一条M链。\n为了避免这种重复查找，我们可以增加判断：\n如果当前M点的\n\n如上图红色M的左上、上、左点都是M，因此红色M的\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  static int n;\n  static int m;\n  static String[][] matrix;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in).useDelimiter(\"[,\\n]\");\n\n    n = sc.nextInt();\n    m = sc.nextInt();\n\n    matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = sc.next();\n      }\n    }\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    int ans = 0;\n\n    int[][] offsets = {{0, 1}, {1, 0}, {1, 1}, {1, -1}};\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        if (\"M\".equals(matrix[i][j])) {\n          for (int[] offset : offsets) {\n            int oldI = i - offset[0];\n            int oldJ = j - offset[1];\n\n            if (oldI >= 0 && oldI < n && oldJ >= 0 && oldJ < m && \"M\".equals(matrix[oldI][oldJ])) {\n              continue;\n            }\n\n            int len = 1;\n            int newI = i + offset[0];\n            int newJ = j + offset[1];\n\n            while (newI >= 0\n                && newI < n\n                && newJ >= 0\n                && newJ < m\n                && \"M\".equals(matrix[newI][newJ])) {\n              len++;\n              newI += offset[0];\n              newJ += offset[1];\n            }\n\n            ans = Math.max(ans, len);\n          }\n        }\n      }\n    }\n\n    return ans;\n  }\n}",
      "python": "# 输入获取\nn, m = map(int, input().split(\",\"))\nmatrix = [input().split(\",\") for _ in range(n)]\n\n\n# 算法入口\ndef getResult():\n    ans = 0\n\n    offsets = ((0, 1), (1, 0), (1, 1), (1, -1))\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == \"M\":\n                for offset in offsets:\n                    oldI = i - offset[0]\n                    oldJ = j - offset[1]\n\n                    if n > oldI >= 0 and m > oldJ >= 0 and matrix[oldI][oldJ] == \"M\":\n                        continue\n\n                    length = 1\n                    newI = i + offset[0]\n                    newJ = j + offset[1]\n\n                    while n > newI >= 0 and m > newJ >= 0 and matrix[newI][newJ] == \"M\":\n                        length += 1\n                        newI += offset[0]\n                        newJ += offset[1]\n\n                    ans = max(ans, length)\n\n    return ans\n\n\n# 调用算法\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "153",
    "title": "寻找最优的路测线路",
    "examType": "A",
    "score": 200,
    "description": "评估一个网络的信号质量，其中一个做法是将网络划分为栅格，然后对每个栅格的信号质量计算。\n路测的时候，希望选择一条信号最好的路线（彼此相连的栅格集合）进行演示。\n现给出 R 行 C 列的整数数组 Cov，每个单元格的数值 S 即为该栅格的信号质量（已归一化，无单位，值越大信号越好）。\n要求从 [0, 0] 到 [R-1, C-1]设计一条最优路测路线。返回该路线得分。\n\n规则：\n路测路线可以上下左右四个方向，不能对角路线的评分是以路线上信号最差的栅格为准的，例如路径 8→4→5→9 的值为4，该线路评分为4。线路最优表示该条线路的评分最高。\n",
    "inputDesc": "第一行表示栅格的行数 R\n第二行表示栅格的列数 C\n第三行开始，每一行表示栅格地图一行的信号值，如5 4 5\n",
    "outputDesc": "最优路线的得分\n\n\n\n用例1图示 用例2图示\n\n\n本题需要我们求解 起点(0,0) 到 终点(r-1, c-1) 的所有路径中 \"最大的\" 最小权值节点的权值。\n\n注：每条路径都由至少一个点组成，而每个点都有权值，因此每条路径自身都有一个最小权值节点。比如路径：5→4→5→6→6，其中最小权值节点的权值就是4\n\n本题需要我们找到起点->终点的所有路径各自的最小权值节点，并比较出其中最大的那个。\n其实这个问题就是单源最短路径的变形题，可以使用Dijkstra算法求解，如果不了解Dijistra算法，可以先看下：\nLeetCode - 743 网络延迟时间（Java & JS & Python）伏城之外 -CSDN博客\n\n下面使用Dijistra算法模拟下用例1的解题过程：\n首先，我们需要定义一个dist数组：\n由于dist[x][y]最终记录的是一个最大值，因此我们需要将dist[x][y]初始化为一个最小值，方便后面被更大值替换，由于本题节点（栅格）的权值（信号强度）最小为0，因此这里dist[x][y]可以初始化为0。\n初始时，我们将dist数组所有元素都初始化为0，其中dist[0][0] = matrix[0][0]，因为起点(0,0)到终点(0,0)的路径中只有一个节点(0,0)。\n\n之后，我们需要定义一个优先队列pq，pq记录路径的终点（x,y），各路径终点的优先级为：对应路径\"最大的\"最小权值节点的权值，即dist[x][y]，即dist[x][y]越大，则对应路径终点(x,y)在优先队列中的优先级越高。\n初始时，将(0,0)加入优先队列。\n\n下面开始从优先队列不停取出优先级最高的节点：\n每当从优先队列中取出一个路径终点（优先级最高），则可以获得如下信息：\n之后基于(ux, uy) 向上下左右四个方向探索，如果新位置(vx, vy)不越界，则进入新位置：\n我们得到了一个新的路径，新路径的终点为(vx, vy)，新路径中最小权值节点的权值w为 min(dist[ux][uy], matrix[vx][vy])\n\n另外，如果 w > dist[vx][vy]，则说明我们找到了起点(0,0)到(vx, vy)的更优路径，即找到了更大的最小权值节点，因此需要更新 dist[vx][vy] = w，然后将新路径加入到pq中重新排优先级。\n按此逻辑一直进行，直到pq为空时，我们就找完了起点(0,0)到所有节点的路径的\"最大的\"最小权值节点的权值。\n最后返回 dist[r-1][c-1] 记录的 起点(0,0) 到 (r-1, c-1) 的所有路径中的\"最大的\"最小权值节点的权值即可。\n\n2023.12.04\n本题的优化思路，由于本题固定求(0,0)到(r-1,c-1)的解，即dist[r-1][c-1]，因此一旦dist[r-1][c-1]确定了，即可停止Dijkstra算法，即不需要找到(0,0)到其余点的dist解。\n因此，当pq弹出的点是(r-1, c-1)时，即可提前结束，因为此时dist[r-1][c-1]已经被求解出来，且是最优解。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int r = sc.nextInt();\n    int c = sc.nextInt();\n\n    int[][] matrix = new int[r][c];\n    for (int i = 0; i < r; i++) {\n      for (int j = 0; j < c; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    // dist[i]记录的 起点0 到 终点i 的所有路径中“最大的”最小权值节点的权值\n    // 其中 i 是将二维坐标一维化后的值，比如(x,y)坐标一维化后为 x * c + y; (c是列数)\n    // dist[i] 记录的 “最大的”最小权值节点的权值，因此需要初始化为一个 \"最小的\" 最小权值节点的权值，方便后面被更大者取代，由于本题节点的最小权值>=0，因此这里可以初始化为0\n    int[] dist = new int[r * c];\n    // 起点0 到 终点0 路径的最小权值节点就是自身，即matrix[0][0]点的权重\n    dist[0] = matrix[0][0];\n\n    // 优先队列记录路径（终点），并且路径中的最小权值节点的权值越大，优先级越高\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> dist[b] - dist[a]);\n    // 初始时将(0,0)入队\n    pq.add(0);\n\n    // 上下左右的方向偏移量\n    int[][] offsets = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n    while (pq.size() > 0) {\n      // 取出优先队列中优先级最大的路径（终点）\n      int u = pq.poll();\n\n      // 将一维化坐标u，解析为二维坐标(x,y)\n      int x = u / c;\n      int y = u % c;\n\n      // 已找到dist[r-1][c-1]最优解，则可以提前结束\n      if (x == r - 1 && y == c - 1) break;\n\n      // 向上下左右四个方向探索\n      for (int[] offset : offsets) {\n        // 新位置坐标\n        int newX = x + offset[0];\n        int newY = y + offset[1];\n\n        // 新位置越界则无法访问\n        if (newX < 0 || newX >= r || newY < 0 || newY >= c) continue;\n\n        // 新位置的一维化坐标\n        int v = newX * c + newY;\n        // 当前路径（终点u）的最小权值节点的权值为dist[u]\n        // 要加入当前路径的新位置的点的权值 matrix[newX][newY]\n        // 那么形成的新路径的最小权值节点的权值即为 w = min(dist[u], matrix[newX][newY])\n        int w = Math.min(dist[u], matrix[newX][newY]);\n\n        // 形成的新路径的终点为 v（即新位置一维化坐标）\n        // 而dist[v]记录的是起点到点v的所有路径中“最大的”最小权值节点\n        if (dist[v] < w) {\n          // 因此如果dist[v] < w的话，则更新dist[v]\n          dist[v] = w;\n          // 并将新路径加入优先队列，参与下一轮比较\n          pq.add(v);\n        }\n      }\n    }\n\n    // 返回起点（0，0）到终点(r-1, c-1)的所有路径中\"最大的\"最小权值节点的权值\n    System.out.println(dist[r * c - 1]);\n  }\n}",
      "python": "# 输入获取\nr = int(input())\nc = int(input())\nmatrix = [list(map(int, input().split())) for _ in range(r)]\n\n\n# 算法入口\ndef getResult():\n    # dist[i]记录的 起点0 到 终点i 的所有路径中“最大的”最小权值节点的权值\n    # 其中 i 是将二维坐标一维化后的值，比如(x,y)坐标一维化后为 x * c + y; (c是列数)\n    # dist[i] 记录的 “最大的”最小权值节点的权值，因此需要初始化为一个 \"最小的\" 最小权值节点的权值，方便后面被更大者取代，由于本题节点的最小权值>=0，因此这里可以初始化为0\n    dist = [0] * (r * c)\n    # 起点0 到 终点0 路径的最小权值节点就是自身，即matrix[0][0]点的权重\n    dist[0] = matrix[0][0]\n\n    # 优先队列记录路径（终点），并且路径中的最小权值节点的权值越大，优先级越高\n    # 初始时将(0,0)入队\n    pq = [0]\n\n    # 上下左右的方向偏移量\n    offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    while len(pq) > 0:\n        # 取出优先队列中优先级最大的路径（终点）\n        u = pq.pop()\n\n        # 将一维化坐标u，解析为二维坐标(x,y)\n        x = u // c\n        y = u % c\n\n        # 已找到dist[r-1][c-1]最优解，则可以提前结束\n        if x == r - 1 and y == c - 1:\n            break\n\n        # 向上下左右四个方向探索\n        for offsetX, offsetY in offsets:\n            # 新位置坐标\n            newX = x + offsetX\n            newY = y + offsetY\n\n            # 新位置越界则无法访问\n            if newX < 0 or newX >= r or newY < 0 or newY >= c:\n                continue\n\n            # 新位置的一维化坐标\n            v = newX * c + newY\n            # 当前路径（终点u）的最小权值节点的权值为dist[u]\n            # 要加入当前路径的新位置的点的权值 matrix[newX][newY]\n            #  那么形成的新路径的最小权值节点的权值即为 w = min(dist[u], matrix[newX][newY])\n            w = min(dist[u], matrix[newX][newY])\n\n            # 形成的新路径的终点为 v（即新位置一维化坐标）\n            # 而dist[v]记录的是起点到点v的所有路径中“最大的”最小权值节点\n            if dist[v] < w:\n                # 因此如果dist[v] < w的话，则更新dist[v]\n                dist[v] = w\n                # 并将新路径加入优先队列，参与下一轮比较\n                pq.append(v)\n                # 优先级排序，由于24行是pq.pop()，尾部优先级最大，因此这里升序\n                pq.sort(key=lambda i: dist[i])\n\n    # 返回起点（0，0）到终点(r-1, c-1)的所有路径中\"最大的\"最小权值节点的权值\n    return dist[r * c - 1]\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "154",
    "title": "数字序列比大小",
    "examType": "A",
    "score": 200,
    "description": "A，B两个人玩一个数字比大小的游戏，在游戏前，两个人会拿到相同长度的两个数字序列，两个数字序列不相同的，且其中的数字是随机的。\nA，B各自从数字序列中挑选出一个数字进行大小比较，赢的人得1分，输的人扣1分，相等则各自的分数不变。 用过的数字需要丢弃。\n求A可能赢B的最大分数。\n",
    "inputDesc": "输入数据的第1个数字表示数字序列的长度N，后面紧跟着两个长度为N的数字序列。\n",
    "outputDesc": "A可能赢B的最大分数\n\n\n输入数据第1个数字表示数字序列长度为3，后面紧跟着两个长度为3的数字序列。\n序列A：4 8 10\n序列B：3 6 4\nA可以赢的最大分数是3。获得该分数的比大小过程可以是：\n1）A：4 B：3\n2）A：8 B：6\n3）A：10 B：4\n\n本题其实就是田忌赛马问题，解析可以参考我的这篇博客：\nPOJ - 2287 Tian Ji -- The Horse Racing_伏城之外的博客-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = Integer.parseInt(sc.nextLine());\n    int[] a = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    int[] b = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n    System.out.println(getResult(n, a, b));\n  }\n\n  public static int getResult(int n, int[] a, int[] b) {\n    Arrays.sort(a);\n    Arrays.sort(b);\n\n    int la = 0; // 指向田忌最慢的马\n    int ra = n - 1; // 指向田忌最快的马\n\n    int lb = 0; // 指向齐王最慢的马\n    int rb = n - 1; // 指向齐王最快的马\n\n    int ans = 0; // 记录田忌获得银币数\n\n    while (la <= ra) {\n      if (a[ra] > b[rb]) {\n        // 田忌最快的马 比 齐王最快的马要快, 则直接比\n        ans += 1;\n        ra--;\n        rb--;\n      } else if (a[ra] < b[rb]) {\n        // 田忌最快的马 比 齐王最快的马要慢, 则结果肯定输, 为了保留田忌最快的马, 我们应该用田忌最慢的马去消耗掉齐王最快的马\n        ans -= 1;\n        la++;\n        rb--;\n      } else {\n        // 田忌最快的马 和 齐王最快的 速度相同, 此时如果平局的话，则会让田忌损失最快的马，因此我们应该找到田忌最慢的马, 即田忌必输的马来消耗掉齐王最快的马\n        if (a[la] > b[lb]) {\n          // 如果田忌最慢的马 比 齐王最慢的马 快, 则此时田忌最慢的马不是必输的马\n          ans += 1;\n          la++;\n          lb++;\n        } else {\n          // 如果田忌最慢的马速度 <= 齐王最慢的马速度, 此时应该让田忌最慢的马 去消耗  齐王最快的马\n\n          // 如果齐王最快的马速度 > 田忌最慢的马速度，则田忌失去银币\n          // 如果齐王最快的马速度 == 田忌最慢的马速度，则田忌不失去银币\n          if (b[rb] > a[la]) ans -= 1;\n          la++;\n          rb--;\n        }\n      }\n    }\n\n    return ans;\n  }\n}",
      "python": "# 输入获取\nn = int(input())\na = list(map(int, input().split()))  # 田忌的马速度数组\nb = list(map(int, input().split()))  # 齐王的马速度数组\n\n\n# 算法入口\ndef getResult():\n    a.sort()\n    b.sort()\n\n    la = 0  # 指向田忌最慢的马\n    ra = n - 1  # 指向田忌最快的马\n\n    lb = 0  # 指向齐王最慢的马\n    rb = n - 1  # 指向齐王最快的马\n\n    ans = 0  # 记录田忌获得银币数\n\n    while la <= ra:\n        if a[ra] > b[rb]:\n            #  田忌最快的马 比 齐王最快的马要快, 则直接比\n            ans += 1\n            ra -= 1\n            rb -= 1\n        elif a[ra] < b[rb]:\n            # 田忌最快的马 比 齐王最快的马要慢, 则结果肯定输, 为了保留田忌最快的马, 我们应该用田忌最慢的马去消耗掉齐王最快的马\n            ans -= 1\n            la += 1\n            rb -= 1\n        else:\n            # 田忌最快的马 和 齐王最快的 速度相同, 此时如果平局的话，则会让田忌损失最快的马，因此我们应该找到田忌最慢的马, 即田忌必输的马来消耗掉齐王最快的马\n            if a[la] > b[lb]:\n                # 如果田忌最慢的马 比 齐王最慢的马 快, 则此时田忌最慢的马不是必输的马\n                ans += 1\n                la += 1\n                lb += 1\n            else:\n                # 如果田忌最慢的马速度 <= 齐王最慢的马速度, 此时应该让田忌最慢的马 去消耗  齐王最快的马\n                # 如果齐王最快的马速度 > 田忌最慢的马速度，则田忌失去银币\n                # 如果齐王最快的马速度 == 田忌最慢的马速度，则田忌不失去银币\n                if b[rb] > a[la]:\n                    ans -= 1\n                la += 1\n                rb -= 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "155",
    "title": "最优资源分配",
    "examType": "A",
    "score": 200,
    "description": "某块业务芯片最小容量单位为1.25G，总容量为M*1.25G，对该芯片资源编号为1，2，...，M。该芯片支持3种不同的配置，分别为A、B、C。\n配置A：占用容量为 1.25 * 1 = 1.25G配置B：占用容量为 1.25 * 2 = 2.5G配置C：占用容量为 1.25 * 8 = 10G\n某块板卡上集成了N块上述芯片，对芯片编号为1，2，...，N，各个芯片之间彼此独立，不能跨芯片占用资源。\n给定板卡上芯片数量N、每块芯片容量M、用户按次序配置后，请输出芯片资源占用情况，保证消耗的芯片数量最少。\n\n资源分配规则：按照芯片编号从小到大分配所需资源，芯片上资源如果被占用标记为1，没有被占用标记为0.\n用户配置序列：用户配置是按次序依次配置到芯片中，如果用户配置序列种某个配置超过了芯片总容量，丢弃该配置，继续遍历用户后续配置。\n",
    "inputDesc": "M：每块芯片容量为 M * 1.25G，取值范围为：1~256\nN：每块板卡包含芯片数量，取值范围为1~32\n用户配置序列：例如ACABA，长度不超过1000\n",
    "outputDesc": "板卡上每块芯片的占用情况\n\n用户配置是按次序依次配置到芯片中，如果用户配置序列种某个配置超过了芯片总容量，丢弃该配置，继续遍历用户后续配置。\n\n用户第1个配置A：占用第1块芯片第1个资源，芯片占用情况为：\n10000000\n00000000\n用户第2个配置C：第1块芯片剩余8.75G，配置C容量不够，只能占用第2块芯片，芯片占用情况为：\n10000000\n11111111\n用户第3个配置A：第1块芯片剩余8.75G，还能继续配置，占用第1块芯片第2个资源，芯片占用情况为：\n11000000\n11111111\n用户第4个配置B：第1块芯片剩余7.5G，还能继续配置，占用第1块芯片第3、4个资源，芯片占用情况为：\n11110000\n11111111\n用户第5个配置A：第1块芯片剩余5G，还能继续配置，占用第1块芯片第5个资源，芯片占用情况为：\n11111000\n11111111\n用户第1个配置A：占用第1块芯片第1个资源，芯片占用情况为：\n10000000\n00000000\n用户第2个配置C：第1块芯片剩余8.75G，配置C容量不够，只能占用第2块芯片，芯片占用情况为：\n10000000\n11111111\n用户第3个配置B：第1块芯片剩余8.75G，还能继续配置，占用第1块芯片第2、3个资源，芯片占用情况为：\n11100000\n11111111\n用户第4个配置C：芯片资源不够，丢弃配置，继续下一个配置，本次配置后芯片占用情况保持不变：\n11100000\n11111111\n用户第5个配置B：第1块芯片剩余6.25G,还能继续配置，占用第1块芯片第4、5个资源，芯片占用情况为：\n11111000\n11111111\n本题输出比较难以理解，我这里以用例1解释一下：\n用例1的前两行输入表示：\n板卡上有N=2个芯片，而每个芯片有8个单位容量，因此对应如下：\n00000000\n00000000\n其中每个0代表一个单位容量，而一个芯片有8单位容量，因此第一排8个0代表一个芯片的总容量，第二排8个0代表另一个芯片的总容量。\n理解了这个，本题就不难了。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n    String sequence = sc.next();\n\n    getResult(m, n, sequence);\n  }\n\n  public static void getResult(int m, int n, String sequence) {\n    double[] boardCard = new double[n];\n    Arrays.fill(boardCard, m * 1.25);\n\n    HashMap<Character, Integer> dict = new HashMap<>();\n    dict.put('A', 1);\n    dict.put('B', 2);\n    dict.put('C', 8);\n\n    for (int i = 0; i < sequence.length(); i++) {\n      double need = 1.25 * dict.get(sequence.charAt(i));\n      for (int j = 0; j < n; j++) {\n        if (boardCard[j] >= need) {\n          boardCard[j] -= need;\n          break;\n        }\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      int unUsed = (int) (boardCard[i] / 1.25);\n      int used = m - unUsed;\n\n      StringBuilder sb = new StringBuilder();\n      for (int j = 0; j < used; j++) {\n        sb.append(1);\n      }\n      for (int k = 0; k < unUsed; k++) {\n        sb.append(0);\n      }\n      System.out.println(sb);\n    }\n  }\n}",
      "python": "# 输入获取\nm = int(input())\nn = int(input())\nsequence = input()\n\n\n# 算法入口\ndef getResult(m, n, sequence):\n    boardCard = [m * 1.25] * n\n    mapping = {\"A\": 1, \"B\": 2, \"C\": 8}\n\n    for i in range(len(sequence)):\n        need = 1.25 * mapping[sequence[i]]\n        for j in range(n):\n            if boardCard[j] >= need:\n                boardCard[j] -= need\n                break\n\n    for remain in boardCard:\n        unUsed = int(remain / 1.25)\n        used = m - unUsed\n        print('1' * used + '0' * unUsed)\n\n\n# 算法调用\ngetResult(m, n, sequence)",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 3) {\n    let m = lines[0] - 0;\n    let n = lines[1] - 0;\n    let sequence = lines[2];\n\n    getResult(m, n, sequence);\n    lines.length = 0;\n  }\n});\n\nfunction getResult(m, n, sequence) {\n  boardCard = new Array(n).fill(0).map(() => m * 1.25);\n\n  dict = { A: 1, B: 2, C: 8 };\n\n  for (let i = 0; i < sequence.length; i++) {\n    const need = 1.25 * dict[sequence[i]];\n    for (let j = 0; j < n; j++) {\n      if (boardCard[j] >= need) {\n        boardCard[j] -= need;\n        break;\n      }\n    }\n  }\n\n  boardCard.forEach((remain) => {\n    unUsed = remain / 1.25;\n    used = m - unUsed;\n    console.log(\n      new Array(used).fill(1).join(\"\") + new Array(unUsed).fill(0).join(\"\")\n    );\n  });\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "156",
    "title": "最佳植树距离",
    "examType": "A",
    "score": 200,
    "description": "按照环保公司要求，小明需要在沙化严重的地区进行植树防沙工作，初步目标是种植一条直线的树带。由于有些区域目前不适合种植树木，所以只能在一些可以种植的点来种植树木。\n在树苗有限的情况下，要达到最佳效果，就要尽量散开种植，不同树苗之间的最小间距要尽量大。给你一个适合种情树木的点坐标和一个树苗的数量，请帮小明选择一个最佳的最小种植间距。\n例如，适合种植树木的位置分别为1,3,5,6,7,10,13 树苗数量是3，种植位置在1,7,13，树苗之间的间距都是6，均匀分开，就达到了散开种植的目的，最佳的最小种植间距是6\n",
    "inputDesc": "第1行表示适合种树的坐标数量 第2行是适合种树的坐标位置 第3行是树苗的数量\n例如：\n7 1 5 3 6 10 7 13 3\n",
    "outputDesc": "最佳的最小种植间距\n\n\n\n本题是LeetCode - 1552 两球之间的磁力_伏城之外的博客-CSDN博客\n的换皮题。题解请参考链接博客。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    int[] positions = new int[n];\n    for (int i = 0; i < n; i++) {\n      positions[i] = sc.nextInt();\n    }\n\n    int m = sc.nextInt();\n\n    System.out.println(getResult(n, positions, m));\n  }\n\n  public static int getResult(int n, int[] positions, int m) {\n    Arrays.sort(positions);\n\n    int min = 1, max = positions[n - 1] - positions[0];\n    int ans = 0;\n\n    while (min <= max) {\n      int mid = (min + max) >> 1;\n\n      if (check(positions, m, mid)) {\n        ans = mid;\n        min = mid + 1;\n      } else {\n        max = mid - 1;\n      }\n    }\n\n    return ans;\n  }\n\n  public static boolean check(int[] positions, int m, int minDis) {\n    int count = 1;\n\n    int curPos = positions[0];\n    for (int i = 1; i < positions.length; i++) {\n      if (positions[i] - curPos >= minDis) {\n        count++;\n        curPos = positions[i];\n      }\n    }\n\n    return count >= m;\n  }\n}",
      "python": "# 输入获取\nn = int(input())\npositions = list(map(int, input().split()))\nm = int(input())\n\n\ndef check(minDis):\n    count = 1\n    curPos = positions[0]\n\n    for i in range(1, n):\n        if positions[i] - curPos >= minDis:\n            count += 1\n            curPos = positions[i]\n\n    return count >= m\n\n\n# 算法入口\ndef getResult():\n    positions.sort()\n\n    low = 1\n    high = positions[-1] - positions[0]\n    ans = 0\n\n    while low <= high:\n        mid = (low + high) >> 1\n\n        if check(mid):\n            ans = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst rl = require(\"readline\").createInterface({\n  input: process.stdin,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 3) {\n    const n = lines[0] - 0;\n    const positions = lines[1].split(\" \").map(Number);\n    const m = lines[2] - 0;\n\n    console.log(getResult(n, positions, m));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(n, positions, m) {\n  positions.sort((a, b) => a - b);\n\n  let min = 1;\n  let max = positions[n - 1] - positions[0];\n  let ans = 0;\n\n  while (min <= max) {\n    const mid = (min + max) >> 1;\n    if (check(positions, m, mid)) {\n      ans = mid;\n      min = mid + 1;\n    } else {\n      max = mid - 1;\n    }\n  }\n\n  return ans;\n}\n\nfunction check(positions, m, minDis) {\n  let count = 1;\n  let curPos = positions[0];\n\n  for (let i = 1; i < positions.length; i++) {\n    if (positions[i] - curPos >= minDis) {\n      count++;\n      curPos = positions[i];\n    }\n  }\n\n  return count >= m;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "157",
    "title": "最佳的出牌方法",
    "examType": "A",
    "score": 200,
    "description": "手上有一副扑克牌，每张牌按牌面数字记分（J=11,Q=12,K=13，没有大小王)，出牌时按照以下规则记分：\n出单张，记牌面分数，例如出一张2，得分为2出对或3张，记牌面分数总和再x2，例如出3张3，得分为(3+3+3)x2=18出5张顺，记牌面分数总和再x2，例如出34567顺，得分为(3+4+5+6+7)x2=50出4张炸弹，记牌面分数总和再x3，例如出4张4，得分为4x4x3=48\n求出一副牌最高的得分数\n",
    "inputDesc": "按顺序排好的一副牌，最少1张，最多15张。 1-9输入为数字1-9，10输入为数字0，JQK输入为大写字母JQK. 无需考虑输入非法的情况，例如输入字符不在[0-9JQK]范围或某一张牌超过4张\n",
    "outputDesc": "最高的得分数\n\n积分规则中没有的出牌方式不支持，例如不支持3带1、4带2，不支持5张以上的顺，且10JQKA (0JQK1) 不算顺。\n\n出对3、对4、对7，单张5、6，得分为67;\n出34567顺，再出单张3、4、7，得分为64\n因此最高得分是按对出，可得到最高分67，输出结果67\n\n本题数量级不大，可以考虑暴力破解。\n\n首先定义一个数组card_count，数组索引就是牌分数，数组元素就是牌数量\n因为本题中牌面是不连续的，比如0代表10，但是牌分数是连续的。\n因此，将牌分数作为数组索引来看的话，就可以用一个长度为5的滑窗来在card_count中找顺子。\n由于K牌面分数是13，因此我们只需要定义card_count数组长度为14即可，题目用例可得数组如下：\n\n\n有了card_count之后，我们就可以开始遍历每一种牌（即遍历card_count数组的索引 i ）：\n对于上面这些出牌策略，我们都可以选或者不选，\n比如当前card_count[i] >= 2，那么我们可以选择出对子，也可以选择不出对子\n只有这样，我们才能尝试出所有出牌的策略组合，这里明显需要用到递归和回溯。\n\n2023.10.29\n之前的代码逻辑中，如下（C语言代码，其他语言的考友可以当成伪代码看）\n\n上面代码逻辑是存在重复探索的。\nstartIdx 位置的牌，可以从 for 循环进入出牌逻辑，也可以从 递归进入出牌逻辑，这会产生冗余探索。\n我们可以只基于递归来完成所有出牌策略的探索。只是需要增加 card_count[startIdx] == 0 时，即 startIdx 位置没有牌时，自动递归到 startIdx + 1 位置出牌的逻辑。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  // 保存最大分数\n  static int max_score = 0;\n\n  public static int getResult(String cards) {\n    // 数组索引是牌面分数, 数组元素是牌面数量, 其中 0 索引不用\n    int[] card_count = new int[14];\n\n    // 统计各种牌的数量\n    for (int i = 0; i < cards.length(); i++) {\n      char card = cards.charAt(i);\n\n      // 1-9输入为数字1-9，10输入为数字0，JQK输入为大写字母JQK\n      // 1-9 牌面分数就是 1-9, 0的牌面分数是 10, J=11,Q=12,K=13, 可以发现牌面分数是连续的，可以和card_count数组的索引对应起来\n      if (card == '0') card_count[10]++;\n      else if (card == 'J') card_count[11]++;\n      else if (card == 'Q') card_count[12]++;\n      else if (card == 'K') card_count[13]++;\n      else card_count[card - '0']++;\n    }\n\n    getMaxScore(card_count, cards.length(), 1, 0);\n\n    return max_score;\n  }\n\n  /**\n   * 获取最大分数\n   *\n   * @param card_count 各种牌的数量\n   * @param unused_card_count 剩余牌的总数量\n   * @param startIdx 从哪个位置开始选牌\n   * @param score 此时已获得的总分数\n   */\n  public static void getMaxScore(int[] card_count, int unused_card_count, int startIdx, int score) {\n    // 所有牌都打完了\n    if (unused_card_count == 0) {\n      // 则比较此时出牌策略获得的总分score，和历史最高分max_score，保留较大者\n      max_score = Math.max(score, max_score);\n      return;\n    }\n\n    // 没有可以出的牌，则继续递归到startIdx+1开始出牌\n    if (card_count[startIdx] == 0) {\n      getMaxScore(card_count, unused_card_count, startIdx + 1, score);\n    }\n\n    // 还有可以出的牌，则从startIdx开始出牌\n    // 如果当前牌的数量至少1张\n    if (card_count[startIdx] >= 1) {\n      // 策略1、可以尝试出顺子，由于最大的顺子是9,10,J,Q,K,因此 i 作为顺子起始牌的话，不能超过9，且后续牌面 i+1, i+2, i+3, i+4 的数量都至少有1张\n      if (startIdx <= 9\n          && card_count[startIdx + 1] >= 1\n          && card_count[startIdx + 2] >= 1\n          && card_count[startIdx + 3] >= 1\n          && card_count[startIdx + 4] >= 1) {\n        card_count[startIdx] -= 1;\n        card_count[startIdx + 1] -= 1;\n        card_count[startIdx + 2] -= 1;\n        card_count[startIdx + 3] -= 1;\n        card_count[startIdx + 4] -= 1;\n        // 顺子是5张牌，因此出掉顺子后，可用牌数量减少5张，总分增加 (i + (i+1) + (i+2) + (i+3) + (i+4)) * 2\n        getMaxScore(card_count, unused_card_count - 5, startIdx, score + (5 * startIdx + 10) * 2);\n        // 回溯\n        card_count[startIdx] += 1;\n        card_count[startIdx + 1] += 1;\n        card_count[startIdx + 2] += 1;\n        card_count[startIdx + 3] += 1;\n        card_count[startIdx + 4] += 1;\n      }\n\n      // 策略2、出单张\n      card_count[startIdx] -= 1;\n      getMaxScore(card_count, unused_card_count - 1, startIdx, score + startIdx);\n      card_count[startIdx] += 1;\n    }\n\n    // 如果当前牌的数量至少2张，那么可以出对子\n    if (card_count[startIdx] >= 2) {\n      card_count[startIdx] -= 2;\n      getMaxScore(card_count, unused_card_count - 2, startIdx, score + startIdx * 2 * 2);\n      card_count[startIdx] += 2;\n    }\n\n    // 如果当前牌的数量至少3张，那么可以出三张\n    if (card_count[startIdx] >= 3) {\n      card_count[startIdx] -= 3;\n      getMaxScore(card_count, unused_card_count - 3, startIdx, score + startIdx * 3 * 2);\n      card_count[startIdx] += 3;\n    }\n\n    // 当前当前牌的数量至少4张，那么可以出炸弹\n    if (card_count[startIdx] >= 4) {\n      card_count[startIdx] -= 4;\n      getMaxScore(card_count, unused_card_count - 4, startIdx, score + startIdx * 4 * 3);\n      card_count[startIdx] += 4;\n    }\n  }\n}",
      "python": "# 输入获取\ncards = input()\n\n# 保存最大分数\nmax_score = 0\n\n\n# 获取牌的最大得分\ndef getMaxScore(card_count, unused_card_count, i, score):\n    \"\"\"\n    获取最大分数\n    :param card_count: 各种牌的数量\n    :param unused_card_count: 剩余牌的总数量\n    :param i: 从哪个位置开始选牌\n    :param score: 此时已获得的总分数\n    \"\"\"\n    global max_score\n\n    # 所有牌都打完了\n    if unused_card_count == 0:\n        # 则比较此时出牌策略获得的总分score，和历史最高分max_score，保留较大者\n        max_score = max(max_score, score)\n        return\n\n    # 没有可以出的牌，则继续递归到i+1开始出牌\n    if card_count[i] == 0:\n        getMaxScore(card_count, unused_card_count, i + 1, score);\n\n    # 还有可以出的牌，则从i开始出牌\n    # 如果当前牌的数量至少1张\n    if card_count[i] >= 1:\n        # 策略1、可以尝试出顺子，由于最大的顺子是9,10,J,Q,K,因此 i 作为顺子起始牌的话，不能超过9，且后续牌面 i+1, i+2, i+3, i+4 的数量都至少有1张\n        if i <= 9 and card_count[i + 1] >= 1 and card_count[i + 2] >= 1 and card_count[i + 3] >= 1 and card_count[i + 4] >= 1:\n            card_count[i] -= 1\n            card_count[i + 1] -= 1\n            card_count[i + 2] -= 1\n            card_count[i + 3] -= 1\n            card_count[i + 4] -= 1\n            # 顺子是5张牌，因此出掉顺子后，可用牌数量减少5张，总分增加 (i + (i+1) + (i+2) + (i+3) + (i+4)) * 2\n            getMaxScore(card_count, unused_card_count - 5, i, score + (5 * i + 10) * 2)\n            # 回溯\n            card_count[i] += 1\n            card_count[i + 1] += 1\n            card_count[i + 2] += 1\n            card_count[i + 3] += 1\n            card_count[i + 4] += 1\n\n        # 策略2、出单张\n        card_count[i] -= 1\n        getMaxScore(card_count, unused_card_count - 1, i, score + i)\n        card_count[i] += 1\n\n    # 如果当前牌的数量至少2张，那么可以出对子\n    if card_count[i] >= 2:\n        card_count[i] -= 2\n        getMaxScore(card_count, unused_card_count - 2, i, score + i * 2 * 2)\n        card_count[i] += 2\n\n    # 如果当前牌的数量至少3张，那么可以出三张\n    if card_count[i] >= 3:\n        card_count[i] -= 3\n        getMaxScore(card_count, unused_card_count - 3, i, score + i * 3 * 2)\n        card_count[i] += 3\n\n    # 当前当前牌的数量至少4张，那么可以出炸弹\n    if card_count[i] >= 4:\n        card_count[i] -= 4\n        getMaxScore(card_count, unused_card_count - 4, i, score + i * 4 * 3)\n        card_count[i] += 4\n\n\n# 算法入口\ndef getResult():\n    # 数组索引是牌面分数, 数组元素是牌面数量, 其中 0 索引不用\n    card_count = [0] * 14\n\n    # 统计各种牌的数量\n    for card in cards:\n        # 1-9输入为数字1-9，10输入为数字0，JQK输入为大写字母JQK\n        # 1-9 牌面分数就是 1-9, 0的牌面分数是 10, J=11,Q=12,K=13, 可以发现牌面分数是连续的，可以和card_count数组的索引对应起来\n        if card == '0':\n            card_count[10] += 1\n        elif card == 'J':\n            card_count[11] += 1\n        elif card == 'Q':\n            card_count[12] += 1\n        elif card == 'K':\n            card_count[13] += 1\n        else:\n            i = ord(card) - ord('0')\n            card_count[i] += 1\n\n    getMaxScore(card_count, len(cards), 1, 0)\n\n    return max_score\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "158",
    "title": "目录删除",
    "examType": "A",
    "score": 200,
    "description": "某文件系统中有 N 个目录，每个目录都有一个独一无二的 ID。\n每个目录只有一个父目录，但每个父目录下可以有零个或者多个子目录，目录结构呈树状结构。\n假设，根目录的 ID 为 0，且根目录没有父目录，其他所有目录的 ID 用唯一的正整数表示，并统一编号。\n现给定目录 ID 和其父目录 ID 的对应父子关系表[子目录 ID，父目录 ID]，以及一个待删除的目录 ID，请计算并返回一个 ID 序列，表示因为删除指定目录后剩下的所有目录，返回的ID序列以递增序输出。\n注意\n1、被删除的目录或文件编号一定在输入的 ID 序列中；\n2、当一个目录删除时，它所有的子目录都会被删除。\n",
    "inputDesc": "输入的第一行为父子关系表的长度 m；\n接下来的 m 行为 m 个父子关系对；\n最后一行为待删除的 ID。\n序列中的元素以空格分割，参见样例。\n",
    "outputDesc": "输出一个序列，表示因为删除指定目录后，剩余的目录 ID。\n\n\n本题咋看上去是让模拟N叉树结构，然后做节点删除操作，最后遍历N叉树。\n但是这样的话思考的话，就太复杂了。\n本题其实并不需要删除节点，也不需要遍历N叉树，我们可以在模拟N叉树的过程中，就统计节点，并排除要删除的节点的插入。\n我首先，统计了所有父节点下的子节点，比如\n8 6 10 8 6 0 20 8 2 6\n可以统计为：\n然后从根节点0开始遍历N叉树\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n\n    int[][] relations = new int[m][2];\n    for (int i = 0; i < m; i++) {\n      relations[i][0] = sc.nextInt();\n      relations[i][1] = sc.nextInt();\n    }\n\n    int del = sc.nextInt();\n\n    System.out.println(getResult(m, relations, del));\n  }\n\n  public static String getResult(int m, int[][] relations, int del) {\n    HashMap<Integer, ArrayList<Integer>> tree = new HashMap<>();\n\n    for (int[] relation : relations) {\n      int child = relation[0];\n      int father = relation[1];\n      tree.putIfAbsent(father, new ArrayList<>());\n      tree.get(father).add(child);\n    }\n\n    if (del == 0) {\n      return \"\";\n    }\n\n    ArrayList<Integer> res = new ArrayList<>();\n    dfs(tree, 0, del, res);\n\n    res.sort((a, b) -> a - b);\n    StringJoiner sj = new StringJoiner(\" \");\n    for (Integer v : res) {\n      sj.add(v + \"\");\n    }\n    return sj.toString();\n  }\n\n  public static void dfs(\n      HashMap<Integer, ArrayList<Integer>> tree, int node, int del, ArrayList<Integer> res) {\n    if (tree.containsKey(node)) {\n      ArrayList<Integer> children = tree.get(node);\n      for (Integer child : children) {\n        if (child != del) {\n          res.add(child);\n          dfs(tree, child, del, res);\n        }\n      }\n    }\n  }\n}",
      "python": "# 输入获取\nm = int(input())\nrelations = [list(map(int, input().split())) for _ in range(m)]\nremove = int(input())\n\n\ndef dfs(tree, node, remove, res):\n    if tree.get(node) is not None:\n        children = tree[node]\n        for child in children:\n            if child != remove:\n                res.append(child)\n                dfs(tree, child, remove, res)\n\n\n# 算法入口\ndef getResult():\n    tree = {}\n\n    for child, father in relations:\n        if tree.get(father) is None:\n            tree[father] = []\n        tree[father].append(child)\n\n    if remove == 0:\n        return \"\"\n\n    res = []\n    dfs(tree, 0, remove, res)\n\n    res.sort()\n    return \" \".join(map(str, res))\n\n\n# 调用算法\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "159",
    "title": "符号运算",
    "examType": "A",
    "score": 200,
    "description": "给定一个表达式，求其分数计算结果。\n\n表达式的限制如下：\n所有的输入数字皆为正整数（包括0）仅支持四则运算（+-*/）和括号结果为整数或分数，分数必须化为最简格式（比如6，3/4，7/8，90/7）除数可能为0，如果遇到这种情况，直接输出\"ERROR\"输入和最终计算结果中的数字都不会超出整型范围\n用例输入一定合法，不会出现括号匹配的情况\n",
    "inputDesc": "字符串格式的表达式，仅支持+-*/，数字可能超过两位，可能带有空格，没有负数\n长度小于200个字符\n",
    "outputDesc": "表达式结果，以最简格式表达\n\n\n本题是经典的中缀表达式计算问题。\n\n关于中缀表达式计算，通常是定义两个栈结构：\n下面我们通过几个例子来说明两个栈的工作原理：\n\n\n\n\n\n\n\n\n\n通过上面流程，我们可以发现，每次出栈oper_sign_stack一个运算符，那么就要出栈oper_num_stack两个操作数。\n那么如果存在下面这种情况，是否支持这样的出栈运算逻辑呢？\n\n上面运算出错的问题就在于，当+入栈oper_sign_stack前，我们应该比较要入栈的'+'运算，和栈顶的'*'运算，哪个优先级更高，如果栈顶运算符优先级更高，此时我们应该先将栈顶运算符出栈运算，即如下：\n\n\n\n\n\n另外，对于运算符入栈时，对比oper_sign_stack栈顶的运算符，如果二者优先级一样，则也需要将oper_sign_stack栈顶运算先出栈运算。\n且只要oper_sign_stack栈顶的运算符 的优先级>= 需要入栈的运算符，则oper_sign_stack就需要不停的出栈运算。\n\n\n\n因此，总结一下就是，如果扫描到了运算符，此时需要和oper_sign_stack栈顶的运算符比较优先级，如果栈顶运算符优先级 >= 当前扫描运算符，则栈顶运算符需要出栈运算，直到oper_sign_stack栈顶运算符优先级小于当前扫描运算符。\n\n另外，本题表达式中还可能出现()，那么遇到括号该怎么处理呢？\n\n\n\n也就是说：\n'(' 对于 +-*/ 运算的入栈oper_sign_stack的逻辑不产生影响，仅用于扫描到')'时oper_sign_stack的出栈结束界定。\n需要注意的时，()内的+-*/运算依旧按照之前的逻辑入栈oper_sign_stack。\n\n以上就是中缀表达式的基于双栈的解题思路。更具体的逻辑，请看代码实现。\n\n本题还对中缀表达式计算做了一些改动，即要求的除法不是整除，而是保留最简分数结果。\n比如 1 / 2 + 3 / 4 的结果不是0，而是 5 / 4。\n\n解决方案很简单，我们之前在 oper_num_stack 中记录的都是整数操作数，现在我们只要改为分数操作数即可。\n但是编程语言中并不支持分数，因此我们可以将分数拆分为分子和分母两部分，进行记录。即可以定义一个类，有如下属性：\n{ ch:, // 分子 fa:, // 分母 }\n分数的分子和分母必然是整数。\n\n如果入栈的元素是一个整数num，则将其转化为如下分数后入栈oper_num_stack\n{ ch: num, fa: 1, }\n\n当我们需要进行出栈运算时，取出的oper_num_stack栈顶的两个操作数，假设分别为a,b，则：\n对于加法运算的结果为：\n{ ch: a.ch * b.fa + b.ch * a.fa, fa: a.fa * b.fa, }\n比如 a = 1 / 3， b = 3 / 4，进行加法运算时，我们应该将他们的分母变为一样，即同时转为 3 * 4\n则 a = (1 * 4) / (3 * 4)， b = （3 * 3）/ (4 * 3)\n\n按照此逻辑，减法运算结果为：\n{ ch: a.ch * b.fa - b.ch * a.fa, fa: a.fa * b.fa, }\n\n而乘法运算结果：\n{ ch: a.ch * b.ch, fa: a.fa * b.fa, }\n\n除法运算结果为：\n{ ch: a.ch * b.fa, fa: a.fa * b.ch, }\n\n这样的话，我们就完成了分数的四则运算。\n\n最后就是关于，分数的最简格式转化了，其实也很简单，就是将分子、分母的最大公约数求解出来，然后分子、分母同时除以最大公约数，即可得到最简格式的分数。\n而两个数的最大公约数的求解，可以使用辗转相除法。如果不熟悉辗转相除法，可以去网上搜索相关资料。\n\n\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  // 分数\n  static class Fractions {\n    int fa; // 分母\n    int ch; // 分子\n\n    public Fractions() {}\n\n    public Fractions(int fa, int ch) {\n      this.fa = fa;\n      this.ch = ch;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  // 操作数栈\n  static LinkedList<Fractions> oper_num = new LinkedList<>();\n  // 操作符栈\n  static LinkedList<Character> oper_sign = new LinkedList<>();\n\n  public static String getResult(String s) {\n    // +,-,*,/ 运算符优先级\n    HashMap<Character, Integer> priority = new HashMap<>();\n    priority.put('+', 1);\n    priority.put('-', 1);\n    priority.put('*', 2);\n    priority.put('/', 2);\n\n    // 操作数的字符缓存容器\n    StringBuilder numStr = new StringBuilder();\n\n    int i = 0;\n    while (i < s.length()) {\n      char c = s.charAt(i);\n\n      // 遇到数字字符\n      if (c >= '0' && c <= '9') {\n        // 则将该数字所在操作数的剩余数字字符一次性探索完\n        while (c >= '0' && c <= '9') {\n          numStr.append(c);\n          if (i + 1 >= s.length()) break;\n          i++;\n          c = s.charAt(i);\n        }\n        // 探索完后，将操作数缓存容器中记录的字符，变为分数后，压入操作数栈\n        oper_num.addLast(new Fractions(1, Integer.parseInt(numStr.toString())));\n        // 注意清空操作数缓存容器\n        numStr = new StringBuilder();\n      }\n\n      // 遇到运算符\n      if (c == '+' || c == '-' || c == '*' || c == '/') {\n        // 只要栈顶运算符的优先级 >= 当前运算符，就需要不停出栈运算\n        while (oper_sign.size() > 0\n            && oper_sign.getLast() != '('\n            && priority.get(c) <= priority.get(oper_sign.getLast())) {\n          calc();\n        }\n        oper_sign.addLast(c);\n      } else if (c == ')') {\n        // 遇到')', 需要将操作符栈中靠近栈顶的'('后面的运算都出栈做了\n        while (oper_sign.getLast() != '(') {\n          calc();\n        }\n        // 最后将')'对应的'('出栈\n        oper_sign.removeLast();\n      } else if (c == '(') {\n        // 遇到'('，则直接压倒操作符栈\n        oper_sign.add(c);\n      }\n\n      i++;\n    }\n\n    // oper_num栈中还有2个以上的数，则还需要进行运算\n    while (oper_num.size() > 1) {\n      calc();\n    }\n\n    // oper_num栈中只剩一个数时，该数就是表达式结果\n    Fractions result = oper_num.removeLast();\n\n    // 如果结果的分母为0（除数为0），则不合法\n    if (result.fa == 0) {\n      return \"ERROR\";\n    }\n\n    // 求分子、分母的最大公约数，并进行约份，求得最简格式的分子，分母\n    int k = getMaxCommonDivisor(result.fa, result.ch);\n    result.fa /= k;\n    result.ch /= k;\n\n    // 求计算结果的符号，这里用乘法是为了避免 分母小，分子大，除法结果为0的情况，这样会丢失符号信息\n    String sign = result.fa * result.ch < 0 ? \"-\" : \"\";\n\n    int fa = Math.abs(result.fa);\n    int ch = Math.abs(result.ch);\n\n    if (fa == 1) {\n      // 如果分母为1，则直接输出分子\n      return sign + ch;\n    } else {\n      // 如果分母不为1，则输出 分子 / 分母\n      return sign + ch + \"/\" + fa;\n    }\n  }\n\n  // 取出oper_num栈顶两个操作数进行运算\n  public static void calc() {\n    // 操作数顺序会对运算产生影响\n    Fractions b = oper_num.removeLast(); // 栈顶元素是运算符右边的操作数\n    Fractions a = oper_num.removeLast(); // 栈顶倒数第二个元素是运算符左边的操作数\n\n    // 运算符\n    char op = oper_sign.removeLast();\n\n    // 记录运算结果\n    Fractions result = new Fractions();\n\n    switch (op) {\n      case '+':\n        result.fa = a.fa * b.fa;\n        result.ch = a.ch * b.fa + b.ch * a.fa;\n        break;\n      case '-':\n        result.fa = a.fa * b.fa;\n        result.ch = a.ch * b.fa - b.ch * a.fa;\n        break;\n      case '*':\n        result.fa = a.fa * b.fa;\n        result.ch = a.ch * b.ch;\n        break;\n      case '/':\n        result.fa = a.fa * b.ch;\n        result.ch = a.ch * b.fa;\n        break;\n    }\n\n    oper_num.add(result);\n  }\n\n  // 辗转相除法，求两个数的最大公约数\n  public static int getMaxCommonDivisor(int x, int y) {\n    while (y != 0) {\n      int tmp = y;\n      y = x % y;\n      x = tmp;\n    }\n    return x;\n  }\n}",
      "python": "# 输入获取\ns = input()\n\n# 操作数栈\noper_num = []\n# 操作符栈\noper_sign = []\n\n\n# 分数类\nclass Fractions:\n    def __init__(self, fa, ch):\n        self.fa = fa  # 分母\n        self.ch = ch  # 分子\n\n\n# 辗转相除法，求两个数的最大公约数\ndef getMaxCommonDivisor(x, y):\n    while y != 0:\n        tmp = y\n        y = x % y\n        x = tmp\n\n    return x\n\n\n# 取出oper_num栈顶两个操作数进行运算\ndef calc():\n    # 操作数顺序会对运算产生影响\n    b = oper_num.pop()  # 栈顶元素是运算符右边的操作数\n    a = oper_num.pop()  # 栈顶倒数第二个元素是运算符左边的操作数\n\n    # 运算符\n    op = oper_sign.pop()\n\n    # 记录运算结果\n    result = Fractions(None, None)\n\n    if op == '+':\n        result.fa = a.fa * b.fa\n        result.ch = a.ch * b.fa + b.ch * a.fa\n    elif op == '-':\n        result.fa = a.fa * b.fa\n        result.ch = a.ch * b.fa - b.ch * a.fa\n    elif op == '*':\n        result.fa = a.fa * b.fa\n        result.ch = a.ch * b.ch\n    elif op == '/':\n        result.fa = a.fa * b.ch\n        result.ch = a.ch * b.fa\n\n    oper_num.append(result)\n\n\ndef getResult():\n    # +,-,*,/ 运算符优先级\n    priority = {\n        \"+\": 1,\n        \"-\": 1,\n        \"*\": 2,\n        \"/\": 2\n    }\n\n    # 操作数的字符缓存容器\n    numStr = []\n\n    i = 0\n    while i < len(s):\n        c = s[i]\n\n        # 遇到数字字符\n        if '9' >= c >= '0':\n            # 则将该数字所在操作数的剩余数字字符一次性探索完\n            while '9' >= c >= '0':\n                numStr.append(c)\n                if i + 1 >= len(s):\n                    break\n                i += 1\n                c = s[i]\n\n            # 探索完后，将操作数缓存容器中记录的字符，变为分数后，压入操作数栈\n            oper_num.append(Fractions(1, int(\"\".join(numStr))))\n            # 注意清空操作数缓存容器\n            numStr.clear()\n\n        # 遇到运算符\n        if c == '+' or c == '-' or c == '*' or c == '/':\n            # 只要栈顶运算符的优先级 >= 当前运算符，就需要不停出栈运算\n            while len(oper_sign) > 0 and oper_sign[-1] != '(' and priority[c] <= priority[oper_sign[-1]]:\n                calc()\n            oper_sign.append(c)\n        elif c == ')':\n            # 遇到')', 需要将操作符栈中靠近栈顶的'('后面的运算都出栈做了\n            while oper_sign[-1] != '(':\n                calc()\n            # 最后将')'对应的'('出栈\n            oper_sign.pop()\n        elif c == '(':\n            # 遇到'('，则直接压倒操作符栈\n            oper_sign.append(c)\n\n        i += 1\n\n    # oper_num栈中还有2个以上的数，则还需要进行运算\n    while len(oper_num) > 1:\n        calc()\n\n    # oper_num栈中只剩一个数时，该数就是表达式结果\n    result = oper_num.pop()\n\n    # 如果结果的分母为0（除数为0），则不合法\n    if result.fa == 0:\n        return \"ERROR\"\n\n    # 求分子、分母的最大公约数，并进行约份，求得最简格式的分子，分母\n    k = getMaxCommonDivisor(result.fa, result.ch)\n    result.fa //= k\n    result.ch //= k\n\n    # 求计算结果的符号，这里用乘法是为了避免 分母小，分子大，除法结果为0的情况，这样会丢失符号信息\n    sign = \"-\" if result.fa * result.ch < 0 else \"\"\n\n    fa = abs(result.fa)\n    ch = abs(result.ch)\n\n    if fa == 1:\n        #  如果分母为1，则直接输出分子\n        return f\"{sign}{ch}\"\n    else:\n        # 如果分母不为1，则输出 分子 / 分母\n        return f\"{sign}{ch}/{fa}\"\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "160",
    "title": "简易内存池",
    "examType": "A",
    "score": 200,
    "description": "请实现一个简易内存池,根据请求命令完成内存分配和释放。内存池支持两种操作命令，REQUEST和RELEASE，其格式为：REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0，则输出error。RELEASE=释放的内存首地址 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。\n\n注意：\n内存池总大小为100字节。内存池地址分配必须是连续内存，并优先从低地址分配。内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放。不会释放已申请的内存块的中间地址。释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。\n",
    "inputDesc": "首行为整数 N , 表示操作命令的个数，取值范围：0 < N <= 100。\n接下来的N行, 每行将给出一个操作命令，操作命令和参数之间用 “=”分割。\n",
    "outputDesc": "请求分配指定大小内存时，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0，则输出error\n释放掉之前分配的内存时，释放成功无需输出，如果释放不存在的首地址则输出error。\n\n第一条指令，申请地址0~9的10个字节内存，返回首地址0\n第二条指令，申请地址10~29的20字节内存，返回首地址10\n第三条指令，释放首地址为0的内存申请，0~9地址内存被释放，变为空闲，释放成功，无需输出\n第四条指令，申请20字节内存，09地址内存连续空间不足20字节，往后查找到3049地址，返回首地址30\n第五条指令，申请10字节，0~9地址内存空间足够，返回首地址0\n我的解题思路如下：\n定义一个used数组，用来存储已被占用的内存区间，即[起始位置，结束位置]。\n初始化给used数组一个 [100,101]，表示存在一个已占有内存区间[100,101]，这个内存区间将作为尾边界使用。\n\n当REQUEST申请size大小的内存时，我们从start=0位置开始申请，即申请[start, start+size-1]区间，接下来看该区间是否和used[i]区间存在交叉，如果存在交xian叉，则说明申请的内存区间中部分内存已被使用，因此我们应该更新 start = used[i][1] + 1位置，重新申请一个区间，这样就必然不和used[i]区间交叉了，但是要继续和used[i+1]区间比较。\n直到找到一个不存在交叉的内存区间，打印此时的start，并将申请到的内存区间插入到used数组中，注意插入位置是 i 。\n如果一直都找不到不存在交叉的内存区间，则打印error。\n\n当RELEASE释放起始位置addr的内存时，我们只需要遍历每一个used[i]，比较used[i][0]和addr是否相同，若相同，则表示找到了要释放的内存，此时只要将used[i]从used中删除即可。\n如果没有找到，则打印error。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  // 输入获取\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    String[][] cmds = new String[n][2];\n    for (int i = 0; i < n; i++) cmds[i] = sc.next().split(\"=\");\n\n    getResult(n, cmds);\n  }\n\n  // 算法入口\n  public static void getResult(int n, String[][] cmds) {\n    // used保存被占用的内存 [起始地址，结束地址]，初始时有一个[100,101]作为尾边界限定\n    LinkedList<Integer[]> used = new LinkedList<>();\n    used.add(new Integer[] {100, 101});\n\n    for (String[] cmd : cmds) {\n      String key = cmd[0];\n      String val = cmd[1];\n\n      // 申请内存\n      if (\"REQUEST\".equals(key)) {\n        // 当指令为REQUEST时，对应值为要申请的内存的大小，即size\n        int size = Integer.parseInt(val);\n\n        // 我们默认从start=0位置开始检查可用内存区间\n        int start = 0;\n        boolean flag = true;\n\n        for (int i = 0; i < used.size(); i++) {\n          int end = start + size - 1;\n          // 要申请的内存区间\n          Integer[] range = {start, end};\n\n          // 检查要申请的内存区间和已占有的内存区间是否交叉\n          if (!hasIntersection(used.get(i), range)) {\n            // 若不存在交叉，则将申请区间加入used中\n            used.add(i, range);\n            flag = false;\n            // 并打印此时申请区间的起始位置\n            System.out.println(start);\n            break;\n          } else {\n            // 若存在交叉，则将变更要申请的内存区间的起始位置\n            start = used.get(i)[1] + 1;\n          }\n        }\n\n        // 一旦申请到内存，那么flag就会被赋值为false，否则就保持true，意味着每申请到内存，则打印error\n        if (flag) System.out.println(\"error\");\n      }\n      // 释放内存\n      else {\n        //  当指令为RELEASE时，值为要释放内存的起始地址addr\n        int addr = Integer.parseInt(val);\n        boolean flag = true;\n\n        for (int i = 0; i < used.size(); i++) {\n          // 到已占有内存中找起始位置是addr的，找到则将该区间从used中删除，表示解除占用\n          if (used.get(i)[0] == addr) {\n            used.remove(i);\n            flag = false;\n            break;\n          }\n        }\n\n        // 一旦释放成功，则flag就会被置为false，否则就保持True,意味着没有内存释放，则打印error\n        if (flag) System.out.println(\"error\");\n      }\n    }\n  }\n\n  // 判断两个区间是否存在交集\n  public static boolean hasIntersection(Integer[] range1, Integer[] range2) {\n    int s1 = range1[0];\n    int e1 = range1[1];\n\n    int s2 = range2[0];\n    int e2 = range2[1];\n\n    if (s1 == s2) return true;\n    else if (s1 < s2) return e1 >= s2;\n    else return e2 >= s1;\n  }\n}",
      "python": "# 输入获取\nn = int(input())\ncmds = [input().split(\"=\") for _ in range(n)]\n\n\n# 判断两个区间是否存在交集\ndef hasIntersection(a1, a2):\n    s1, e1 = a1\n    s2, e2 = a2\n\n    if s1 == s2:\n        return True\n    elif s1 < s2:\n        return e1 >= s2\n    else:\n        return e2 >= s1\n\n\n# 算法入口\ndef getResult():\n    # used保存被占用的内存 [起始地址，结束地址]，初始时有一个[100,101]作为尾边界限定\n    used = [[100, 101]]\n\n    for key, val in cmds:\n        # 申请内存\n        if key == \"REQUEST\":\n            # 当指令为REQUEST时，对应值为要申请的内存的大小，即size\n            size = int(val)\n\n            #  我们默认从start=0位置开始检查可用内存区间\n            start = 0\n            flag = True\n\n            for i in range(len(used)):\n                end = start + size - 1\n\n                # 要申请的内存区间\n                ran = [start, end]\n\n                # 检查要申请的内存区间和已占有的内存区间是否交叉\n                if not hasIntersection(used[i], ran):\n                    # 若不存在交叉，则将申请区间加入used中\n                    used.insert(i, ran)\n                    flag = False\n                    # 并打印此时申请区间的起始位置\n                    print(start)\n                    break\n                else:\n                    #  若存在交叉，则将变更要申请的内存区间的起始位置\n                    start = used[i][1] + 1\n\n            # 一旦申请到内存，那么flag就会被赋值为false，否则就保持true，意味着每申请到内存，则打印error\n            if flag:\n                print(\"error\")\n        # 释放内存\n        else:\n            # 当指令为RELEASE时，值为要释放内存的起始地址addr\n            addr = int(val)\n            flag = True\n\n            for i in range(len(used)):\n                # 到已占有内存中找起始位置是addr的，找到则将该区间从used中删除，表示解除占用\n                if used[i][0] == addr:\n                    used.pop(i)\n                    flag = False\n                    break\n\n            # 一旦释放成功，则flag就会被置为false，否则就保持True,意味着没有内存释放，则打印error\n            if flag:\n                print(\"error\")\n\n\n# 算法调用\ngetResult()",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = lines[0] - 0;\n  }\n\n  if (n && lines.length === n + 1) {\n    lines.shift();\n    getResult(lines.map((line) => line.split(\"=\")));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(commands) {\n  // used保存被占用的内存 [起始地址，结束地址]，初始时有一个[100,101]作为尾边界限定\n  const used = [[100, 101]];\n\n  for (let [key, val] of commands) {\n    // 申请内存\n    if (key === \"REQUEST\") {\n      // 当指令为REQUEST时，对应值为要申请的内存的大小，即size\n      const size = val - 0;\n\n      // 我们默认从start=0位置开始检查可用内存区间\n      let start = 0;\n      let flag = true;\n\n      for (let i = 0; i < used.length; i++) {\n        let end = start + size - 1;\n        // 要申请的内存区间\n        const range = [start, end];\n        // 检查要申请的内存区间和已占有的内存区间是否交叉\n        if (!hasIntersection(used[i], range)) {\n          // 若不存在交叉，则将申请区间加入used中\n          used.splice(i, 0, range);\n          flag = false;\n          // 并打印此时申请区间的起始位置\n          console.log(start);\n          break;\n        } else {\n          // 若存在交叉，则将变更要申请的内存区间的起始位置\n          start = used[i][1] + 1;\n        }\n      }\n\n      // 一旦申请到内存，那么flag就会被赋值为false，否则就保持true，意味着每申请到内存，则打印error\n      if (flag) console.log(\"error\");\n    }\n    // 释放内存\n    else {\n      //  当指令为RELEASE时，值为要释放内存的起始地址addr\n      const addr = val - 0;\n      let flag = true;\n\n      for (let i = 0; i < used.length; i++) {\n        // 到已占有内存中找起始位置是addr的，找到则将该区间从used中删除，表示解除占用\n        if (used[i][0] === addr) {\n          used.splice(i, 1);\n          flag = false;\n          break;\n        }\n      }\n\n      // 一旦释放成功，则flag就会被置为false，否则就保持True,意味着没有内存释放，则打印error\n      if (flag) console.log(\"error\");\n    }\n  }\n}\n\n// 判断两个区间是否存在交集\nfunction hasIntersection(area1, area2) {\n  const [s1, e1] = area1;\n  const [s2, e2] = area2;\n\n  if (s1 === s2) return true;\n  else if (s1 < s2) return e1 >= s2;\n  else return e2 >= s1;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "161",
    "title": "篮球游戏",
    "examType": "A",
    "score": 200,
    "description": "幼儿园里有一个放倒的圆桶，它是一个线性结构，允许在桶的右边将篮球放入，可以在桶的左边和右边将篮球取出。\n每个篮球有单独的编号，老师可以连续放入一个或多个篮球，小朋友可以在桶左边或右边将篮球取出，当桶只有一个篮球的情况下，必须从左边取出。\n如老师按顺序放入1、2、3、4、5 共有 5 个编号的篮球，那么小朋友可以依次取出编号为1、2、3、4、5 或者 3、1、2、4、5 编号的篮球，无法取出 5、1、3、2、4 编号的篮球。\n其中 3、1、2、4、5 的取出场景为：\n连续放入1、2、3号从右边取出3号 从左边取出1号 从左边取出2号放入4号从左边取出4号放入5号从左边取出5号\n简答起见，我们以 L 表示左，R表示右，此时取出篮球的依次取出序列为“RLLLL”。\n",
    "inputDesc": "每次输入包含一个测试用例：\n第一行的数字作为老师依次放入的篮球编号第二行的数字作为要检查是否能够按照放入的顺序取出给定的篮球的编号，其中篮球的编号用逗号进行分隔。\n其中篮球编号用逗号进行分隔。\n",
    "outputDesc": "对于每个篮球的取出序列，如果确实可以获取，请打印出其按照左右方向的操作取出顺序，如果无法获取则打印“NO”。\n\n\n\n本题可以使用双端队列dque来模拟圆桶。\n假设\n第一行给定放入顺序是inputs\n第二行给定取出顺序是outputs\n由于需要按照outputs顺序取出，因此我们定义一个index指向当前outputs要被取出的元素，\n初始时index = 0\n\n按照inputs顺序依次放入（篮球编号）到dque（圆桶）右边（addLast操作），每当放入一个后，则需要进行多次取出检查，即一次放入后，可以进行多次取出行为：\n假设\n圆桶左边篮球编号是left，则 left = dque.getFirst\n圆桶右边篮球编号是right，则 right = dque.getLast\n当前要取出的篮球编号是outputs[index]\n优先检查 outputs[index] 编号的篮球是不是left 的原因是：题目说当桶只有一个篮球的情况下，必须从左边取出\n\n最后，完成上面逻辑，检查圆桶中是否有剩余篮球\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int[] inputs = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n    int[] outputs = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n\n    // 利用队列结构模拟圆桶\n    LinkedList<Integer> queue = new LinkedList<>();\n\n    // outputs[index]是要被取出的篮球的编号\n    int index = 0;\n\n    // 记录题解\n    StringBuilder sb = new StringBuilder();\n\n    for (int input : inputs) {\n      // 按照放入顺序，从圆桶右边放入\n      queue.addLast(input);\n\n      // 然后开始尝试取出\n      while (queue.size() > 0) {\n        // 圆桶左边的篮球的编号\n        int left = queue.getFirst();\n        // 圆桶右边的篮球的编号\n        int right = queue.getLast();\n\n        if (left == outputs[index]) {\n          // 优先比较圆桶左边的篮球是不是当前要取出的篮球，优先左边的原因是：当桶只有一个篮球的情况下，必须从左边取出\n          sb.append(\"L\");\n          queue.removeFirst();\n          index++;\n        } else if (right == outputs[index]) {\n          // 比较圆桶右边的篮球是不是当前要取出的篮球\n          sb.append(\"R\");\n          queue.removeLast();\n          index++;\n        } else {\n          // 如果圆桶左右两边都不是要取出的球，则本轮取出流程结束\n          break;\n        }\n      }\n    }\n\n    // 最终如果圆桶空了，则说明所有球都取出了，否则按照给定要求无法取出所有球\n    if (queue.size() != 0) {\n      System.out.println(\"NO\");\n    } else {\n      System.out.println(sb);\n    }\n  }\n}",
      "python": "# 输入获取\nipts = list(map(int, input().split(\",\")))\nopts = list(map(int, input().split(\",\")))\n\n\n# 算法入口\ndef getResult():\n    # 利用队列结构模拟圆桶\n    queue = []\n    # outputs[index]是要被取出的篮球的编号\n    index = 0\n\n    # 记录题解\n    res = []\n\n    for ipt in ipts:\n        # 按照放入顺序，从圆桶右边放入\n        queue.append(ipt)\n\n        # 然后开始尝试取出\n        while len(queue) > 0:\n            # 圆桶左边的篮球的编号\n            left = queue[0]\n            # 圆桶右边的篮球的编号\n            right = queue[-1]\n\n            if left == opts[index]:\n                # 优先比较圆桶左边的篮球是不是当前要取出的篮球，优先左边的原因是：当桶只有一个篮球的情况下，必须从左边取出\n                res.append(\"L\")\n                queue.pop(0)\n                index += 1\n            elif right == opts[index]:\n                # 比较圆桶右边的篮球是不是当前要取出的篮球\n                res.append(\"R\")\n                queue.pop()\n                index += 1\n            else:\n                # 如果圆桶左右两边都不是要取出的球，则本轮取出流程结束\n                break\n\n    # 最终如果圆桶空了，则说明所有球都取出了，否则按照给定要求无法取出所有球\n    if len(queue) != 0:\n        return \"NO\"\n    else:\n        return \"\".join(map(str, res))\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "162",
    "title": "编码能力提升计划",
    "examType": "A",
    "score": 200,
    "description": "为了提升软件编码能力，小王制定了刷题计划，他选了题库中的n道题，编号从0到n-1，并计划在m天内按照题目编号顺序刷完所有的题目（注意，小王不能用多天完成同一题）。\n在小王刷题计划中，小王需要用tme[i]的时间完成编号 i 的题目。\n此外，小王还可以查看答案，可以省去该题的做题时间。为了真正达到刷题效果，小王每天最多直接看一次答案。\n我们定义m天中做题时间最多的一天耗时为T（直接看答案的题目不计入做题总时间)。\n请你帮小王求出最小的T是多少。\n",
    "inputDesc": "第一行输入为time，time[i]的时间完成编号 i 的题目\n第二行输入为m，m表示几天内完成所有题目，1 ≤ m ≤ 180\n",
    "outputDesc": "最小耗时整数T\n\n第一天完成前3题，第3题看答案;\n第二天完成第4题和第5题，第5题看答案；\n第三天完成第6和第7题，第7提看答案;\n第四天完成第8题，直接看答案:\n第五天完成第9题，直接看答案\n\n本题要求的 T 即为每天最多要花费的做题时间，比如T=5，即表示每天最多有5个小时做题。另外，在每天花费T时间做题的情况下，要在m天中做完所有题目。\n现在这种可能解T有多个，我们要找到这些可能解中最小的T。\n这是一个典型的最大最小问题，我们可以用二分法解题。\n\n二分法用于求解可能解T，首先需要确定T的两个边界范围（初始的二分范围）。\n因此，T的取值范围是 [0, sum(time) - max(time)]\n我们通过二分法，取中间值作为可能解 t，然后进行验证，该 t 是否可以保证在 m 天内完成 所有题目：\n这样最终我们就能求得最小的T。\n\n但是本题的难点不在于二分法，而在于如何验证 t 是否能在 m 天内完成所有题目？\n我们以用例2为例来讲解：\n首先 T 的初始取值范围是 [0, 30]，我们二分求得中间值 t = 15\n下面即开始验证，每天只有15个时间单位做题目，是否可以再 m = 5 天内完成所有题目。\n\n注意：此时我们有一次看答案机会，但是我们应该用这次机会看哪一题答案呢？\n很简单，我们应该将这次宝贵的机会用在看耗时最长的题目上，而这些题目中耗时最长的是time[4]，因此我们看time[4]题目的答案，总耗时17 - 5 = 12。\n\n这里，可能有人会有疑问，我们如果看time[5]答案，那么总耗时17 - 4 = 13，也可以不超时呀。我们可以假设，如果下一题time[6]耗时是3，那么会产生什么影响？\n因此，看time[4]答案是更优策略。\n第1天做到了time[6]，那么第2天从time[7]开始做。\n因此，当t = 15时，只需要2天（< m）就能做完所有题目。所以 t = 15 是一个可能解，但不一定时最优解，我们应该尝试更小的 t。\n\n接下来 T 的范围缩小为 [0, 14]，我们二分求得中间值 t = 7。\n按照上面思路，继续验证 t 是否能满足 m 天内完成所有题目。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  static int[] times;\n  static int m;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    times = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n    m = Integer.parseInt(sc.nextLine());\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    int sum = 0;\n    int max = 0;\n    for (int time : times) {\n      sum += time;\n      max = Math.max(time, max);\n    }\n\n    // T的初始取值范围\n    int low = 0;\n    int high = sum - max;\n\n    // 二分\n    while (low <= high) {\n      // 取中间值尝试\n      int mid = (low + high) >> 1;\n\n      if (check(mid)) {\n        high = mid - 1;\n      } else {\n        low = mid + 1;\n      }\n    }\n\n    return low;\n  }\n\n  public static boolean check(int t) {\n    // 今天总耗时\n    int sum_cost = 0;\n    // 今天耗时最多的题目的耗时\n    int max_cost = 0;\n    // 今天是否可以申请帮助\n    boolean canHelp = true;\n\n    // 第几天\n    int day = 1;\n\n    int i = 0;\n    while (i < times.length) {\n      sum_cost += times[i];\n      max_cost = Math.max(max_cost, times[i]);\n\n      if (sum_cost > t) {\n        // 如果做完times[i]，总耗时超过了t\n        if (canHelp) {\n          // 如果可以申请帮助，那么就看耗时最长的题目的答案\n          sum_cost -= max_cost;\n          // 今天申请帮助的机会用完了\n          canHelp = false;\n          // 下面继续做下一题\n          i++;\n        } else {\n          // 如果不能申请帮助，则今天做不了times[i]题目，只能放到明天做\n          // 进入明天\n          day++;\n          // 重置总耗时，最大耗时题目，以及申请帮助机会\n          sum_cost = 0;\n          max_cost = 0;\n          canHelp = true;\n        }\n      } else {\n        // 如果做完times[i]，总耗时没有超过t，则继续做下面的题目\n        i++;\n      }\n    }\n\n    return day <= m;\n  }\n}",
      "python": "# 输入获取\ntimes = list(map(int, input().split(\",\")))\nm = int(input())\n\n\ndef check(t):\n    # 今天总耗时\n    sum_cost = 0\n    # 今天耗时最多的题目的耗时\n    max_cost = 0\n    # 今天是否可以申请帮助\n    canHelp = True\n\n    # 第几天\n    day = 1\n\n    i = 0\n    while i < len(times):\n        sum_cost += times[i]\n        max_cost = max(max_cost, times[i])\n\n        if sum_cost > t:\n            # 如果做完times[i]，总耗时超过了t\n            if canHelp:\n                # 如果可以申请帮助，那么就看耗时最长的题目的答案\n                sum_cost -= max_cost\n                # 今天申请帮助的机会用完了\n                canHelp = False\n                # 下面继续做下一题\n                i += 1\n            else:\n                # 如果不能申请帮助，则今天做不了times[i]题目，只能放到明天做\n                # 进入明天\n                day += 1\n                # 重置总耗时，最大耗时题目，以及申请帮助机会\n                sum_cost = 0\n                max_cost = 0\n                canHelp = True\n        else:\n            # 如果做完times[i]，总耗时没有超过t，则继续做下面的题目\n            i += 1\n\n    return day <= m\n\n\n# 算法入口\ndef getResult():\n    # T的初始取值范围\n    low = 0\n    high = sum(times) - max(times)\n\n    # 二分\n    while low <= high:\n        # 取中间值尝试\n        mid = (low + high) >> 1\n\n        if check(mid):\n            high = mid - 1\n        else:\n            low = mid + 1\n\n    return low\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "163",
    "title": "羊、狼、农夫过河",
    "examType": "A",
    "score": 200,
    "description": "羊、狼、农夫都在岸边，当羊的数量小于狼的数量时，狼会攻击羊，农夫则会损失羊。农夫有一艘容量固定的船，能够承载固定数量的动物。\n要求求出不损失羊情况下将全部羊和狼运到对岸需要的最小次数。\n只计算农夫去对岸的次数，回程时农夫不会运送羊和狼。\n备注：农夫在或农夫离开后羊的数量大于狼的数量时狼不会攻击羊。\n",
    "inputDesc": "第一行输入为M，N，X， 分别代表羊的数量，狼的数量，小船的容量。\n",
    "outputDesc": "输出不损失羊情况下将全部羊和狼运到对岸需要的最小次数（若无法满足条件则输出0）。\n\n第一次运2只狼\n第二次运3只羊\n第三次运2只羊和1只狼\n本题求不损失羊的前提下，将羊和狼全部运到对岸的最小次数。\n首先，要搞清楚，如何保证不损失羊？\n农夫在或农夫离开后羊的数量大于狼的数量时狼不会攻击羊。\n这里有个文字断句陷阱，到底是这样断句\n还是这样断句\n经过一位网友的真实机考反馈，上面画删除线的断句理解是错误的。\n\n那么”农夫在时，狼不会攻击羊“，这句话到底会有什么影响呢？\n只计算农夫去对岸的次数，回程时农夫不会运送羊和狼。\n通过上面这句话，我们可以理解，农夫回程不会带动物。因此可以认定：\n因此，”农夫在时，狼不会攻击羊“，这句话只会影响：船上，羊和狼的关系，即农夫在船上时，如果羊数量 <= 狼数量，此时因为农夫在，因此狼不会攻击羊。\n\n本题没有什么好的解题思路，只能通过暴力枚举所有羊、狼数量情况，只需要满足下面三个条件：\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n    int x = sc.nextInt();\n\n    System.out.println(getResult(m, n, x));\n  }\n\n  /**\n   * @param sheep 本岸羊数量\n   * @param wolf 本岸狼数量\n   * @param boat 船负载\n   * @return 最少运送次数\n   */\n  public static int getResult(int sheep, int wolf, int boat) {\n    ArrayList<Integer> ans = new ArrayList<>();\n    dfs(sheep, wolf, boat, 0, 0, 0, ans);\n\n    if (ans.size() > 0) {\n      return Collections.min(ans);\n    } else {\n      return 0;\n    }\n  }\n\n  public static void dfs(\n      int sheep,\n      int wolf,\n      int boat,\n      int oppo_sheep,\n      int oppo_wolf,\n      int count,\n      ArrayList<Integer> ans) {\n    if (sheep == 0 && wolf == 0) {\n      ans.add(count);\n      return;\n    }\n\n    if (sheep + wolf <= boat) {\n      ans.add(count + 1);\n      return;\n    }\n\n    // i 代表船上羊数量，最多Math.min(boat, sheep)\n    for (int i = 0; i <= Math.min(boat, sheep); i++) {\n      // j 代表船上狼数量，最多Math.min(boat, wolf)\n      for (int j = 0; j <= Math.min(boat, wolf); j++) {\n        // 空运\n        if (i + j == 0) continue;\n        // 超载\n        if (i + j > boat) break;\n\n        // 本岸羊 <= 本岸狼，说明狼运少了\n        if (sheep - i <= wolf - j && sheep - i != 0) continue;\n\n        // 对岸羊 <= 对岸狼，说明狼运多了\n        if (oppo_sheep + i <= oppo_wolf + j && oppo_sheep + i != 0) break;\n\n        // 对岸没羊，但是对岸狼已经超过船载量，即下次即使整船都运羊，也无法保证对岸羊 > 对岸狼\n        if (oppo_sheep + i == 0 && oppo_wolf + j >= boat) break;\n\n        dfs(sheep - i, wolf - j, boat, oppo_sheep + i, oppo_wolf + j, count + 1, ans);\n      }\n    }\n  }\n}",
      "python": "import math\n\n# 输入获取\nm, n, x = map(int, input().split())\n\n\n# 算法入口\ndef getResult(sheep, wolf, boat):\n    ans = []\n    dfs(sheep, wolf, boat, 0, 0, 0, ans)\n\n    if len(ans) > 0:\n        return min(ans)\n    else:\n        return 0\n\n\ndef dfs(sheep, wolf, boat, oppo_sheep, oppo_wolf, count, ans):\n    if sheep == 0 and wolf == 0:\n        ans.append(count)\n        return\n\n    if sheep + wolf <= boat:\n        ans.append(count + 1)\n        return\n\n    # i 代表船上羊数量，最多Math.min(boat, sheep)\n    for i in range(min(boat, sheep) + 1):\n        # j 代表船上狼数量，最多Math.min(boat, wolf)\n        for j in range(min(boat, wolf) + 1):\n            # 空运\n            if i + j == 0:\n                continue\n\n            # 超载\n            if i + j > boat:\n                break\n\n            # 本岸羊 <= 本岸狼，说明狼运少了\n            if sheep - i <= wolf - j and sheep - i != 0:\n                continue\n\n            # 对岸羊 <= 对岸狼，说明狼运多了\n            if oppo_sheep + i <= oppo_wolf + j and oppo_sheep + i != 0:\n                break\n\n            # 对岸没羊，但是对岸狼已经超过船载量，即下次即使整船都运羊，也无法保证对岸羊 > 对岸狼\n            if oppo_sheep + i == 0 and oppo_wolf + j >= boat:\n                break\n\n            dfs(sheep - i, wolf - j, boat, oppo_sheep + i, oppo_wolf + j, count + 1, ans)\n\n\n# 算法调用\nprint(getResult(m, n, x))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const [m, n, x] = line.split(\" \").map(Number);\n\n  console.log(getResult(m, n, x));\n});\n\nfunction getResult(sheep, wolf, boat) {\n  const ans = [];\n  dfs(sheep, wolf, boat, 0, 0, 0, ans);\n\n  if (ans.length) {\n    return Math.min.apply(null, ans);\n  } else {\n    return 0;\n  }\n}\n\nfunction dfs(sheep, wolf, boat, oppo_sheep, oppo_wolf, count, ans) {\n  if (sheep === 0 && wolf === 0) {\n    ans.push(count);\n    return;\n  }\n\n  if (sheep + wolf <= boat) {\n    ans.push(count + 1);\n    return;\n  }\n\n  // i 代表船上羊数量，最多Math.min(boat, sheep)\n  for (let i = 0; i <= Math.min(boat, sheep); i++) {\n    // j 代表船上狼数量，最多Math.min(boat, wolf)\n    for (let j = 0; j <= Math.min(boat, wolf); j++) {\n      // 空运\n      if (i + j === 0) continue;\n\n      // 超载\n      if (i + j > boat) break;\n\n      // 本岸羊 <= 本岸狼，说明狼运少了\n      if (sheep - i <= wolf - j && sheep - i !== 0) continue;\n\n      // 对岸羊 <= 对岸狼，说明狼运多了\n      if (oppo_sheep + i <= oppo_wolf + j && oppo_sheep + i !== 0) break;\n\n      // 对岸没羊，但是对岸狼已经超过船载量，即下次即使整船都运羊，也无法保证对岸羊 > 对岸狼\n      if (oppo_sheep + i === 0 && oppo_wolf + j >= boat) break;\n\n      dfs(\n        sheep - i,\n        wolf - j,\n        boat,\n        oppo_sheep + i,\n        oppo_wolf + j,\n        count + 1,\n        ans\n      );\n    }\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "164",
    "title": "运输时间",
    "examType": "A",
    "score": 200,
    "description": "M（1 ≤ M ≤ 20）辆车需要在一条不能超车的单行道到达终点，起点到终点的距离为 N（1 ≤ N ≤ 400）。\n速度快的车追上前车后，只能以前车的速度继续行驶，求最后一辆车到达目的地花费的时间。\n\n注：每辆车固定间隔 1 小时出发，比如第一辆车 0 时出发，第二辆车 1 时出发，依次类推\n",
    "inputDesc": "第一行两个数字：M N，分别代表车辆数和到终点的距离，以空格分隔\n接下来 M 行，每行一个数字 S，代表每辆车的速度。0 < S < 30\n",
    "outputDesc": "最后一辆车到达目的地花费的时间\n\n\n本题需要注意的是：速度快的车追上前车后，是可以和前车并行的。即本题的：\n一条不能超车的单行道\n指的应该是\"单向\"车道，即可能有多条单向车道，支持多辆车并行。\n\n因此本题的解题就很简单了，由于后车不能超过前车，因此：\n\n本题要求输出的是：到达目的地花费的时间 = 到达时刻 - 出发时刻\n\n另外，需要注意，本题输出可能是小数，但是本题并没有说保留几位有效小数，我这边默认保留3位有效小数，四舍五入，实际考试时视情况改动。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.text.NumberFormat;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n\n    // 记录前车到达终点的时刻，本题后车不可能比前车更早到达，因此如果后车到达时刻 < 前车到达时刻arrived，则后车也是按照前车arrived时刻达到\n    double arrived = 0;\n\n    for (int i = 0; i < m; i++) {\n      // 当前车的速度\n      double speed = sc.nextDouble();\n      // 当前车到达终点的时刻\n      // * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算\n      // * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算\n      arrived = Math.max(arrived, n / speed + i); // n*1.0/speed是行驶花费时间； i是第i辆车的出发时间\n    }\n\n    // 到达时刻 - 出发时刻 = 路上花费的时间\n    double cost = arrived - (m - 1);\n\n    // 格式化打印小数\n    NumberFormat nf = NumberFormat.getInstance();\n    nf.setMinimumFractionDigits(0); // 没有小数位则不保留\n    nf.setMaximumFractionDigits(3); // 有小数位则至多保留3位\n\n    System.out.println(nf.format(cost));\n  }\n}",
      "python": "# 输入获取\nm, n = map(int, input().split())\n\n# 记录前车到达终点的时刻，本题后车不可能比前车更早到达，因此如果后车到达时刻 < 前车到达时刻arrived，则后车也是按照前车arrived时刻达到\narrived = 0\n\nfor i in range(m):\n    # 当前车的速度\n    speed = int(input())\n    # 当前车到达终点的时刻\n    # * 当前车如果比前车更早到达，则被前车阻碍，按前车到达时间算\n    # * 当前车如果比前车更晚到达，则不被前车阻碍，按后车到达时间算\n    arrived = max(arrived, n / speed + i)  # n*1.0/speed是行驶花费时间； i是第i辆车的出发时间\n\n# 到达时刻 - 出发时刻 = 路上花费的时间\ncost = arrived - (m - 1)\n\nprint(\"{:g}\".format(round(cost, 3)))  # 如果有小数位则至多保留3位，:g 用于去除无效小数位",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "165",
    "title": "字母组合过滤组合字符串",
    "examType": "A",
    "score": 200,
    "description": "每个数字关联多个字母，关联关系如下：\n0 关联 “a”,”b”,”c”1 关联 “d”,”e”,”f”2 关联 “g”,”h”,”i”3 关联 “j”,”k”,”l”4 关联 “m”,”n”,”o”5 关联 “p”,”q”,”r”6 关联 “s”,”t”7 关联 “u”,”v”8 关联 “w”,”x”9 关联 “y”,”z”\n输入一串数字后，通过数字和字母的对应关系可以得到多个字母字符串（要求按照数字的顺序组合字母字符串）；\n屏蔽字符串：屏蔽字符串中的所有字母不能同时在输出的字符串出现，如屏蔽字符串是abc，则要求字符串中不能同时出现a,b,c，但是允许同时出现a,b或a,c或b,c等；\n给定一个数字字符串和一个屏蔽字符串，输出所有可能的字符组合；\n例如输入数字字符串78和屏蔽字符串ux，输出结果为uw，vw，vx；数字字符串78，可以得到如下字符串uw，ux，vw，vx；由于ux是屏蔽字符串，因此排除ux，最终的输出是uw，vw，vx;",
    "inputDesc": "第一行输入为一串数字字符串，数字字符串中的数字不允许重复，数字字符串的长度大于0，小于等于5；\n第二行输入是屏蔽字符串，屏蔽字符串的长度一定小于数字字符串的长度，屏蔽字符串中字符不会重复；",
    "outputDesc": "输出可能的字符串组合\n注：字符串之间使用逗号隔开，最后一个字符串后携带逗号",
    "examples": [
      {
        "input": "ux",
        "output": "uw,vw,vx,",
        "explanation": "ux完全包含屏蔽字符串ux，因此剔除"
      },
      {
        "input": "x",
        "output": "uw,vw,",
        "explanation": ""
      }
    ],
    "solution": "这个题目的核心在于根据映射关系生成组合，然后剔除包含屏蔽字符串的组合。\n数字与字母的映射关系：每个数字都映射到一组字母，例如数字0映射到字母’a’, ‘b’, ‘c’，数字1映射到’d’, ‘e’, ‘f’，以此类推。这个映射关系可以看作是类似于传统手机键盘上的数字与字母的对应关系。生成字母组合：用户输入一串不重复的数字字符串，题目要求按照数字的顺序生成所有可能的字母组合。例如，输入\"78\"，7对应’u’, ‘v’，8对应’w’, ‘x’，那么可以生成的组合是：uw, ux, vw, vx。屏蔽字符串的限制：屏蔽字符串中的所有字母不能同时出现在生成的字母组合中。也就是说，如果一个字母组合包含了屏蔽字符串中的所有字符，这个组合就需要被剔除。例如，如果屏蔽字符串是\"ux\"，那么组合中的ux会被剔除。",
    "codes": {
      "java": "import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n    static String[] map = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 输入数字字符串\n        char[] digits = sc.next().toCharArray();\n        // 输入屏蔽字符串\n        String filter = sc.next();\n\n        // 根据数字字符串得到每个数字对应的字母字符串\n        String[] letters = new String[digits.length];\n        for (int i = 0; i < digits.length; i++) {\n            letters[i] = map[digits[i] - '0'];\n        }\n\n        // 用于存储结果的字符串\n        StringBuilder sb = new StringBuilder();\n        // 开始进行深度优先搜索\n        dfs(letters, 0, new StringBuilder(), sb, filter, new HashSet<>());\n\n        // 输出结果\n        System.out.println(sb.toString());\n    }\n\n    public static void dfs(\n            String[] letters, int index, StringBuilder path, StringBuilder res, String filter, HashSet<Character> used) {\n        if (index == letters.length) {\n            // 过滤包含屏蔽字符串的路径\n            if (!path.toString().contains(filter)) {\n                res.append(path).append(\",\");\n            }\n            return;\n        }\n\n        // 对于每个数字，遍历其对应的字母字符串\n        for (int i = 0; i < letters[index].length(); i++) {\n            char c = letters[index].charAt(i);\n            if (!used.contains(c)) {\n                path.append(c);\n                used.add(c);\n                dfs(letters, index + 1, path, res, filter, used);\n                path.deleteCharAt(path.length() - 1);\n                used.remove(c);\n            }\n        }\n    }\n}",
      "python": "import sys\n\n# 定义数字到字母的映射关系，map[0] 对应 'abc', map[1] 对应 'def'，依此类推\nmap = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"]\n\n# 深度优先搜索 (DFS) 递归函数\ndef dfs(letters, index, path, res, filter, used):\n    # 如果当前索引等于字母组的长度，说明已经生成了一个完整的字母组合\n    if index == len(letters):\n        # 如果生成的组合不包含屏蔽字符串，则将其加入结果集\n        if filter not in path:\n            res.append(path + \",\")\n        return\n    \n    # 遍历当前索引位置对应的所有字母\n    for i in range(len(letters[index])):\n        c = letters[index][i]  # 当前字母\n        # 如果当前字母尚未被使用\n        if c not in used:\n            path += c  # 将字母加入当前路径\n            used.add(c)  # 标记字母为已使用\n            # 递归调用下一层，处理下一个索引\n            dfs(letters, index + 1, path, res, filter, used)\n            path = path[:-1]  # 回溯，移除最后添加的字母\n            used.remove(c)  # 取消字母的使用标记\n\n\ndigits = input().strip()  # 读取输入的数字字符串，并去除首尾空格\nfilter = input().strip()  # 读取输入的屏蔽字符串，并去除首尾空格\n\n# 将输入的数字字符串转换为对应的字母组，如\"78\" -> ['uv', 'wx']\nletters = [map[int(digit)] for digit in digits]\n\nsb = \"\"  # 初始化一个空字符串，用于存储当前路径\nres = []  # 结果列表，存储所有符合条件的字母组合\ndfs(letters, 0, sb, res, filter, set())  # 调用DFS函数，开始递归搜索\n\n# 输出结果，将结果列表中的元素连接成一个字符串并打印\nprint(\"\".join(res))",
      "javascript": "const readline = require('readline');\n\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 定义数字到字母的映射关系，类似于传统手机键盘上的字母排列\nconst map = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"];\n\n// 监听用户输入的第一行内容，即数字字符串\nrl.on(\"line\", (digits) => {\n  // 监听用户输入的第二行内容，即屏蔽字符串\n  rl.on(\"line\", (filter) => {\n    // 初始化一个数组，用于存储根据输入数字映射得到的字母组\n    const letters = new Array(digits.length);\n    for (let i = 0; i < digits.length; i++) {\n      // 将每个数字转换成对应的字母组并存入数组\n      letters[i] = map[parseInt(digits[i])];\n    }\n\n    const sb = []; // 存储最终的结果组合\n    dfs(letters, 0, \"\", sb, filter, new Set()); // 调用DFS函数进行深度优先搜索\n\n    // 输出结果，用逗号分隔各个字母组合\n    console.log(sb.join(\",\"));\n    rl.close(); // 关闭读取接口\n  });\n});\n\n// 深度优先搜索 (DFS) 递归函数\nfunction dfs(letters, index, path, res, filter, used) {\n  // 如果当前索引等于字母组的长度，说明已经生成了一个完整的字母组合\n  if (index === letters.length) {\n    // 如果生成的组合不包含屏蔽字符串，则将其加入结果集\n    if (!path.includes(filter)) {\n      res.push(path);\n    }\n    return;\n  }\n\n  // 遍历当前索引位置对应的所有字母\n  for (let i = 0; i < letters[index].length; i++) {\n    const c = letters[index][i];  // 当前字母\n    // 如果当前字母尚未被使用\n    if (!used.has(c)) {\n      path += c;  // 将字母加入当前路径\n      used.add(c);  // 标记字母为已使用\n      // 递归调用下一层，处理下一个索引\n      dfs(letters, index + 1, path, res, filter, used);\n      path = path.slice(0, -1);  // 回溯，移除最后添加的字母\n      used.delete(c);  // 取消字母的使用标记\n    }\n  }\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nvector<string> map = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"};\n\nvoid dfs(\n        vector<string>& letters, int index, string path, string& res, string& filter, unordered_set<char>& used) {\n    if (index == letters.size()) {\n        // 过滤包含屏蔽字符串的路径\n        if (path.find(filter) == string::npos) {\n            res += path + \",\";\n        }\n        return;\n    }\n\n    // 对于每个数字，遍历其对应的字母字符串\n    for (int i = 0; i < letters[index].length(); i++) {\n        char c = letters[index][i];\n        if (used.find(c) == used.end()) {\n            path += c;\n            used.insert(c);\n            dfs(letters, index + 1, path, res, filter, used);\n            path.pop_back();\n            used.erase(c);\n        }\n    }\n}\n\nint main() {\n    string digits;\n    cin >> digits;\n    string filter;\n    cin >> filter;\n\n    // 根据数字字符串得到每个数字对应的字母字符串\n    vector<string> letters(digits.length());\n    for (int i = 0; i < digits.length(); i++) {\n        letters[i] = map[digits[i] - '0'];\n    }\n\n    // 用于存储结果的字符串\n    string res = \"\";\n    // 开始进行深度优先搜索\n    unordered_set<char> used;\n    dfs(letters, 0, \"\", res, filter, used);\n\n    // 输出结果\n    cout << res << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 100\n#define RES_LEN 1000\n\n// 定义一个常量映射数组，用于将数字映射到对应的字母字符串\nconst char *map[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"};\n\n// DFS函数声明\nvoid dfs(char letters[][MAX_LEN], int num_digits, int index, char *path, int path_len, char *res, char *filter, int *used);\n\nint main() {\n    char digits[MAX_LEN];  // 用于存储输入的数字字符串\n    char filter[MAX_LEN];  // 用于存储输入的屏蔽字符串\n\n    // 输入数字字符串和屏蔽字符串\n    scanf(\"%s\", digits);\n    scanf(\"%s\", filter);\n\n    int length = strlen(digits);\n    char letters[length][MAX_LEN];  // 用于存储每个数字对应的字母字符串\n\n    // 根据输入的数字字符串生成对应的字母字符串\n    for (int i = 0; i < length; i++) {\n        strcpy(letters[i], map[digits[i] - '0']);\n    }\n\n    char res[RES_LEN] = \"\";  // 用于存储结果的字符串\n    char path[MAX_LEN] = \"\";  // 用于存储当前路径的字符串\n    int used[128] = {0};  // 用于标记当前路径中已使用的字符\n\n    // 开始进行深度优先搜索\n    dfs(letters, length, 0, path, 0, res, filter, used);\n\n    // 输出结果\n    printf(\"%s\\n\", res);\n\n    return 0;\n}\n\n// DFS函数定义\nvoid dfs(char letters[][MAX_LEN], int num_digits, int index, char *path, int path_len, char *res, char *filter, int *used) {\n    // 如果当前索引等于字母组的长度，说明已经生成了一个完整的字母组合\n    if (index == num_digits) {\n        // 判断生成的路径是否包含屏蔽字符串\n        if (strstr(path, filter) == NULL) {\n            if (strlen(res) > 0) {\n                strcat(res, \",\");  // 添加逗号分隔符\n            }\n            strcat(res, path);\n        }\n        return;\n    }\n\n    // 遍历当前索引位置对应的所有字母\n    for (int i = 0; letters[index][i] != '\\0'; i++) {\n        char c = letters[index][i];  // 当前字母\n        if (!used[(int)c]) {  // 如果当前字母尚未被使用\n            path[path_len] = c;  // 将字母加入当前路径\n            path[path_len + 1] = '\\0';\n            used[(int)c] = 1;  // 标记字母为已使用\n            // 递归调用下一层，处理下一个索引\n            dfs(letters, num_digits, index + 1, path, path_len + 1, res, filter, used);\n            // 回溯，移除最后添加的字母\n            path[path_len] = '\\0';\n            used[(int)c] = 0;  // 取消字母的使用标记\n        }\n    }\n}"
    }
  },
  {
    "id": "166",
    "title": "字符串化繁为简",
    "examType": "A",
    "score": 200,
    "description": "给定一个输入字符串，字符串只可能由英文字母（ ‘a’ ~ ‘z’、‘A’ ~ ‘Z’ ）和左右小括号（ ‘(’、‘)’ ）组成。\n当字符里存在小括号时，小括号是成对的，可以有一个或多个小括号对，小括号对不会嵌套，小括号对内可以包含1个或多个英文字母，也可以不包含英文字母。\n当小括号对内包含多个英文字母时，这些字母之间是相互等效的关系，而且等效关系可以在不同的小括号对之间传递，即当存在 ‘a’ 和 ‘b’ 等效和存在 ‘b’ 和 ‘c’ 等效时，‘a’ 和 ‘c’ 也等效，另外，同一个英文字母的大写字母和小写字母也相互等效（即使它们分布在不同的括号对里）\n需要对这个输入字符串做简化，输出一个新的字符串，输出字符串里只需保留输入字符串里的没有被小括号对包含的字符（按照输入字符串里的字符顺序），并将每个字符替换为在小括号对里包含的且字典序最小的等效字符。\n如果简化后的字符串为空，请输出为\"0\"。\n示例 : 输入字符串为\"never(dont)give(run)up(f)()\"，初始等效字符集合为(‘d’, ‘o’, ‘n’, ‘t’)、(‘r’, ‘u’, ‘n’)，由于等效关系可以传递，因此最终等效字符集合为(‘d’, ‘o’, ‘n’, ‘t’, ‘r’, ‘u’)，将输入字符串里的剩余部分按字典序最小的等效字符替换后得到\"devedgivedp’",
    "inputDesc": "input_string\n输入为1行，代表输入字符串\n输入字符串的长度在1~100000之间",
    "outputDesc": "output_string\n输出为1行，代表输出字符串",
    "examples": [
      {
        "input": "()abd",
        "output": "abd",
        "explanation": "输入字符串里没有被小括号包含的子字符串为\"abd\"，其中每个字符没有等效字符，输出为\"abd\""
      },
      {
        "input": "()happy(xyz)new(wxy)year(t)",
        "output": "happwnewwear",
        "explanation": "等效字符集为(‘x’, ‘y’, ‘z’, ‘w’)，输入字符串里没有被小括号包含的子字符串集合为\"happynewyear\"，将其中字符替换为字典序最小的等效字符后输出为：“happwnewwear”"
      },
      {
        "input": "()abcdefgAC(a)(Ab)(C)",
        "output": "AAcdefgAC",
        "explanation": "等效字符集为(‘a’, ‘A’, ‘b’)，输入字符里没有被小括号包含的子字符串集合为\"abcdefgAC\"，将其中字符替换为字典序最小的等效字符后输出为：“AAcdefgAC”"
      }
    ],
    "solution": "题目的核心要求是对字符串中的字符进行等效关系的解析和替换，其中小括号内的字符表明了字符之间的等效关系，等效关系可以跨多个小括号传递，且大小写字母也视为等效。基于这些等效关系，我们需要替换字符串中未被小括号包围的字符，使用其等效集合中字典序最小的字符进行替换。\n具体如下：\n等效字符集：当字符被包含在小括号中时，这些字符互相等效。例如在(abd)中，a、b、和d互相等效。 传递性：等效关系具有传递性，即如果a等效于b，且b等效于c，则a也等效于c。例如，如果(a)(Ab)，则由于a和A都等效，并且A和b等效，最终a、A、b三者互相等效。 大小写等效：题目规定不同大小写的同一字母也是等效的，即A等效于a。 输出字符的选择：对于字符串中未被小括号包含的每个字符，需要在其所有等效字符中选择字典序最小的字符进行替换。 示例解释： ()abd：没有括号内字符，所以abd不变。(abd)demand(fb)()for：这里abd和fb中的字符互相等效，因此输出替换后的d、e、m、a、n、d、f、o、r为a、e、m、a、n、a、a、o、r。()happy(xyz)new(wxy)year(t)：这里xyz和wxy中的字符互相等效，t无关系，所以替换happynewyear中的x, y, w为字典序最小的w。()abcdefgAC(a)(Ab)(C)：这里a, A, b互相等效，同时A和C也等效，所以在abcdefgAC中，a, b和C被替换为A。\n等效字符集：当字符被包含在小括号中时，这些字符互相等效。例如在(abd)中，a、b、和d互相等效。\n传递性：等效关系具有传递性，即如果a等效于b，且b等效于c，则a也等效于c。例如，如果(a)(Ab)，则由于a和A都等效，并且A和b等效，最终a、A、b三者互相等效。\n大小写等效：题目规定不同大小写的同一字母也是等效的，即A等效于a。\n输出字符的选择：对于字符串中未被小括号包含的每个字符，需要在其所有等效字符中选择字典序最小的字符进行替换。\n示例解释：\n()abd：没有括号内字符，所以abd不变。(abd)demand(fb)()for：这里abd和fb中的字符互相等效，因此输出替换后的d、e、m、a、n、d、f、o、r为a、e、m、a、n、a、a、o、r。()happy(xyz)new(wxy)year(t)：这里xyz和wxy中的字符互相等效，t无关系，所以替换happynewyear中的x, y, w为字典序最小的w。()abcdefgAC(a)(Ab)(C)：这里a, A, b互相等效，同时A和C也等效，所以在abcdefgAC中，a, b和C被替换为A。",
    "codes": {
      "java": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个Scanner对象，用于读取用户输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取用户输入的字符串\n        String inputString = scanner.nextLine();\n        // 创建一个StringBuilder对象，用于存储最终的输出结果\n        StringBuilder outputStringBuilder = new StringBuilder();\n        // 创建一个LinkedList对象，用于存储等价集合\n        LinkedList<TreeSet<Character>> equivalentSets = new LinkedList<>();\n\n        // 用于判断当前是否在括号内部的标志变量\n        boolean isInsideParentheses = false;\n\n        // 遍历输入字符串的每个字符\n        for (int i = 0; i < inputString.length(); i++) {\n            // 获取当前字符\n            char currentChar = inputString.charAt(i);\n\n            // 如果当前字符是左括号'('，则表示进入了括号内部\n            if (currentChar == '(') {\n                isInsideParentheses = true;\n                // 创建一个新的等价集合，并将其添加到LinkedList中\n                equivalentSets.add(new TreeSet<>());\n            }\n            // 如果当前字符是右括号')'，则表示离开了括号内部\n            else if (currentChar == ')') {\n                isInsideParentheses = false;\n                // 如果最后一个等价集合为空集合，则将其从LinkedList中移除\n                if (equivalentSets.getLast().size() == 0) equivalentSets.removeLast();\n            }\n            // 如果当前字符既不是左括号也不是右括号\n            else {\n                // 如果当前不在括号内部，则直接将字符添加到输出结果中\n                if (!isInsideParentheses) {\n                    outputStringBuilder.append(currentChar);\n                }\n                // 如果当前在括号内部，则将字符添加到最后一个等价集合中\n                else {\n                    equivalentSets.getLast().add(currentChar);\n                }\n            }\n        }\n\n        // 用于判断是否进行了合并操作的标志变量\n        boolean merged = true;\n        // 循环执行合并操作，直到没有可以合并的等价集合为止\n        while (merged) {\n            merged = false;\n            // 遍历等价集合LinkedList中的每个等价集合\n            for (int i = 0; i < equivalentSets.size(); i++) {\n                for (int j = i + 1; j < equivalentSets.size(); j++) {\n                    boolean canCombine = false;\n                    // 遍历字母'a'到'z'，判断两个等价集合是否可以合并\n                    for (char c = 'a'; c <= 'z'; c++) {\n                        char uppercaseC = (char) (c - 32);\n                        if ((equivalentSets.get(i).contains(c) || equivalentSets.get(i).contains(uppercaseC)) && (equivalentSets.get(j).contains(c) || equivalentSets.get(j).contains(uppercaseC))) {\n                            canCombine = true;\n                            break;\n                        }\n                    }\n                    // 如果可以合并，则将第二个等价集合中的元素合并到第一个等价集合中，并从LinkedList中移除第二个等价集合\n                    if (canCombine) {\n                        equivalentSets.get(i).addAll(equivalentSets.get(j));\n                        equivalentSets.remove(j);\n                        merged = true;\n                        break;\n                    }\n                }\n                if (merged) break;\n            }\n        }\n\n        // 将输出结果转换为字符数组\n        char[] outputCharArray = outputStringBuilder.toString().toCharArray();\n\n        // 对每个等价集合进行处理，将等价集合中的字符替换为集合中的第一个字符\n        for (TreeSet<Character> eq : equivalentSets) {\n            Character firstChar = eq.first();\n            for (int i = 0; i < outputCharArray.length; i++) {\n                if (eq.contains(outputCharArray[i])) outputCharArray[i] = firstChar;\n            }\n        }\n\n        // 将字符数组转换为字符串\n        String resultString = new String(outputCharArray);\n\n        // 如果结果字符串为空，则返回\"0\"，否则返回结果字符串\n        String finalResult = resultString.length() == 0 ? \"0\" : resultString;\n        System.out.println(finalResult);\n    }\n}",
      "python": "from collections import deque\nfrom typing import List, Set\n\ndef main():\n    # 创建一个输入函数，用于读取用户输入\n    input_string = input()\n    # 创建一个列表，用于存储最终的输出结果\n    output_string_builder = []\n    # 创建一个双端队列对象，用于存储等价集合\n    equivalent_sets = deque()\n\n    # 用于判断当前是否在括号内部的标志变量\n    is_inside_parentheses = False\n\n    # 遍历输入字符串的每个字符\n    for current_char in input_string:\n        # 如果当前字符是左括号'('，则表示进入了括号内部\n        if current_char == '(':\n            is_inside_parentheses = True\n            # 创建一个新的等价集合，并将其添加到双端队列中\n            equivalent_sets.append(set())\n        # 如果当前字符是右括号')'，则表示离开了括号内部\n        elif current_char == ')':\n            is_inside_parentheses = False\n            # 如果最后一个等价集合为空集合，则将其从双端队列中移除\n            if len(equivalent_sets[-1]) == 0:\n                equivalent_sets.pop()\n        # 如果当前字符既不是左括号也不是右括号\n        else:\n            # 如果当前不在括号内部，则直接将字符添加到输出结果中\n            if not is_inside_parentheses:\n                output_string_builder.append(current_char)\n            # 如果当前在括号内部，则将字符添加到最后一个等价集合中\n            else:\n                equivalent_sets[-1].add(current_char)\n\n    # 用于判断是否进行了合并操作的标志变量\n    merged = True\n    # 循环执行合并操作，直到没有可以合并的等价集合为止\n    while merged:\n        merged = False\n        # 遍历等价集合双端队列中的每个等价集合\n        for i in range(len(equivalent_sets)):\n            for j in range(i + 1, len(equivalent_sets)):\n                can_combine = False\n                # 遍历字母'a'到'z'，判断两个等价集合是否可以合并\n                for c in range(ord('a'), ord('z') + 1):\n                    uppercase_c = chr(c - 32)\n                    if (chr(c) in equivalent_sets[i] or uppercase_c in equivalent_sets[i]) and (chr(c) in equivalent_sets[j] or uppercase_c in equivalent_sets[j]):\n                        can_combine = True\n                        break\n                # 如果可以合并，则将第二个等价集合中的元素合并到第一个等价集合中，并从双端队列中移除第二个等价集合\n                if can_combine:\n                    equivalent_sets[i].update(equivalent_sets[j])\n                    del equivalent_sets[j]\n                    merged = True\n                    break\n            if merged:\n                break\n\n    # 对每个等价集合进行处理，将等价集合中的字符替换为集合中的第一个字符\n    for eq in equivalent_sets:\n        first_char = min(eq)\n        for i in range(len(output_string_builder)):\n            if output_string_builder[i] in eq:\n                output_string_builder[i] = first_char\n\n    # 将字符列表转换为字符串\n    result_string = ''.join(output_string_builder)\n\n    # 如果结果字符串为空，则返回\"0\"，否则返回结果字符串\n    final_result = \"0\" if len(result_string) == 0 else result_string\n    print(final_result)\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "// 导入readline模块，用于读取用户输入\nconst readline = require('readline');\n\n// 创建readline接口实例\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 监听用户输入事件\nrl.on('line', (input) => {\n    // 创建一个列表，用于存储最终的输出结果\n    let outputString = [];\n    // 创建一个数组，用于存储等价集合\n    let equivalentSets = [];\n\n    // 用于判断当前是否在括号内部的标志变量\n    let isInsideParentheses = false;\n\n    // 遍历输入字符串的每个字符\n    for (let currentChar of input) {\n        // 如果当前字符是左括号'('，则表示进入了括号内部\n        if (currentChar === '(') {\n            isInsideParentheses = true;\n            // 创建一个新的等价集合，并将其添加到数组中\n            equivalentSets.push(new Set());\n        }\n        // 如果当前字符是右括号')'，则表示离开了括号内部\n        else if (currentChar === ')') {\n            isInsideParentheses = false;\n            // 如果最后一个等价集合为空集合，则将其从数组中移除\n            if (equivalentSets[equivalentSets.length - 1].size === 0) {\n                equivalentSets.pop();\n            }\n        }\n        // 如果当前字符既不是左括号也不是右括号\n        else {\n            // 如果当前不在括号内部，则直接将字符添加到输出结果中\n            if (!isInsideParentheses) {\n                outputString.push(currentChar);\n            }\n            // 如果当前在括号内部，则将字符添加到最后一个等价集合中\n            else {\n                equivalentSets[equivalentSets.length - 1].add(currentChar);\n            }\n        }\n    }\n\n    // 用于判断是否进行了合并操作的标志变量\n    let merged = true;\n    // 循环执行合并操作，直到没有可以合并的等价集合为止\n    while (merged) {\n        merged = false;\n        // 遍历等价集合数组中的每个等价集合\n        for (let i = 0; i < equivalentSets.length; i++) {\n            for (let j = i + 1; j < equivalentSets.length; j++) {\n                let canCombine = false;\n                // 遍历字母'a'到'z'，判断两个等价集合是否可以合并\n                for (let c = 'a'.charCodeAt(0); c <= 'z'.charCodeAt(0); c++) {\n                    let uppercaseC = String.fromCharCode(c - 32);\n                    if ((equivalentSets[i].has(String.fromCharCode(c)) || equivalentSets[i].has(uppercaseC)) && (equivalentSets[j].has(String.fromCharCode(c)) || equivalentSets[j].has(uppercaseC))) {\n                        canCombine = true;\n                        break;\n                    }\n                }\n                // 如果可以合并，则将第二个等价集合中的元素合并到第一个等价集合中，并从数组中移除第二个等价集合\n                if (canCombine) {\n                    equivalentSets[i] = new Set([...equivalentSets[i], ...equivalentSets[j]]);\n                    equivalentSets.splice(j, 1);\n                    merged = true;\n                    break;\n                }\n            }\n            if (merged) {\n                break;\n            }\n        }\n    }\n\n    // 对每个等价集合进行处理，将等价集合中的字符替换为集合中的第一个字符\n    for (let eq of equivalentSets) {\n        let firstChar = [...eq].sort()[0];\n        outputString = outputString.map(char => eq.has(char) ? firstChar : char);\n    }\n\n    // 如果结果字符串为空，则返回\"0\"，否则返回结果字符串\n    let finalResult = outputString.length === 0 ? \"0\" : outputString.join('');\n    console.log(finalResult);\n});",
      "cpp": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    // 读取用户输入的字符串\n    string inputString;\n    getline(cin, inputString);\n\n    // 创建一个字符串，用于存储最终的输出结果\n    string outputString = \"\";\n\n    // 创建一个vector对象，用于存储等价集合\n    vector<set<char>> equivalentSets;\n\n    // 用于判断当前是否在括号内部的标志变量\n    bool isInsideParentheses = false;\n\n    // 遍历输入字符串的每个字符\n    for (char currentChar : inputString) {\n        // 如果当前字符是左括号'('，则表示进入了括号内部\n        if (currentChar == '(') {\n            isInsideParentheses = true;\n            // 创建一个新的等价集合，并将其添加到vector中\n            equivalentSets.push_back(set<char>());\n        }\n        // 如果当前字符是右括号')'，则表示离开了括号内部\n        else if (currentChar == ')') {\n            isInsideParentheses = false;\n            // 如果最后一个等价集合为空集合，则将其从vector中移除\n            if (equivalentSets.back().empty()) equivalentSets.pop_back();\n        }\n        // 如果当前字符既不是左括号也不是右括号\n        else {\n            // 如果当前不在括号内部，则直接将字符添加到输出结果中\n            if (!isInsideParentheses) {\n                outputString += currentChar;\n            }\n            // 如果当前在括号内部，则将字符添加到最后一个等价集合中\n            else {\n                equivalentSets.back().insert(currentChar);\n            }\n        }\n    }\n\n    // 用于判断是否进行了合并操作的标志变量\n    bool merged = true;\n    // 循环执行合并操作，直到没有可以合并的等价集合为止\n    while (merged) {\n        merged = false;\n        // 遍历等价集合vector中的每个等价集合\n        for (size_t i = 0; i < equivalentSets.size(); ++i) {\n            for (size_t j = i + 1; j < equivalentSets.size(); ++j) {\n                bool canCombine = false;\n                // 遍历字母'a'到'z'，判断两个等价集合是否可以合并\n                for (char c = 'a'; c <= 'z'; ++c) {\n                    char uppercaseC = static_cast<char>(c - 32);\n                    if ((equivalentSets[i].count(c) || equivalentSets[i].count(uppercaseC)) && (equivalentSets[j].count(c) || equivalentSets[j].count(uppercaseC))) {\n                        canCombine = true;\n                        break;\n                    }\n                }\n                // 如果可以合并，则将第二个等价集合中的元素合并到第一个等价集合中，并从vector中移除第二个等价集合\n                if (canCombine) {\n                    equivalentSets[i].insert(equivalentSets[j].begin(), equivalentSets[j].end());\n                    equivalentSets.erase(equivalentSets.begin() + j);\n                    merged = true;\n                    break;\n                }\n            }\n            if (merged) break;\n        }\n    }\n\n    // 对每个等价集合进行处理，将等价集合中的字符替换为集合中的第一个字符\n    for (const set<char>& eq : equivalentSets) {\n        char firstChar = *eq.begin();\n        for (char& c : outputString) {\n            if (eq.count(c)) c = firstChar;\n        }\n    }\n\n    // 如果结果字符串为空，则返回\"0\"，否则返回结果字符串\n    string finalResult = outputString.empty() ? \"0\" : outputString;\n    cout << finalResult << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <ctype.h>  // 用于字符大小写转换\n\n#define MAX_SIZE 1000  // 定义输入字符串的最大长度\n\n// 定义字符集合结构体，用于存储和处理字符\ntypedef struct {\n    char elements[256];  // 存储集合中的所有字符\n    int count[256];      // 对应字符是否在集合中的标记数组\n} TreeSet;\n\n// 初始化字符集合，将所有字符的存在标记置为0\nvoid initTreeSet(TreeSet *set) {\n    memset(set->count, 0, sizeof(set->count));  // 使用memset函数初始化计数数组为0\n}\n\n// 向字符集合中添加字符\nvoid addCharToSet(TreeSet *set, char c) {\n    int index = (unsigned char)c;  // 将字符转换为无符号字符，避免负索引\n    if (set->count[index] == 0) {\n        set->elements[index] = c;  // 如果字符未存在，则添加到元素数组中\n    }\n    set->count[index] = 1;  // 标记字符存在\n}\n\n// 检查字符集合中是否包含指定字符\nint setContains(TreeSet *set, char c) {\n    return set->count[(unsigned char)c];  // 返回字符存在的标记\n}\n\n// 将两个字符集合合并为一个\nvoid mergeSets(TreeSet *dest, TreeSet *src) {\n    for (int i = 0; i < 256; i++) {\n        if (src->count[i]) {\n            addCharToSet(dest, src->elements[i]);  // 如果源集合中存在字符，则添加到目标集合中\n        }\n    }\n}\n\nint main() {\n    char inputString[MAX_SIZE];  // 输入字符串\n    char outputString[MAX_SIZE];  // 输出字符串\n    int outputIndex = 0;  // 输出字符串索引\n\n    TreeSet sets[MAX_SIZE];  // 等价集合数组\n    int numSets = 0;  // 等价集合数量\n    int isInsideParentheses = 0;  // 标记是否在括号内部\n\n    fgets(inputString, MAX_SIZE, stdin);  // 读取输入字符串\n    inputString[strcspn(inputString, \"\\n\")] = 0;  // 移除字符串末尾的换行符\n\n    // 遍历输入字符串中的每个字符\n    for (int i = 0; i < strlen(inputString); i++) {\n        char currentChar = inputString[i];  // 当前字符\n        if (currentChar == '(') {\n            isInsideParentheses = 1;  // 标记进入括号内部\n            initTreeSet(&sets[numSets++]);  // 初始化新集合并增加集合计数\n        } else if (currentChar == ')') {\n            isInsideParentheses = 0;  // 标记离开括号内部\n        } else {\n            if (!isInsideParentheses) {\n                outputString[outputIndex++] = currentChar;  // 如果不在括号内，直接添加到输出字符串\n            } else {\n                addCharToSet(&sets[numSets - 1], currentChar);  // 在括号内，添加字符到最新的集合中\n            }\n        }\n    }\n\n    // 合并可合并的集合\n    int merged = 1;\n    while (merged) {\n        merged = 0;\n        for (int i = 0; i < numSets; i++) {\n            for (int j = i + 1; j < numSets; j++) {\n                for (char c = 'a'; c <= 'z'; c++) {\n                    if ((setContains(&sets[i], c) || setContains(&sets[i], toupper(c))) &&\n                        (setContains(&sets[j], c) || setContains(&sets[j], toupper(c)))) {\n                        mergeSets(&sets[i], &sets[j]);  // 合并集合\n\n                        // 移除已合并的集合\n                        for (int k = j; k < numSets - 1; k++) {\n                            sets[k] = sets[k + 1];\n                        }\n                        numSets--;\n                        merged = 1;\n                        break;\n                    }\n                }\n                if (merged) break;\n            }\n            if (merged) break;\n        }\n    }\n\n    // 应用等价集合的替换规则，将输出中的字符替换为等价集合的首字符\n    for (int s = 0; s < numSets; s++) {\n        char firstChar = 0;\n        for (int c = 0; c < 256; c++) {\n            if (sets[s].count[c]) {\n                firstChar = sets[s].elements[c];\n                break;\n            }\n        }\n        for (int i = 0; i < outputIndex; i++) {\n            if (setContains(&sets[s], outputString[i])) {\n                outputString[i] = firstChar;  // 替换字符\n            }\n        }\n    }\n\n    outputString[outputIndex] = '\\0';  // 确保输出字符串正确终止\n    printf(\"%s\\n\", outputIndex ? outputString : \"0\");  // 输出最终结果\n\n    return 0;\n}"
    }
  },
  {
    "id": "167",
    "title": "导师请吃火锅",
    "examType": "A",
    "score": 200,
    "description": "入职后，导师会请你吃饭，你选择了火锅。\n火锅里会在不同时间下很多菜。\n不同食材要煮不同的时间，才能变得刚好合适。\n你希望吃到最多的刚好合适的菜，但你的手速不够快，用m代表手速，每次下手捞菜后至少要过m秒才能再捞（每次只能捞一个）。\n那么用最合理的策略，最多能吃到多少刚好合适的菜？",
    "inputDesc": "第一行两个整数n，m，其中n代表往锅里下的菜的个数，m代表手速。（1 < n, m < 1000）\n接下来有n行，每行有两个数x，y代表第x秒下的菜过y秒才能变得刚好合适。（1 < x, y < 1000）",
    "outputDesc": "输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量。",
    "examples": [
      {
        "input": "1\n 2\n 1",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "题目的核心是在多个可能的捞菜时刻中，通过合理安排选择，尽可能多地吃到“刚好合适”的菜。考虑到每次捞菜后的冷却时间，需要设计一个策略，尽量避开同时煮熟的菜以最大化收益。\n菜的描述： 有 n 个菜依次被放入火锅，每个菜放入的时间和煮熟的时间不同。每个菜从放入到煮熟需要特定的时间，具体描述为：在第 x 秒放入的菜需要煮 y 秒后才能达到刚好合适的状态。 手速限制： 你每次只能捞一个菜，捞完一个菜后由于手速限制，需要等待 m 秒后才能再次捞下一个菜。 目标： 在限制条件下（每次捞菜需要等待 m 秒），最大化吃到刚好合适的菜的数量。\n菜的描述：\n有 n 个菜依次被放入火锅，每个菜放入的时间和煮熟的时间不同。每个菜从放入到煮熟需要特定的时间，具体描述为：在第 x 秒放入的菜需要煮 y 秒后才能达到刚好合适的状态。\n手速限制：\n你每次只能捞一个菜，捞完一个菜后由于手速限制，需要等待 m 秒后才能再次捞下一个菜。\n目标：\n在限制条件下（每次捞菜需要等待 m 秒），最大化吃到刚好合适的菜的数量。\n输入：\n123\n解析：\n总共有 2 个菜（n = 2），你的手速需要 1 秒的冷却时间（m = 1）。第一个菜在第 1 秒放入，需要 2 秒才能煮熟，所以这个菜在第 3 秒刚好煮熟。第二个菜在第 2 秒放入，需要 1 秒煮熟，所以在第 3 秒刚好煮熟。\n输出：\n1\n解释：\n两个菜都在第 3 秒刚好煮熟，但你在第 3 秒只能捞一个，因为你捞完一个菜后要等 1 秒才能捞下一个菜。因此，你最多只能捞到其中一个刚好合适的菜，所以输出 1。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);  // 创建Scanner对象用于获取用户输入\n        int n = scanner.nextInt();  // 读取菜的个数n\n        int m = scanner.nextInt();  // 读取手速m，即每次捞菜后必须等待的时间\n\n        List<Integer> times = new ArrayList<>();  // 用于存储每道菜煮熟的时间点\n        for (int i = 0; i < n; i++) {\n            int start = scanner.nextInt();  // 读取开始时间\n            int duration = scanner.nextInt();  // 读取持续时间\n            times.add(start + duration);  // 计算并存储每道菜的煮熟时间\n        }\n\n        int[] nums = new int[getMax(times) + 1];  // 创建一个数组，用于标记每个时间点是否有菜\n        for (int t : times) {\n            nums[t] = 1;  // 将有菜的时间点标记为1\n        }\n\n        List<Integer> dp = new ArrayList<>();  // 用于存储不同策略下吃到的菜的数量\n\n        dfs(1, new ArrayList<>(), nums, dp, m);  // 从时间点1开始，使用深度优先搜索\n\n        int max = 0;\n        for (int count : dp) {\n            max = Math.max(max, count);  // 找出能吃到最多菜的策略\n        }\n\n        System.out.println(max);  // 输出最多能吃到的菜的数量\n    }\n\n    private static void dfs(int t, List<Integer> data, int[] nums, List<Integer> dp, int m) {\n        if (t >= nums.length) {  // 如果时间点超出范围，计算当前策略的总菜数\n            int sum = 0;\n            for (int count : data) {\n                sum += count;  // 统计吃到的菜的总数\n            }\n            dp.add(sum);  // 将结果加入dp列表\n            return;\n        }\n\n        if (nums[t] == 1) {  // 当前时间点有菜\n            List<Integer> newData = new ArrayList<>(data);  // 创建一个新的策略列表\n            newData.add(1);  // 添加吃到的菜\n            dfs(t + m, newData, nums, dp, m);  // 选择捞菜后跳过m个时间点继续搜索\n            dfs(t + 1, data, nums, dp, m);  // 不捞菜，继续搜索下一个时间点\n        } else {\n            dfs(t + 1, data, nums, dp, m);  // 如果当前时间点没有菜，直接搜索下一个时间点\n        }\n    }\n\n    private static int getMax(List<Integer> list) {\n        int max = Integer.MIN_VALUE;\n        for (int num : list) {\n            max = Math.max(max, num);  // 找出列表中的最大值\n        }\n        return max;\n    }\n}",
      "python": "n, m = list(map(int, input().split()))  # 输入n和m，n代表菜的个数，m代表手速\n\ntimes = []  # 用来存储每个菜的时间\nfor _ in range(n):\n    start, duration = list(map(int, input().split()))  # 输入每个菜的开始时间和需要的时间\n    times.append(start + duration)  # 将每个菜的结束时间存入times列表中\n\nnums = [0] * (max(times) + 1)  # 用来记录每个时间点是否有菜，初始化为0\nfor t in times:\n    nums[t] = 1  # 将有菜的时间点置为1\n\ndp = []  # 用来存储每种策略下能吃到的刚好合适的菜的数量\n\ndef dfs(t, data):  # 深度优先搜索函数，t表示当前时间点，data表示当前策略下已经吃到的菜的数量\n    if t >= len(nums):  # 如果当前时间点超过了最大时间点，说明已经搜索完所有时间点\n        dp.append(sum(data))  # 将当前策略下吃到的菜的数量加入dp列表中\n        return\n    if nums[t] == 1:  # 如果当前时间点有菜\n        dfs(t + m, data + [1])  # 选择捞菜，并将捞到的菜的数量加入data列表中\n        dfs(t + 1, data)  # 不捞菜，继续搜索下一个时间点\n    else:  # 如果当前时间点没有菜\n        dfs(t + 1, data)  # 直接搜索下一个时间点\n\ndfs(1, [])  # 从第一个时间点开始搜索，初始策略下没有吃到任何菜\n\nprint(max(dp))  # 输出最多能吃到的刚好合适的菜的数量",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst lines = [];\nlet n = 0, m = 0;\n\nrl.on('line', (line) => {\n  lines.push(line);\n  if (lines.length === 1) {\n    const [nStr, mStr] = line.split(' ');  // 读取n和m，n代表菜的个数，m代表手速\n    n = parseInt(nStr);\n    m = parseInt(mStr);\n  }\n  if (n > 0 && lines.length === n + 1) {  // 当读取的行数等于n+1时，开始处理数据\n    lines.shift();  // 移除第一行，因为已经读取了n和m\n    const times = [];\n    for (let i = 0; i < n; i++) {\n      const [startStr, durationStr] = lines[i].split(' ');  // 读取每道菜的开始时间和持续时间\n      const start = parseInt(startStr);\n      const duration = parseInt(durationStr);\n      times.push(start + duration);  // 计算每道菜的煮熟时间并存入times数组\n    }\n    const nums = new Array(Math.max(...times) + 1).fill(0);  // 创建一个数组标记时间点是否有菜\n    for (let t of times) {\n      nums[t] = 1;  // 将有菜的时间点标记为1\n    }\n    const dp = [];  // 用于存储不同策略下吃到的菜的数量\n\n    function dfs(t, data) {  // 深度优先搜索函数\n      if (t >= nums.length) {  // 如果时间点超出范围，计算当前策略的总菜数\n        dp.push(data.reduce((a, b) => a + b, 0));  // 统计吃到的菜的总数并加入dp\n        return;\n      }\n      if (nums[t] === 1) {  // 如果当前时间点有菜\n        dfs(t + m, [...data, 1]);  // 选择捞菜后跳过m个时间点继续搜索\n        dfs(t + 1, data);  // 不捞菜，继续搜索下一个时间点\n      } else {\n        dfs(t + 1, data);  // 当前时间点没有菜，直接搜索下一个时间点\n      }\n    }\n\n    dfs(1, []);  // 从时间点1开始搜索\n\n    console.log(Math.max(...dp));  // 输出最多能吃到的菜的数量\n    rl.close();  // 关闭输入流\n  }\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nvoid dfs(int t, vector<int>& nums, vector<int>& dp, vector<int>& data, int m) {\n    if (t >= nums.size()) {  // 如果时间点超出范围\n        dp.push_back(accumulate(data.begin(), data.end(), 0));  // 统计当前策略下吃到的菜的总数并加入dp\n        return;\n    }\n    if (nums[t] == 1) {  // 如果当前时间点有菜\n        data.push_back(1);  // 记录捞到的菜\n        dfs(t + m, nums, dp, data, m);  // 选择捞菜后跳过m个时间点继续搜索\n        data.pop_back();  // 撤销选择\n    }\n    dfs(t + 1, nums, dp, data, m);  // 不论是否捞菜，都继续搜索下一个时间点\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;  // 输入菜的个数n和手速m\n    \n    vector<int> times;\n    for (int i = 0; i < n; i++) {\n        int start, duration;\n        cin >> start >> duration;  // 输入每道菜的开始时间和持续时间\n        times.push_back(start + duration);  // 计算每道菜的煮熟时间并存入times数组\n    }\n    \n    int maxTime = *max_element(times.begin(), times.end());  // 找到最大时间点\n    vector<int> nums(maxTime + 1, 0);  // 创建一个数组标记时间点是否有菜\n    for (int t : times) {\n        nums[t] = 1;  // 将有菜的时间点标记为1\n    }\n    \n    vector<int> dp;  // 用于存储不同策略下吃到的菜的数量\n    vector<int> data;  // 用于存储当前策略\n    dfs(1, nums, dp, data, m);  // 从时间点1开始搜索\n    \n    cout << *max_element(dp.begin(), dp.end()) << endl;  // 输出最多能吃到的菜的数量\n    \n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 1000  // 假定最多有1000个菜，可以根据实际需求调整\n\n// 用于获取数组中的最大值\nint getMax(int* array, int size) {\n    int max = array[0];  // 假设第一个元素为最大值\n    for (int i = 1; i < size; i++) {\n        if (array[i] > max) {\n            max = array[i];  // 更新最大值\n        }\n    }\n    return max;\n}\n\n// 深度优先搜索函数\nvoid dfs(int t, int* data, int data_size, int* nums, int nums_size, int* dp, int* dp_size, int m) {\n    if (t >= nums_size) {  // 如果当前时间点超出范围\n        int sum = 0;\n        for (int i = 0; i < data_size; i++) {\n            sum += data[i];  // 统计当前策略下吃到的菜的数量\n        }\n        dp[(*dp_size)++] = sum;  // 将结果存储在dp数组中\n        return;\n    }\n\n    if (nums[t] == 1) {  // 如果当前时间点有菜\n        int* newData = (int*)malloc((data_size + 1) * sizeof(int));  // 创建新的策略数组\n        for (int i = 0; i < data_size; i++) {\n            newData[i] = data[i];  // 原来的策略\n        }\n        newData[data_size] = 1;  // 在当前策略中增加捞到的一道菜\n        dfs(t + m, newData, data_size + 1, nums, nums_size, dp, dp_size, m);  // 选择捞菜后跳过m个时间点继续搜索\n        free(newData);  // 释放动态分配的内存\n        dfs(t + 1, data, data_size, nums, nums_size, dp, dp_size, m);  // 不捞菜，继续搜索下一个时间点\n    } else {\n        dfs(t + 1, data, data_size, nums, nums_size, dp, dp_size, m);  // 如果当前时间点没有菜，直接搜索下一个时间点\n    }\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);  // 读取菜的个数n和手速m\n\n    int times[MAX_SIZE];  // 用于存储每道菜煮熟的时间点\n    for (int i = 0; i < n; i++) {\n        int start, duration;\n        scanf(\"%d %d\", &start, &duration);  // 读取每道菜的开始时间和持续时间\n        times[i] = start + duration;  // 计算并存储每道菜的煮熟时间\n    }\n\n    int max_time = getMax(times, n);  // 获取所有菜中最大的煮熟时间\n    int nums[MAX_SIZE] = {0};  // 创建并初始化标记数组，用于标记每个时间点是否有菜\n    for (int i = 0; i < n; i++) {\n        nums[times[i]] = 1;  // 将有菜的时间点标记为1\n    }\n\n    int dp[MAX_SIZE] = {0};  // 用于存储不同策略下吃到的菜的数量\n    int dp_size = 0;  // 当前存储的策略数\n\n    int data[MAX_SIZE] = {0};  // 初始策略为空\n    dfs(1, data, 0, nums, max_time + 1, dp, &dp_size, m);  // 从时间点1开始搜索\n\n    int max = 0;\n    for (int i = 0; i < dp_size; i++) {\n        if (dp[i] > max) {\n            max = dp[i];  // 找出能吃到最多菜的策略\n        }\n    }\n\n    printf(\"%d\\n\", max);  // 输出最多能吃到的菜的数量\n\n    return 0;\n}"
    }
  },
  {
    "id": "168",
    "title": "找单词",
    "examType": "A",
    "score": 200,
    "description": "给一个字符串和一个二维字符数组，如果该字符串存在于该数组中，则按字符串的字符顺序输出字符串每个字符所在单元格的位置下标字符串，如果找不到返回字符串“N”。\n需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。 同一个单元格内的字母不允许被重复使用。 假定在数组中最多只存在一个可能的匹配。\n需要按照字符串的字符组成顺序搜索，且搜索到的位置必须是相邻单元格，其中“相邻单元格”是指那些水平相邻或垂直相邻的单元格。\n同一个单元格内的字母不允许被重复使用。\n假定在数组中最多只存在一个可能的匹配。",
    "inputDesc": "第1行为一个数字N指示二维数组在后续输入所占的行数。\n第2行到第N+1行输入为一个二维大写字符数组，每行字符用半角,分割。\n第N+2行为待查找的字符串，由大写字符组成。\n二维数组的大小为N*N，0<N<=100。 单词长度K，0<K<1000。\n二维数组的大小为N*N，0<N<=100。\n单词长度K，0<K<1000。",
    "outputDesc": "出一个位置下标字符串，拼接格式为：第1个字符行下标+”,”+第1个字符列下标+”,”+第2个字符行下标+”,”+第2个字符列下标… +”,”+第N个字符行下标+”,”+第N个字符列下标。",
    "examples": [
      {
        "input": "A,C,C,F\nC,D,E,D\nB,E,S,S\nF,E,C,A\nACCESS",
        "output": ",0,0,1,0,2,1,2,2,2,2,3",
        "explanation": "ACCESS分别对应二维数组的[0,0] [0,1] [0,2] [1,2] [2,2] [2,3]下标位置。"
      }
    ],
    "solution": "该题目要求在一个二维字符数组（棋盘）中寻找一个给定的字符串，并按特定规则返回字符串每个字符在数组中的位置。题目的核心是使用深度优先搜索（DFS）方法，从二维数组的每一个字符出发，按顺序查找相邻位置的字符是否能组成目标字符串。如果找到就输出路径下标字符串，如果找不到就返回 “N”。\n字符顺序和相邻性： 需要按照给定字符串中字符的顺序在二维字符数组中寻找匹配。字符在二维数组中的位置必须是相邻的。相邻的定义是：水平方向（左右相邻）或垂直方向（上下相邻）的单元格。 不可重复使用： 在寻找过程中，同一个单元格中的字母不能被重复使用。例如，如果某个位置的字母已经被用来匹配字符串的一部分，那么在匹配同一个字符串的其他部分时不能再次使用这个位置。 重要条件： 假设在二维数组中，最多只有一个可能的匹配路径。这意味着如果找到了一个匹配的字符串路径，就不需要考虑其他可能性。\n需要按照给定字符串中字符的顺序在二维字符数组中寻找匹配。字符在二维数组中的位置必须是相邻的。相邻的定义是：水平方向（左右相邻）或垂直方向（上下相邻）的单元格。\n在寻找过程中，同一个单元格中的字母不能被重复使用。例如，如果某个位置的字母已经被用来匹配字符串的一部分，那么在匹配同一个字符串的其他部分时不能再次使用这个位置。\n假设在二维数组中，最多只有一个可能的匹配路径。这意味着如果找到了一个匹配的字符串路径，就不需要考虑其他可能性。\n示例用例解析：\n输入： 4 A,C,C,F C,D,E,D B,E,S,S F,E,C,A ACCESS 123456 这里二维数组是： A C C F C D E D B E S S F E C A 1234 需要查找的字符串是 “ACCESS”。 输出： 0,0,0,1,0,2,1,2,2,2,2,3 1 查找过程：在二维数组中，字符串 “ACCESS” 的路径是： ‘A’ 在 [0,0]‘C’ 在 [0,1]‘C’ 在 [0,2]‘E’ 在 [1,2]‘S’ 在 [2,2]‘S’ 在 [2,3] 输出按照这些位置下标拼接成字符串 “0,0,0,1,0,2,1,2,2,2,2,3”。\n输入：\n123456\n这里二维数组是：\n1234\n需要查找的字符串是 “ACCESS”。\n输出：\n1\n查找过程：在二维数组中，字符串 “ACCESS” 的路径是： ‘A’ 在 [0,0]‘C’ 在 [0,1]‘C’ 在 [0,2]‘E’ 在 [1,2]‘S’ 在 [2,2]‘S’ 在 [2,3] 输出按照这些位置下标拼接成字符串 “0,0,0,1,0,2,1,2,2,2,2,3”。\n‘A’ 在 [0,0]‘C’ 在 [0,1]‘C’ 在 [0,2]‘E’ 在 [1,2]‘S’ 在 [2,2]‘S’ 在 [2,3]",
    "codes": {
      "java": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n    // 定义全局变量\n    private static int n;  // 二维数组的大小\n    private static String[][] matrix;  // 二维数组\n    private static String tar;  // 待查找的字符串\n    private static boolean[][] visited;  // 记录每个单元格是否已被访问\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();  // 读取二维数组的大小\n        scanner.nextLine();  // 读取并忽略换行符\n        matrix = new String[n][n];  // 初始化二维数组\n        // 读取二维数组的每一行\n        for (int i = 0; i < n; i++) {\n            String line = scanner.nextLine();\n            matrix[i] = line.split(\",\");  // 使用逗号分割每一行，得到每个单元格的字符\n        }\n        tar = scanner.nextLine();  // 读取待查找的字符串\n        scanner.close();  // 关闭扫描器\n\n        visited = new boolean[n][n];  // 初始化访问记录数组\n        String result = findString();  // 查找字符串\n        System.out.println(result);  // 输出结果\n    }\n\n    // 查找字符串的函数\n    public static String findString() {\n        LinkedList<Integer[]> path = new LinkedList<>();  // 存储路径的链表\n        // 遍历二维数组的每个单元格\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                // 如果当前单元格的字符与待查找字符串的第一个字符相同\n                if (matrix[i][j].equals(tar.substring(0, 1))) {\n                    // 使用深度优先搜索查找字符串\n                    boolean found = dfs(i, j, 0, path);\n                    // 如果找到了字符串\n                    if (found) {\n                        StringBuilder sb = new StringBuilder();\n                        // 将路径中的每个单元格的位置添加到结果字符串中\n                        for (Integer[] pos : path) {\n                            sb.append(pos[0]).append(\",\").append(pos[1]).append(\",\");\n                        }\n                        sb.deleteCharAt(sb.length() - 1);  // 删除最后一个逗号\n                        return sb.toString();  // 返回结果字符串\n                    }\n                }\n            }\n        }\n        return \"N\";  // 如果没有找到字符串，返回\"N\"\n    }\n\n    // 深度优先搜索的函数\n    public static boolean dfs(int i, int j, int k, LinkedList<Integer[]> path) {\n        // 如果当前位置越界，或已被访问，或当前位置的字符与待查找字符串的当前字符不相同\n        if (i < 0 || i >= n || j < 0 || j >= n || visited[i][j] || !tar.substring(k, k + 1).equals(matrix[i][j])) {\n            return false;  // 返回false\n        }\n        path.add(new Integer[] {i, j});  // 将当前位置添加到路径中\n        visited[i][j] = true;  // 标记当前位置已被访问\n        // 如果已经找到了所有的字符\n        if (k == tar.length() - 1) {\n            return true;  // 返回true\n        }\n        // 定义四个方向\n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        // 对四个方向进行深度优先搜索\n        for (int[] direction : directions) {\n            int ni = i + direction[0];\n            int nj = j + direction[1];\n            boolean res = dfs(ni, nj, k + 1, path);\n            // 如果在某个方向上找到了字符串\n            if (res) {\n                return true;  // 返回true\n            }\n        }\n        visited[i][j] = false;  // 撤销对当前位置的访问标记\n        path.removeLast();  // 从路径中移除当前位置\n        return false;  // 返回false\n    }\n}",
      "python": "n = int(input())  # 读取二维数组的大小\nmatrix = []  # 初始化二维数组\nfor _ in range(n):  # 读取二维数组的每一行\n    line = input()\n    matrix.append(line.split(\",\"))  # 使用逗号分割每一行，得到每个单元格的字符\ntar = input()  # 读取待查找的字符串\n\nvisited = [[False] * n for _ in range(n)]  # 初始化访问记录数组\n\ndef findString():\n    path = []  # 存储路径的列表\n    for i in range(n):  # 遍历二维数组的每个单元格\n        for j in range(n):\n            if matrix[i][j] == tar[0]:  # 如果当前单元格的字符与待查找字符串的第一个字符相同\n                found = dfs(i, j, 0, path)  # 使用深度优先搜索查找字符串\n                if found:  # 如果找到了字符串\n                    result = \"\"  # 初始化结果字符串\n                    for pos in path:  # 将路径中的每个单元格的位置添加到结果字符串中\n                        result += str(pos[0]) + \",\" + str(pos[1]) + \",\"\n                    result = result[:-1]  # 删除最后一个逗号\n                    return result  # 返回结果字符串\n    return \"N\"  # 如果没有找到字符串，返回\"N\"\n\ndef dfs(i, j, k, path):\n    # 如果当前位置越界，或已被访问，或当前位置的字符与待查找字符串的当前字符不相同\n    if i < 0 or i >= n or j < 0 or j >= n or visited[i][j] or tar[k] != matrix[i][j]:\n        return False  # 返回false\n    path.append([i, j])  # 将当前位置添加到路径中\n    visited[i][j] = True  # 标记当前位置已被访问\n    if k == len(tar) - 1:  # 如果已经找到了所有的字符\n        return True  # 返回true\n    directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]  # 定义四个方向\n    for direction in directions:  # 对四个方向进行深度优先搜索\n        ni = i + direction[0]\n        nj = j + direction[1]\n        res = dfs(ni, nj, k + 1, path)\n        if res:  # 如果在某个方向上找到了字符串\n            return True  # 返回true\n    visited[i][j] = False  # 撤销对当前位置的访问标记\n    path.pop()  # 从路径中移除当前位置\n    return False  # 返回false\n\nresult = findString()  # 查找字符串\nprint(result)  # 输出结果",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,  // 输入流为标准输入\n  output: process.stdout  // 输出流为标准输出\n});\n\n// 存储输入的每一行数据\nconst lines = [];\n// 存储二维数组的大小\nlet n;\n\n// 监听命令行输入的每一行数据\nrl.on(\"line\", (line) => {\n  // 将每一行数据存入lines数组\n  lines.push(line);\n  // 如果输入的是二维数组的大小\n  if (lines.length === 1) {\n    n = parseInt(lines[0]);\n  }\n  // 如果输入的是二维数组和待查找的字符串\n  if (n && lines.length === n + 2) {\n    // 删除lines数组中的第一个元素，即二维数组的大小\n    lines.shift();\n    // 将lines数组中的最后一个元素，即待查找的字符串，存入变量str\n    const str = lines.pop();\n    // 将lines数组中的其余元素，即二维数组的每一行，按逗号分隔存入二维数组grid\n    const grid = lines.map((line) => line.split(\",\"));\n    // 调用findString函数，输出结果\n    console.log(findString(grid, n, str));\n    // 清空lines数组\n    lines.length = 0;\n  }\n});\n\n// 查找字符串的函数\nfunction findString(grid, n, tar) {\n  // 创建一个n*n的二维数组，所有元素初始化为false，表示没有被访问过\n  const visited = Array.from(Array(n), () => Array(n).fill(false));\n  // 存储路径的数组\n  const path = [];\n  // 遍历二维数组的每个单元格\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      // 如果当前单元格的字符与待查找字符串的第一个字符相同\n      if (grid[i][j] === tar[0]) {\n        // 使用深度优先搜索查找字符串\n        const found = dfs(i, j, 0, path);\n        // 如果找到了字符串\n        if (found) {\n          // 初始化结果字符串\n          let result = \"\";\n          // 将路径中的每个单元格的位置添加到结果字符串中\n          for (const pos of path) {\n            result += pos[0] + \",\" + pos[1] + \",\";\n          }\n          // 删除最后一个逗号\n          result = result.slice(0, -1);\n          // 返回结果字符串\n          return result;\n        }\n      }\n    }\n  }\n  // 如果没有找到字符串，返回\"N\"\n  return \"N\";\n\n  // 深度优先搜索的函数\n  function dfs(i, j, k, path) {\n    // 如果当前位置越界，或已被访问，或当前位置的字符与待查找字符串的当前字符不相同\n    if (\n      i < 0 ||\n      i >= n ||\n      j < 0 ||\n      j >= n ||\n      visited[i][j] ||\n      tar[k] !== grid[i][j]\n    ) {\n      // 返回false\n      return false;\n    }\n    // 将当前位置添加到路径中\n    path.push([i, j]);\n    // 标记当前位置已被访问\n    visited[i][j] = true;\n    // 如果已经找到了所有的字符\n    if (k === tar.length - 1) {\n      // 返回true\n      return true;\n    }\n    // 定义四个方向\n    const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n    // 对四个方向进行深度优先搜索\n    for (const direction of directions) {\n      const ni = i + direction[0];\n      const nj = j + direction[1];\n      const res = dfs(ni, nj, k + 1, path);\n      // 如果在某个方向上找到了字符串\n      if (res) {\n        // 返回true\n        return true;\n      }\n    }\n    // 撤销对当前位置的访问标记\n    visited[i][j] = false;\n    // 从路径中移除当前位置\n    path.pop();\n    // 返回false\n    return false;\n  }\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint n;  // 二维数组的大小\nvector<vector<string>> matrix;  // 二维数组\nstring tar;  // 待查找的字符串\nvector<vector<bool>> visited;  // 记录每个单元格是否已被访问\n\nstring findString();  // 查找字符串的函数声明\nbool dfs(int i, int j, int k, vector<vector<int>>& path);  // 深度优先搜索的函数声明\n\nint main() {\n    cin >> n;  // 读取二维数组的大小\n    cin.ignore();  // 忽略换行符\n    matrix.resize(n, vector<string>(n));  // 初始化二维数组\n    for (int i = 0; i < n; i++) {  // 读取二维数组的每一行\n        string line;\n        getline(cin, line);\n        int pos = 0;\n        for (int j = 0; j < n; j++) {  // 使用逗号分割每一行，得到每个单元格的字符\n            int comma = line.find(',', pos);\n            matrix[i][j] = line.substr(pos, comma - pos);\n            pos = comma + 1;\n        }\n    }\n    getline(cin, tar);  // 读取待查找的字符串\n\n    visited.resize(n, vector<bool>(n));  // 初始化访问记录数组\n    string result = findString();  // 查找字符串\n    cout << result << endl;  // 输出结果\n\n    return 0;\n}\n\nstring findString() {\n    vector<vector<int>> path;  // 存储路径的列表\n    for (int i = 0; i < n; i++) {  // 遍历二维数组的每个单元格\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] == tar.substr(0, 1)) {  // 如果当前单元格的字符与待查找字符串的第一个字符相同\n                bool found = dfs(i, j, 0, path);  // 使用深度优先搜索查找字符串\n                if (found) {  // 如果找到了字符串\n                    string result;  // 初始化结果字符串\n                    for (vector<int>& pos : path) {  // 将路径中的每个单元格的位置添加到结果字符串中\n                        result += to_string(pos[0]) + \",\" + to_string(pos[1]) + \",\";\n                    }\n                    result.pop_back();  // 删除最后一个逗号\n                    return result;  // 返回结果字符串\n                }\n            }\n        }\n    }\n    return \"N\";  // 如果没有找到字符串，返回\"N\"\n}\n\nbool dfs(int i, int j, int k, vector<vector<int>>& path) {\n    // 如果当前位置越界，或已被访问，或当前位置的字符与待查找字符串的当前字符不相同\n    if (i < 0 || i >= n || j < 0 || j >= n || visited[i][j] || tar.substr(k, 1) != matrix[i][j]) {\n        return false;  // 返回false\n    }\n    path.push_back({i, j});  // 将当前位置添加到路径中\n    visited[i][j] = true;  // 标记当前位置已被访问\n    if (k == tar.length() - 1) {  // 如果已经找到了所有的字符\n        return true;  // 返回true\n    }\n    vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};  // 定义四个方向\n    for (vector<int>& direction : directions) {  // 对四个方向进行深度优先搜索\n        int ni = i + direction[0];\n        int nj = j + direction[1];\n        bool res = dfs(ni, nj, k + 1, path);\n        if (res) {  // 如果在某个方向上找到了字符串\n            return true;  // 返回true\n        }\n    }\n    visited[i][j] = false;  // 撤销对当前位置的访问标记\n    path.pop_back();  // 从路径中移除当前位置\n    return false;  // 返回false\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_SIZE 100\n\nint n;  // 二维数组的大小\nchar matrix[MAX_SIZE][MAX_SIZE];  // 二维字符数组\nbool visited[MAX_SIZE][MAX_SIZE];  // 访问状态数组\nchar tar[MAX_SIZE];  // 待查找的字符串\n\n// 深度优先搜索\nbool dfs(int x, int y, int index, char *path) {\n    if (index == strlen(tar)) return true;  // 如果找到了字符串，返回true\n\n    if (x < 0 || x >= n || y < 0 || y >= n || visited[x][y] || matrix[x][y] != tar[index]) {\n        return false;  // 越界、已访问或不匹配的情况下，返回false\n    }\n\n    int len = strlen(path);\n    sprintf(path + len, \"%d,%d,\", x, y);  // 记录路径\n    visited[x][y] = true;  // 标记当前单元格为已访问\n\n    // 四个方向的搜索\n    static int dx[4] = {-1, 0, 1, 0};\n    static int dy[4] = {0, 1, 0, -1};\n    for (int i = 0; i < 4; i++) {\n        if (dfs(x + dx[i], y + dy[i], index + 1, path)) {\n            return true;  // 如果找到，返回true\n        }\n    }\n\n    visited[x][y] = false;  // 回溯\n    path[len] = '\\0';  // 撤销路径记录\n    return false;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    char buffer[200];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", buffer);\n        char *token = strtok(buffer, \",\");\n        int j = 0;\n        while (token != NULL) {\n            matrix[i][j++] = token[0];\n            token = strtok(NULL, \",\");\n        }\n    }\n    scanf(\"%s\", tar);\n\n    char path[1000] = {0};  // 存储路径的字符串\n    memset(visited, 0, sizeof(visited));  // 初始化访问状态数组\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(i, j, 0, path)) {\n                path[strlen(path) - 1] = '\\0';  // 移除最后的逗号\n                printf(\"%s\\n\", path);\n                return 0;\n            }\n        }\n    }\n\n    printf(\"N\\n\");  // 如果没有找到字符串，输出\"N\"\n    return 0;\n}"
    }
  },
  {
    "id": "169",
    "title": "最大社交距离",
    "examType": "A",
    "score": 200,
    "description": "疫情期间需要大家保证一定的社交距离，公司组织开交流会议。座位一排共 N 个座位，编号分别为[0,N-1],\n要求员工一个接着一个进入会议室，并且可以在任何时候离开会议室。\n满足：\n每当一个员工进入时，需要坐到最大社交距离（最大化自己和其他人的距离的座位）；如果有多个这样的座位，则坐到索引最小的那个座位。",
    "inputDesc": "会议室座位总数 seatNum\n1 ≤ seatNum ≤ 500\n员工的进出顺序 seatOrLeave 数组\n元素值为 1，表示进场 元素值为负数，表示出场（特殊：位置 0 的员工不会离开） 例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上）\n元素值为 1，表示进场\n元素值为负数，表示出场（特殊：位置 0 的员工不会离开）\n例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上）",
    "outputDesc": "最后进来员工，他会坐在第几个位置，如果位置已满，则输出-1。",
    "examples": [
      {
        "input": "[1, 1, 1, 1, -4, 1]",
        "output": "",
        "explanation": "seat -> 0,空在任何位置都行，但是要给他安排索引最小的位置，也就是座位 0 seat -> 9,要和旁边的人距离最远，也就是座位 9 seat -> 4,要和旁边的人距离最远，应该坐到中间，也就是座位 4 seat -> 2,员工最后坐在 2 号座位上 leave[4], 4 号座位的员工离开 seat -> 5,员工最后坐在 5 号座位上"
      }
    ],
    "solution": "动态维护一个已占用座位的列表，并在每次有员工进入时计算最佳座位，以及在有员工离开时更新座位状态 。\n初始化座位状态：使用一个动态数组seat来记录当前已被占用的座位编号。 处理每个操作：遍历给定的操作序列seatOrLeave，对于每个操作： 如果操作为正数（即1），表示有员工进入： 会议室为空：如果当前seat数组为空，说明会议室内没有人，新员工直接坐在0号座位。会议室不为空：遍历seat数组，计算每两个相邻已占座位之间的距离，以及第一个座位到0号座位的距离和最后一个座位到seatNum-1的距离。找到这些距离中的最大值对应的座位，作为新员工的座位。 如果操作为负数，表示有员工离开，根据操作值的绝对值找到对应的座位编号，并从seat数组中移除该座位编号。 更新座位状态：对于进入的员工，将其座位编号添加到seat数组中，并对seat数组进行排序，以便下次操作时能快速找到最佳座位。 输出结果：在处理完所有操作后，输出最后一个进入的员工的座位编号。如果会议室已满，则输出-1。\n初始化座位状态：使用一个动态数组seat来记录当前已被占用的座位编号。\n处理每个操作：遍历给定的操作序列seatOrLeave，对于每个操作：\n如果操作为正数（即1），表示有员工进入： 会议室为空：如果当前seat数组为空，说明会议室内没有人，新员工直接坐在0号座位。会议室不为空：遍历seat数组，计算每两个相邻已占座位之间的距离，以及第一个座位到0号座位的距离和最后一个座位到seatNum-1的距离。找到这些距离中的最大值对应的座位，作为新员工的座位。 如果操作为负数，表示有员工离开，根据操作值的绝对值找到对应的座位编号，并从seat数组中移除该座位编号。\n会议室为空：如果当前seat数组为空，说明会议室内没有人，新员工直接坐在0号座位。会议室不为空：遍历seat数组，计算每两个相邻已占座位之间的距离，以及第一个座位到0号座位的距离和最后一个座位到seatNum-1的距离。找到这些距离中的最大值对应的座位，作为新员工的座位。\n更新座位状态：对于进入的员工，将其座位编号添加到seat数组中，并对seat数组进行排序，以便下次操作时能快速找到最佳座位。\n输出结果：在处理完所有操作后，输出最后一个进入的员工的座位编号。如果会议室已满，则输出-1。",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取输入\n        int seatNum = scanner.nextInt();  // 读取座位总数\n        scanner.nextLine();  // 读取换行符\n        String str = scanner.nextLine();  // 读取座位占用和离开的操作序列\n        // 去除字符串首尾的括号并分割成数组\n        String[] parts = str.substring(1, str.length() - 1).split(\",\");\n        ArrayList<Integer> seatOrLeave = new ArrayList<>();\n        for (String part : parts) {\n            seatOrLeave.add(Integer.parseInt(part.trim()));  // 转换为整数并添加到列表\n        }\n\n        // 初始化\n        ArrayList<Integer> seat = new ArrayList<>();  // 存储已占用的座位\n        int ans = -1;  // 下一个人的最佳座位号\n\n        // 遍历座位占用和离开的操作序列\n        for (int sol : seatOrLeave) {\n            if (sol != 1) {\n                // 如果sol为负数，表示有员工离开，移除对应座位号\n                seat.remove(Integer.valueOf(-sol));\n            } else {\n                // 如果sol为1，表示有员工进入，需要找到最佳座位\n                if (seat.isEmpty()) {\n                    // 如果会议室为空，新员工坐在0号座位\n                    ans = 0;\n                } else {\n                    // 如果会议室不为空，找到最大的空闲区间\n                    int maxDistance = seat.get(0);  // 初始化最大距离为第一个座位号\n                    ans = 0;  // 初始化最佳座位号为0\n                    for (int i = 0; i < seat.size(); i++) {\n                        int distance;\n                        if (i == seat.size() - 1) {\n                            // 检查最后一个座位到座位总数之间的距离\n                            distance = seatNum - 1 - seat.get(i);\n                        } else {\n                            // 检查相邻座位之间的距离\n                            distance = (seat.get(i + 1) - seat.get(i)) / 2;\n                        }\n                        if (distance > maxDistance) {\n                            // 更新最大距离和最佳座位号\n                            maxDistance = distance;\n                            ans = (i == seat.size() - 1) ? seatNum - 1 : seat.get(i) + distance;\n                        }\n                    }\n                }\n\n                // 如果会议室已满，设置最佳座位号为-1\n                if (seat.size() == seatNum) {\n                    ans = -1;\n                } else {\n                    // 将新员工的座位号加入到座位列表，并排序\n                    seat.add(ans);\n                    Collections.sort(seat);\n                }\n            }\n        }\n\n        // 打印最后一个操作后的最佳座位号\n        System.out.println(ans);\n        scanner.close();\n    }\n}",
      "python": "import math\n\n# 读取输入\nseatNum = int(input())  # 座位总数\nstr = input()  # 座位占用和离开的操作序列\nseatOrLeave = list(map(int, str[1:-1].split(\",\")))  # 将字符串转换为整数数组\n\n# 初始化\nseat = []  # 存储已占用的座位\nans = -1  # 下一个人的最佳座位号\n\nfor sol in seatOrLeave:  # 遍历座位占用和离开的操作序列\n    if sol != 1:\n        # 如果sol为负数，表示有员工离开，移除对应座位号\n        seat.remove(-sol)\n    else:\n        # 如果sol为1，表示有员工进入，需要找到最佳座位\n        if not seat:\n            # 如果会议室为空，新员工坐在0号座位\n            ans = 0\n        else:\n            # 如果会议室不为空，找到最大的空闲区间\n            max_distance = seat[0]  # 初始化最大距离为第一个座位号\n            ans = 0  # 初始化最佳座位号为0\n            for i in range(len(seat)):\n                if i == len(seat) - 1:\n                    # 检查最后一个座位到座位总数之间的距离\n                    distance = seatNum - 1 - seat[i]\n                else:\n                    # 检查相邻座位之间的距离\n                    distance = (seat[i + 1] - seat[i]) // 2\n                if distance > max_distance:\n                    # 更新最大距离和最佳座位号\n                    max_distance = distance\n                    if i == len(seat) - 1:\n                        ans = seatNum - 1\n                    else:\n                        ans = seat[i] + distance\n\n        # 如果会议室已满，输出-1\n        if len(seat) == seatNum:\n            ans = -1\n        else:\n            # 将新员工的座位号加入到座位列表，并排序\n            seat.append(ans)\n            seat.sort()\n\nprint(ans)",
      "javascript": "const readline = require('readline');\n// 创建 readline 接口实例\nconst rl = readline.createInterface({\n    input: process.stdin,  // 标准输入流\n    output: process.stdout  // 标准输出流\n});\n\n// 监听 'line' 事件，每次输入一行触发\nrl.on('line', (seatNum) => {\n    // 再次监听 'line' 事件，获取座位占用和离开的操作序列\n    rl.on('line', (str) => {\n        // 解析输入的字符串，去掉首尾的括号，分割后转换为数字数组\n        const seatOrLeave = str.slice(1, -1).split(',').map(Number);\n\n        let seat = [];  // 存储已占用的座位\n        let ans = -1;  // 下一个人的最佳座位号\n\n        // 遍历操作序列\n        for (let sol of seatOrLeave) {\n            if (sol !== 1) {\n                // 如果操作不是1，表示有员工离开，移除对应座位号\n                seat = seat.filter(s => s !== -sol);\n            } else {\n                // 如果操作是1，表示有员工进入，需要找到最佳座位\n                if (seat.length === 0) {\n                    // 如果会议室为空，新员工坐在0号座位\n                    ans = 0;\n                } else {\n                    // 如果会议室不为空，找到最大的空闲区间\n                    let max_distance = seat[0];  // 初始化最大距离为第一个座位号\n                    ans = 0;  // 初始化最佳座位号为0\n                    for (let i = 0; i < seat.length; i++) {\n                        // 计算当前座位与下一个座位之间的距离\n                        let distance = i === seat.length - 1 ? seatNum - 1 - seat[i] : Math.floor((seat[i + 1] - seat[i]) / 2);\n                        if (distance > max_distance) {\n                            // 如果当前距离大于最大距离，则更新最大距离和最佳座位号\n                            max_distance = distance;\n                            ans = i === seat.length - 1 ? seatNum - 1 : seat[i] + distance;\n                        }\n                    }\n                }\n                // 如果会议室已满，设置最佳座位号为-1\n                if (seat.length === seatNum) {\n                    ans = -1;\n                } else {\n                    // 将新员工的座位号加入到座位列表，并按升序排序\n                    seat.push(ans);\n                    seat.sort((a, b) => a - b);\n                }\n            }\n        }\n\n        // 输出最后一个操作后的最佳座位号\n        console.log(ans);\n        // 关闭 readline 接口实例\n        rl.close();\n    });\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n\nusing namespace std;\n\n// 寻找最佳座位的函数\nint findBestSeat(const vector<int>& occupiedSeats, int seatNum) {\n    // 如果还没有人坐，第一个人坐在0号座位\n    if (occupiedSeats.empty()) return 0;\n    // 如果只有一个人坐，那么下一个人坐在最后一个座位\n    if (occupiedSeats.size() == 1) return seatNum - 1;\n\n    int maxDistance = 0, bestSeat = -1;\n    // 检查是否可以在第一个座位坐下（即第一个座位之前的空位）\n    if (occupiedSeats.front() > 0) {\n        maxDistance = occupiedSeats.front();\n        bestSeat = 0;\n    }\n    // 检查是否可以在最后一个座位坐下（即最后一个座位之后的空位）\n    if (seatNum - 1 - occupiedSeats.back() > maxDistance) {\n        maxDistance = seatNum - 1 - occupiedSeats.back();\n        bestSeat = seatNum - 1;\n    }\n    // 检查中间的最大间隔，寻找最佳座位\n    for (int i = 1; i < occupiedSeats.size(); ++i) {\n        int distance = (occupiedSeats[i] - occupiedSeats[i - 1]) / 2;\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            bestSeat = occupiedSeats[i - 1] + distance;\n        }\n    }\n    // 返回最佳座位编号\n    return bestSeat;\n}\n\nint main() {\n    int seatNum; // 会议室座位总数\n    cin >> seatNum;\n\n    string input; // 存放员工进出顺序的字符串\n    cin >> ws; // 忽略前面的空白字符\n    getline(cin, input); // 读取整行作为字符串\n\n    // 处理输入字符串，将其转换为int数组\n    stringstream ss(input.substr(1, input.size() - 2)); // 去掉字符串的首尾括号\n    vector<int> seatOrLeave;\n    int num;\n    while (ss >> num) {\n        seatOrLeave.push_back(num);\n        if (ss.peek() == ',') ss.ignore();\n    }\n\n    vector<int> occupiedSeats; // 存储已占用座位的数组\n    int lastSeat = -1; // 存储最后一个坐下的员工的座位号\n\n    // 遍历员工的进出操作\n    for (int action : seatOrLeave) {\n        if (action == 1) { // 进场操作\n            int bestSeat = findBestSeat(occupiedSeats, seatNum);\n            if (bestSeat != -1) { // 如果找到了最佳座位\n                occupiedSeats.push_back(bestSeat); // 更新已占用座位列表\n                sort(occupiedSeats.begin(), occupiedSeats.end()); // 保持座位列表排序\n                lastSeat = bestSeat; // 更新最后一个坐下的座位号\n            }\n        } else if (action < 0) { // 出场操作\n            action = -action; // 转为正数，表示座位号\n            auto it = find(occupiedSeats.begin(), occupiedSeats.end(), action);\n            if (it != occupiedSeats.end()) occupiedSeats.erase(it); // 从已占用座位中移除\n        }\n    }\n\n    cout << lastSeat << endl; // 输出最后一个进来员工的座位号\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 500 // 定义最大座位数\n\n// 比较函数，用于qsort排序\nint cmp(const void *a, const void *b) {\n    return *((int *) a) - *((int *) b);\n}\n\nint main() {\n    int seatNum; // 座位总数\n    scanf(\"%d\", &seatNum); // 读取座位总数\n\n    getchar(); // 读取换行符\n\n    int seatOrLeave[MAX_SIZE] = {0}; // 存储进出座位的数组\n    int seatOrLeave_size = 0; // 进出座位数组的当前大小\n\n    // 读取进出座位的序列，支持两种格式：[数字,] 或 数字,\n    while (scanf(\"[%d\", &seatOrLeave[seatOrLeave_size]) || scanf(\"%d\", &seatOrLeave[seatOrLeave_size])) {\n        seatOrLeave_size++; // 数组大小增加\n        if (getchar() != ',') break; // 如果不是逗号，则停止读取\n    }\n\n    int seat[MAX_SIZE]; // 存储已有人的座位号\n    int seat_size = 0; // 已有人的座位号数组的当前大小\n    int lastSeatIdx = -1; // 最后一个坐下的座位号\n\n    // 遍历所有进出记录\n    for (int i = 0; i < seatOrLeave_size; i++) {\n        int info = seatOrLeave[i]; // 当前记录\n\n        // 如果是负数，表示有人离开\n        if (info < 0) {\n            int leaveIdx = -info; // 离开的座位号\n            for (int j = 0; j < seat_size; j++) {\n                if (seat[j] == leaveIdx) {\n                    // 移除离开的座位号\n                    for (int k = j; k < seat_size - 1; k++) {\n                        seat[k] = seat[k + 1];\n                    }\n                    seat_size--; // 座位数组大小减小\n                    break;\n                }\n            }\n        } else {\n            // 如果是第一个人，则坐在第一个位置\n            if (seat_size == 0) {\n                lastSeatIdx = 0;\n                seat[seat_size++] = lastSeatIdx;\n            } else {\n                int maxDist = -1; // 最大距离\n                int bestSeat = -1; // 最佳座位\n\n                // 检查第一个座位是否空闲\n                if (seat[0] > 0) {\n                    maxDist = seat[0];\n                    bestSeat = 0;\n                }\n\n                // 遍历已坐座位，寻找最佳座位\n                for (int j = 1; j < seat_size; j++) {\n                    int dist = (seat[j] - seat[j - 1]) / 2; // 计算距离\n                    if (dist > maxDist) {\n                        maxDist = dist;\n                        bestSeat = seat[j - 1] + dist;\n                    }\n                }\n\n                // 检查最后一个座位是否空闲\n                if (seatNum - 1 - seat[seat_size - 1] > maxDist) {\n                    bestSeat = seatNum - 1;\n                }\n\n                // 如果找到了最佳座位，将其加入数组\n                if (bestSeat >= 0 && seat_size < seatNum) {\n                    seat[seat_size++] = bestSeat;\n                    qsort(seat, seat_size, sizeof(int), cmp); // 排序座位数组\n                }\n\n                lastSeatIdx = bestSeat; // 更新最后一个坐下的座位号\n            }\n        }\n    }\n\n    printf(\"%d\\n\", lastSeatIdx); // 打印最后一个坐下的座位号\n\n    return 0;\n}"
    }
  },
  {
    "id": "170",
    "title": "最长方连续方波信号",
    "examType": "A",
    "score": 200,
    "description": "输入一串方波信号，求取最长的完全连续交替方波信号，并将其输出，如果有相同长度的交替方波信号，输出任一即可。方波信号高位用1标识，低位用0标识 。\n说明：\n一个完整的信号一定以0开始然后以0结尾，即010是一个完整信号，但101，1010，0101不是输入的一串方波信号是由一个或多个完整信号组成两个相邻信号之间可能有0个或多个低位，如0110010，011000010同一个信号中可以有连续的高位，如01110101011110001010，前14位是一个具有连续高位的信号完全连续交替方波是指10交替，如01010是完全连续交替方波，0110不是\n输入信号字符串（长度 >= 3 且 <= 1024）：\n例如：0010101010110000101000010\n注：输入总是合法的，不用考虑异常情况\n输出最长的完全连续交替方波信号串\n例如：01010\n若不存在完全连续交替方波信号串，输出 -1。",
    "inputDesc": "",
    "outputDesc": "",
    "examples": [],
    "solution": "题目要求处理一串由0和1组成的方波信号字符串，从中找出最长的“完全连续交替方波”信号，并输出该信号。如果有多个相同长度的完全连续交替方波信号，则输出任意一个。如果不存在符合要求的信号串，则输出-1。\n完全连续交替方波的定义：\n必须以0开头，以0结尾。中间部分必须是1和0严格交替的形式（例如010，01010等）。例如：01010是一个完全连续交替方波，而0110和101则不是。",
    "codes": {
      "java": "import java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String signal = scanner.nextLine(); // 输入信号字符串\n\n        Pattern pattern = Pattern.compile(\"^(01)+0$\"); // 定义正则表达式匹配完全连续交替方波信号\n\n        int maxLength = 0; // 最长完全连续交替方波信号的长度\n        String result = \"-1\"; // 最长完全连续交替方波信号的字符串\n\n        StringBuilder sb = new StringBuilder(); // 用于存储当前处理的信号\n        for (char c : signal.toCharArray()) {\n            if (c == '0' && sb.length() > 0 && sb.charAt(sb.length() - 1) == '0') { // 当前字符是0，且前一个字符也是0，说明一个完整信号结束\n                Matcher matcher = pattern.matcher(sb.toString()); // 对当前信号进行匹配\n                if (matcher.find() && sb.length() > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n                    maxLength = sb.length(); // 更新最大长度\n                    result = sb.toString(); // 更新最大长度对应的字符串\n                }\n                sb.setLength(0); // 清空当前信号\n            }\n            sb.append(c); // 将当前字符加入当前信号\n        }\n\n        Matcher matcher = pattern.matcher(sb.toString()); // 对最后一个信号进行匹配\n        if (matcher.find() && sb.length() > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n            result = sb.toString(); // 更新最大长度对应的字符串\n        }\n\n        System.out.println(result); // 输出最长的完全连续交替方波信号串\n    }\n}",
      "python": "import re\n\nsignal = input() # 输入信号字符串\n\npattern = re.compile(\"^(01)+0$\") # 定义正则表达式匹配完全连续交替方波信号\n\nmaxLength = 0 # 最长完全连续交替方波信号的长度\nresult = \"-1\" # 最长完全连续交替方波信号的字符串\n\nsb = \"\" # 用于存储当前处理的信号\nfor c in signal:\n    if c == '0' and len(sb) > 0 and sb[-1] == '0': # 当前字符是0，且前一个字符也是0，说明一个完整信号结束\n        matcher = pattern.match(sb) # 对当前信号进行匹配\n        if matcher and len(sb) > maxLength: # 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n            maxLength = len(sb) # 更新最大长度\n            result = sb # 更新最大长度对应的字符串\n        sb = \"\" # 清空当前信号\n\n    sb += c # 将当前字符加入当前信号\n\nmatcher = pattern.match(sb) # 对最后一个信号进行匹配\nif matcher and len(sb) > maxLength: # 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n    result = sb # 更新最大长度对应的字符串\n\nprint(result) # 输出最长的完全连续交替方波信号串",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (signal) => {\n  const pattern = /^(01)+0$/; // 定义正则表达式匹配完全连续交替方波信号\n\n  let maxLength = 0; // 最长完全连续交替方波信号的长度\n  let result = '-1'; // 最长完全连续交替方波信号的字符串\n\n  let sb = ''; // 用于存储当前处理的信号\n  for (let i = 0; i < signal.length; i++) {\n    const c = signal.charAt(i);\n\n    if (c === '0' && sb.length > 0 && sb.charAt(sb.length - 1) === '0') { // 当前字符是0，且前一个字符也是0，说明一个完整信号结束\n      const matcher = sb.match(pattern); // 对当前信号进行匹配\n      if (matcher && sb.length > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n        maxLength = sb.length; // 更新最大长度\n        result = sb; // 更新最大长度对应的字符串\n      }\n      sb = ''; // 清空当前信号\n    }\n\n    sb += c; // 将当前字符加入当前信号\n  }\n\n  const matcher = sb.match(pattern); // 对最后一个信号进行匹配\n  if (matcher && sb.length > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n    result = sb; // 更新最大长度对应的字符串\n  }\n\n  console.log(result); // 输出最长的完全连续交替方波信号串\n\n  rl.close();\n});",
      "cpp": "#include <iostream>\n#include <string>\n#include <regex>\nusing namespace std;\n\nint main() {\n    string signal;\n    getline(cin, signal); // 输入信号字符串\n\n    regex pattern(\"^(01)+0$\"); // 定义正则表达式匹配完全连续交替方波信号\n\n    int maxLength = 0; // 最长完全连续交替方波信号的长度\n    string result = \"-1\"; // 最长完全连续交替方波信号的字符串\n\n    string sb; // 用于存储当前处理的信号\n    for (int i = 0; i < signal.length(); i++) {\n        char c = signal[i];\n\n        if (c == '0' && sb.length() > 0 && sb[sb.length() - 1] == '0') { // 当前字符是0，且前一个字符也是0，说明一个完整信号结束\n            smatch matcher; // 定义匹配结果\n            if (regex_match(sb, matcher, pattern) && sb.length() > maxLength) { // 对当前信号进行匹配，如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n                maxLength = sb.length(); // 更新最大长度\n                result = sb; // 更新最大长度对应的字符串\n            }\n            sb = \"\"; // 清空当前信号\n        }\n\n        sb += c; // 将当前字符加入当前信号\n    }\n\n    smatch matcher; // 对最后一个信号进行匹配\n    if (regex_match(sb, matcher, pattern) && sb.length() > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n        result = sb; // 更新最大长度对应的字符串\n    }\n\n    cout << result << endl; // 输出最长的完全连续交替方波信号串\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n// 检查字符串是否匹配\"^(01)+0$\"的模式\nbool is_alternating_wave(const char *str) {\n    int len = strlen(str);\n    \n    // 如果字符串长度小于3，直接返回false\n    if (len < 3) {\n        return false;\n    }\n    \n    // 检查字符串是否以\"01\"开头，并以\"0\"结尾，中间部分要严格交替\n    if (str[0] != '0' || str[len-1] != '0') {\n        return false;\n    }\n    \n    // 遍历字符串中间部分，检查是否严格交替 \"01\"\n    for (int i = 1; i < len - 1; i++) {\n        if (str[i] == str[i-1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    char signal[1025]; // 输入信号字符串，长度最大为1024\n    fgets(signal, sizeof(signal), stdin); // 从标准输入读取信号字符串\n    \n    int maxLength = 0; // 最长的完全连续交替方波信号的长度\n    char result[1025] = \"-1\"; // 最长的完全连续交替方波信号的字符串，默认值为 \"-1\"\n    \n    char sb[1025] = \"\"; // 用于存储当前处理的信号\n    int sb_len = 0; // 当前信号的长度\n    \n    int signal_len = strlen(signal);\n    \n    // 遍历输入的信号字符串\n    for (int i = 0; i < signal_len; i++) {\n        char c = signal[i];\n\n        // 如果遇到两个连续的\"0\"，说明一个完整信号段结束\n        if (c == '0' && sb_len > 0 && sb[sb_len - 1] == '0') {\n            if (is_alternating_wave(sb) && sb_len > maxLength) { // 如果当前信号是完全连续交替方波，并且长度大于之前的最大长度\n                maxLength = sb_len; // 更新最大长度\n                strcpy(result, sb); // 更新最大长度对应的信号串\n            }\n            sb[0] = '\\0'; // 清空当前信号串\n            sb_len = 0; // 重置当前信号长度\n        }\n        \n        // 将当前字符加入当前信号串\n        sb[sb_len++] = c;\n        sb[sb_len] = '\\0';\n    }\n    \n    // 处理最后一个信号段\n    if (is_alternating_wave(sb) && sb_len > maxLength) {\n        strcpy(result, sb); // 更新最大长度对应的信号串\n    }\n    \n    printf(\"%s\\n\", result); // 输出最长的完全连续交替方波信号串\n\n    return 0; // 程序结束\n}"
    }
  },
  {
    "id": "171",
    "title": "模拟目录管理",
    "examType": "A",
    "score": 200,
    "description": "实现一个模拟目录管理功能的软件，输入一个命令序列，输出最后一条命令运行结果。\n支持命令：\n创建目录命令：mkdir 目录名称，如 mkdir abc 为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作。此命令无输出。进入目录命令：cd 目录名称，如 cd abc 为进入abc目录，特别地，cd … 为返回上级目录，如果目录不存在则不执行任何操作。此命令无输出。查看当前所在路径命令：pwd，输出当前路径字符串。\n约束：\n目录名称仅支持小写字母；mkdir 和 cd 命令的参数仅支持单个目录，如：mkdir abc 和 cd abc；不支持嵌套路径和绝对路径，如 mkdir abc/efg，cd abc/efg，mkdir /abc/efg，cd /abc/efg 是不支持的。目录符号为/，根目录/作为初始目录。任何不符合上述定义的无效命令不做任何处理并且无输出。",
    "inputDesc": "输入 N 行字符串，每一行字符串是一条命令。\n命令行数限制100行以内，目录名称限制10个字符以内。",
    "outputDesc": "输出最后一条命令运行结果字符串。",
    "examples": [
      {
        "input": "mkdir abc\ncd abc\npwd",
        "output": "/abc/",
        "explanation": "在根目录创建一个abc的目录并进入abc目录中查看当前目录路径，输出当前路径/abc/。"
      }
    ],
    "solution": "定义一个节点类（Node），用于表示文件系统中的每个目录。该类包含路径信息和一个映射，映射存储子目录和对应的节点对象。 创建一个根节点实例，代表文件系统的根目录。根目录没有父目录。 读取用户输入，根据输入的命令和参数执行相应的操作。 如果输入的是创建目录的命令（例如，“mkdir”），检查目录名是否有效，然后在当前节点下创建新的子目录节点。如果输入的是切换目录的命令（例如，“cd”），检查目标目录是否存在，如果存在，则更新当前节点为目标节点。如果输入的是打印当前目录路径的命令（例如，“pwd”），则输出当前节点的路径信息。 循环读取输入直到结束，并在结束时输出最后的路径信息。\n定义一个节点类（Node），用于表示文件系统中的每个目录。该类包含路径信息和一个映射，映射存储子目录和对应的节点对象。\n创建一个根节点实例，代表文件系统的根目录。根目录没有父目录。\n读取用户输入，根据输入的命令和参数执行相应的操作。\n如果输入的是创建目录的命令（例如，“mkdir”），检查目录名是否有效，然后在当前节点下创建新的子目录节点。如果输入的是切换目录的命令（例如，“cd”），检查目标目录是否存在，如果存在，则更新当前节点为目标节点。如果输入的是打印当前目录路径的命令（例如，“pwd”），则输出当前节点的路径信息。\n循环读取输入直到结束，并在结束时输出最后的路径信息。",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n    // 定义一个内部类Node，用于表示文件系统中的每个目录\n    static class Node {\n        String path; // 目录的路径\n        Map<String, Node> next = new HashMap<>(); // 存储当前目录下的子目录，键为目录名，值为对应的Node对象\n\n        // Node类的构造方法ac\n        Node(String path, Node parent) {\n            this.path = path; // 设置当前节点的路径\n            // 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n            if (parent != null) {\n                this.next.put(\"..\", parent);\n            }\n        }\n    }\n\n    // 程序的主入口点\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in); // 创建Scanner对象来读取用户的输入\n        Node root = new Node(\"/\", null); // 创建根目录节点，根目录没有父目录，所以第二个参数为null\n        Node currentNode = root; // 初始化当前目录为根目录\n        String lastOutput = \"\"; // 用于存储最后输出的路径\n\n        // 循环读取用户输入的命令\n        while (scanner.hasNextLine()) {\n            String input = scanner.nextLine().trim(); // 读取一行输入并去除前后空格\n            if (input.isEmpty()) break; // 如果输入为空，则退出循环\n\n            String[] parts = input.split(\" \"); // 将输入的命令按空格分割为命令和参数\n            String command = parts[0]; // 获取命令部分\n\n            // 处理mkdir命令，用于创建新的子目录\n            if (\"mkdir\".equals(command) && parts.length == 2 && isValidDirectoryName(parts[1])) {\n                // 如果目录名有效并且不存在，则创建一个新的目录节点，并将其添加到当前目录的子目录映射中\n                currentNode.next.putIfAbsent(parts[1], new Node(currentNode.path + parts[1] + \"/\", currentNode));\n            } else if (\"cd\".equals(command) && parts.length == 2 && isValidChangeDirectory(parts[1])) {\n                // 处理cd命令，用于改变当前目录\n                Node nextNode = currentNode.next.get(parts[1]); // 从子目录映射中获取要切换的目录节点\n                if (nextNode != null) {\n                    currentNode = nextNode; // 如果目录存在，则将当前目录切换为该目录\n                }\n            } else if (\"pwd\".equals(command) && parts.length == 1) {\n                // 处理pwd命令，用于打印当前目录的路径\n                lastOutput = currentNode.path; // 将当前目录的路径保存到lastOutput变量中\n            }\n        }\n\n        System.out.println(lastOutput); // 循环结束后，打印最后保存的路径\n    }\n\n    // 检查目录名是否有效的方法，目录名只能包含小写字母\n    private static boolean isValidDirectoryName(String name) {\n        for (char c : name.toCharArray()) {\n            if (c < 'a' || c > 'z') {\n                return false; // 如果目录名中包含非小写字母的字符，则返回false\n            }\n        }\n        return true; // 如果目录名全部由小写字母组成，则返回true\n    }\n\n    // 检查是否可以切换到指定的目录的方法，目录名要么是有效的，要么是\"..\"表示上级目录\n    private static boolean isValidChangeDirectory(String name) {\n        return \"..\".equals(name) || isValidDirectoryName(name); // 如果是\"..\"或者是有效的目录名，则返回true\n    }\n}",
      "python": "# 定义一个类Node，用于表示文件系统中的每个目录\nclass Node:\n    def __init__(self, path, parent):\n        self.path = path  # 目录的路径\n        self.next = {}  # 存储当前目录下的子目录，键为目录名，值为对应的Node对象\n        if parent:\n            self.next['..'] = parent  # 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n\n# 检查目录名是否有效的函数，目录名只能包含小写字母\ndef is_valid_directory_name(name):\n    return name.islower() and name.isalpha()  # 如果目录名全部由小写字母组成，则返回true\n\n# 检查是否可以切换到指定的目录的函数，目录名要么是有效的，要么是\"..\"表示上级目录\ndef is_valid_change_directory(name):\n    return name == '..' or is_valid_directory_name(name)  # 如果是\"..\"或者是有效的目录名，则返回true\n\nroot = Node('/', None)  # 创建根目录节点，根目录没有父目录，所以第二个参数为None\ncurrent_node = root  # 初始化当前目录为根目录\nlast_output = ''  # 用于存储最后输出的路径\n\n# 循环读取用户输入的命令\ntry:\n    while True:\n        input_command = input().strip()  # 读取一行输入并去除前后空格\n        if not input_command:\n            break\n        parts = input_command.split(' ')  # 将输入的命令按空格分割为命令和参数\n        command = parts[0]  # 获取命令部分\n\n        if command == 'mkdir' and len(parts) == 2 and is_valid_directory_name(parts[1]):\n            # 处理mkdir命令，用于创建新的子目录\n            if parts[1] not in current_node.next:\n                current_node.next[parts[1]] = Node(current_node.path + parts[1] + '/', current_node)\n        elif command == 'cd' and len(parts) == 2 and is_valid_change_directory(parts[1]):\n            # 处理cd命令，用于改变当前目录\n            next_node = current_node.next.get(parts[1])\n            if next_node:\n                current_node = next_node  # 如果目录存在，则将当前目录切换为该目录\n        elif command == 'pwd' and len(parts) == 1:\n            # 处理pwd命令，用于打印当前目录的路径\n            last_output = current_node.path  # 将当前目录的路径保存到last_output变量中\nexcept EOFError:\n    pass\n\nprint(last_output)  # 打印最后保存的路径",
      "javascript": "const readline = require('readline');\n\n// 定义一个类Node，用于表示文件系统中的每个目录\nclass Node {\n    constructor(path, parent) {\n        this.path = path; // 目录的路径\n        this.next = {}; // 存储当前目录下的子目录，键为目录名，值为对应的Node对象\n        if (parent) {\n            this.next['..'] = parent; // 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n        }\n    }\n}\n\n// 检查目录名是否有效的函数，目录名只能包含小写字母\nfunction isValidDirectoryName(name) {\n    return /^[a-z]+$/.test(name); // 如果目录名全部由小写字母组成，则返回true\n}\n\n// 检查是否可以切换到指定的目录的函数，目录名要么是有效的，要么是\"..\"表示上级目录\nfunction isValidChangeDirectory(name) {\n    return name === '..' || isValidDirectoryName(name); // 如果是\"..\"或者是有效的目录名，则返回true\n}\n\n// 创建readline接口实例\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst root = new Node('/', null); // 创建根目录节点，根目录没有父目录，所以第二个参数为null\nlet currentNode = root; // 初始化当前目录为根目录\nlet lastOutput = ''; // 用于存储最后输出的路径\n\n// 逐行读取输入\nrl.on('line', (input) => {\n    const parts = input.trim().split(' '); // 将输入的命令按空格分割为命令和参数\n    const command = parts[0]; // 获取命令部分\n\n    if (command === 'mkdir' && parts.length === 2 && isValidDirectoryName(parts[1])) {\n        // 处理mkdir命令，用于创建新的子目录\n        if (!currentNode.next[parts[1]]) {\n            currentNode.next[parts[1]] = new Node(currentNode.path + parts[1] + '/', currentNode);\n        }\n    } else if (command === 'cd' && parts.length === 2 && isValidChangeDirectory(parts[1])) {\n        // 处理cd命令，用于改变当前目录\n        const nextNode = currentNode.next[parts[1]];\n        if (nextNode) {\n            currentNode = nextNode; // 如果目录存在，则将当前目录切换为该目录\n        }\n    } else if (command === 'pwd' && parts.length === 1) {\n        // 处理pwd命令，用于打印当前目录的路径\n        lastOutput = currentNode.path; // 将当前目录的路径保存到lastOutput变量中\n    }\n}).on('close', () => {\n    console.log(lastOutput); // 当输入流关闭时，打印最后保存的路径\n});",
      "cpp": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nusing namespace std;\n// 定义一个类Node，用于表示文件系统中的每个目录\nclass Node {\npublic:\n    string path; // 目录的路径\n    unordered_map<string, Node*> next; // 存储当前目录下的子目录，键为目录名，值为对应的Node指针\n\n    // Node类的构造方法\n    Node(string path, Node* parent) : path(path) {\n        // 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n        if (parent != nullptr) {\n            this->next[\"..\"] = parent;\n        }\n    }\n};\n\n// 检查目录名是否有效的函数，目录名只能包含小写字母\nbool isValidDirectoryName(const string& name) {\n    for (char c : name) {\n        if (c < 'a' || c > 'z') {\n            return false; // 如果目录名中包含非小写字母的字符，则返回false\n        }\n    }\n    return true; // 如果目录名全部由小写字母组成，则返回true\n}\n\n// 检查是否可以切换到指定的目录的函数，目录名要么是有效的，要么是\"..\"表示上级目录\nbool isValidChangeDirectory(const string& name) {\n    return name == \"..\" || isValidDirectoryName(name); // 如果是\"..\"或者是有效的目录名，则返回true\n}\n\nint main() {\n    Node* root = new Node(\"/\", nullptr); // 创建根目录节点，根目录没有父目录，所以第二个参数为nullptr\n    Node* currentNode = root; // 初始化当前目录为根目录\n    string lastOutput; // 用于存储最后输出的路径\n\n    // 循环读取用户输入的命令\n    string input;\n    while (getline(cin, input)) {\n        istringstream iss(input);\n        string command, arg;\n        iss >> command;\n\n        if (command == \"mkdir\") {\n            iss >> arg;\n            if (isValidDirectoryName(arg)) {\n                // 如果目录名有效并且不存在，则创建一个新的目录节点，并将其添加到当前目录的子目录映射中\n                if (currentNode->next.find(arg) == currentNode->next.end()) {\n                    currentNode->next[arg] = new Node(currentNode->path + arg + \"/\", currentNode);\n                }\n            }\n        } else if (command == \"cd\") {\n            iss >> arg;\n            if (isValidChangeDirectory(arg)) {\n                // 处理cd命令，用于改变当前目录\n                auto it = currentNode->next.find(arg);\n                if (it != currentNode->next.end()) {\n                    currentNode = it->second; // 如果目录存在，则将当前目录切换为该目录\n                }\n            }\n        } else if (command == \"pwd\") {\n            // 处理pwd命令，用于打印当前目录的路径\n            lastOutput = currentNode->path; // 将当前目录的路径保存到lastOutput变量中\n        }\n    }\n\n    cout << lastOutput << endl; // 循环结束后，打印最后保存的路径\n\n  \n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_CHILDREN 128  // 假设每个目录最多可以有128个子目录\n\n// 定义一个结构体Node，用于表示文件系统中的每个目录\ntypedef struct Node {\n    char path[1024]; // 目录的完整路径\n    struct Node* children[MAX_CHILDREN]; // 存储指向子目录的指针数组\n    char* childNames[MAX_CHILDREN]; // 存储子目录名的数组\n    int childCount; // 实际子目录的数量\n    struct Node* parent; // 指向父目录的指针\n} Node;\n\n// 创建新目录节点的函数，接受目录路径和父节点作为参数\nNode* createNode(const char* path, Node* parent) {\n    Node* newNode = (Node*)malloc(sizeof(Node)); // 分配内存\n    strcpy(newNode->path, path); // 设置目录路径\n    memset(newNode->children, 0, sizeof(newNode->children)); // 初始化子目录指针数组\n    memset(newNode->childNames, 0, sizeof(newNode->childNames)); // 初始化子目录名数组\n    newNode->childCount = 0; // 初始化子目录计数\n    newNode->parent = parent; // 设置父目录\n    return newNode; // 返回新创建的节点\n}\n\n// 检查目录名是否仅包含小写字母\nint isValidDirectoryName(const char* name) {\n    for (int i = 0; name[i] != '\\0'; i++) {\n        if (!islower(name[i])) {\n            return 0; // 如果含有非小写字母，则返回0\n        }\n    }\n    return 1; // 全部是小写字母，则返回1\n}\n\n// 向特定父目录添加一个新的子目录\nvoid addDirectory(Node* parent, const char* name, Node* child) {\n    if (parent->childCount < MAX_CHILDREN) { // 检查是否还有空间添加子目录\n        parent->children[parent->childCount] = child; // 添加子目录指针\n        parent->childNames[parent->childCount] = strdup(name); // 并存储子目录名\n        parent->childCount++; // 子目录计数增加\n    }\n}\n\n// 根据目录名在父目录中查找子目录\nNode* findDirectory(Node* parent, const char* name) {\n    for (int i = 0; i < parent->childCount; i++) {\n        if (strcmp(parent->childNames[i], name) == 0) {\n            return parent->children[i]; // 找到匹配的子目录后返回其指针\n        }\n    }\n    return NULL; // 未找到返回NULL\n}\n\nint main() {\n    Node* root = createNode(\"/\", NULL); // 创建根目录节点\n    Node* currentNode = root; // 初始当前目录为根目录\n    char input[1024], lastOutput[1024] = \"/\"; // 输入缓冲区和最终输出缓冲区\n\n    while (fgets(input, sizeof(input), stdin)) { // 读取命令行输入\n        char* command = strtok(input, \" \\n\"); // 分割出命令\n        char* arg = strtok(NULL, \" \\n\"); // 分割出参数\n\n        if (strcmp(command, \"mkdir\") == 0 && arg && isValidDirectoryName(arg)) {\n            if (findDirectory(currentNode, arg) == NULL) { // 检查目录是否已存在\n                char newPath[1024];\n                sprintf(newPath, \"%s%s/\", currentNode->path, arg); // 构建新目录的完整路径\n                Node* newNode = createNode(newPath, currentNode); // 创建新目录节点\n                addDirectory(currentNode, arg, newNode); // 将新目录添加到当前节点的子目录中\n            }\n        } else if (strcmp(command, \"cd\") == 0 && arg) {\n            if (strcmp(arg, \"..\") == 0 && currentNode->parent) { // 返回上一级目录\n                currentNode = currentNode->parent;\n            } else if (isValidDirectoryName(arg)) { // 改变当前目录到指定的子目录\n                Node* foundNode = findDirectory(currentNode, arg);\n                if (foundNode) {\n                    currentNode = foundNode;\n                }\n            }\n        } else if (strcmp(command, \"pwd\") == 0) { // 输出当前目录的路径\n            strcpy(lastOutput, currentNode->path);\n        }\n    }\n\n    printf(\"%s\\n\", lastOutput); // 打印最后记录的路径\n \n    return 0;\n}"
    }
  },
  {
    "id": "173",
    "title": "空栈压数",
    "examType": "A",
    "score": 200,
    "description": "向一个空栈压入正整数，每当压入一个整数时，执行以下规则（设: 栈顶至栈底整数依次编号为 n1, n2, …, nx，其中n1 为最新压入的整数)\n如果 n1 = n2，则 n1、n2全部出栈，压入新数据 m (m = 2*n1) 如果 n1 = n2 + … + ny( y的范围为[3,x]) ，则 n1, n2, …, ny 全部出栈，压入新数据 m (m = 2*n1)。 如果上述规则都不满足，则不做操作。\n如果 n1 = n2，则 n1、n2全部出栈，压入新数据 m (m = 2*n1)\n如果 n1 = n2 + … + ny( y的范围为[3,x]) ，则 n1, n2, …, ny 全部出栈，压入新数据 m (m = 2*n1)。\n如果上述规则都不满足，则不做操作。\n如：依次向栈压入 6、1、2、3，\n当压入 2 时，栈顶至栈底依次为 [2,1,6]；当压入 3 时，3 = 2 + 1，3、2、1 全部出栈，重新入栈整数6，此时栈顶至栈底依次为 [6,6]；6 = 6，两个 6 全部出栈，压入 12，最终栈中只剩个元素 12。 向栈中输入一串数字，请输出应用此规则后栈中最终存留的数字。\n使用单个空格隔开的正整数的字符串，如 “5 6 7 8”，左边的数字先入栈。\n正整数大小为 [1, 2^31−1]。正整数个数为 [1,1000]。\n最终栈中存留的元素值，元素值使用单个空格隔开，如 \"8 7 6 5\"，从左至右依次为栈顶至栈底的数字。",
    "inputDesc": "",
    "outputDesc": "",
    "examples": [
      {
        "input": "20 50 80 1 1",
        "output": "160",
        "explanation": "解释: 向栈压入 80 时，10+20+50=80，数据合并后入栈 160，压入两个 1 时，合并为 2，最终栈顶至栈底的数字为 2 和 160。"
      },
      {
        "input": "10 20 50 85 1",
        "output": "170",
        "explanation": ""
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] inputSequence = scanner.nextLine().split(\" \");\n        // 创建一个 LinkedList 对象用作数字栈\n        LinkedList<Integer> numberStack = new LinkedList<>();\n\n        // 遍历输入的数字序列\n        for (String numberString : inputSequence) {\n            // 将字符串转换为整数\n            int currentNumber = Integer.parseInt(numberString);\n            // 初始化部分和为当前数字\n            int partialSum = currentNumber;\n\n            // 从栈顶向栈底检查是否满足出栈条件\n            for (int index = numberStack.size() - 1; index >= 0; index--) {\n                // 从部分和中减去栈中的元素\n                partialSum -= numberStack.get(index);\n\n                // 如果满足出栈条件，清除子列表并更新当前数字\n                if (partialSum == 0) {\n                    // 清除子列表\n                    numberStack.subList(index, numberStack.size()).clear();\n                    // 更新当前数字\n                    currentNumber *= 2;\n                    // 更新部分和\n                    partialSum = currentNumber;\n                } else if (partialSum < 0) {\n                    // 如果部分和小于0，跳出循环\n                    break;\n                }\n            }\n\n            // 将当前数字入栈\n            numberStack.add(currentNumber);\n        }\n\n        // 输出栈中的元素，从栈顶到栈底\n        // 创建一个 StringJoiner 对象，用于连接栈中的元素\n        StringJoiner outputJoiner = new StringJoiner(\" \");\n        // 当栈不为空时，依次移除栈顶元素并添加到 StringJoiner 中\n        while (!numberStack.isEmpty()) {\n            outputJoiner.add(numberStack.removeLast().toString());\n        }\n        // 输出最终结果\n        System.out.println(outputJoiner.toString());\n    }\n}",
      "python": "def main():\n    # 读取用户输入并使用空格分隔\n    input_sequence = input().split()\n    # 创建一个列表用作数字栈\n    number_stack = []\n\n    # 遍历输入的数字序列\n    for number_string in input_sequence:\n        # 将字符串转换为整数\n        current_number = int(number_string)\n        # 初始化部分和为当前数字\n        partial_sum = current_number\n\n        # 从栈顶向栈底检查是否满足出栈条件\n        index = len(number_stack) - 1\n        while index >= 0:\n            # 从部分和中减去栈中的元素\n            partial_sum -= number_stack[index]\n\n            # 如果满足出栈条件，清除子列表并更新当前数字\n            if partial_sum == 0:\n                # 清除子列表\n                number_stack = number_stack[:index]\n                # 更新当前数字\n                current_number *= 2\n                # 更新部分和\n                partial_sum = current_number\n            elif partial_sum < 0:\n                # 如果部分和小于0，跳出循环\n                break\n\n            index -= 1\n\n        # 将当前数字入栈\n        number_stack.append(current_number)\n\n    # 输出栈中的元素，从栈顶到栈底\n    output = ' '.join(map(str, reversed(number_stack)))\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
      "javascript": "const readline = require('readline');\n\n// 创建一个 readline.Interface 实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 读取用户输入\nrl.on('line', (input) => {\n  const inputSequence = input.split(' ');\n  // 创建一个数组用作数字栈\n  const numberStack = [];\n\n  // 遍历输入的数字序列\n  for (const numberString of inputSequence) {\n    // 将字符串转换为整数\n    let currentNumber = parseInt(numberString, 10);\n    // 初始化部分和为当前数字\n    let partialSum = currentNumber;\n\n    // 从栈顶向栈底检查是否满足出栈条件\n    for (let index = numberStack.length - 1; index >= 0; index--) {\n      // 从部分和中减去栈中的元素\n      partialSum -= numberStack[index];\n\n      // 如果满足出栈条件，清除子列表并更新当前数字\n      if (partialSum === 0) {\n        // 清除子列表\n        numberStack.splice(index);\n        // 更新当前数字\n        currentNumber *= 2;\n        // 更新部分和\n        partialSum = currentNumber;\n      } else if (partialSum < 0) {\n        // 如果部分和小于0，跳出循环\n        break;\n      }\n    }\n\n    // 将当前数字入栈\n    numberStack.push(currentNumber);\n  }\n\n  // 输出栈中的元素，从栈顶到栈底\n  const output = numberStack.reverse().join(' ');\n  console.log(output);\n\n  // 关闭 readline.Interface 实例\n  rl.close();\n});",
      "cpp": "#include <iostream>\n\nint main() {\n    // 读取用户输入\n    int input_sequence[1000];\n    int input_size = 0;\n    int temp;\n    while (std::cin >> temp) {\n        input_sequence[input_size++] = temp;\n    }\n\n    // 创建一个普通数组用作数字栈\n    int number_stack[1000];\n    int stack_size = 0;\n\n    // 遍历输入的数字序列\n    for (int i = 0; i < input_size; ++i) {\n        int current_number = input_sequence[i];\n        // 初始化部分和为当前数字\n        int partial_sum = current_number;\n\n        // 从栈顶向栈底检查是否满足出栈条件\n        int index = stack_size - 1;\n        while (index >= 0) {\n            // 从部分和中减去栈中的元素\n            partial_sum -= number_stack[index];\n\n            // 如果满足出栈条件，清除子列表并更新当前数字\n            if (partial_sum == 0) {\n                // 清除子列表\n                stack_size = index;\n                // 更新当前数字\n                current_number *= 2;\n                // 更新部分和\n                partial_sum = current_number;\n            } else if (partial_sum < 0) {\n                // 如果部分和小于0，跳出循环\n                break;\n            }\n\n            index -= 1;\n        }\n\n        // 将当前数字入栈\n        number_stack[stack_size++] = current_number;\n    }\n\n    // 输出栈中的元素，从栈顶到栈底\n    for (int i = stack_size - 1; i >= 0; --i) {\n        std::cout << number_stack[i];\n        if (i > 0) {\n            std::cout << \" \";\n        }\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义一个栈结构体，用于存储整数\ntypedef struct {\n    int *data;      // 栈中存储的数据\n    int top;        // 栈顶索引\n    int capacity;   // 栈的容量\n} Stack;\n\n// 初始化栈，分配内存并设置初始值\nStack* createStack(int capacity) {\n    Stack *stack = (Stack*)malloc(sizeof(Stack));\n    stack->data = (int*)malloc(capacity * sizeof(int));\n    stack->top = -1;   // 初始化栈顶索引为-1，表示空栈\n    stack->capacity = capacity;\n    return stack;\n}\n\n// 判断栈是否为空\nint isEmpty(Stack *stack) {\n    return stack->top == -1;\n}\n\n// 向栈中压入元素\nvoid push(Stack *stack, int value) {\n    stack->data[++stack->top] = value;\n}\n\n// 从栈中弹出元素\nint pop(Stack *stack) {\n    return stack->data[stack->top--];\n}\n\n// 返回栈顶元素但不弹出\nint peek(Stack *stack) {\n    return stack->data[stack->top];\n}\n\n// 释放栈的内存\nvoid freeStack(Stack *stack) {\n    free(stack->data);\n    free(stack);\n}\n\n// 主函数，负责处理输入输出和逻辑\nint main() {\n    char input[10000]; // 存储输入字符串\n    fgets(input, sizeof(input), stdin); // 读取输入字符串\n\n    // 初始化栈，容量设为1000\n    Stack *stack = createStack(1000);\n\n    // 解析输入的整数序列\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        int currentNumber = atoi(token);  // 将当前字符串转换为整数\n        int partialSum = currentNumber;   // 初始化部分和为当前数字\n\n        // 从栈顶向栈底检查是否满足出栈条件\n        for (int index = stack->top; index >= 0; index--) {\n            partialSum -= stack->data[index]; // 从部分和中减去栈中的元素\n\n            // 如果满足出栈条件，清除子列表并更新当前数字\n            if (partialSum == 0) {\n                stack->top = index - 1;  // 调整栈顶位置以清除子列表\n                currentNumber *= 2;      // 更新当前数字为原数字的2倍\n                partialSum = currentNumber; // 更新部分和\n            } else if (partialSum < 0) {\n                // 如果部分和小于0，跳出循环\n                break;\n            }\n        }\n\n        // 将当前数字压入栈中\n        push(stack, currentNumber);\n\n        // 获取下一个输入的整数\n        token = strtok(NULL, \" \");\n    }\n\n    // 输出栈中的元素，从栈顶到栈底\n    int first = 1; // 用于控制输出格式\n    while (!isEmpty(stack)) {\n        if (!first) {\n            printf(\" \"); // 在元素之间输出空格\n        }\n        printf(\"%d\", pop(stack)); // 输出栈顶元素\n        first = 0;\n    }\n    printf(\"\\n\"); // 输出换行符\n\n    // 释放栈的内存\n    freeStack(stack);\n\n    return 0;\n}"
    }
  },
  {
    "id": "174",
    "title": "计算疫情扩散时间",
    "examType": "A",
    "score": 200,
    "description": "在一个地图中(地图由n*n个区域组成），有部分区域被感染病菌。 感染区域每天都会把周围（上下左右）的4个区域感染。 请根据给定的地图计算，多少天以后，全部区域都会被感染。 如果初始地图上所有区域全部都被感染，或者没有被感染区域，返回-1",
    "inputDesc": "一行N*N个数字（只包含0,1，不会有其他数字）表示一个地图，数字间用,分割，0表示未感染区域，1表示已经感染区域\n每N个数字表示地图中一行，输入数据共表示N行N列的区域地图。\n例如输入1,0,1,0,0,0,1,0,1，表示地图\n123",
    "outputDesc": "一个整数，表示经过多少天以后，全部区域都被感染 1<=N<200",
    "examples": [
      {
        "input": ",0,1,0,0,0,1,0,1",
        "output": "",
        "explanation": "1天以后，地图中仅剩余中心点未被感染；2天以后，全部被感染。"
      },
      {
        "input": ",1,1,1,1,1,1,1,1",
        "output": "-1",
        "explanation": "全部都感染"
      }
    ],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        List<Integer> map = new ArrayList<>();\n        int pos = 0;\n        String token;\n        while ((pos = input.indexOf(\",\")) != -1) { // 将输入字符串转换为一维数组\n            token = input.substring(0, pos);\n            map.add(Integer.parseInt(token));\n            input = input.substring(pos + 1);\n        }\n        map.add(Integer.parseInt(input));\n        System.out.println(getInfectionDays(map)); // 输出感染天数\n    }\n\n    public static int getInfectionDays(List<Integer> map) {\n        int n = (int) Math.sqrt(map.size());\n\n        int[][] matrix = new int[n][n]; // 将一维数组转换为二维矩阵\n\n        Queue<int[]> q = new LinkedList<>(); // 用队列存储感染区域\n\n        int healthy = 0; // 记录未感染区域数量\n\n        int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 记录四个方向的偏移量\n\n        for (int i = 0; i < n * n; i++) {\n            int x = i / n;\n            int y = i % n;\n            matrix[x][y] = map.get(i); // 将一维数组转换为二维矩阵\n            if (matrix[x][y] == 1) {\n                q.offer(new int[]{x, y}); // 将感染区域加入队列\n            } else {\n                healthy++; // 计算未感染区域数量\n            }\n        }\n\n        if (healthy == 0 || healthy == n * n) { // 判断特殊情况\n            return -1;\n        }\n\n        int day = 0; // 记录感染天数\n        while (!q.isEmpty() && healthy > 0) { // 当队列不为空且还有未感染区域时，进行循环\n            int[] tmp = q.poll(); // 取出队首元素\n            int x = tmp[0], y = tmp[1]; // 获取队首元素的坐标\n            day = matrix[x][y] + 1; // 记录感染天数\n\n            for (int[] offset : offsets) { // 遍历四个方向\n                int newX = x + offset[0]; // 新的横坐标\n                int newY = y + offset[1]; // 新的纵坐标\n\n                if (newX >= 0 && newX < n && newY >= 0 && newY < n && matrix[newX][newY] == 0) { // 判断边界和未感染区域\n                    healthy--; // 未感染区域数量减一\n                    matrix[newX][newY] = day; // 标记该区域已感染\n                    q.offer(new int[]{newX, newY}); // 将该区域加入队列\n                }\n            }\n        }\n\n        return day - 1; // 返回感染天数\n    }\n}",
      "python": "import math\nfrom queue import Queue\n\ndef getInfectionDays(map):\n    # 计算地图边长，即每一行（或列）的元素个数\n    n = int(math.sqrt(len(map)))\n    \n    # 构建二维矩阵表示地图，初始值为0\n    matrix = [[0 for j in range(n)] for i in range(n)]\n    \n    # 初始化一个队列，用于存放已感染区域的位置\n    q = Queue()\n    \n    # 遍历地图，将已感染区域的坐标入队，并初始化二维矩阵\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = map[i * n + j]\n            if matrix[i][j] == 1:\n                q.put((i, j))\n    \n    # 如果队列为空（没有感染区域）或所有区域都已被感染，返回-1\n    if q.empty() or q.qsize() == len(map):\n        return -1\n    \n    # 计算未感染区域的数量\n    healthy = len(map) - q.qsize()\n    \n    # 定义四个方向的偏移量（上下左右）\n    offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    \n    # 初始化天数计数器\n    day = 0\n    \n    # 广度优先搜索，通过队列逐层扩散感染\n    while not q.empty() and healthy > 0:\n        tmp = q.get()\n        x, y = tmp[0], tmp[1]\n        day = matrix[x][y] + 1  # 更新天数\n        \n        # 对当前节点的四个方向进行探索\n        for offset in offsets:\n            new_x = x + offset[0]\n            new_y = y + offset[1]\n            \n            # 检查新坐标是否越界\n            if new_x < 0 or new_x >= n or new_y < 0 or new_y >= n:\n                continue\n            \n            # 如果新坐标的区域未被感染，则将其感染，并将其加入队列\n            if matrix[new_x][new_y] == 0:\n                healthy -= 1\n                matrix[new_x][new_y] = day\n                q.put((new_x, new_y))\n    \n    # 返回全部区域被感染所需的天数，由于最后一天的增加已在循环中完成，故减1\n    return day - 1\n\n# 读取输入，并转换成整数列表\ninput_str = input()\ninput_list = list(map(int, input_str.split(\",\")))\n\n# 输出计算结果\nprint(getInfectionDays(input_list))",
      "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nfunction getInfectionDays(map) {\n  const n = Math.sqrt(map.length);\n\n  const matrix = new Array(n).fill().map(() => new Array(n)); // 将一维数组转换为二维矩阵\n\n  const q = []; // 用队列存储感染区域\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      matrix[i][j] = map[i * n + j]; // 将一维数组转换为二维矩阵\n      if (matrix[i][j] === 1) q.push([i, j]); // 将感染区域加入队列\n    }\n  }\n\n  if (q.length === 0 || q.length === map.length) { // 判断特殊情况\n    return -1;\n  }\n\n  let healthy = map.length - q.length; // 记录未感染区域数量\n\n  const offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 记录四个方向的偏移量\n\n  let day = 0; // 记录感染天数\n  while (q.length > 0 && healthy > 0) { // 当队列不为空且还有未感染区域时，进行循环\n    const [x, y] = q.shift(); // 取出队首元素\n    day = matrix[x][y] + 1; // 记录感染天数\n\n    for (const offset of offsets) { // 遍历四个方向\n      const [dx, dy] = offset;\n      const newX = x + dx; // 新的横坐标\n      const newY = y + dy; // 新的纵坐标\n\n      if (newX < 0 || newX >= n || newY < 0 || newY >= n) continue; // 判断边界\n\n      if (matrix[newX][newY] === 0) { // 如果该区域未感染\n        healthy--; // 未感染区域数量减一\n        matrix[newX][newY] = day; // 标记该区域已感染\n        q.push([newX, newY]); // 将该区域加入队列\n      }\n    }\n  }\n\n  return day - 1; // 返回感染天数\n}\n\nrl.on('line', (input) => {\n  const map = input.split(',').map(Number);\n  console.log(getInfectionDays(map));\n});",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nint getInfectionDays(vector<int>& map) {\n    int n = sqrt(map.size());\n\n    vector<vector<int>> matrix(n, vector<int>(n)); // 将一维数组转换为二维矩阵\n\n    queue<pair<int, int>> q; // 用队列存储感染区域\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            matrix[i][j] = map[i * n + j]; // 将一维数组转换为二维矩阵\n            if (matrix[i][j] == 1) q.push({i, j}); // 将感染区域加入队列\n        }\n    }\n\n    if (q.empty() || q.size() == map.size()) { // 判断特殊情况\n        return -1;\n    }\n\n    int healthy = map.size() - q.size(); // 记录未感染区域数量\n\n    vector<vector<int>> offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 记录四个方向的偏移量\n\n    int day = 0; // 记录感染天数\n    while (!q.empty() && healthy > 0) { // 当队列不为空且还有未感染区域时，进行循环\n        pair<int, int> tmp = q.front(); // 取出队首元素\n        q.pop(); // 弹出队首元素\n        int x = tmp.first, y = tmp.second; // 获取队首元素的坐标\n        day = matrix[x][y] + 1; // 记录感染天数\n\n        for (vector<int>& offset : offsets) { // 遍历四个方向\n            int newX = x + offset[0]; // 新的横坐标\n            int newY = y + offset[1]; // 新的纵坐标\n\n            if (newX < 0 || newX >= n || newY < 0 || newY >= n) continue; // 判断边界\n\n            if (matrix[newX][newY] == 0) { // 如果该区域未感染\n                healthy--; // 未感染区域数量减一\n                matrix[newX][newY] = day; // 标记该区域已感染\n                q.push({newX, newY}); // 将该区域加入队列\n            }\n        }\n    }\n\n    return day - 1; // 返回感染天数\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n    vector<int> map;\n    size_t pos = 0;\n    string token;\n    while ((pos = input.find(\",\")) != string::npos) { // 将输入字符串转换为一维数组\n        token = input.substr(0, pos);\n        map.push_back(stoi(token));\n        input.erase(0, pos + 1);\n    }\n    map.push_back(stoi(input));\n    cout << getInfectionDays(map) << endl; // 输出感染天数\n    return 0;\n}",
      "c": ""
    }
  },
  {
    "id": "175",
    "title": "跳马",
    "examType": "A",
    "score": 200,
    "description": "输入 m 和 n 两个数，m 和 n 表示一个 m*n 的棋盘。输入棋盘内的数据。棋盘中存在数字和\".\"两种字符，如果是数字表示该位置是一匹马，如果是\".\"表示该位置为空的，棋盘内的数字表示为该马能走的最大步数。\n例如棋盘内某个位置一个数字为 k，表示该马只能移动 1~k 步的距离。\n棋盘内的马移动类似于中国象棋中的马移动，先在水平或者垂直方向上移动一格，然后再将其移动到对角线位置。\n棋盘内的马可以移动到同一个位置，同一个位置可以有多匹马。\n请问能否将棋盘上所有的马移动到同一个位置，若可以请输入移动的最小步数。若不可以输出 0。",
    "inputDesc": "输入 m 和 n 两个数，m 和 n 表示一个 m*n 的棋盘。输入棋盘内的数据。棋盘中存在数字和\".\"两种字符，如果是数字表示该位置是一匹马，如果是\".\"表示该位置为空的，棋盘内的数字表示为该马能走的最大步数。\n例如棋盘内某个位置一个数字为 k，表示该马只能移动 1~k 步的距离。\n棋盘内的马移动类似于中国象棋中的马移动，先在水平或者垂直方向上移动一格，然后再将其移动到对角线位置。\n棋盘内的马可以移动到同一个位置，同一个位置可以有多匹马。\n请问能否将棋盘上所有的马移动到同一个位置，若可以请输入移动的最小步数。若不可以输出 0。",
    "outputDesc": "能否将棋盘上所有的马移动到同一个位置，若可以请输入移动的最小步数。若不可以输出 0。",
    "examples": [
      {
        "input": "2\n. .\n .\n. .",
        "output": "",
        "explanation": ""
      },
      {
        "input": "5\n 7 . 4 8\n 7 4 4 .\n . . . .",
        "output": "",
        "explanation": ""
      }
    ],
    "solution": "给定的用例是一个3行5列的棋盘，其中一些位置有数字，代表马的位置和它们可以走的最大步数。我们将逐步模拟广度优先搜索（BFS）的过程来找到所有马都能到达的位置，并计算出最小步数。\n棋盘布局：\n123\n步骤：\n初始化： 马的位置和最大步数分别为：(0,0,4), (0,1,7), (0,3,4), (0,4,8), (1,0,4), (1,1,7), (1,2,4), (1,3,4), (2,0,7)。 对棋盘上的每个位置进行BFS： 我们需要检查棋盘上的每个位置，看看是否所有马都能到达那里。例如，我们检查位置(0,2)。 对每个马进行BFS： 从马(0,0,4)开始，它可以在4步内到达的位置有限。我们将这些位置和步数记录下来，并检查是否包括(0,2)。接下来，我们对马(0,1,7)执行同样的操作，记录它可以到达的位置和步数。我们重复这个过程，直到考虑了所有的马。 累加步数： 如果所有马都可以在它们的最大步数内到达位置(0,2)，我们将这些步数累加起来。 更新最小步数： 如果我们发现所有马都能到达位置(0,2)，我们将这个累加的步数与当前的最小步数进行比较，并更新最小步数。如果有任何一个马不能到达位置(0,2)，我们将忽略这个位置，并继续检查下一个位置。 重复以上步骤： 我们重复以上步骤，对棋盘上的每个位置进行检查。 得出结果： 在检查完所有位置后，我们得到所有马都能到达的位置的最小步数。如果没有这样的位置，则返回0。\n初始化：\n马的位置和最大步数分别为：(0,0,4), (0,1,7), (0,3,4), (0,4,8), (1,0,4), (1,1,7), (1,2,4), (1,3,4), (2,0,7)。\n对棋盘上的每个位置进行BFS：\n我们需要检查棋盘上的每个位置，看看是否所有马都能到达那里。例如，我们检查位置(0,2)。\n对每个马进行BFS：\n从马(0,0,4)开始，它可以在4步内到达的位置有限。我们将这些位置和步数记录下来，并检查是否包括(0,2)。接下来，我们对马(0,1,7)执行同样的操作，记录它可以到达的位置和步数。我们重复这个过程，直到考虑了所有的马。\n累加步数：\n如果所有马都可以在它们的最大步数内到达位置(0,2)，我们将这些步数累加起来。\n更新最小步数：\n如果我们发现所有马都能到达位置(0,2)，我们将这个累加的步数与当前的最小步数进行比较，并更新最小步数。如果有任何一个马不能到达位置(0,2)，我们将忽略这个位置，并继续检查下一个位置。\n重复以上步骤：\n我们重复以上步骤，对棋盘上的每个位置进行检查。\n得出结果：\n在检查完所有位置后，我们得到所有马都能到达的位置的最小步数。如果没有这样的位置，则返回0。\n初始化数据结构： 读取棋盘的行数和列数。创建一个二维数组来表示棋盘。创建一个列表来存储每个马的位置和它们可以走的最大步数。 广度优先搜索（BFS）： 定义一个函数来执行BFS，该函数将遍历棋盘上的每个位置，尝试找到所有马都能到达的位置，并计算出最小步数。在BFS中，定义马可以走的八个方向。对于棋盘上的每个位置，初始化步数为0，并设置一个标志来判断是否所有马都能到达该位置。 遍历棋盘上的每个位置： 对于棋盘上的每个位置，遍历每个马，使用BFS来判断马是否能到达该位置。对于每个马，使用一个队列来存储它可以到达的位置和对应的步数。使用一个集合来记录已经访问过的位置，避免重复访问。 遍历每个马： 从马的当前位置开始，将其加入队列，并将该位置标记为已访问。当队列不为空时，取出队列的头部元素，这是当前马的位置和步数。如果该位置是目标位置，累加步数并标记找到目标位置。否则，遍历马可以走的八个方向，对于每个方向，计算新的位置并检查是否有效且未访问过。如果新位置有效，将其加入队列并标记为已访问。 更新步数和可能性： 如果找到目标位置，累加步数。如果没有找到目标位置，标记为不可能到达。 计算最小步数： 如果所有马都能到达当前位置，更新最小步数。如果没有任何位置能被所有马到达，返回-1。否则，返回找到的最小步数。\n初始化数据结构：\n读取棋盘的行数和列数。创建一个二维数组来表示棋盘。创建一个列表来存储每个马的位置和它们可以走的最大步数。\n广度优先搜索（BFS）：\n定义一个函数来执行BFS，该函数将遍历棋盘上的每个位置，尝试找到所有马都能到达的位置，并计算出最小步数。在BFS中，定义马可以走的八个方向。对于棋盘上的每个位置，初始化步数为0，并设置一个标志来判断是否所有马都能到达该位置。\n遍历棋盘上的每个位置：\n对于棋盘上的每个位置，遍历每个马，使用BFS来判断马是否能到达该位置。对于每个马，使用一个队列来存储它可以到达的位置和对应的步数。使用一个集合来记录已经访问过的位置，避免重复访问。\n遍历每个马：\n从马的当前位置开始，将其加入队列，并将该位置标记为已访问。当队列不为空时，取出队列的头部元素，这是当前马的位置和步数。如果该位置是目标位置，累加步数并标记找到目标位置。否则，遍历马可以走的八个方向，对于每个方向，计算新的位置并检查是否有效且未访问过。如果新位置有效，将其加入队列并标记为已访问。\n更新步数和可能性：\n如果找到目标位置，累加步数。如果没有找到目标位置，标记为不可能到达。\n计算最小步数：\n如果所有马都能到达当前位置，更新最小步数。如果没有任何位置能被所有马到达，返回-1。否则，返回找到的最小步数。",
    "codes": {
      "java": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n    // 定义棋盘的行数和列数\n    private static int m, n;\n    // 定义棋盘\n    private static int[][] board;\n    // 定义马的位置和步数的列表\n    private static LinkedList<int[]> horses = new LinkedList<>();\n\n    public static void main(String[] args) throws IOException {\n        // 使用BufferedReader读取输入\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        // 读取第一行输入，获取棋盘的行数和列数\n        String[] firstLine = br.readLine().split(\" \");\n        m = Integer.parseInt(firstLine[0]);\n        n = Integer.parseInt(firstLine[1]);\n        // 初始化棋盘\n        board = new int[m][n];\n\n        // 读取棋盘上每个位置的输入\n        for (int i = 0; i < m; i++) {\n            String[] line = br.readLine().split(\" \");\n            for (int j = 0; j < n; j++) {\n                // 如果当前位置不是空点，则将马的位置和步数添加到列表中\n                if (!line[j].equals(\".\")) {\n                    horses.add(new int[]{i, j, Integer.parseInt(line[j])});\n                }\n            }\n        }\n\n        // 调用bfs方法并打印结果\n        System.out.println(bfs());\n    }\n\n    // 定义广度优先搜索方法\n    private static int bfs() {\n        // 定义马能走的八个方向\n        int[][] directions = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};\n        // 初始化最小步数为最大值\n        int minSteps = Integer.MAX_VALUE;\n\n        // 遍历棋盘上的每个位置\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                // 初始化当前位置的步数为0\n                int steps = 0;\n                // 标记是否所有马都能到达当前位置\n                boolean possible = true;\n\n                // 遍历每个马\n                for (int[] horse : horses) {\n                    // 使用队列进行BFS\n                    Queue<int[]> queue = new LinkedList<>();\n                    // 使用集合记录已访问的位置\n                    Set<String> visited = new HashSet<>();\n                    // 将当前马的位置和步数0加入队列\n                    queue.offer(new int[]{horse[0], horse[1], 0});\n                    // 将当前马的位置添加到已访问集合中\n                    visited.add(horse[0] + \",\" + horse[1]);\n                    // 标记是否找到当前位置\n                    boolean found = false;\n\n                    // 当队列不为空且可能到达当前位置时\n                    while (!queue.isEmpty() && possible) {\n                        // 取出队列头部元素\n                        int[] current = queue.poll();\n                        // 如果当前元素位置等于目标位置\n                        if (current[0] == i && current[1] == j) {\n                            // 累加步数\n                            steps += current[2];\n                            // 标记为找到\n                            found = true;\n                            break;\n                        }\n\n                        // 遍历马能走的八个方向\n                        for (int[] dir : directions) {\n                            // 计算新的位置\n                            int nx = current[0] + dir[0];\n                            int ny = current[1] + dir[1];\n                            // 如果新位置有效且未访问过，则加入队列\n                            if (nx >= 0 && nx < m && ny >= 0 && ny < n && current[2] < horse[2] && !visited.contains(nx + \",\" + ny)) {\n                                queue.offer(new int[]{nx, ny, current[2] + 1});\n                                visited.add(nx + \",\" + ny);\n                            }\n                        }\n                    }\n\n                    // 如果没有找到目标位置，则标记为不可能到达\n                    if (!found) {\n                        possible = false;\n                    }\n                }\n\n                // 如果所有马都能到达当前位置，则更新最小步数\n                if (possible) {\n                    minSteps = Math.min(minSteps, steps);\n                }\n            }\n        }\n\n        // 如果最小步数为最大值，则返回0，否则返回最小步数\n        return minSteps == Integer.MAX_VALUE ? 0 : minSteps;\n    }\n}",
      "python": "from collections import deque\n\n# 读取棋盘的行数和列数\nm, n = map(int, input().split())\n# 初始化棋盘数组，虽然在这个程序中没有直接使用棋盘数据\nboard = [[0] * n for _ in range(m)]\n\n# 存储每个马的位置和它们的最大移动步数\nhorses = []\nfor i in range(m):\n    line = input().split()\n    for j in range(n):\n        if line[j] != '.':\n            # 如果位置不是空点，则记录马的位置和初始步数\n            horses.append((i, j, int(line[j])))\n\ndef bfs():\n    # 马可以移动的八个方向\n    directions = [(-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2)]\n    # 初始化最小步数为无穷大\n    min_steps = float('inf')\n\n    # 遍历棋盘上的每一个位置作为目标位置\n    for i in range(m):\n        for j in range(n):\n            steps = 0\n            possible = True\n\n            # 遍历每个马\n            for horse in horses:\n                queue = deque([(horse[0], horse[1], 0)])\n                visited = set()\n                visited.add((horse[0], horse[1]))\n                found = False\n\n                # 使用 BFS 寻找每个马到目标位置的最短路径\n                while queue and possible:\n                    x, y, dist = queue.popleft()\n                    if (x, y) == (i, j):\n                        steps += dist\n                        found = True\n                        break\n\n                    for dx, dy in directions:\n                        nx, ny = x + dx, y + dy\n                        # 检查新位置是否有效，并且未被访问过\n                        if 0 <= nx < m and 0 <= ny < n and dist < horse[2] and (nx, ny) not in visited:\n                            queue.append((nx, ny, dist + 1))\n                            visited.add((nx, ny))\n                \n                # 如果找不到路径，则此目标位置不可达\n                if not found:\n                    possible = False\n            \n            # 如果所有马都可以到达此位置，更新最小步数\n            if possible:\n                min_steps = min(min_steps, steps)\n    \n    # 如果找不到任何可行的解决方案，则返回0，否则返回最小步数\n    return 0 if min_steps == float('inf') else min_steps\n\n# 打印广度优先搜索的结果\nprint(bfs())",
      "javascript": "// 导入readline模块，用于从标准输入读取数据\nconst readline = require('readline');\n// 创建readline接口实例\nconst rl = readline.createInterface({\n    input: process.stdin\n});\n\n// 用于存储输入的所有行\nconst lines = [];\n// 监听行输入事件\nrl.on('line', (input) => {\n    lines.push(input); // 将每行输入存储到 lines 数组中\n}).on('close', () => { // 输入结束时触发\n    // 解析第一行数据获取棋盘的行数和列数\n    const [m, n] = lines[0].split(' ').map(Number);\n    // 创建一个m行n列的棋盘，初始值为'.'\n    const board = Array.from({ length: m }, () => Array(n).fill('.'));\n    // 存储马的位置和步数的数组\n    const horses = [];\n\n    // 遍历输入的棋盘数据\n    for (let i = 1; i <= m; i++) {\n        lines[i].split(' ').forEach((cell, j) => {\n            if (cell !== '.') {\n                // 如果当前位置有马，则记录其位置和步数\n                horses.push([i - 1, j, parseInt(cell)]);\n            }\n        });\n    }\n\n    // 调用bfs函数计算结果，并打印\n    console.log(bfs(m, n, horses));\n});\n\n// 定义广度优先搜索函数\nfunction bfs(m, n, horses) {\n    // 定义马能走的八个方向\n    const directions = [[-1, -2], [-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2]];\n    // 初始化最小步数为无穷大\n    let minSteps = Infinity;\n\n    // 遍历棋盘的每一个位置\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let steps = 0; // 存储到达当前位置的总步数\n            let possible = true; // 标记所有马是否都能到达当前位置\n\n            // 遍历每一匹马\n            for (const [x, y, maxSteps] of horses) {\n                const queue = [[x, y, 0]]; // 使用队列实现BFS\n                const visited = new Set(`${x},${y}`); // 记录已访问的位置\n\n                let found = false; // 标记是否找到路径\n                // 当队列不为空并且仍可能到达当前位置时继续循环\n                while (queue.length > 0 && possible) {\n                    const [currentX, currentY, currentSteps] = queue.shift();\n                    // 如果当前位置是目标位置\n                    if (currentX === i && currentY === j) {\n                        steps += currentSteps; // 累加步数\n                        found = true; // 标记已找到\n                        break;\n                    }\n\n                    // 遍历马能走的八个方向\n                    directions.forEach(([dx, dy]) => {\n                        const nx = currentX + dx;\n                        const ny = currentY + dy;\n                        // 检查新位置是否有效并且未被访问过\n                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && currentSteps < maxSteps && !visited.has(`${nx},${ny}`)) {\n                            queue.push([nx, ny, currentSteps + 1]); // 加入新位置到队列\n                            visited.add(`${nx},${ny}`); // 标记为已访问\n                        }\n                    });\n                }\n\n                // 如果没有找到目标位置，则标记为不可能到达\n                if (!found) possible = false;\n            }\n\n            // 如果所有马都能到达当前位置，更新最小步数\n            if (possible) minSteps = Math.min(minSteps, steps);\n        }\n    }\n\n    // 如果最小步数为无穷大，表示没有可行解，返回0；否则返回最小步数\n    return minSteps === Infinity ? 0 : minSteps;\n}",
      "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <string>\n#include <climits>\n#include <tuple>  \n\nusing namespace std;\n\n// 定义棋盘的行数和列数\nint m, n;\n// 定义棋盘\nvector<vector<char>> board;\n// 定义马的位置和步数的列表\nvector<tuple<int, int, int>> horses;\n\n// 定义广度优先搜索方法\nint bfs() {\n    // 定义马能走的八个方向\n    vector<pair<int, int>> directions = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};\n    // 初始化最小步数为最大值\n    int minSteps = INT_MAX;\n\n    // 遍历棋盘上的每个位置\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            // 初始化当前位置的步数为0\n            int steps = 0;\n            // 标记是否所有马都能到达当前位置\n            bool possible = true;\n\n            // 遍历每个马\n            for (auto& horse : horses) {\n                // 使用队列进行BFS\n                queue<tuple<int, int, int>> queue;\n                // 使用集合记录已访问的位置\n                set<string> visited;\n                // 获取马的位置和最大步数\n                int x, y, maxSteps;\n                tie(x, y, maxSteps) = horse;\n                // 将当前马的位置和步数0加入队列\n                queue.push(make_tuple(x, y, 0));\n                // 将当前马的位置添加到已访问集合中\n                visited.insert(to_string(x) + \",\" + to_string(y));\n                // 标记是否找到当前位置\n                bool found = false;\n\n                // 当队列不为空且可能到达当前位置时\n                while (!queue.empty() && possible) {\n                    // 取出队列头部元素\n                    tuple<int, int, int> current = queue.front();\n                    queue.pop();\n                    int cx, cy, cs;\n                    tie(cx, cy, cs) = current; // Unpack the tuple\n                    // 如果当前元素位置等于目标位置\n                    if (cx == i && cy == j) {\n                        // 累加步数\n                        steps += cs;\n                        // 标记为找到\n                        found = true;\n                        break;\n                    }\n\n                    // 遍历马能走的八个方向\n                    for (auto& dir : directions) {\n                        // 计算新的位置\n                        int nx = cx + dir.first;\n                        int ny = cy + dir.second;\n                        // 如果新位置有效且未访问过，则加入队列\n                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && cs < maxSteps && !visited.count(to_string(nx) + \",\" + to_string(ny))) {\n                            queue.push(make_tuple(nx, ny, cs + 1));\n                            visited.insert(to_string(nx) + \",\" + to_string(ny));\n                        }\n                    }\n                }\n\n                // 如果没有找到目标位置，则标记为不可能到达\n                if (!found) {\n                    possible = false;\n                }\n            }\n\n            // 如果所有马都能到达当前位置，则更新最小步数\n            if (possible) {\n                minSteps = min(minSteps, steps);\n            }\n        }\n    }\n\n    // 如果最小步数为最大值，则返回0，否则返回最小步数\n    return minSteps == INT_MAX ? 0 : minSteps;\n}\n\n// 主函数\nint main() {\n    // 读取棋盘的行数和列数\n    cin >> m >> n;\n    // 初始化棋盘\n    board.resize(m, vector<char>(n));\n    // 读取棋盘上每个位置的输入\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> board[i][j];\n            // 如果当前位置不是空点，则将马的位置和步数添加到列表中\n            if (board[i][j] != '.') {\n                horses.emplace_back(i, j, board[i][j] - '0');\n            }\n        }\n    }\n\n    // 调用bfs方法并打印结果\n    cout << bfs() << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n// 定义棋盘的最大行数和列数\n#define MAX_M 100\n#define MAX_N 100\n\n// 定义棋盘的行数和列数\nint m, n;\n// 定义棋盘\nchar board[MAX_M][MAX_N];\n// 定义马的位置和步数的结构体\ntypedef struct {\n    int x, y, steps;\n} Horse;\n// 定义马的数组\nHorse horses[MAX_M * MAX_N];\n// 定义马的数量\nint horse_count = 0;\n\n// 定义队列中的元素结构体\ntypedef struct {\n    int x, y, step;\n} QueueItem;\n\n// 定义队列\nQueueItem queue[MAX_M * MAX_N * 8];\n// 队列的头和尾\nint queue_head = 0, queue_tail = 0;\n\n// 队列操作函数\nvoid queue_push(QueueItem item) {\n    queue[queue_tail++] = item;\n}\n\nQueueItem queue_pop() {\n    return queue[queue_head++];\n}\n\nint queue_empty() {\n    return queue_head == queue_tail;\n}\n\n// 定义广度优先搜索方法\nint bfs() {\n    // 定义马能走的八个方向\n    int directions[8][2] = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};\n    // 初始化最小步数为最大值\n    int minSteps = INT_MAX;\n\n    // 遍历棋盘上的每个位置\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            // 初始化当前位置的步数为0\n            int steps = 0;\n            // 标记是否所有马都能到达当前位置\n            int possible = 1;\n\n            // 遍历每个马\n            for (int h = 0; h < horse_count; ++h) {\n                // 使用队列进行BFS\n                queue_head = queue_tail = 0;\n                // 使用二维数组记录已访问的位置\n                int visited[MAX_M][MAX_N];\n                memset(visited, 0, sizeof(visited));\n\n                // 获取马的位置和最大步数\n                Horse horse = horses[h];\n                // 将当前马的位置和步数0加入队列\n                queue_push((QueueItem){horse.x, horse.y, 0});\n                // 将当前马的位置添加到已访问数组中\n                visited[horse.x][horse.y] = 1;\n                // 标记是否找到当前位置\n                int found = 0;\n\n                // 当队列不为空且可能到达当前位置时\n                while (!queue_empty() && possible) {\n                    // 取出队列头部元素\n                    QueueItem current = queue_pop();\n                    // 如果当前元素位置等于目标位置\n                    if (current.x == i && current.y == j) {\n                        // 累加步数\n                        steps += current.step;\n                        // 标记为找到\n                        found = 1;\n                        break;\n                    }\n\n                    // 遍历马能走的八个方向\n                    for (int d = 0; d < 8; ++d) {\n                        // 计算新的位置\n                        int nx = current.x + directions[d][0];\n                        int ny = current.y + directions[d][1];\n                        // 如果新位置有效且未访问过，则加入队列\n                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && current.step < horse.steps && !visited[nx][ny]) {\n                            queue_push((QueueItem){nx, ny, current.step + 1});\n                            visited[nx][ny] = 1;\n                        }\n                    }\n                }\n\n                // 如果没有找到目标位置，则标记为不可能到达\n                if (!found) {\n                    possible = 0;\n                }\n            }\n\n            // 如果所有马都能到达当前位置，则更新最小步数\n            if (possible) {\n                minSteps = minSteps < steps ? minSteps : steps;\n            }\n        }\n    }\n\n    // 如果最小步数为最大值，则返回0，否则返回最小步数\n    return minSteps == INT_MAX ? 0 : minSteps;\n}\n\n// 主函数\nint main() {\n    // 读取棋盘的行数和列数\n    scanf(\"%d %d\", &m, &n);\n    // 读取棋盘上每个位置的输入\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            scanf(\" %c\", &board[i][j]); // 注意%c前的空格，用于跳过空白字符\n            // 如果当前位置不是空点，则将马的位置和步数添加到列表中\n            if (board[i][j] != '.') {\n                horses[horse_count++] = (Horse){i, j, board[i][j] - '0'};\n            }\n        }\n    }\n\n    // 调用bfs方法并打印结果\n    printf(\"%d\\n\", bfs());\n    return 0;\n}"
    }
  },
  {
    "id": "176",
    "title": "通过软盘拷贝文件",
    "examType": "A",
    "score": 200,
    "description": "有一名科学家想要从一台古董电脑中拷贝文件到自己的电脑中加以研究。\n但此电脑除了有一个3.5寸软盘驱动器以外，没有任何手段可以将文件持贝出来，而且只有一张软盘可以使用。\n因此这一张软盘是唯一可以用来拷贝文件的载体。\n科学家想要尽可能多地将计算机中的信息拷贝到软盘中，做到软盘中文件内容总大小最大。\n已知该软盘容量为1474560字节。文件占用的软盘空间都是按块分配的，每个块大小为512个字节。一个块只能被一个文件使用。拷贝到软盘中的文件必须是完整的，且不能采取任何压缩技术。",
    "inputDesc": "第1行为一个整数N，表示计算机中的文件数量。1 ≤ N ≤ 1000. 接下来的第2行到第N+1行(共N行)，每行为一个整数，表示每个文件的大小Si，单位为字节。\n0 ≤ i < N,0 ≤ Si\n为了充分利用软盘空间，将每个文件在软盘上占用的块记录到本子上。即真正占用软盘空间的只有文件内容本身。",
    "outputDesc": "科学家最多能拷贝的文件总大小",
    "examples": [],
    "solution": "该题可以采用背包问题的思想进行求解。\n首先，根据输入的文件数量和每个文件的大小，将文件大小存储在一个数组中。\n然后，计算软盘可以存放的块数，即将软盘总容量除以每个块的大小。\n接下来，创建一个动态规划数组dp，其中dp[i]表示容量为i的背包可以存储的最大文件大小。\n对于每个文件，将文件大小转换成块数，并将文件大小作为价值存储在worth中。\n然后，从背包容量为blockCount开始向前遍历，对于每个背包容量，计算选择当前文件和不选择当前文件两种情况下的最大值。\n最后，输出dp[blockCount]，即可得到科学家最多能拷贝的文件总大小。",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n\n    int n = scanner.nextInt();\n\n    int[] fileSizeArray = new int[n];\n    for (int i = 0; i < n; i++) {\n        fileSizeArray[i] = scanner.nextInt();\n    }\n\n    // 计算软盘可以存放的块数\n    int blockCount = 1474560 / 512; \n\n    // 动态规划数组，dp[i] 表示容量为 i 的背包可以存储的最大文件大小\n    int[] dp = new int[blockCount + 1];\n\n    for (int fileSize : fileSizeArray) {\n        // 把文件大小转换成块数\n        int weight = (int) Math.ceil(fileSize / 512.0);  \n        int worth = fileSize; \n        for (int j = blockCount; j >= weight; j--) {\n            dp[j] = Math.max(dp[j], dp[j - weight] + worth);\n        }\n    }\n\n    System.out.println(dp[blockCount]);\n  }\n}",
      "python": "import math\n\nn = int(input())\n\nfileSizeArray = []\nfor i in range(n):\n    fileSizeArray.append(int(input()))\n\nblockCount = 1474560 // 512\n\ndp = [0] * (blockCount + 1)\n\nfor fileSize in fileSizeArray:\n    weight = math.ceil(fileSize / 512)\n    worth = fileSize\n    for j in range(blockCount, weight - 1, -1):\n        dp[j] = max(dp[j], dp[j - weight] + worth)\n\nprint(dp[blockCount])",
      "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet n;\nlet fileSizeArray = [];\n\nrl.on('line', (input) => {\n  if (!n) {\n    n = parseInt(input);\n  } else {\n    fileSizeArray.push(parseInt(input));\n    if (fileSizeArray.length === n) {\n      rl.close();\n      const blockCount = 1474560 / 512;\n      const dp = new Array(blockCount + 1).fill(0);\n      fileSizeArray.forEach((fileSize) => {\n        const weight = Math.ceil(fileSize / 512);\n        const worth = fileSize;\n        for (let j = blockCount; j >= weight; j--) {\n          dp[j] = Math.max(dp[j], dp[j - weight] + worth);\n        }\n      });\n      console.log(dp[blockCount]);\n    }\n  }\n});",
      "cpp": "#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n\n    int fileSizeArray[n];\n    for (int i = 0; i < n; i++) {\n        cin >> fileSizeArray[i];\n    }\n\n    // 计算软盘可以存放的块数\n    int blockCount = 1474560 / 512; \n\n    // 动态规划数组，dp[i] 表示容量为 i 的背包可以存储的最大文件大小\n    int dp[blockCount + 1] = {0};\n\n    for (int i = 0; i < n; i++) {\n        // 把文件大小转换成块数\n        int weight = ceil(fileSizeArray[i] / 512.0);  \n        int worth = fileSizeArray[i]; \n        for (int j = blockCount; j >= weight; j--) {\n            dp[j] = max(dp[j], dp[j - weight] + worth);\n        }\n    }\n\n    cout << dp[blockCount] << endl;\n\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n// 定义一个返回较大值的函数\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint main() {\n    int n;\n    \n    // 输入文件数量\n    scanf(\"%d\", &n);\n\n    // 动态分配存储文件大小的数组\n    int *fileSizeArray = (int *)malloc(n * sizeof(int));\n    // 输入每个文件的大小\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &fileSizeArray[i]);\n    }\n\n    // 计算软盘可以存放的块数\n    int blockCount = 1474560 / 512;\n\n    // 动态规划数组，dp[i] 表示容量为 i 的背包可以存储的最大文件大小\n    int *dp = (int *)malloc((blockCount + 1) * sizeof(int));\n    // 初始化 dp 数组，将其所有元素置为0\n    for (int i = 0; i <= blockCount; i++) {\n        dp[i] = 0;\n    }\n\n    // 处理每个文件，计算在给定块数内能够存储的最大文件大小\n    for (int i = 0; i < n; i++) {\n        // 把文件大小转换成块数\n        int weight = (int)ceil(fileSizeArray[i] / 512.0);  \n        int worth = fileSizeArray[i];\n        \n        // 从后向前遍历，更新动态规划数组\n        for (int j = blockCount; j >= weight; j--) {\n            dp[j] = max(dp[j], dp[j - weight] + worth);\n        }\n    }\n\n    // 输出最大可以存储的文件大小\n    printf(\"%d\\n\", dp[blockCount]);\n\n    return 0;\n}"
    }
  },
  {
    "id": "177",
    "title": "组装最大可靠性设备",
    "examType": "",
    "score": 200,
    "description": "一个设备由N种类型元器件组成(每种类型元器件只需要一个，类型type编号从0~N-1)，\n每个元器件均有可靠性属性reliability，可靠性越高的器件其价格price越贵。\n而设备的可靠性由组成设备的所有器件中可靠性最低的器件决定。\n给定预算S，购买N种元器件( 每种类型元器件都需要购买一个)，在不超过预算的情况下，请给出能够组成的设备的最大可靠性。\n",
    "inputDesc": "S N // S总的预算，N元器件的种类\ntotal // 元器件的总数，每种型号的元器件可以有多种;\n此后有total行具体器件的数据\ntype reliability price // type 整数类型，代表元器件的类型编号从0 ~ N-1; reliabilty 整数类型 ，代表元器件的可靠性; price 整数类型 ，代表元器件的价格\n",
    "outputDesc": "符合预算的设备的最大可靠性，如果预算无法买齐N种器件，则返回 -1\n\n\n预算500，设备需要3种元件组成，方案\n类型0的第一个(可靠性80),\n类型1的第二个(可靠性70),\n类型2的第二个(可靠性60),\n可以使设备的可靠性最大 60\n本题很像是分组背包问题，但是细看却不是，因为题目描述中说：\n每种类型元器件都需要购买一个\n\n我的解题思路是二分。\n首先，不分种类，收集所有器件出现过的可靠性到一个Set集合中，收集完后，进行升序排序，升序后可靠性数组设为maybe，即maybe数组里面的可靠性都有可能是题解。\n之后，将所有器件按类型统计，由于题目输入已经给出了种类数n，因此可以定义一个长度为n的数组kinds，即为种类数组，kinds[type]下记录对应类型的所有器件。统计完后，我们需要遍历每一个kinds[type]，然后将它按照器件的可靠性进行升序。\n预备处理如上。\n\n接下来我们需要在maybe中二分取中间值maybe[mid]，作为一个可能的题解，即设备最大可靠性。然后遍历kinds，在每一个种类的器件中，找到一个可靠性>=maybe[mid]，且最接近maybe[mid]的器件，这里需要想清楚两点：\n由于之前，已经对kinds[type]进行了升序，因此这里可以二分查找：可靠性>=maybe[mid]，且最接近maybe[mid]的器件\n这里又涉及到二分查找的目标位置和有序插入位置的知识，具体可以看：\n算法设计 - 二分法和三分法，洛谷P3382_伏城之外的博客-CSDN博客\n\n当找到所有kinds[type]中可靠性>=maybe[mid]，且最接近maybe[mid]的器件后，对这些器件的price进行求和，得到sumPrice：\n按此二分逻辑，将最后一次符合要求的maybe[mid]可能解返回即可，如果没有符合要求的maybe[mid]，则返回-1。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n  // 器件类\n  static class Device {\n    int reliability;\n    int price;\n\n    public Device(int reliability, int price) {\n      this.reliability = reliability;\n      this.price = price;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int s = sc.nextInt(); // 总预算\n    int n = sc.nextInt(); // 器件的种类数\n\n    // 收集器件的可靠性\n    TreeSet<Integer> reliabilities = new TreeSet<>();\n\n    // 各种类集合\n    ArrayList<ArrayList<Device>> kinds = new ArrayList<>();\n    // 为每个具体种类创建一个集合，用于装对应种类的器件\n    for (int i = 0; i < n; i++) kinds.add(new ArrayList<>());\n\n    int total = sc.nextInt(); // 之后输入total行具体器件的数据\n\n    for (int i = 0; i < total; i++) {\n      // 器件种类\n      int type = sc.nextInt();\n\n      // 器件可靠性\n      int reliability = sc.nextInt();\n      reliabilities.add(reliability); // 收集器件的可靠性\n\n      // 器件价值\n      int price = sc.nextInt();\n\n      // 将器件加入到对应的种类中\n      kinds.get(type).add(new Device(reliability, price));\n    }\n\n    System.out.println(getResult(s, kinds, reliabilities));\n  }\n\n  /**\n   * @param s 总预算\n   * @param kinds 种类集合\n   * @param reliabilities 可靠性集合\n   * @return 最大可靠性\n   */\n  public static int getResult(\n      int s, ArrayList<ArrayList<Device>> kinds, TreeSet<Integer> reliabilities) {\n\n    // ans记录题解\n    int ans = -1;\n\n    // 将每个种类内的器件按照可靠性升序\n    for (ArrayList<Device> kind : kinds) {\n      kind.sort((a, b) -> a.reliability - b.reliability);\n    }\n\n    // 将所有器件的可靠性集合，变为数组\n    Integer[] maybe = reliabilities.toArray(new Integer[0]);\n\n    // 二分选取可能的最大可靠性maybe\n    int low = 0;\n    int high = maybe.length - 1;\n\n    while (low <= high) {\n      int mid = (low + high) >> 1;\n      // 如果maybe[mid]可靠性可以保证所有种类器件都能选到，且价格之和小于s\n      if (check(kinds, maybe[mid], s)) {\n        // 则maybe[mid]可靠性就是一个可能解\n        ans = maybe[mid];\n        // 继续尝试更优解，即找更大的可靠性\n        low = mid + 1;\n      } else {\n        // 否则，说明可靠性选高了，我们应该继续尝试更低的可靠性\n        high = mid - 1;\n      }\n    }\n\n    return ans;\n  }\n\n  public static boolean check(ArrayList<ArrayList<Device>> kinds, int maxReliability, int s) {\n    int sum = 0;\n    for (ArrayList<Device> kind : kinds) {\n      // 注意kind内的器件已经按照可靠性升序了\n      // 我们需要在该kind种类内找到一个可靠性>=maxReliability的器件\n      int idx = binarySearch(kind, maxReliability);\n\n      // 如果idx<0，则说明idx是一个插入位置\n      if (idx < 0) {\n        idx = -idx - 1;\n      }\n\n      // 如果idx==kind.size()则说明kind内所有器件的可靠性都低于maxReliability，因此此kind器件选取不到，可以直接返回false\n      if (idx == kind.size()) return false;\n\n      // 否则，选取对应idx位置的器件，并计入价格到总价\n      sum += kind.get(idx).price;\n    }\n\n    // 如果最终总价小于总预算s，则此maxReliability可行\n    return sum <= s;\n  }\n\n  public static int binarySearch(ArrayList<Device> kind, int target) {\n    int low = 0;\n    int high = kind.size() - 1;\n\n    while (low <= high) {\n      int mid = (low + high) >> 1;\n      Device device = kind.get(mid);\n\n      if (device.reliability > target) {\n        high = mid - 1;\n      } else if (device.reliability < target) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -low - 1;\n  }\n}",
      "python": "class Device:\n    def __init__(self, reliability, price):\n        self.reliability = reliability\n        self.price = price\n\n\n# 输入获取\ns, n = map(int, input().split())  # s总预算, n器件的种类数\ntotal = int(input())  # 之后输入total行具体器件的数据\narr = [list(map(int, input().split())) for _ in range(total)]\n\nreliabilities = set()  # 收集器件的可靠性\n\nkinds = [[] for _ in range(n)]  # 各种类集合\nfor ty, reliability, price in arr:\n    kinds[int(ty)].append(Device(reliability, price))\n    reliabilities.add(reliability)\n\n\ndef binarySearch(kind, target):\n    low = 0\n    high = len(kind) - 1\n\n    while low <= high:\n        mid = (low + high) >> 1\n        device = kind[mid]\n\n        if device.reliability > target:\n            high = mid - 1\n        elif device.reliability < target:\n            low = mid + 1\n        else:\n            return mid\n\n    return -low - 1;\n\n\ndef check(reliability):\n    sumPrice = 0\n\n    for kind in kinds:\n        # 注意kind内的器件已经按照可靠性升序了\n        # 我们需要在该kind种类内找到一个可靠性>=maxReliability的器件\n        idx = binarySearch(kind, reliability)\n\n        # 如果idx<0，则说明idx是一个插入位置\n        if idx < 0:\n            idx = -idx - 1\n\n        # 如果idx==kind.size()则说明kind内所有器件的可靠性都低于maxReliability，因此此kind器件选取不到，可以直接返回false\n        if idx == len(kind):\n            return False\n\n        # 否则，选取对应idx位置的器件，并计入价格到总价\n        sumPrice += kind[idx].price\n\n    # 如果最终总价小于总预算s，则此maxReliability可行\n    return sumPrice <= s\n\n\n# 算法入口\ndef getResult():\n    # ans记录题解\n    ans = -1\n\n    # 将每个种类内的器件按照可靠性升序\n    for kind in kinds:\n        kind.sort(key=lambda x: x.reliability)\n\n    # 将所有器件的可靠性集合，变为数组\n    maybe = list(reliabilities)\n    maybe.sort()\n\n    # 二分选取可能的最大可靠性maybe\n    low = 0\n    high = len(maybe) - 1\n    while low <= high:\n        mid = (low + high) >> 1\n\n        # 如果maybe[mid]可靠性可以保证所有种类器件都能选到，且价格之和小于s\n        if check(maybe[mid]):\n            # 则maybe[mid]可靠性就是一个可能解\n            ans = maybe[mid]\n            # 继续尝试更优解，即找更大的可靠性\n            low = mid + 1\n        else:\n            # 否则，说明可靠性选高了，我们应该继续尝试更低的可靠性\n            high = mid - 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "178",
    "title": "万能字符单词拼写",
    "examType": "A",
    "score": 100,
    "description": "有一个字符串数组 words 和一个字符串 chars。\n假如可以用 chars 中的字母拼写出 words 中的某个“单词”（字符串），那么我们就认为你掌握了这个单词。\nwords 的字符仅由 a-z 英文小写字母组成，例如 \"abc\"\nchars 由 a-z 英文小写字母和 \"?\" 组成。其中英文 \"?\" 表示万能字符，能够在拼写时当作任意一个英文字母。例如：\"?\" 可以当作 \"a\" 等字母。\n注意：每次拼写时，chars 中的每个字母和万能字符都只能使用一次。\n输出词汇表 words 中你掌握的所有单词的个数。没有掌握任何单词，则输出0。\n",
    "inputDesc": "第一行：输入数组 words 的个数，记作N。\n第二行 ~ 第N+1行：依次输入数组words的每个字符串元素\n第N+2行：输入字符串chars\n",
    "outputDesc": "输出一个整数，表示词汇表 words 中你掌握的单词个数\n\n\n\n本题可以分别统计出chars和word中各字符的数量，然后遍历word每个字符c，比较word和chars中统计的c字符数量，如果word的c数量超过了chars的c数量，那么就就将超出数量计入diff中。\n最终比较diff和chars中万能字符‘?’的数量，如果chars中万能字符‘?’的数量 >= diff，那么说明chars可以使用万能字符补足不同部分，即可以学会word。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n\n    String[] words = new String[n];\n    for (int i = 0; i < n; i++) {\n      words[i] = sc.next();\n    }\n\n    String chars = sc.next();\n\n    System.out.println(getResult(words, n, chars));\n  }\n\n  public static int getResult(String[] words, int n, String chars) {\n    int ans = 0;\n\n    // 统计chars字符串中各字符的数量\n    int[] cnt_chars = charStatistic(chars);\n\n    for (int i = 0; i < n; i++) {\n      int diff = 0;\n\n      // 统计word字符串中各字符的数量\n      int[] cnt_word = charStatistic(words[i]);\n\n      for (int j = 0; j < 128; j++) {\n        // 记录word的某字符超过chars的对应字符出现的数量\n        diff += Math.max(cnt_word[j] - cnt_chars[j], 0);\n      }\n\n      if (diff <= cnt_chars['?']) {\n        ans++;\n        // System.out.println(words[i]);\n      }\n    }\n\n    return ans;\n  }\n\n  public static int[] charStatistic(String s) {\n    int[] cnts = new int[128];\n\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      cnts[c] += 1;\n    }\n\n    return cnts;\n  }\n}",
      "python": "# 输入获取\nn = int(input())\n\nwords = []\nfor i in range(n):\n    words.append(input())\n\nchars = input()\n\n\ndef charStatistic(s):\n    cnts = [0] * 128\n\n    for c in s:\n        cnts[ord(c)] += 1\n\n    return cnts\n\n\n# 算法入口\ndef getResult():\n    ans = 0\n\n    # 统计chars字符串中各字符的数量\n    cnt_chars = charStatistic(chars)\n\n    for word in words:\n        diff = 0\n\n        # 统计word字符串中各字符的数量\n        cnt_word = charStatistic(word)\n\n        for j in range(128):\n            # 记录word的某字符超过chars的对应字符出现的数量\n            diff += max(cnt_word[j] - cnt_chars[j], 0)\n\n        if diff <= cnt_chars[ord('?')]:\n            ans += 1\n            # print(word)\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "179",
    "title": "返回矩阵中非1的元素个数",
    "examType": "",
    "score": 200,
    "description": "存在一个m*n的二维数组，其成员取值范围为0，1，2。\n其中值为1的元素具备同化特性，每经过1S，将上下左右值为0的元素同化为1。\n而值为2的元素，免疫同化。\n将数组所有成员随机初始化为0或2，再将矩阵的[0, 0]元素修改成1，在经过足够长的时间后求矩阵中有多少个元素是0或2（即0和2数量之和）。\n",
    "inputDesc": "输入的前两个数字是矩阵大小。后面是数字矩阵内容。\n",
    "outputDesc": "返回矩阵中非1的元素个数。\n\n输入数字前两个数字是矩阵大小。后面的数字是矩阵内容。\n起始位置(0,0)被修改为1后，最终只能同化矩阵为：\n1 1 1 1\n1 2 2 2\n1 2 0 0\n1 2 0 0\n所以矩阵中非1的元素个数为9\n\n本题可以使用广度优先搜索BFS解决。\n关于广度优先搜索，可以看：华为OD机试 - 计算疫情扩散时间（Java & JS & Python）_在一个地图中(地图由n*n个区域组成)_伏城之外的博客-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n\n    int[][] matrix = new int[m][n];\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    matrix[0][0] = 1;\n\n    System.out.println(getResult(m, n, matrix));\n  }\n\n  public static int getResult(int m, int n, int[][] matrix) {\n    // 上、下、左、右偏移量\n    int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // 广搜队列\n    LinkedList<int[]> queue = new LinkedList<>();\n\n    // 初始时只有矩阵[0,0]位置元素为1\n    queue.add(new int[] {0, 0});\n\n    // count记录矩阵中值为1的元素的个数\n    int count = 1;\n\n    // 广搜\n    while (queue.size() > 0) {\n      int[] pos = queue.removeFirst();\n\n      int x = pos[0];\n      int y = pos[1];\n\n      for (int[] offset : offsets) {\n        int newX = x + offset[0];\n        int newY = y + offset[1];\n\n        if (newX >= 0 && newX < m && newY >= 0 && newY < n && matrix[newX][newY] == 0) {\n          matrix[newX][newY] = 1;\n          count++;\n          queue.add(new int[] {newX, newY});\n        }\n      }\n    }\n\n    return m * n - count;\n  }\n}",
      "python": "# 输入获取\nm, n = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(m)]\nmatrix[0][0] = 1\n\n\n# 算法入口\ndef getResult():\n    # 上、下、左、右偏移量\n    offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    # 广搜队列, 初始时只有矩阵[0,0]位置元素为1\n    queue = [[0, 0]]\n\n    # count记录矩阵中值为1的元素的个数\n    count = 1\n\n    # 广搜\n    while len(queue) > 0:\n        x, y = queue.pop(0)\n\n        for offset in offsets:\n            newX = x + offset[0]\n            newY = y + offset[1]\n\n            if m > newX >= 0 and n > newY >= 0 and matrix[newX][newY] == 0:\n                matrix[newX][newY] = 1\n                count += 1\n                queue.append([newX, newY])\n\n    return m * n - count\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "182",
    "title": "传递悄悄话",
    "examType": "B",
    "score": 100,
    "description": "给定一个二叉树，每个节点上站一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。\n初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。",
    "inputDesc": "给定二叉树\n0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2\n注：-1表示空节点\n",
    "outputDesc": "返回所有节点都接收到悄悄话花费的时间\n38",
    "examples": [],
    "solution": "读取输入： 读取一行输入，这行输入包含了一系列的整数，每个整数代表从父节点到子节点的悄悄话传递时间。 处理根节点： 将根节点（索引为0）加入队列，并设置其悄悄话接收时间为0。 层次遍历： 当队列不为空时，循环执行以下步骤： 从队列中取出一个节点（包括节点索引和该节点的悄悄话接收时间）。计算左右子节点的索引。检查左右子节点是否存在（索引有效且不为-1）。 更新子节点时间： 如果子节点存在，将当前节点的悄悄话接收时间加上从当前节点到子节点的悄悄话传递时间，得到子节点的悄悄话接收时间。将子节点及其悄悄话接收时间加入队列。 更新最大时间： 每次子节点的悄悄话接收时间被计算后，更新最大时间为当前子节点时间和已记录的最大时间中的较大值。\n读取一行输入，这行输入包含了一系列的整数，每个整数代表从父节点到子节点的悄悄话传递时间。\n将根节点（索引为0）加入队列，并设置其悄悄话接收时间为0。\n当队列不为空时，循环执行以下步骤： 从队列中取出一个节点（包括节点索引和该节点的悄悄话接收时间）。计算左右子节点的索引。检查左右子节点是否存在（索引有效且不为-1）。\n从队列中取出一个节点（包括节点索引和该节点的悄悄话接收时间）。计算左右子节点的索引。检查左右子节点是否存在（索引有效且不为-1）。\n如果子节点存在，将当前节点的悄悄话接收时间加上从当前节点到子节点的悄悄话传递时间，得到子节点的悄悄话接收时间。将子节点及其悄悄话接收时间加入队列。\n每次子节点的悄悄话接收时间被计算后，更新最大时间为当前子节点时间和已记录的最大时间中的较大值。\n给定的输入数组0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2代表一棵二叉树，其中每个值代表从父节点到子节点的悄悄话传递时间。数组中的-1表示没有子节点。数组索引代表节点的顺序，按照完全二叉树的顺序排列。\n模拟计算过程如下：\n初始化队列： 将根节点索引0加入队列，此时队列为[0]。 开始层次遍历： 队列非空，继续遍历。 处理根节点： 取出队列头部元素（根节点索引0），队列变为[]。计算左子节点索引1（2*0+1），右子节点索引2（2*0+2）。左子节点值为9，更新为0+9=9，加入队列，队列变为[1]。右子节点值为20，更新为0+20=20，加入队列，队列变为[1, 2]。更新maxTime为20。 处理索引为1的节点： 取出队列头部元素1，队列变为[2]。计算左子节点索引3（2*1+1），右子节点索引4（2*1+2）。左右子节点值均为-1，没有子节点，不做操作。 处理索引为2的节点： 取出队列头部元素2，队列变为[]。计算左子节点索引5（2*2+1），右子节点索引6（2*2+2）。左子节点值为15，更新为20+15=35，加入队列，队列变为[5]。右子节点值为7，更新为20+7=27，加入队列，队列变为[5, 6]。更新maxTime为35。 处理索引为5的节点： 取出队列头部元素5，队列变为[6]。计算左子节点索引11（2*5+1），右子节点索引12（2*5+2）。左子节点值为3，更新为35+3=38，加入队列，队列变为[6, 11]。右子节点值为2，更新为35+2=37，加入队列，队列变为[6, 11, 12]。更新maxTime为38。 处理索引为6的节点： 取出队列头部元素6，队列变为[11, 12]。计算左子节点索引13（2*6+1），右子节点索引14（2*6+2）。由于索引超出数组长度，没有子节点，不做操作。 处理索引为11和12的节点： 取出队列头部元素11和12，队列变为[]。由于索引超出数组长度，没有子节点，不做操作。 结束遍历： 队列为空，遍历结束。 输出结果： 最大时间maxTime为38，这是最后一个节点接收悄悄话的时间。\n初始化队列：\n将根节点索引0加入队列，此时队列为[0]。\n开始层次遍历：\n队列非空，继续遍历。\n处理根节点：\n取出队列头部元素（根节点索引0），队列变为[]。计算左子节点索引1（2*0+1），右子节点索引2（2*0+2）。左子节点值为9，更新为0+9=9，加入队列，队列变为[1]。右子节点值为20，更新为0+20=20，加入队列，队列变为[1, 2]。更新maxTime为20。\n处理索引为1的节点：\n取出队列头部元素1，队列变为[2]。计算左子节点索引3（2*1+1），右子节点索引4（2*1+2）。左右子节点值均为-1，没有子节点，不做操作。\n处理索引为2的节点：\n取出队列头部元素2，队列变为[]。计算左子节点索引5（2*2+1），右子节点索引6（2*2+2）。左子节点值为15，更新为20+15=35，加入队列，队列变为[5]。右子节点值为7，更新为20+7=27，加入队列，队列变为[5, 6]。更新maxTime为35。\n处理索引为5的节点：\n取出队列头部元素5，队列变为[6]。计算左子节点索引11（2*5+1），右子节点索引12（2*5+2）。左子节点值为3，更新为35+3=38，加入队列，队列变为[6, 11]。右子节点值为2，更新为35+2=37，加入队列，队列变为[6, 11, 12]。更新maxTime为38。\n处理索引为6的节点：\n取出队列头部元素6，队列变为[11, 12]。计算左子节点索引13（2*6+1），右子节点索引14（2*6+2）。由于索引超出数组长度，没有子节点，不做操作。\n处理索引为11和12的节点：\n取出队列头部元素11和12，队列变为[]。由于索引超出数组长度，没有子节点，不做操作。\n结束遍历：\n队列为空，遍历结束。\n输出结果：\n最大时间maxTime为38，这是最后一个节点接收悄悄话的时间。\n因此，所有节点接收悄悄话的总时间为38。\n",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建扫描器读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取一行输入并将其转换为整数数组，数组中的每个元素代表从父节点到当前节点的时间\n        int[] whisperTimes = Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 关闭扫描器\n        scanner.close();\n\n        // 记录最后一个节点接收悄悄话的时间\n        int maxTime = 0;\n\n        // 使用队列来进行二叉树的层次遍历\n        Queue<Integer> nodeQueue = new LinkedList<>();\n        // 将根节点索引0加入队列\n        nodeQueue.add(0);\n\n        // 当队列不为空时，继续遍历\n        while (!nodeQueue.isEmpty()) {\n            // 从队列中取出一个节点索引\n            int parentNodeIndex = nodeQueue.poll();\n\n            // 计算左子节点索引\n            int leftChildIndex = 2 * parentNodeIndex + 1;\n            // 计算右子节点索引\n            int rightChildIndex = 2 * parentNodeIndex + 2;\n\n            // 如果左子节点存在，处理左子节点\n            if (leftChildIndex < whisperTimes.length && whisperTimes[leftChildIndex] != -1) {\n                // 更新左子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n                // 将左子节点加入队列\n                nodeQueue.add(leftChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[leftChildIndex]);\n            }\n\n            // 如果右子节点存在，处理右子节点\n            if (rightChildIndex < whisperTimes.length && whisperTimes[rightChildIndex] != -1) {\n                // 更新右子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n                // 将右子节点加入队列\n                nodeQueue.add(rightChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[rightChildIndex]);\n            }\n        }\n\n        // 所有节点都接收到悄悄话后，打印最大时间\n        System.out.println(maxTime);\n    }\n}",
      "python": "from collections import deque\n\n# 读取一行输入并将其转换为整数列表\n# 列表中的每个元素代表从父节点到当前节点的时间\nwhisper_times = list(map(int, input().split()))\n\n# 记录最后一个节点接收悄悄话的时间\nmax_time = 0\n\n# 使用队列来进行二叉树的层次遍历\nnode_queue = deque([0])  # 将根节点索引0加入队列\n\n# 当队列不为空时，继续遍历\nwhile node_queue:\n    # 从队列中取出一个节点索引\n    parent_node_index = node_queue.popleft()\n\n    # 计算左子节点索引\n    left_child_index = 2 * parent_node_index + 1\n    # 计算右子节点索引\n    right_child_index = 2 * parent_node_index + 2\n\n    # 如果左子节点存在，处理左子节点\n    if left_child_index < len(whisper_times) and whisper_times[left_child_index] != -1:\n        # 更新左子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[left_child_index] += whisper_times[parent_node_index]\n        # 将左子节点加入队列\n        node_queue.append(left_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[left_child_index])\n\n    # 如果右子节点存在，处理右子节点\n    if right_child_index < len(whisper_times) and whisper_times[right_child_index] != -1:\n        # 更新右子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[right_child_index] += whisper_times[parent_node_index]\n        # 将右子节点加入队列\n        node_queue.append(right_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[right_child_index])\n\n# 所有节点都接收到悄悄话后，打印最大时间\nprint(max_time)",
      "javascript": "",
      "cpp": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    // 数组中的每个元素代表从父节点到当前节点的时间\n    string line;\n    getline(cin, line);\n    istringstream iss(line);\n    vector<int> whisperTimes;\n    int time;\n    while (iss >> time) {\n        whisperTimes.push_back(time);\n    }\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用队列来进行二叉树的层次遍历\n    queue<int> nodeQueue;\n    // 将根节点索引0加入队列\n    nodeQueue.push(0);\n\n    // 当队列不为空时，继续遍历\n    while (!nodeQueue.empty()) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = nodeQueue.front();\n        nodeQueue.pop();\n\n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < whisperTimes.size() && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            nodeQueue.push(leftChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[leftChildIndex]);\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < whisperTimes.size() && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            nodeQueue.push(rightChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[rightChildIndex]);\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    cout << maxTime << endl;\n    return 0;\n}",
      "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 10000 // 假设二叉树节点数不超过10000\n\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    char input[MAX_SIZE];\n    fgets(input, sizeof(input), stdin);\n    \n    int whisperTimes[MAX_SIZE];\n    int i = 0, time;\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        sscanf(token, \"%d\", &time);\n        whisperTimes[i++] = time;\n        token = strtok(NULL, \" \");\n    }\n    int length = i; // 数组长度\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用数组模拟队列进行二叉树的层次遍历\n    int queue[MAX_SIZE];\n    int front = 0, rear = 0; // 队列的头和尾索引\n\n    // 将根节点索引0加入队列\n    queue[rear++] = 0;\n\n    // 当队列不为空时，继续遍历\n    while (front < rear) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = queue[front++];\n        \n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < length && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            queue[rear++] = leftChildIndex;\n            // 更新最大时间\n            if (whisperTimes[leftChildIndex] > maxTime) {\n                maxTime = whisperTimes[leftChildIndex];\n            }\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < length && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            queue[rear++] = rightChildIndex;\n            // 更新最大时间\n            if (whisperTimes[rightChildIndex] > maxTime) {\n                maxTime = whisperTimes[rightChildIndex];\n            }\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    printf(\"%d\\n\", maxTime);\n    return 0;\n}"
    }
  },
  {
    "id": "186",
    "title": "字符串序列判定",
    "examType": "B",
    "score": 100,
    "description": "输入两个字符串 S 和 L ，都只包含英文小写字母。S长度 ≤ 100，L长度 ≤ 500,000。判定S是否是L的有效子串。\n判定规则：S 中的每个字符在 L 中都能找到（可以不连续），且 S 在Ｌ中字符的前后顺序与 S 中顺序要保持一致。（例如，S = ”ace” 是 L= ”abcde” 的一个子序列且有效字符是a、c、e，而”aec”不是有效子序列，且有效字符只有a、e）\n",
    "inputDesc": "输入两个字符串 S 和 L，都只包含英文小写字母。S长度 ≤ 100，L长度 ≤ 500,000。\n先输入S，再输入L，每个字符串占一行。\n",
    "outputDesc": "S 串最后一个有效字符在 L 中的位置。（首位从0开始计算，无有效字符返回-1）\n\nace abcde\nfgh abcde\n\n本题可以利用双指针来解决。\n定义两个指针 i , j，分别指向S，L 字符串的索引0位置，\n当 i ≥ S.length || J ≥ l.length 时结束\n\n如果最后，i == S.length，则说明，在 L 字符串中找到了所有的 S 字符串字符。且 S 字符串最后一个字符在 L 中的位置就是 j - 1。否则，就返回-1。\n\n用例1图示如下：\n\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String s = sc.nextLine();\n    String l = sc.nextLine();\n\n    System.out.println(getResult(s, l));\n  }\n\n  public static int getResult(String s, String l) {\n    int i = 0;\n    int j = 0;\n\n    while (i < s.length() && j < l.length()) {\n      if (s.charAt(i) == l.charAt(j)) {\n        i++;\n      }\n      j++;\n    }\n\n    if (i == s.length()) return j - 1;\n    else return -1;\n  }\n}",
      "python": "# 输入获取\ns = input()\nl = input()\n\n\n# 算法入口\ndef getResult():\n    i = 0\n    j = 0\n\n    while i < len(s) and j < len(l):\n        if s[i] == l[j]:\n            i += 1\n        j += 1\n\n    if i == len(s):\n        return j - 1\n    else:\n        return -1\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "187",
    "title": "打印机队列",
    "examType": "B",
    "score": 100,
    "description": "有5台打印机打印文件，每台打印机有自己的待打印队列。\n因为打印的文件内容有轻重缓急之分，所以队列中的文件有1~10不同的代先级，其中数字越大优先级越高。\n打印机会从自己的待打印队列中选择优先级最高的文件来打印。\n如果存在两个优先级一样的文件，则选择最早进入队列的那个文件。\n现在请你来模拟这5台打印机的打印过程。\n",
    "inputDesc": "每个输入包含1个测试用例，\n每个测试用例第一行给出发生事件的数量N（0 < N < 1000）。\n接下来有 N 行，分别表示发生的事件。共有如下两种事件：\n“IN P NUM”，表示有一个拥有优先级 NUM 的文件放到了打印机 P 的待打印队列中。（0< P <= 5, 0 < NUM <= 10)；“OUT P”，表示打印机 P 进行了一次文件打印，同时该文件从待打印队列中取出。（0 < P <= 5）。\n",
    "outputDesc": "本题可以基于优先队列实现打印机总是打印优先级最高的文件。\n优先队列，如果想简单一点的话，则可以基于有序数组实现，但是有序数组是整体有序，每次有新任务入队，都需要O(n)时间复杂度维持。\n优先队列最好是基于堆结构实现，所谓堆结构，即一颗完全二叉树。本题是优先级数值越大，优先级越高，因此我们可以使用大顶堆。\n关于基于堆结构实现优先队列，可以参考\nLeetCode - 1705 吃苹果的最大数目_伏城之外的博客-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = Integer.parseInt(sc.nextLine());\n    String[][] tasks = new String[n][];\n\n    for (int i = 0; i < n; i++) {\n      String[] s = sc.nextLine().split(\" \");\n      tasks[i] = s;\n    }\n\n    getResult(tasks);\n  }\n\n  public static void getResult(String[][] tasks) {\n    // print中存放每台打印机的等待队列\n    HashMap<String, PriorityQueue<int[]>> print = new HashMap<>();\n\n    // 文件的编号定义为”IN P NUM”事件发生第 x 次，此处待打印文件的编号为x。编号从1开始。\n    int x = 1;\n    for (int i = 0; i < tasks.length; i++) {\n      String[] task = tasks[i];\n      // IN,OUT都有type和printId\n      String type = task[0];\n      String printId = task[1];\n\n      if (\"IN\".equals(type)) {\n        // IN还有priority\n        String priority = task[2];\n        // arr是打印任务\n        int[] arr = {x, Integer.parseInt(priority), i}; // i代表先来后到的顺序\n        // 为打印机printId设置打印优先级，打印任务的priority越大，优先级越高\n        print.putIfAbsent(\n            printId,\n            new PriorityQueue<>(\n                (a, b) ->\n                    a[1] != b[1] ? b[1] - a[1] : a[2] - b[2])); // 优先按priority，如果priority相同，按先来后到i\n        // 将打印任务加入对应打印机\n        print.get(printId).offer(arr);\n        x++;\n      } else {\n        // 打印机等待队列中取出优先级最高的打印任务arr\n        if (!print.containsKey(printId) || print.get(printId).isEmpty()) {\n          // 如果此时没有文件可以打印，请输出”NULL“。\n          System.out.println(\"NULL\");\n        } else {\n          int[] arr = print.get(printId).poll();\n          if (arr != null) System.out.println(arr[0]); // arr[0]是x\n          else System.out.println(\"NULL\");\n        }\n      }\n    }\n  }\n}",
      "python": "import queue\n\n# 输入获取\nn = int(input())\n\ntasks = []\nfor i in range(n):\n    tasks.append(input().split())\n\n\nclass Task:\n    def __init__(self, taskId, priority, index):\n        \"\"\"\n        :param taskId: 任务ID\n        :param priority: 任务优先级\n        :param index: 任务到达顺序\n        \"\"\"\n        self.taskId = taskId\n        self.priority = priority\n        self.index = index\n\n    def __lt__(self, other):\n        if self.priority != other.priority:\n            return self.priority > other.priority\n        else:\n            return self.index < other.index\n\n\n# 算法入口\ndef getResult(tasks):\n    printer = {}\n\n    taskId = 1\n    for i in range(len(tasks)):\n        task = tasks[i]\n\n        type = task[0]\n        printerId = task[1]\n\n        if type == \"IN\":\n            priority = task[2]\n            if printer.get(printerId) is None:\n                printer[printerId] = queue.PriorityQueue()\n            printer[printerId].put(Task(taskId, int(priority), i))\n            taskId += 1\n        else:\n            if printer.get(printerId) is None or printer[printerId].qsize() == 0:\n                print(\"NULL\")\n            else:\n                t = printer[printerId].get()\n                print(t.taskId)\n\n\ngetResult(tasks)",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = parseInt(lines[0]);\n  }\n\n  if (n && lines.length === n + 1) {\n    lines.shift();\n\n    const tasks = lines.map((line) => line.split(\" \"));\n\n    getResult(tasks);\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(tasks) {\n  const print = {};\n\n  let taskId = 1;\n  for (let i = 0; i < tasks.length; i++) {\n    const [type, printId, priority] = tasks[i];\n\n    if (type === \"IN\") {\n      const arr = [taskId, priority, i]; // i 是先来后到的顺序\n      if (!print[printId]) {\n        print[printId] = []; // 基于数组实现优先队列\n      }\n      print[printId].push(arr);\n      print[printId].sort((a, b) => (a[1] != b[1] ? b[1] - a[1] : a[2] - b[2])); // 维持高优先级在头部，如果优先级相同，则按先来后到\n      taskId++;\n    } else {\n      if (!print[printId] || print[printId].length == 0) {\n        console.log(\"NULL\");\n      } else {\n        const arr = print[printId].shift();\n        console.log(arr ? arr[0] : \"NULL\");\n      }\n    }\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "188",
    "title": "拼接URL",
    "examType": "B",
    "score": 100,
    "description": "给定一个url前缀和url后缀,通过,分割 需要将其连接为一个完整的url\n如果前缀结尾和后缀开头都没有/，需要自动补上/连接符如果前缀结尾和后缀开头都为/，需要自动去重\n约束：不用考虑前后缀URL不合法情况\n",
    "inputDesc": "url前缀(一个长度小于100的字符串)，url后缀(一个长度小于100的字符串)",
    "outputDesc": "拼接后的url\n\n\n逻辑题，可以直接看代码实现了解逻辑。\n20230813 本题Java解法中split函数比较难搞，对于下面情况按照\",\"分割出来的字符串数组分别是：\n我们需要注意处理下。\nJS和Python的split函数就要规矩的多，上面三种输入情况，都会返回一个长度为2的字符串数组。\n更新解法使用了正则表达式，其中\nprefix前缀，需要将其结尾的多个/去除，使用正则 /+$ 来匹配结尾的多个/\nsuffix后缀，需要将其开头的多个/去除，使用正则 ^/+ 来匹配开头的多个/\n最后拼接 prefix + \"/\" + suffix 即可\n\n对于python而言，有更简单的lstrip和rstrip方法，实现同样效果。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String s = sc.nextLine();\n\n    String[] arr = s.split(\",\");\n\n    String prefix = arr.length > 0 && arr[0].length() > 0 ? arr[0] : \"/\";\n    String suffix = arr.length > 1 && arr[1].length() > 0 ? arr[1] : \"/\";\n\n    System.out.println(getResult(prefix, suffix));\n  }\n\n  public static String getResult(String prefix, String suffix) {\n    prefix = prefix.replaceAll(\"/+$\", \"\");\n    suffix = suffix.replaceAll(\"^/+\", \"\");\n    return prefix + \"/\" + suffix;\n  }\n}",
      "python": "# 输入获取\nprefix, suffix = input().split(\",\")\n\nprefix = prefix.rstrip(\"/\")\nsuffix = suffix.lstrip(\"/\")\n\nprint(prefix + \"/\" + suffix)",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "189",
    "title": "提取字符串中的最长合法简单数学表达式",
    "examType": "B",
    "score": 100,
    "description": "提取字符串中的最长合法简单数学表达式，字符串长度最长的，并计算表达式的值。如果没有，则返回 0 。\n简单数学表达式只能包含以下内容：\n0-9数字，符号+-*\n说明：\n所有数字，计算结果都不超过long如果有多个长度一样的，请返回第一个表达式的结果数学表达式，必须是最长的，合法的操作符不能连续出现，如 +--+1 是不合法的\n",
    "inputDesc": "字符串\n",
    "outputDesc": "表达式值\n\n\n注意！！！本题原题描述中没有 / 除号\n\n因此，本题的合法表达式不需要考虑 '/' 号，也就不用考虑除0，以及除法是整除还是小数除的问题。\n另外，本题的 +、-号仅作为运算符号，不作为正负号。因此 \"+1\"，\"-1\" 这种不能理解为合法的表达式。\n本题可以分为两步求解：\n关于1的求解，有两种思路：\n其中正则匹配实现起来比较简单，用于匹配合法表达式的正则也不是很难写，对应正则解析如下：\n\n对于python而言，为了更好地适配findall方法，我们可以对上面正则表达式中内层括号使用到非捕获组\n\n\n关于2的求解\n对于JS和Python而言，可以使用内置的eval函数计算字符串表达式的结果。\n更常规的思路是利用栈结构：\n找出最长合法表达式子串后，比如 \"1-2*3+10+2\"，我们需要注意表达式运算符优先级问题，即先乘，后加减，相同优先级的运算从左到右进行。\n\n这里我的思路是将 合法表达式串 进行分块，比如上面表达式可以分为：\n我们可以发现：\n分块之后，我们只需要求各块结果之和即可。\n\n具体逻辑实现如下：\n扫描合法表达式串，如果当前扫描的字符c是：\n这块实现的更详细解析，可以参考：\n华为OD机试 - 符号运算（Java & JS & Python & C）_java 华为od机试,符号运算-CSDN博客\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  public static long getResult(String s) {\n    String maxLenExp = getMaxLenExp(s);\n\n    if (maxLenExp.length() == 0) {\n      return 0;\n    } else {\n      return calcExpStr(maxLenExp);\n    }\n  }\n\n  public static String getMaxLenExp(String s) {\n    Matcher matcher = Pattern.compile(\"((\\\\d+[+*-])*\\\\d+)\").matcher(s);\n\n    String maxLenExp = \"\";\n\n    while (matcher.find()) {\n      String exp = matcher.group(0);\n\n      if (exp.length() > maxLenExp.length()) {\n        maxLenExp = exp;\n      }\n    }\n\n    return maxLenExp;\n  }\n\n  public static long calcExpStr(String exp) {\n    // 这里在表达式结尾追加\"+0\"是为了避免后面收尾操作，不理解的话，可以去掉此步，测试下\"1-2\"\n    exp += \"+0\";\n\n    // 记录表达式中各块的操作数\n    LinkedList<Long> stack = new LinkedList<>();\n    // 各块操作数的\"值\"部分的缓存容器\n    StringBuilder numStr = new StringBuilder();\n    // 各块操作数的\"系数\"部分，默认为1\n    long num_coef = 1;\n\n    for (int i = 0; i < exp.length(); i++) {\n      char c = exp.charAt(i);\n\n      if (c >= '0' && c <= '9') {\n        numStr.append(c);\n        continue;\n      }\n\n      // 如果扫描到的字符c是运算符，那么该运算符打断了前面操作数的扫描，前面操作数 = 系数 * 值\n      long num = num_coef * Long.parseLong(numStr.toString());\n      stack.add(num);\n\n      // 清空缓存容器，用于下一个操作数的”值“记录\n      numStr = new StringBuilder();\n\n      switch (c) {\n        case '+':\n          // 如果运算符是加法，则后一个操作数的系数为1\n          num_coef = 1;\n          break;\n        case '-':\n          // 如果运算符是减法，则后一个操作数的系数为-1\n          num_coef = -1;\n          break;\n        case '*':\n          // 如果运算符是乘法，则后一个操作数的系数为栈顶值，比如2*3，其中2可以当作3的系数\n          num_coef = stack.removeLast();\n          break;\n      }\n    }\n\n    // 表达式分块后，每一块独立计算，所有块的和就是表达式的结果\n    long res = 0;\n    for (long num : stack) {\n      res += num;\n    }\n\n    return res;\n  }\n}",
      "python": "# 输入获取\nimport re\n\ns = input()\n\n\n# 计算合法表达式的结果\ndef calcExpStr(exp):\n    # 这里在表达式结尾追加\"+0\"是为了避免后面收尾操作，不理解的话，可以去掉此步，测试下\"1-2\"\n    exp += '+0'\n\n    # 记录表达式中各块的操作数\n    stack = []\n    # 各块操作数的\"值\"部分的缓存容器\n    numStr = []\n    # 各块操作数的\"系数\"部分，默认为1\n    num_coef = 1\n\n    for c in exp:\n        if '9' >= c >= '0':\n            numStr.append(c)\n            continue\n\n        # 如果扫描到的字符c是运算符，那么该运算符打断了前面操作数的扫描，前面操作数 = 系数 * 值\n        num = num_coef * int(\"\".join(numStr))\n        stack.append(num)\n\n        # 清空缓存容器，用于下一个操作数的”值“记录\n        numStr.clear()\n\n        if c == '+':\n            # 如果运算符是加法，则后一个操作数的系数为1\n            num_coef = 1\n        elif c == '-':\n            # 如果运算符是减法，则后一个操作数的系数为-1\n            num_coef = -1\n        elif c == '*':\n            # 如果运算符是乘法，则后一个操作数的系数为栈顶值，比如2*3，其中2可以当作3的系数\n            num_coef = stack.pop()\n\n    # 表达式分块后，每一块独立计算，所有块的和就是表达式的结果\n    return sum(stack)\n\n\n# 获取最长合法表达式\ndef getMaxLenExp():\n    lst = re.compile(r\"((?:\\d+[+*-])*\\d+)\").findall(s)\n\n    maxLenExp = \"\"\n\n    for exp in lst:\n        if len(exp) > len(maxLenExp):\n            maxLenExp = exp\n\n    return maxLenExp\n\n\n# 算法入口\ndef getResult():\n    maxLenExp = getMaxLenExp()\n\n    if len(maxLenExp) == 0:\n        return 0\n    else:\n        return calcExpStr(maxLenExp)\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "190",
    "title": "数组组成的最小数字",
    "examType": "B",
    "score": 100,
    "description": "给定一个整型数组，请从该数组中选择3个元素组成最小数字并输出\n（如果数组长度小于3，则选择数组中所有元素来组成最小数字）。\n",
    "inputDesc": "一行用半角逗号分割的字符串记录的整型数组，0 < 数组长度 <= 100，0 < 整数的取值范围 <= 10000。\n",
    "outputDesc": "由3个元素组成的最小数字，如果数组长度小于3，则选择数组中所有元素来组成最小数字。\n\n此题可以使用暴力法，求n个数取3个全排列，也就是O(n^3)的时间复杂度，但是题目提示0 < 数组长度 <= 100，这个数据规模很容易超时，因此我们应该想一想更优化的方法。\n\n我们知道Array.prototype.sort默认排序是按照Unicode值从小到大排的，因此对于只有两个数的情况，我们直接按照sort字典序升序，比如5,21，字典序升序后就是21,5，而215就是最小组合数。\n2023.02.03 这里直接对数组进行字典序升序，拼接后得到的组合数，不一定是最小的，比如数组 [3, 32, 321]，此时按照字典序升序后，还是 [3, 32, 321]，拼接出来为332321，而这显然不是最小的组合数，最小的组合数应该是321323。\n此处，得到最小组合数的正确排序规则应该是：请看下面博客解析华为OD机试 - 组合出合法最小数_伏城之外的博客-CSDN博客\n\n对于三个数及以上的数组，我们需要从中取出3个数，这个3个数，首先需要保证总长度最短，即保证组合数的位数最少，其值才能最小，因此我们需要将数组升序，这样小数在前，大数在后，我们只要取前三位即可，比如21,30,62,5,31升序为 5,21,30,31,62，取前3个，5,21,30然后进行sort默认排序，变为21，30，5，而21305就是最小值。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String[] strs = sc.nextLine().split(\",\");\n    System.out.println(getResult(strs));\n  }\n\n  public static String getResult(String[] strs) {\n    Arrays.sort(strs, (a, b) -> Integer.parseInt(a) - Integer.parseInt(b));\n\n    String[] tmp = Arrays.copyOfRange(strs, 0, Math.min(3, strs.length));\n    Arrays.sort(tmp, (a, b) -> (a + b).compareTo(b + a));\n\n    StringBuilder sb = new StringBuilder();\n    for (String s : tmp) {\n      sb.append(s);\n    }\n\n    return sb.toString();\n  }\n}",
      "python": "import functools\n\n# 输入获取\nstrs = input().split(\",\")\n\n\n# 算法入口\ndef cmp(a, b):\n    s1 = a + b\n    s2 = b + a\n    return 0 if s1 == s2 else 1 if s1 > s2 else -1\n\n\ndef getResult(strs):\n    strs.sort(key=lambda x: int(x))\n    tmp = strs[:3]\n    tmp.sort(key=functools.cmp_to_key(cmp))\n    return \"\".join(tmp)\n\n\n# 算法调用\nprint(getResult(strs))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const strs = line.split(\",\");\n  console.log(getResult(strs));\n});\n\nfunction getResult(strs) {\n  strs.sort((a, b) => a - b);\n\n  return strs\n    .slice(0, 3)\n    .sort((a, b) => {\n      const s1 = a + b;\n      const s2 = b + a;\n      return s1 == s2 ? 0 : s1 > s2 ? 1 : -1;\n    })\n    .join(\"\");\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "191",
    "title": "整理扑克牌",
    "examType": "B",
    "score": 100,
    "description": "给定一组数字，表示扑克牌的牌面数字，忽略扑克牌的花色，请按如下规则对这一组扑克牌进行整理：\n步骤1. 对扑克牌进行分组，形成组合牌，规则如下：\n当牌面数字相同张数大于等于4时，组合牌为“炸弹”；3张相同牌面数字 + 2张相同牌面数字，且3张牌与2张牌不相同时，组合牌为“葫芦”；3张相同牌面数字，组合牌为“三张”；2张相同牌面数字，组合牌为“对子”；剩余没有相同的牌，则为“单张”；\n步骤2. 对上述组合牌进行由大到小排列，规则如下：\n不同类型组合牌之间由大到小排列规则：“炸弹” > “葫芦” > “三张” > “对子” > “单张”；相同类型组合牌之间，除“葫芦”外，按组合牌全部牌面数字加总由大到小排列；“葫芦”则先按3张相同牌面数字加总由大到小排列，3张相同牌面数字加总相同时，再按另外2张牌面数字加总由大到小排列；由于“葫芦”>“三张”，因此如果能形成更大的组合牌，也可以将“三张”拆分为2张和1张，其中的2张可以和其它“三张”重新组合成“葫芦”，剩下的1张为“单张”\n步骤3. 当存在多个可能组合方案时，按如下规则排序取最大的一个组合方案：\n依次对组合方案中的组合牌进行大小比较，规则同上；当组合方案A中的第n个组合牌大于组合方案B中的第n个组合牌时，组合方案A大于组合方案B；\n",
    "inputDesc": "第一行为空格分隔的N个正整数，每个整数取值范围[1,13]，N的取值范围[1,1000]\n",
    "outputDesc": "经重新排列后的扑克牌数字列表，每个数字以空格分隔\n\n我的解题思路如下：\n首先，将给定牌中，炸弹，三张，对子，单子先统计出来，即先不处理葫芦。\n统计逻辑很简单，就是看某个牌面的数量：\n统计完后，我们就可以先对炸弹进行排序，排序规则是：全部牌面数字加总由大到小排列\n接着可以组合葫芦了，组合逻辑如下：\n首先，需要先对三张、对子按照加总降序\n然后，选取一个最大的三张，并比较第二大的三张的牌面和第一大的对子的牌面\n按照上面规则组合葫芦，直到三张用完。\n注意上面逻辑是三张用完结束，而不是对子用完，因为还有一种情况就是对子先用完了，但是三张还有多个，此时我们要继续拆分小的三张来组合大三张为葫芦。\n组合完葫芦后。\n我们就可以对单张进行加总降序排序了，因为组合葫芦过程中，很可能产生新的单张。\n最后，依次将统计并排序后的炸弹、葫芦、三张、对子、单张，打印出来\n2023.03.24 补充说明\n在看了满分答案后，我发现当前我的代码实现和满分答案的区别仅仅在于炸弹排序有所不同，比如下面用例：\n5 5 5 5 4 4 4 4 4\n满分答案的输出是：4 4 4 4 4 5 5 5 5\n我的答案输出是：5 5 5 5 4 4 4 4 4\n\n对满分答案经过分析后，我发现造成这个差异的原因是，我对题目中“加总”的理解有偏差。\n比如，斗地主时，炸弹的张数越多，炸弹越大，因此五个4 在现实中就是要比 四个5 的炸弹大。\n但是本题中“加总”这个词比较有迷惑性，我理解是 = 牌面值 * 牌数量，即炸弹的所有牌之和，因此我的逻辑中 五个4 和 四个5 的炸弹是一样大的。\n而满分答案的对“加总”的理解和现实生活中一致，就是炸弹的牌数越多，就越大。\n\n因此，本题代码修正非常容易，就是将炸弹的排序规则修改一下，先按照炸弹牌的牌数量降序，如果牌数量一致，则再按照牌面大小降序。\n比如下面代码中：\nJS的第49行\nJava的第58行\nPython的第37行\n\n那么其他类型牌，比如葫芦，三张，对子，单张，的排序逻辑是否需要变动呢？\n答案是不需要，因为这些类型牌中的牌数量都是固定的，比如葫芦就是3+2，三张就是3，对子就是2，单张就是1。因此这些同类型牌之间的对比就是牌面值得对比。可以沿用之前得逻辑。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String str = sc.nextLine();\n    Integer[] arr = Arrays.stream(str.split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    System.out.println(getResult(arr));\n  }\n\n  public static String getResult(Integer[] arr) {\n    HashMap<Integer, Integer> card = new HashMap<>();\n\n    // 统计各种牌面的数量\n    for (Integer num : arr) {\n      if (card.containsKey(num)) {\n        int val = card.get(num);\n        card.put(num, ++val);\n      } else {\n        card.put(num, 1);\n      }\n    }\n\n    // 统计组合，4代表炸弹，3+2代表葫芦，3代表三张，2代表对子，1代表单张\n    HashMap<String, LinkedList<Integer[]>> combine = new HashMap<>();\n    combine.put(\"4\", new LinkedList<Integer[]>());\n    combine.put(\"3+2\", new LinkedList<Integer[]>());\n    combine.put(\"3\", new LinkedList<Integer[]>());\n    combine.put(\"2\", new LinkedList<Integer[]>());\n    combine.put(\"1\", new LinkedList<Integer[]>());\n\n    // 首先将初始组合统计出来\n    Set<Integer> cardKeys = card.keySet();\n    for (Integer num : cardKeys) {\n      switch (card.get(num)) {\n        case 3:\n          combine.get(\"3\").add(new Integer[] {num});\n          break;\n        case 2:\n          combine.get(\"2\").add(new Integer[] {num});\n          break;\n        case 1:\n          combine.get(\"1\").add(new Integer[] {num});\n          break;\n        default:\n          combine\n              .get(\"4\")\n              .add(\n                  new Integer[] {\n                    num, card.get(num)\n                  }); // 由于炸弹可能有4张以上相同牌面组成，因此既需要统计牌面num，也需要统计牌数card[num]\n      }\n    }\n\n    // 炸弹排序\n    combine.get(\"4\").sort((a, b) -> !Objects.equals(a[1], b[1]) ? b[1] - a[1] : b[0] - a[0]);\n\n    // 三张排序，牌面值越大，三张越大\n    combine.get(\"3\").sort((a, b) -> b[0] - a[0]);\n\n    // 对子排序，牌面值越大，对子越大\n    combine.get(\"2\").sort((a, b) -> b[0] - a[0]);\n\n    // 尝试组合出葫芦\n    while (combine.get(\"3\").size() > 0) {\n      // 如果对子用完，三张还有一个，那么可以直接结束循环\n      if (combine.get(\"2\").size() == 0 && combine.get(\"3\").size() == 1) break;\n\n      // 否则，选取一个最大的三张\n      Integer san_top = combine.get(\"3\").removeFirst()[0];\n\n      Integer tmp;\n      // 如果此时没有对子了，胡总和第二大的三张的牌面，比最大的对子牌面大，则可以拆分三张，组合出葫芦\n      if (combine.get(\"2\").size() == 0\n          || (combine.get(\"3\").size() > 0\n              && combine.get(\"3\").get(0)[0] > combine.get(\"2\").get(0)[0])) {\n        tmp = combine.get(\"3\").removeFirst()[0];\n        // 拆分三张为对子的话，会多出一个单张\n        combine.get(\"1\").add(new Integer[] {tmp});\n      } else {\n        // 如果对子牌面比三张大，则不需要拆分三张，直接使用对子组合出葫芦\n        tmp = combine.get(\"2\").removeFirst()[0];\n      }\n      combine.get(\"3+2\").add(new Integer[] {san_top, tmp}); // 葫芦元素含义：[三张牌面，对子牌面]\n    }\n\n    // 处理完葫芦后，就可以对单张进行降序了（因为组合葫芦的过程中，可能产生新的单张，因此单张排序要在葫芦组合得到后进行）\n    combine.get(\"1\").sort((a, b) -> b[0] - a[0]);\n\n    // ans存放题解\n    ArrayList<Integer> ans = new ArrayList<>();\n\n    // 首先将炸弹放到ans中\n    for (Integer[] vals : combine.get(\"4\")) {\n      int score = vals[0];\n      int count = vals[1];\n      for (int i = 0; i < count; i++) {\n        ans.add(score);\n      }\n    }\n\n    // 然后将葫芦放大ans中\n    for (Integer[] vals : combine.get(\"3+2\")) {\n      int san = vals[0];\n      int er = vals[1];\n      for (int i = 0; i < 3; i++) ans.add(san);\n      for (int i = 0; i < 2; i++) ans.add(er);\n    }\n\n    // 之后将三张放到ans中\n    for (Integer[] vals : combine.get(\"3\")) {\n      for (int i = 0; i < 3; i++) ans.add(vals[0]);\n    }\n\n    // 接着是对子放到ans中\n    for (Integer[] vals : combine.get(\"2\")) {\n      for (int i = 0; i < 2; i++) ans.add(vals[0]);\n    }\n\n    // 最后是单张放到ans中\n    for (Integer[] vals : combine.get(\"1\")) {\n      ans.add(vals[0]);\n    }\n\n    StringJoiner sj = new StringJoiner(\" \");\n    for (Integer an : ans) {\n      sj.add(an + \"\");\n    }\n\n    return sj.toString();\n  }\n}",
      "python": "# 输入获取\narr = input().split()\n\n\n# 算法入口\ndef getResult(arr):\n    # card统计各种牌面的数量\n    card = {}\n    for num in arr:\n        if card.get(num) is None:\n            card[num] = 1\n        else:\n            card[num] += 1\n\n    # combine统计组合，4代表炸弹，3+2代表葫芦，3代表三张，2代表对子，1代表单张\n    combine = {\n        \"4\": [],\n        \"3+2\": [],\n        \"3\": [],\n        \"2\": [],\n        \"1\": []\n    }\n\n    # 首先将初始组合统计出来\n    for num in card.keys():\n        if card[num] == 3:\n            combine[\"3\"].append(int(num))\n        elif card[num] == 2:\n            combine[\"2\"].append(int(num))\n        elif card[num] == 1:\n            combine[\"1\"].append(int(num))\n        else:\n            # 由于炸弹可能有4张以上相同牌面组成，因此既需要统计牌面num，也需要统计牌数card[num]\n            combine[\"4\"].append([int(num), card[num]])\n\n    # 炸弹排序\n    combine[\"4\"].sort(key=lambda x: (-x[1], -x[0]))\n\n    # 三张排序，牌面值越大，三张越大\n    combine[\"3\"].sort(reverse=True)\n\n    # 对子降序，牌面值越大，对子越大\n    combine[\"2\"].sort(reverse=True)\n\n    # 尝试组合出葫芦\n    while len(combine[\"3\"]) > 0:\n        # 如果对子用完，三张还有一个，那么可以直接结束循环\n        if len(combine[\"2\"]) == 0 and len(combine[\"3\"]) == 1:\n            break\n\n        # 选取一个最大的三张\n        san_top = combine[\"3\"].pop(0)\n\n        tmp = None\n\n        #  如果第二大的三张的牌面，比最大的对子牌面大，或者没有对子了，则可以拆分三张，组合出葫芦\n        if len(combine[\"2\"]) == 0 or (len(combine[\"3\"]) >= 1 and combine[\"3\"][0] > combine[\"2\"][0]):\n            tmp = combine[\"3\"].pop(0)\n            # 拆分三张为对子的话，会多出一个单张\n            combine[\"1\"].append(tmp)\n        else:\n            # 如果对子牌面比三张大，则不需要拆分三张，直接使用对子组合出葫芦\n            tmp = combine[\"2\"].pop(0)\n\n        combine[\"3+2\"].append([san_top, tmp])  # 葫芦元素含义：[三张牌面，对子牌面]\n\n    # 处理完葫芦后，就可以对单张进行降序了（因为组合葫芦的过程中，可能产生新的单张，因此单张排序要在葫芦组合得到后进行）\n    combine[\"1\"].sort(reverse=True)\n\n    # ans存放题解\n    ans = []\n\n    # 首先将炸弹放到ans中\n    for score, count in combine[\"4\"]:\n        ans += [score] * count\n\n    # 然后将葫芦放大ans中\n    for san, er in combine[\"3+2\"]:\n        ans += [san] * 3 + [er] * 2\n\n    # 之后将三张放到ans中\n    for san in combine[\"3\"]:\n        ans += [san] * 3\n\n    # 接着是对子放到ans中\n    for er in combine[\"2\"]:\n        ans += [er] * 2\n\n    # 最后是单张放到ans中\n    for dan in combine[\"1\"]:\n        ans += [dan]\n\n    return \" \".join(map(str, ans))\n\n\n# 算法调用\nprint(getResult(arr))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const arr = line.split(\" \").map(Number);\n  console.log(getResult(arr));\n});\n\nfunction getResult(arr) {\n  const card = {};\n\n  // 统计各种牌面的数量\n  for (let num of arr) {\n    card[num] ? card[num]++ : (card[num] = 1);\n  }\n\n  // 统计组合，4代表炸弹，3+2代表葫芦，3代表三张，2代表对子，1代表单张\n  const combine = {\n    4: [],\n    \"3+2\": [],\n    3: [],\n    2: [],\n    1: [],\n  };\n\n  // 首先将初始组合统计出来\n  for (let num in card) {\n    switch (card[num]) {\n      case 3:\n        combine[3].push(num - 0);\n        break;\n      case 2:\n        combine[2].push(num - 0);\n        break;\n      case 1:\n        combine[1].push(num - 0);\n        break;\n      default:\n        combine[4].push([num - 0, card[num]]); // 由于炸弹可能有4张以上相同牌面组成，因此既需要统计牌面num，也需要统计牌数card[num]\n    }\n  }\n\n  // 炸弹排序\n  combine[4].sort((a, b) => (a[1] != b[1] ? b[1] - a[1] : b[0] - a[0]));\n\n  // 三张排序，牌面值越大，三张越大\n  combine[3].sort((a, b) => b - a);\n\n  // 对子降序，牌面值越大，对子越大\n  combine[2].sort((a, b) => b - a);\n\n  // 尝试组合出葫芦\n  while (combine[3].length) {\n    // 如果对子用完，三张还有一个，那么可以直接结束循环\n    if (combine[2].length === 0 && combine[3].length === 1) break;\n\n    // 选取一个最大的三张\n    const san_top = combine[3].shift();\n\n    let tmp;\n    // 如果第二大的三张的牌面，比最大的对子牌面大，或者没有对子了，则可以拆分三张，组合出葫芦\n    if (\n      combine[2].length === 0 ||\n      (combine[3].length >= 1 && combine[3][0] > combine[2][0])\n    ) {\n      tmp = combine[3].shift();\n      // 拆分三张为对子的话，会多出一个单张\n      combine[1].push(tmp);\n    } else {\n      // 如果对子牌面比三张大，则不需要拆分三张，直接使用对子组合出葫芦\n      tmp = combine[2].shift();\n    }\n    combine[\"3+2\"].push([san_top, tmp]); // 葫芦元素含义：[三张牌面，对子牌面]\n  }\n\n  // 处理完葫芦后，就可以对单张进行降序了（因为组合葫芦的过程中，可能产生新的单张，因此单张排序要在葫芦组合得到后进行）\n  combine[1].sort((a, b) => b - a);\n\n  // ans存放题解\n  const ans = [];\n\n  // 首先将炸弹放到ans中\n  for (let card of combine[4]) {\n    const [score, count] = card;\n    ans.push(...new Array(count).fill(score));\n  }\n\n  // 然后将葫芦放大ans中\n  for (let card of combine[\"3+2\"]) {\n    const [san, er] = card;\n    ans.push(...new Array(3).fill(san), ...new Array(2).fill(er));\n  }\n\n  // 之后将三张放到ans中\n  for (let san of combine[3]) {\n    ans.push(...new Array(3).fill(san));\n  }\n\n  // 接着是对子放到ans中\n  for (let er of combine[2]) {\n    ans.push(...new Array(2).fill(er));\n  }\n\n  // 最后是单张放到ans中\n  ans.push(...combine[1]);\n\n  return ans.join(\" \");\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "192",
    "title": "最大数字",
    "examType": "B",
    "score": 100,
    "description": "给定一个由纯数字组成以字符串表示的数值，现要求字符串中的每个数字最多只能出现2次，超过的需要进行删除；\n删除某个重复的数字后，其它数字相对位置保持不变。\n如”34533″，数字3重复超过2次，需要删除其中一个3，删除第一个3后获得最大数值”4533″\n请返回经过删除操作后的最大的数值，以字符串表示。\n",
    "inputDesc": "第一行为一个纯数字组成的字符串，长度范围：[1,100000]\n",
    "outputDesc": "输出经过删除操作后的最大的数值\n\n本题最优解题思路是利用栈结构。\n\n首先，我们需要定义两个map，分别是unused和reserve，其中：\n然后对他们进行初始化，初始时unused就是统计输入字符串中各数字字符的出现次数，而reserve每个数字字符的个数都初始化为0。\n\n接下来，遍历出输入字符串的每个字符c：\n如果此时stack栈顶没有元素，则将遍历的c直接压入栈，然后unused[c]--，reserve[c]++\n如果此时stack栈顶有元素，假设为top，则：\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String str = sc.next();\n\n    System.out.println(getResult(str));\n  }\n\n  public static String getResult(String str) {\n    // 每个数字字符的可用个数\n    HashMap<Character, Integer> unused = new HashMap<>();\n    // 每个数字字符的保留个数\n    HashMap<Character, Integer> reserve = new HashMap<>();\n\n    // 初始时，每个数字有多少个，就可用多少个，由于还未使用，因此保留个数为0\n    for (int i = 0; i < str.length(); i++) {\n      char c = str.charAt(i);\n      unused.put(c, unused.getOrDefault(c, 0) + 1);\n      reserve.putIfAbsent(c, 0);\n    }\n\n    // 定义一个栈\n    LinkedList<Character> stack = new LinkedList<>();\n\n    // 遍历输入字符串的每个数字字符c\n    for (int i = 0; i < str.length(); i++) {\n      char c = str.charAt(i);\n\n      // 如果该字符已经保留了2个了，则后续再出现该数字字符可以不保留\n      if (reserve.get(c) == 2) {\n        // 则可用c数字个数--\n        unused.put(c, unused.get(c) - 1);\n        continue;\n      }\n\n      // 比较当前数字c和栈顶数字top，如果c>top，那么需要考虑将栈顶数字弹出\n      while (stack.size() > 0) {\n        char top = stack.getLast();\n\n        // 如果栈顶数字被弹出后，已保留的top字符数量和未使用的top字符数量之和大于等于2，则可以弹出，否则不可以\n        if (top < c && unused.get(top) + reserve.get(top) - 1 >= 2) {\n          stack.removeLast();\n          reserve.put(top, reserve.get(top) - 1);\n        } else {\n          break;\n        }\n      }\n\n      // 选择保留当前遍历的数字c\n      stack.add(c);\n      // 则可用c数字个数--\n      unused.put(c, unused.get(c) - 1);\n      // 已保留c数字个数++\n      reserve.put(c, reserve.get(c) + 1);\n    }\n\n    StringBuilder sb = new StringBuilder();\n    for (Character c : stack) {\n      sb.append(c);\n    }\n    return sb.toString();\n  }\n}",
      "python": "# 输入获取\ns = input()\n\n\n# 算法入口\ndef getResult(s):\n    # 每个数字字符的可用个数\n    unused = {}\n    # 每个数字字符的保留个数\n    reserve = {}\n\n    # 初始时，每个数字有多少个，就可用多少个，由于还未使用，因此保留个数为0\n    for c in s:\n        if unused.get(c) is None:\n            unused[c] = 0\n\n        if reserve.get(c) is None:\n            reserve[c] = 0\n\n        unused[c] += 1\n\n    # 定义一个栈\n    stack = []\n\n    # 遍历输入字符串的每个数字字符c\n    for c in s:\n        # 如果该字符已经保留了2个了，则后续再出现该数字字符可以不保留\n        if reserve[c] == 2:\n            # 则可用c数字个数--\n            unused[c] -= 1\n            continue\n\n        # 比较当前数字c和栈顶数字top，如果c>top，那么需要考虑将栈顶数字弹出\n        while len(stack) > 0:\n            top = stack[-1]\n\n            # 如果栈顶数字被弹出后，已保留的top字符数量和未使用的top字符数量之和大于等于2，则可以弹出，否则不可以\n            if top < c and unused[top] + reserve[top] - 1 >= 2:\n                stack.pop()\n                reserve[top] -= 1\n            else:\n                break\n\n        # 选择保留当前遍历的数字c\n        stack.append(c)\n        # 则可用c数字个数--\n        unused[c] -= 1\n        # 已保留c数字个数++\n        reserve[c] += 1\n\n    return \"\".join(stack)\n\n\n# 算法调用\nprint(getResult(s))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  console.log(getResult(line));\n});\n\nfunction getResult(str) {\n  // 每个数字字符的可用个数\n  const unused = {};\n  // 每个数字字符的保留个数\n  const reserve = {};\n\n  // 初始时，每个数字有多少个，就可用多少个，由于还未使用，因此保留个数为0\n  for (let c of str) {\n    unused[c] ? unused[c]++ : (unused[c] = 1);\n    reserve[c] = 0;\n  }\n\n  // 定义一个栈\n  const stack = [];\n\n  // 遍历输入字符串的每个数字字符c\n  for (let c of str) {\n    // 如果该字符已经保留了2个了，则后续再出现该数字字符可以不保留\n    if (reserve[c] == 2) {\n      // 则可用c数字个数--\n      unused[c]--;\n      continue;\n    }\n\n    // 比较当前数字c和栈顶数字top，如果c>top，那么需要考虑将栈顶数字弹出\n    while (stack.length) {\n      const top = stack.at(-1);\n\n      // 如果栈顶数字被弹出后，已保留的top字符数量和未使用的top字符数量之和大于等于2，则可以弹出，否则不可以\n      if (top < c && unused[top] + reserve[top] - 1 >= 2) {\n        stack.pop();\n        reserve[top]--;\n      } else {\n        break;\n      }\n    }\n\n    // 选择保留当前遍历的数字c\n    stack.push(c);\n    // 则可用c数字个数--\n    unused[c]--;\n    // 已保留c数字个数++\n    reserve[c]++;\n  }\n\n  return stack.join(\"\");\n}\n;",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "193",
    "title": "最小调整顺序次数、特异性双端队列",
    "examType": "B",
    "score": 100,
    "description": "有一个特异性的双端队列，该队列可以从头部或尾部添加数据，但是只能从头部移出数据。\n小A依次执行2n个指令往队列中添加数据和移出数据。其中n个指令是添加数据（可能从头部添加、也可能从尾部添加），依次添加1到n；n个指令是移出数据。\n现在要求移除数据的顺序为1到n。\n为了满足最后输出的要求，小A可以在任何时候调整队列中数据的顺序。\n\n请问 小A 最少需要调整几次才能够满足移除数据的顺序正好是1到n；\n",
    "inputDesc": "第一行一个数据n，表示数据的范围。\n接下来的2n行，其中有n行为添加数据，指令为：\n\"head add x\" 表示从头部添加数据 x，\"tail add x\" 表示从尾部添加数据x，\n另外 n 行为移出数据指令，指令为：\"remove\" 的形式，表示移出1个数据；\n1 ≤ n ≤ 3 * 10^5。\n所有的数据均合法。\n",
    "outputDesc": "一个整数，表示 小A 要调整的最小次数。\n\n\n本题重在题目意思理解，本题最后要求：最小的调整顺序次数。而不是最小的交换次数。因此本题的难度大大降低了。\n比如用例：\n因此，只需要在第7步调整一次顺序。\n\n本题不需要模拟出一个队列，因为那样需要频繁的验证队列元素顺序，以及调整顺序，非常不划算。\n我们可以总结规律：\n如果队列为空，即size===0，此时无论head add，还是tail add，都不会破坏队列顺序性。\n如果队列不为空，即size!==0，此时tail add不会破坏顺序性，head add会破坏顺序性。\n我们定义一个变量isSorted表示队列是否有序，初始时isSorted = true，表示初始时队列有序。当有序性被破坏，即isSorted = false。\n\nhead add和tail add会导致size++，remove会导致size--。\n我们定义一个count变量来记录调整顺序的次数，初始为0。\n当remove时，如果isSorted为false，则我们需要调整顺序，即count++，并更新isSorted = true。\n当head add时，如果size为0，则不破坏顺序性，isSorted为true，如果size不为0，则会破坏顺序性，即isSorted=false。另外size++。\n当tail add时，仅size++。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = Integer.parseInt(sc.nextLine());\n    int m = n * 2;\n\n    String[] cmds = new String[m];\n    for (int i = 0; i < m; i++) {\n      cmds[i] = sc.nextLine();\n    }\n\n    System.out.println(getResult(cmds));\n  }\n\n  public static int getResult(String[] cmds) {\n    int size = 0;\n    boolean isSorted = true;\n    int count = 0;\n\n    for (int i = 0; i < cmds.length; i++) {\n      String cmd = cmds[i];\n      if (cmd.startsWith(\"head add\")) {\n        if (size > 0 && isSorted) isSorted = false;\n        size++;\n      } else if (cmd.startsWith(\"tail add\")) {\n        size++;\n      } else {\n        if (size == 0) continue;\n        if (!isSorted) {\n          count++;\n          isSorted = true;\n        }\n        size--;\n      }\n    }\n\n    return count;\n  }\n}",
      "python": "# 输入获取\nn = int(input())\ncmds = [input() for i in range(2 * n)]\n\n\n# 算法入口\ndef getResult(cmds):\n    size = 0\n    isSorted = True\n    count = 0\n\n    for cmd in cmds:\n        if cmd.startswith(\"head add\"):\n            if size > 0 and isSorted:\n                isSorted = False\n            size += 1\n        elif cmd.startswith(\"tail add\"):\n            size += 1\n        else:\n            if size <= 0:\n                continue\n\n            if not isSorted:\n                count += 1\n                isSorted = True\n\n            size -= 1\n\n    return count\n\n\n# 算法调用\nprint(getResult(cmds))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = parseInt(lines[0]);\n  }\n\n  if (n && lines.length === 1 + 2 * n) {\n    lines.shift();\n    console.log(getResult(lines));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(cmds) {\n  let size = 0;\n  let isSorted = true;\n  let count = 0;\n\n  for (let i = 0; i < cmds.length; i++) {\n    const cmd = cmds[i];\n    if (cmd.startsWith(\"head add\")) {\n      if (size && isSorted) isSorted = false;\n      size++;\n    } else if (cmd.startsWith(\"tail add\")) {\n      size++;\n    } else {\n      if (!size) continue;\n      if (!isSorted) {\n        count++;\n        isSorted = true;\n      }\n      size--;\n    }\n  }\n\n  return count;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "194",
    "title": "查找单入口空闲区域",
    "examType": "B",
    "score": 100,
    "description": "给定一个 m x n 的矩阵，由若干字符 ‘X’ 和 ‘O’构成，’X’表示该处已被占据，’O’表示该处空闲，请找到最大的单入口空闲区域。\n解释：\n空闲区域是由连通的’O’组成的区域，位于边界的’O’可以构成入口，\n单入口空闲区域即有且只有一个位于边界的’O’作为入口的由连通的’O’组成的区域。 如果两个元素在水平或垂直方向相邻，则称它们是“连通”的。\n",
    "inputDesc": "第一行输入为两个数字，第一个数字为行数m，第二个数字为列数n，两个数字以空格分隔，1<=m,n<=200。\n剩余各行为矩阵各行元素，元素为‘X’或‘O’，各元素间以空格分隔。\n",
    "outputDesc": "若有唯一符合要求的最大单入口空闲区域，输出三个数字\n三个数字以空格分隔；\n若有多个符合要求，则输出区域大小最大的，若多个符合要求的单入口区域的区域大小相同，则此时只需要输出区域大小，不需要输出入口坐标。\n若没有，输出NULL。\n\n本题可以使用深度优先搜索来解题。\n首先，我们可以遍历矩阵元素，当遍历到“O”时，已该“O”的坐标位置开始向其上、下、左、右方向开始深度优先搜索，每搜索到一个“O”，则该空闲区域数量+1，如果搜索到的“O”的坐标位置处于矩阵第一列，或最后一列，或者第一行，或者最后一行，那么该“O”位置就是空闲区域的入口位置，我们将其缓存到out数组中。\n当所有深度优先搜索的分支都搜索完了，则判断out统计的入口数量，\n另外，我们还需要定义一个check集合来缓存，已经被递归过的\"O\"位置，避免重复的深度优先搜索。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    static int n;\n    static int m;\n    static String[][] matrix;\n    static int[][] offset = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n    static HashSet<String> checked = new HashSet<>();\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n\n        matrix = new String[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                matrix[i][j] = sc.next();\n            }\n        }\n\n        System.out.println(getResult(matrix, n, m));\n    }\n\n    public static String getResult(String[][] matrix, int n, int m) {\n        ArrayList<Integer[]> ans = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (\"O\".equals(matrix[i][j]) && !checked.contains(i + \"-\" + j)) {\n                    ArrayList<Integer[]> enter = new ArrayList<>();\n                    int count = dfs(i, j, 0, enter);\n                    if (enter.size() == 1) {\n                        Integer[] pos = enter.get(0);\n                        Integer[] an = {pos[0], pos[1], count};\n                        ans.add(an);\n                    }\n                }\n            }\n        }\n\n        if (ans.size() == 0) return \"NULL\";\n        ans.sort((a, b) -> b[2] - a[2]);\n\n        if (ans.size() == 1 || ans.get(0)[2] > ans.get(1)[2]) {\n            StringJoiner sj = new StringJoiner(\" \", \"\", \"\");\n            for (Integer ele : ans.get(0)) {\n                sj.add(ele + \"\");\n            }\n            return sj.toString();\n        } else {\n            return ans.get(0)[2] + \"\";\n        }\n\n    }\n\n    public static int dfs(int i, int j, int count, ArrayList<Integer[]> enter) {\n        String pos = i + \"-\" + j;\n\n        if (i < 0 || i >= n || j < 0 || j >= m || \"X\".equals(matrix[i][j]) || checked.contains(pos)) {\n            return count;\n        }\n\n        checked.add(pos);\n\n        if (i == 0 || i == n - 1 || j == 0 || j == m - 1) enter.add(new Integer[]{i, j});\n\n        count++;\n\n        for (int k = 0; k < offset.length; k++) {\n            int offsetX = offset[k][0];\n            int offsetY = offset[k][1];\n\n            int newI = i + offsetX;\n            int newJ = j + offsetY;\n            count = dfs(newI, newJ, count, enter);\n        }\n\n        return count;\n    }\n}",
      "python": "# 输入获取\nm, n = map(int, input().split())\nmatrix = [input().split() for i in range(m)]\n\n\n# 算法入口\ndef getResult(matrix, m, n):\n    checked = set()\n\n    offsets = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\n    def dfs(i, j, count, out):\n        pos = f\"{i}-{j}\"\n\n        if i < 0 or i >= m or j < 0 or j >= n or matrix[i][j] == \"X\" or pos in checked:\n            return count\n\n        checked.add(pos)\n\n        if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n            out.append([i, j])\n\n        count += 1\n\n        for offsetX, offsetY in offsets:\n            newI = i + offsetX\n            newJ = j + offsetY\n            count = dfs(newI, newJ, count, out)\n\n        return count\n\n    ans = []\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == \"O\" and f\"{i}-{j}\" not in checked:\n                out = []\n                count = dfs(i, j, 0, out)\n                if len(out) == 1:\n                    tmp = out[0][:]\n                    tmp.append(count)\n                    ans.append(tmp)\n\n    if len(ans) == 0:\n        return \"NULL\"\n\n    ans.sort(key=lambda x: -x[2])\n\n    if len(ans) == 1 or ans[0][2] > ans[1][2]:\n        return \" \".join(map(str, ans[0]))\n    else:\n        return ans[0][2]\n\n\n# 算法调用\nprint(getResult(matrix, m, n))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n, m;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [n, m] = lines[0].split(\" \").map(Number);\n  }\n\n  if (n && lines.length === n + 1) {\n    lines.shift();\n    const matrix = lines.map((line) => line.split(\" \"));\n    console.log(getResult(matrix, n, m));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(matrix, n, m) {\n  const checked = new Set();\n\n  const offset = [\n    [0, -1],\n    [0, 1],\n    [-1, 0],\n    [1, 0],\n  ];\n\n  function dfs(i, j, count, out) {\n    const pos = `${i}-${j}`;\n\n    if (\n      i < 0 ||\n      i >= n ||\n      j < 0 ||\n      j >= m ||\n      matrix[i][j] === \"X\" ||\n      checked.has(pos)\n    )\n      return count;\n\n    checked.add(pos);\n\n    if (i === 0 || i === n - 1 || j === 0 || j === m - 1) out.push([i, j]);\n\n    count++;\n\n    for (let k = 0; k < offset.length; k++) {\n      const [offsetX, offsetY] = offset[k];\n      const newI = i + offsetX;\n      const newJ = j + offsetY;\n      count = dfs(newI, newJ, count, out);\n    }\n\n    return count;\n  }\n\n  const ans = [];\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (matrix[i][j] === \"O\" && !checked.has(`${i}-${j}`)) {\n        const out = [];\n        const count = dfs(i, j, 0, out);\n        if (out.length === 1) {\n          ans.push([...out[0], count]);\n        }\n      }\n    }\n  }\n\n  if (!ans.length) return \"NULL\";\n\n  ans.sort((a, b) => b[2] - a[2]);\n\n  if (ans.length === 1 || ans[0][2] > ans[1][2]) {\n    return ans[0].join(\" \");\n  } else {\n    return ans[0][2];\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "195",
    "title": "流水线",
    "examType": "B",
    "score": 100,
    "description": "一个工厂有m条流水线，来并行完成n个独立的作业，该工厂设置了一个调度系统，在安排作业时，总是优先执行处理时间最短的作业。\n现给定流水线个数m，需要完成的作业数n, 每个作业的处理时间分别为t1,t2…tn。请你编程计算处理完所有作业的耗时为多少？\n当n>m时，首先处理时间短的m个作业进入流水线，其他的等待，当某个作业完成时，依次从剩余作业中取处理时间最短的进入处理。\n",
    "inputDesc": "第一行为2个整数（采用空格分隔），分别表示流水线个数m和作业数n；\n第二行输入n个整数（采用空格分隔），表示每个作业的处理时长t1,t2…tn。\n0< m,n<100，0<t1,t2…tn<100。\n注：保证输入都是合法的。\n",
    "outputDesc": "输出处理完所有作业的总时长。\n\n3 5 8 4 3 2 10\n1、先安排时间为2、3、4的3个作业。\n2、第一条流水线先完成作业，然后调度剩余时间最短的作业8。\n3、第二条流水线完成作业，然后调度剩余时间最短的作业10。\n4、总工耗时就是第二条流水线完成作业的时间13（3+10）。\n\n简单的逻辑题。解题思路如下：\n题目说“总是优先执行处理时间最短的作业”，因此我们可以将8 4 3 2 10 进行升序排序变为2 3 4 8 10，然后依次将排序后元素投入对应流水线中，如下图所示\n\n计算每条流水线的时间总和，最大的个就是题解。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n\n    int[] times = new int[n];\n    for (int i = 0; i < n; i++) times[i] = sc.nextInt();\n\n    System.out.println(getResult(m, n, times));\n  }\n\n  public static int getResult(int m, int n, int[] times) {\n    Arrays.sort(times);\n\n    int[] mArr = new int[m];\n    for (int i = 0; i < n; i++) {\n      mArr[i % m] += times[i];\n    }\n\n    return Arrays.stream(mArr).max().orElse(0);\n  }\n}",
      "python": "# 输入获取\nm, n = map(int, input().split())\ntimes = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult():\n    times.sort()\n\n    mArr = [0]*m\n\n    for i in range(len(times)):\n        mArr[i % m] += times[i]\n\n    return max(mArr)\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "196",
    "title": "游戏分组",
    "examType": "B",
    "score": 100,
    "description": "部门准备举办一场王者荣耀表演赛，有 10 名游戏爱好者参与，分为两队，每队 5 人。\n每位参与者都有一个评分，代表着他的游戏水平。为了表演赛尽可能精彩，我们需要把 10 名参赛者分为示例尽量相近的两队。\n一队的实力可以表示为这一队 5 名队员的评分总和。\n现在给你 10 名参与者的游戏水平评分，请你根据上述要求分队，最后输出这两组的实力差绝对值。\n例：10 名参赛者的评分分别为：5 1 8 3 4 6 7 10 9 2，分组为（1 3 5 8 10）和（2 4 6 7 9），两组实力差最小，差值为1。有多种分法，但是实力差的绝对值最小为1。\n",
    "inputDesc": "10个整数，表示10名参与者的游戏水平评分。范围在 [1, 10000] 之间。\n",
    "outputDesc": "1个整数，表示分组后两组实力差绝对值的最小值。\n\n\n本题和华为OD机试 - 篮球比赛（Java & JS & Python & C）-CSDN博客\n类似。具体解析请参考上面博客。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n \npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n \n    int[] arr = new int[10];\n    for (int i = 0; i < 10; i++) {\n      arr[i] = sc.nextInt();\n    }\n \n    System.out.println(getResult(arr));\n  }\n \n  public static int getResult(int[] arr) {\n    Arrays.sort(arr);\n \n    ArrayList<Integer> res = new ArrayList<>();\n    // dfs求10选5的去重组合，并将组合之和记录进res中，即res中记录的是所有可能性的5人小队实力值之和\n    dfs(arr, 0, 0, 0, res);\n \n    int sum = Arrays.stream(arr).reduce(Integer::sum).orElse(0);\n    // 某队实力为subSum，则另一队实力为sum - subSum，则两队实力差为 abs((sum - subSum) - subSum)，先求最小实力差\n    return res.stream().map(subSum -> Math.abs(sum - 2 * subSum)).min((a, b) -> a - b).orElse(0);\n  }\n \n  // 求解去重组合\n  public static void dfs(int[] arr, int index, int level, int sum, ArrayList<Integer> res) {\n    if (level == 5) {\n      res.add(sum);\n      return;\n    }\n \n    for (int i = index; i < 10; i++) {\n      if (i > index && arr[i] == arr[i - 1]) continue; // arr已经升序，这里进行树层去重\n      dfs(arr, i + 1, level + 1, sum + arr[i], res);\n    }\n  }\n}",
      "python": "# 输入获取\narr = list(map(int, input().split()))\n \n \n# 求解去重组合\ndef dfs(arr, index, level, sumV, res):\n    if level == 5:\n        res.append(sumV)\n        return\n \n    for i in range(index, 10):\n        if i > index and arr[i] == arr[i - 1]: # arr已经升序，这里进行树层去重\n            continue\n        dfs(arr, i + 1, level + 1, sumV + arr[i], res)\n \n \n# 算法入口\ndef getResult(arr):\n    arr.sort()\n \n    res = []\n    # dfs求10选5的去重组合，并将组合之和记录进res中，即res中记录的是所有可能性的5人小队实力值之和\n    dfs(arr, 0, 0, 0, res)\n \n    sumV = sum(arr)\n    #  某队实力为subSum，则另一队实力为sum - subSum，则两队实力差为 abs((sum - subSum) - subSum)，先求最小实力差\n    return min(map(lambda subSum: abs(sumV - 2 * subSum), res))\n \n \n# 算法调用\nprint(getResult(arr))",
      "javascript": "const rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid (async function () {\n  const arr = (await readline()).split(\" \").map(Number);\n\n  arr.sort((a, b) => a - b);\n\n  const res = [];\n  // dfs求10选5的去重组合，并将组合之和记录进res中，即res中记录的是所有可能性的5人小队实力值之和\n  dfs(arr, 0, 0, 0, res);\n\n  const sum = arr.reduce((p, c) => p + c);\n\n  // 某队实力为subSum，则另一队实力为sum - subSum，则两队实力差为 abs((sum - subSum) - subSum)，先求最小实力差\n  const ans = res\n    .map((subSum) => Math.abs(sum - 2 * subSum))\n    .sort((a, b) => a - b)[0];\n\n  console.log(ans);\n})();\n\n// 求解去重组合\nfunction dfs(arr, index, level, sum, res) {\n  if (level === 5) {\n    return res.push(sum);\n  }\n\n  for (let i = index; i < 10; i++) {\n    if (i > index && arr[i] == arr[i - 1]) continue; // arr已经升序，这里进行树层去重\n    dfs(arr, i + 1, level + 1, sum + arr[i], res);\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "197",
    "title": "精准核酸检测",
    "examType": "B",
    "score": 100,
    "description": "为了达到新冠疫情精准防控的需要，为了避免全员核酸检测带来的浪费，需要精准圈定可能被感染的人群。\n现在根据传染病流调以及大数据分析，得到了每个人之间在时间、空间上是否存在轨迹交叉。\n现在给定一组确诊人员编号（X1,X2,X3,...,Xn），在所有人当中，找出哪些人需要进行核酸检测，输出需要进行核酸检测的人数。（注意：确诊病例自身不需要再做核酸检测）\n需要进行核酸检测的人，是病毒传播链条上的所有人员，即有可能通过确诊病例所能传播到的所有人。\n例如：A是确诊病例，A和B有接触、B和C有接触、C和D有接触、D和E有接触，那么B\\C\\D\\E都是需要进行核酸检测的人。\n",
    "inputDesc": "第一行为总人数 N\n第二行为确认病例人员编号（确诊病例人员数量 < N），用逗号分割\n第三行开始，为一个 N * N 的矩阵，表示每个人员之间是否有接触，0表示没有接触，1表示有接触。\n",
    "outputDesc": "整数：需要做核酸检测的人数\n\n\n编号为1、2号的人员，为确诊病例。\n1号和0号有接触，0号和3号有接触。\n2号和4号有接触。\n所以，需要做核酸检测的人是0号、3号、4号，总计3人需要进行核酸检测。\n\n本题可以用并查集解题。关于并查集的实现可以看：\n华为校招机试 - 发广播（20210310）_华为机试 发广播 伏城之外-CSDN博客\n\n即将有接触的人进行合并操作，纳入到同一个连通分量中。比如matrix[i]][j] == 1，即 i 和 j 就处于同一个连通分量中，需要进行合并。\n另外，本题的接触关系矩阵matrix是沿对角线对称的，因此只需要遍历对角线一边即可。\n当遍历完所有接触关系后，就可以求解每一个连通分量中的节点数，即每个接触群体的人数，求解原理如下：\n并查集底层的fa数组，fa数组索引代表每个节点，fa数组元素代表对应索引的节点的根节点，而同一个连通分量中的节点的根都是相同的，因此，我们需要对fa每一个数组索引找一下根，这里可以使用并查集的find操作（递归实现），最后统计同一个根下的节点数量，即为同一个接触群体的人数。\n\n当每个接触群体人数求解出来后，我们只需要统计”确诊病例人员编号“对应的根（连通分量）下的人数即可。\n最后的统计的总人数需要减去确诊病例的数量，因为题目说：\n确诊病例自身不需要再做核酸检测\n\n本题需要注意的是，有可能多个确诊病人在同一个连通分量重，此时需要注意避免重复统计。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = Integer.parseInt(sc.nextLine());\n\n    int[] confirmed = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n\n    int[][] matrix = new int[n][n];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n    }\n\n    System.out.println(getResult(n, confirmed, matrix));\n  }\n\n  public static int getResult(int n, int[] confirmed, int[][] matrix) {\n    UnionFindSet ufs = new UnionFindSet(n);\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i; j < n; j++) {\n        if (matrix[i][j] == 1) {\n          // 有过接触的人进行合并\n          ufs.union(i, j);\n        }\n      }\n    }\n\n    // 统计每个接触群体（连通分量）中的人数\n    int[] cnts = new int[n];\n    for (int i = 0; i < n; i++) {\n      int fa = ufs.find(i);\n      cnts[fa]++;\n    }\n\n    // 记录已统计过的感染群体\n    HashSet<Integer> confirmed_fa = new HashSet<>();\n\n    // 将有感染者的接触群体的人数统计出来\n    int ans = 0;\n    for (int i : confirmed) {\n      int fa = ufs.find(i);\n\n      // 如果该感染群体已统计过，则不再统计\n      if (confirmed_fa.contains(fa)) continue;\n      confirmed_fa.add(fa);\n\n      ans += cnts[fa];\n    }\n\n    // 最终需要做核酸的人数，不包括已感染的人\n    return ans - confirmed.length;\n  }\n}\n\n// 并查集实现\nclass UnionFindSet {\n  int[] fa;\n\n  public UnionFindSet(int n) {\n    this.fa = new int[n];\n    for (int i = 0; i < n; i++) fa[i] = i;\n  }\n\n  public int find(int x) {\n    if (x != this.fa[x]) {\n      this.fa[x] = this.find(this.fa[x]);\n      return this.fa[x];\n    }\n    return x;\n  }\n\n  public void union(int x, int y) {\n    int x_fa = this.find(x);\n    int y_fa = this.find(y);\n\n    if (x_fa != y_fa) {\n      this.fa[y_fa] = x_fa;\n    }\n  }\n}",
      "python": "# 并查集实现\nclass UnionFindSet:\n    def __init__(self, n):\n        self.fa = [i for i in range(n)]\n\n    def find(self, x):\n        if x != self.fa[x]:\n            self.fa[x] = self.find(self.fa[x])\n            return self.fa[x]\n        return x\n\n    def union(self, x, y):\n        x_fa = self.find(x)\n        y_fa = self.find(y)\n\n        if x_fa != y_fa:\n            self.fa[y_fa] = x_fa\n\n\n# 输入获取\nn = int(input())\nconfirmed = list(map(int, input().split(\",\")))\nmatrix = [list(map(int, input().split(\",\"))) for _ in range(n)]\n\n\n# 算法入口\ndef getResult():\n    ufs = UnionFindSet(n)\n\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[i][j] == 1:\n                # 有过接触的人进行合并\n                ufs.union(i, j)\n\n    # 统计每个接触群体（连通分量）中的人数\n    cnts = [0] * n\n    for i in range(n):\n        fa = ufs.find(i)\n        cnts[fa] += 1\n\n    # 记录已统计过的可能感染群体\n    confirmed_fa = set()\n\n    # 将有感染者的接触群体的人数统计出来\n    ans = 0\n    for i in confirmed:\n        fa = ufs.find(i)\n\n        # 已统计过的可能感染群体不再统计\n        if fa in confirmed_fa:\n            continue\n        confirmed_fa.add(fa)\n\n        ans += cnts[fa]\n\n    # 最终需要做核酸的人数，不包括已感染的人\n    return ans - len(confirmed)\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "198",
    "title": "统计射击比赛成绩",
    "examType": "B",
    "score": 100,
    "description": "给定一个射击比赛成绩单，包含多个选手若干次射击的成绩分数，请对每个选手按其最高3个分数之和进行降序排名，输出降序排名后的选手ID序列。\n\n一个选手可以有多个射击成绩的分数，且次序不固定。如果一个选手成绩少于3个，则认为选手的所有成绩无效，排名忽略该选手。如果选手的成绩之和相等，则成绩之和相等的选手按照其ID降序排列。",
    "inputDesc": "输入第一行，一个整数N，表示该场比赛总共进行了N次射击，产生N个成绩分数（2<=N<=100）。输入第二行，一个长度为N整数序列，表示参与每次射击的选手ID（0<=ID<=99）。输入第三行，一个长度为N整数序列，表示参与每次射击的选手对应的成绩（0<=成绩<=100）。\n",
    "outputDesc": "符合题设条件的降序排名后的选手ID序列。\n\n13 3,3,7,4,4,4,4,7,7,3,5,5,5 53,80,68,24,39,76,66,16,100,55,53,80,55\n该场射击比赛进行了13次\n参赛的选手为3,4,5,7\n比较各个选手最高3个成绩的和，有3号=5号>7号>4号，由于3号和5号成绩相等且ID号5>3， 所以输出为：5,3,7,4\n\n简答的排序问题，按照题目要求写排序规则即可。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = Integer.parseInt(sc.nextLine());\n\n    Integer[] ids =\n        Arrays.stream(sc.nextLine().split(\",\")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    Integer[] scores =\n        Arrays.stream(sc.nextLine().split(\",\")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    System.out.println(getResult(n, ids, scores));\n  }\n\n  public static String getResult(int n, Integer[] ids, Integer[] scores) {\n    HashMap<Integer, ArrayList<Integer>> players = new HashMap<>();\n\n    for (int i = 0; i < n; i++) {\n      players.putIfAbsent(ids[i], new ArrayList<>());\n      players.get(ids[i]).add(scores[i]);\n    }\n\n    ArrayList<int[]> ans = new ArrayList<>();\n\n    for (int id : players.keySet()) {\n      ArrayList<Integer> idScores = players.get(id);\n      if (idScores.size() >= 3) {\n        int total =\n            idScores.stream().sorted((a, b) -> b - a).limit(3).reduce(Integer::sum).orElse(0);\n\n        ans.add(new int[] {id, total});\n      }\n    }\n\n    ans.sort((a, b) -> a[1] != b[1] ? b[1] - a[1] : b[0] - a[0]);\n\n    StringJoiner sj = new StringJoiner(\",\");\n    for (int[] player : ans) sj.add(player[0] + \"\");\n\n    return sj.toString();\n  }\n}",
      "python": "# 输入获取\nn = int(input())\nids = list(map(int, input().split(\",\")))\nscores = list(map(int, input().split(\",\")))\n\n\n# 算法入口\ndef getResult():\n    players = {}\n\n    for i in range(n):\n        players.setdefault(ids[i], [])\n        players.get(ids[i]).append(scores[i])\n\n    ans = []\n\n    for pid in players:\n        if len(players[pid]) >= 3:\n            players[pid].sort(reverse=True)\n            ans.append((pid, sum(players[pid][:3])))\n\n    ans.sort(key=lambda x: (-x[1], -x[0]))\n\n    return \",\".join(map(lambda x: str(x[0]), ans))\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "203",
    "title": "G网络建设",
    "examType": "B",
    "score": 200,
    "description": "现需要在某城市进行5G网络建设，已经选取N个地点设置5G基站，编号固定为1到N，接下来需要各个基站之间使用光纤进行连接以确保基站能互联互通，不同基站之间假设光纤的成本各不相同，且有些节点之间已经存在光纤相连。\n请你设计算法，计算出能联通这些基站的最小成本是多少。\n注意：基站的联通具有传递性，比如基站A与基站B架设了光纤，基站B与基站C也架设了光纤，则基站A与基站C视为可以互相联通。\n",
    "inputDesc": "第一行输入表示基站的个数N，其中：\n0 < N ≤ 20\n第二行输入表示具备光纤直连条件的基站对的数目M，其中：\n0 < M < N * (N - 1) / 2\n从第三行开始连续输入M行数据，格式为\nX Y Z P\n其中：\nX，Y 表示基站的编号\n0 < X ≤ N0 < Y ≤ NX ≠ Y\nZ 表示在 X、Y之间架设光纤的成本\n0 < Z < 100\nP 表示是否已存在光纤连接，0 表示未连接，1表示已连接\n",
    "outputDesc": "如果给定条件，可以建设成功互联互通的5G网络，则输出最小的建设成本\n如果给定条件，无法建设成功互联互通的5G网络，则输出 -1\n\n\n（下图中，虚线代表节点之间可以铺设光纤，但是还没有铺设，实线表示已经铺好了）\n用例1图示\n\n\n用例2图示\n\n用例3图示\n\n\n本题是经典的最小生成树问题\n\n而在了解最小生成树概念前，我们需要先了解生成树的概念：\n在无向连通图中，生成树是指包含了全部顶点的极小连通子图。\n生成树包含原图全部的n个顶点和n-1条边。（注意，边的数量一定是n-1）\n比如下面无向连通图例子：\n\n根据生成树概念，我们可以基于上面无向连通图，产生多个生成树，下面举几个生成树例子：\n\n\n如上图我们用n-1条橙色边连接了n个顶点。这样就从无向连通图中产生了生成树。\n为什么生成树只能由n-1条边呢？\n因为少一条边，则生成树就无法包含所有顶点。多一条边，则生成树就会形成环。\n而生成树最重要的两个特性就是：\n1、包含所有顶点\n2、无环\n\n了解了生成树概念后，我们就可以进一步学习最小生成树了。\n我们回头看看无向连通图，可以发现每条边都有权重值，比如v1-v2权重值是6，v3-v6权重值是4。\n最小生成树指的是，生成树中n-1条边的权重值之和最小。\n\n那么如何才能准确的找出一个无向连通图的最小生成树呢？\n有两种算法：Prim算法和Kruskal算法。\nPrim算法是基于顶点找最小生成树。Kruskal是基于边找最小生成树。\n\n首先，我们介绍Prim算法：\n我们可以选择无向连通图中的任意一个顶点作为起始点，比如我们选v1顶点为起始点\n\n从v1顶点出发，有三条边，我们选择权重最小的1，即将v1-v3相连\n\n此时我们需要将v1-v3看成一个整体，然后继续找这个整体出发的所有边里面的最小的，\n\n可以发现为最小权重为4，因此，将v3-v6相连\n\n接着将v1-v3-v6看出一个整体，找这个整体出发的所有边里面的最小的，可以找到最小权重2，因此将v6-v4相连\n\n但是接下来，我们会发现，从v1-v3-v6-v4整体出发的所有边里面同时有三个最小权重5，那么该如何选择呢？\n\n其实不难看出，如果选择v4-v3，或者v4-v1相连，则对应的生成树就形成了环结构，因此就不符合生成树特性了，因此我们只能选择v3-v2。\n（注意：如果有多个相同的最小权重边可选，并且都不会产生环结构，则可以选择其中任意一条边，最终得到结果都是最小生成树）\n其实，不仅仅在上面遇到相同权重边时，需要判断是否形成环，在前选择每一条边时都需要判断是否形成环，一旦选择的边能够形成环，那么我们就应该舍弃它，选择第二小的权重边，并继续判断。\n\n按照上面逻辑，我们可以继续找到v1-v2-v3-v4-v6整体出发所有边中的最小权重边3，即将v2-v5相连，并且连接后不会形成环\n\n此时选择的边数已经达到了n-1条，因此可以结束逻辑，而现在得到的就是最小生成树。我们可以将这个最小生成数的所有边的权重值之和计算出来为15。\n上面这种基于顶点的找最小生成树的方式就是Prim算法。\n关于Prim算法具体实现细节请看代码实现，已添加详细注释。\n\n接下来介绍Kruskal算法：\nKruskal算法要求我们将所有的边按照权重值升序排序，因此可得：\n\n首先，我们将权重最小的边v1-v3加入，得到下图\n\n接着将下个最小权重2的边v4-v6加入\n\n接着继续加最小权重边\n\n\n\n此时边数已经达到n-1，而刚好这个过程中也没有环的形成，因此得到的就是最小生成树。\n但是这里有巧合因素在里面，因为最后一步中，最小权重5的边有多条，如果并不是v2-v3排在前面呢，比如是v1-v4呢？\n\n可以发现，形成了环，因此我们应该舍弃这条边，继续找剩下的最小权重边。最后总能找到v2-v3。\n\n那么判断环的存在就是实现上面Prim算法和Kruskal算法的关键点！\n其实，生成树就是一个连通分量，初始时，生成树这个连通分量只有一个顶点（Prim），或者两个顶点（Kruskal），后面会不断合入新的顶点进来，来扩大连通分量范围。\n而连通分量可以使用并查集表示，\n并查集本质就是一个长度为n的数组（n为无向图的顶点数），数组索引值代表图中某个顶点child，数组索引指向的元素值，代表child顶点的祖先顶点father。\n初始时，每个child的father都是自己。即初始时，默认有n个连通分量。\n比如 arr = [1,1,1,5,5,5] 数组就可以模拟出一个无向图\n\n\n我们可以用father指代一个连通分量。比如上面arr = [1,1,1,5,5,5]就有两个连通分量，分别是father为1的连通分量和father为5的连通分量。\n最小生成树中的顶点必然都处于同一个连通分量中，因此每加入一个新的顶点child_new，我们我们就可以看它的father是否已经是连通分量对应的father，如果是，则说明顶点child_new其实已经存在于最小生成树中了，因此就产生了环，比如下面例子：\n​\n上面右图绿色部分（对应连通图中橙色实线），则arr变为\n​\n上面右图黄色部分（对应连通图中黑色实线），即v4顶点的father改成v1，但是实际上v4的father已经是v1，那么此时如果再强行加入的话，那么就形成了环。\n\nPrim算法是基于节点操作的，因此Prim算法适用于节点少，边多的情况\nKruskal算法是基于边操作的，因此Kruskal算法适用于节点多，边少的情况。\n\n本题属于最小生成树的变种题，区别于板子题，本题中主要是存在一些已经关联好的节点。\n比如下面连通图中，2-3是已经连通好的。\n\n其实处理起来也很简单，对于已经关联了的节点，我们可以认为他们之间的边权为0。\n即上图中，2-3虽然边权为5，但是由于已经关联好了，因此可以认为实际边权为0。\n这样的话，本题就变成最小生成树的板子题了。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt(); // 基站数量（节点数）\n    int m = sc.nextInt(); // 基站对数量（边数）\n\n    // 邻接矩阵\n    int[][] graph = new int[n + 1][n + 1];\n    for (int i = 1; i <= n; i++) {\n      for (int j = 1; j <= n; j++) {\n        // 初始化默认各点之间互不联通，即i-j边权无限大\n        graph[i][j] = Integer.MAX_VALUE;\n      }\n    }\n\n    for (int i = 0; i < m; i++) {\n      int x = sc.nextInt();\n      int y = sc.nextInt();\n      int z = sc.nextInt();\n      int p = sc.nextInt();\n\n      if (p == 0) {\n        // x-y边权为z\n        graph[x][y] = z;\n        graph[y][x] = z;\n      } else {\n        // 对应已经联通的两点，可以理解为边权为0\n        graph[x][y] = 0;\n        graph[y][x] = 0;\n      }\n    }\n\n    System.out.println(prim(graph, n));\n  }\n\n  public static int prim(int[][] graph, int n) {\n    // 记录最小生成树的边权和\n    int minWeight = 0;\n\n    // inTree[i] 表示 节点i 是否在最小生成树中\n    boolean[] inTree = new boolean[n + 1];\n\n    // 初始时任选一个节点作为最小生成树的初始节点，这里选择节点1\n    inTree[1] = true;\n    // 记录最小生成树中点数量\n    int inTree_count = 1;\n\n    // dis[i]表示 节点i 到最小生成树集合 的最短距离\n    int[] dis = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      // 初始时，最小生成树集合中只有节点1，因此其他节点到最小生成树的距离，其实就是到节点1的距离\n      dis[i] = graph[1][i];\n    }\n\n    // 如果最小生成树中点数量达到n个，则结束循环\n    while (inTree_count < n) {\n      // 现在我们需要从未纳入最小生成树的点中，找到一个距离最小生成树最近的\n\n      // minDis 记录这个最近距离\n      int minDis = Integer.MAX_VALUE;\n      // idx 记录距离最小生成树minDis个距离的节点\n      int nodeIdx = 0;\n\n      for (int i = 1; i <= n; i++) {\n        // 从未纳入最小生成树的点中，找到一个距离最小生成树最近的\n        if (!inTree[i] && dis[i] < minDis) {\n          minDis = dis[i];\n          nodeIdx = i;\n        }\n      }\n\n      // 如果nodeIdx == 0,则说明未纳入最小生成树的这些点到最小生成树的距离都是Integer.MAX_VALUE，即不与最小生成树存在关联\n      if (nodeIdx == 0) {\n        // 则说明，当前所有点无法形成最小生成树\n        return -1;\n      }\n\n      inTree[nodeIdx] = true; // 最小生成树需要纳入最短距离点nodeIdx\n      inTree_count++; // 最小生成树中点数量+1\n      minWeight += dis[nodeIdx]; // 更新最小生成树的权重和\n\n      // dis[i] 初始时记录的是节点i 到 节点1 的距离（初始的生成树中只有节点1）\n      // 现在生成树纳入了新节点nodeIdx，则我们需要更新一下dis[i]，即有可能某些点到最小生成树中的nodeIdx点距离更近\n      for (int i = 1; i <= n; i++) {\n        if (!inTree[i] && graph[nodeIdx][i] < dis[i]) {\n          // 注意，这是一个累进过程，初始时dis[i]记录的是节点i到节点1的距离，\n          // 之后，最小生成树纳入新点后，如果节点i到新点的距离更近，则dis[i]就更新为这个更短距离\n          // 总之，dis[i] 记录的是 节点 i 到最小生成树的最短距离\n          dis[i] = graph[nodeIdx][i];\n        }\n      }\n    }\n\n    return minWeight;\n  }\n}",
      "python": "import sys\n\n# 输入获取\nn = int(input())  # 基站数量（节点数）\nm = int(input())  # 基站对数量（边数）\n\n# 邻接矩阵, 初始化默认各点之间互不联通，即i-j边权无限大\ngraph = [[sys.maxsize for _ in range(n + 1)] for _ in range(n + 1)]\n\nfor _ in range(m):\n    x, y, z, p = map(int, input().split())\n\n    if p == 0:\n        # x-y边权为z\n        graph[x][y] = z\n        graph[y][x] = z\n    else:\n        # 对应已经联通的两点，可以理解为边权为0\n        graph[x][y] = 0\n        graph[y][x] = 0\n\n\n# Prim算法\ndef prim():\n    # 记录最小生成树的边权和\n    minWeight = 0\n\n    # inTree[i] 表示 节点i 是否在最小生成树中\n    inTree = [False] * (n + 1)\n\n    # 初始时任选一个节点作为最小生成树的初始节点，这里选择节点1\n    inTree[1] = True\n    # 记录最小生成树中点数量\n    inTree_count = 1\n\n    # dis[i]表示 节点i 到最小生成树集合 的最短距离\n    # 初始时，最小生成树集合中只有节点1，因此其他节点到最小生成树的距离，其实就是到节点1的距离\n    dis = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dis[i] = graph[1][i]\n\n    # 如果最小生成树中点数量达到n个，则结束循环\n    while inTree_count < n:\n        # 现在我们需要从未纳入最小生成树的点中，找到一个距离最小生成树最近的\n        minDis = sys.maxsize  # minDis 记录这个最近距离\n        nodeIdx = 0  # idx 记录距离最小生成树minDis个距离的节点\n\n        for i in range(1, n+1):\n            # 从未纳入最小生成树的点中，找到一个距离最小生成树最近的\n            if not inTree[i] and dis[i] < minDis:\n                minDis = dis[i]\n                nodeIdx = i\n\n        # 如果nodeIdx == 0,则说明未纳入最小生成树的这些点到最小生成树的距离都是Integer.MAX_VALUE，即不与最小生成树存在关联\n        if nodeIdx == 0:\n            # 则说明，当前所有点无法形成最小生成树\n            return -1\n\n        inTree[nodeIdx] = True  # 最小生成树需要纳入最短距离点nodeIdx\n        inTree_count += 1  # 最小生成树中点数量+1\n        minWeight += dis[nodeIdx]  # 更新最小生成树的权重和\n\n        # dis[i] 初始时记录的是节点i 到 节点1 的距离（初始的生成树中只有节点1）\n        # 现在生成树纳入了新节点nodeIdx，则我们需要更新一下dis[i]，即有可能某些点到最小生成树中的nodeIdx点距离更近\n        for i in range(1, n+1):\n            if not inTree[i] and graph[nodeIdx][i] < dis[i]:\n                # 注意，这是一个累进过程，初始时dis[i]记录的是节点i到节点1的距离，\n                # 之后，最小生成树纳入新点后，如果节点i到新点的距离更近，则dis[i]就更新为这个更短距离\n                # 总之，dis[i] 记录的是 节点 i 到最小生成树的最短距离\n                dis[i] = graph[nodeIdx][i]\n\n    return minWeight\n\n\n# 算法调用\nprint(prim())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "204",
    "title": "Excel单元格数值统计",
    "examType": "B",
    "score": 200,
    "description": "Excel工作表中对选定区域的数值进行统计的功能非常实用。\n仿照Excel的这个功能，请对给定表格中选中区域中的单元格进行求和统计，并输出统计结果。\n为简化计算，假设当前输入中每个单元格内容仅为数字或公式两种。\n如果为数字，则是一个非负整数，形如3、77\n如果为公式，则固定以=开头，且仅包含下面三种情况：\n等于某单元格的值，例如=B12两个单元格的双目运算（仅为+或-），形如=C1-C2、C3+B2单元格和数字的双目运算（仅为+或-），形如=B1+1、100-B2\n注意：\n公式内容都是合法的，例如不存在，=C+1、=C1-C2+B3,=5、=3+5不存在循环引用，例如A1=B1+C1、C1=A1+B2内容中不存在空格、括号\n",
    "inputDesc": "第一行两个整数rows cols，表示给定表格区域的行数和列数，1<=rows<=20，1<=cols<=26。 接下来rows行，每行cols个以空格分隔的字符串，表示给定表格values的单元格内容。 最后一行输入的字符串，表示给定的选中区域，形如A1:C2。\n",
    "outputDesc": "一个整数，表示给定选中区域各单元格中数字的累加总和，范围-2,147,483,648 ~ 2,147,483,647\n\n\n\n\n本题逻辑不难，但是实现起来比较麻烦。\n我的解题思路如下：\n首先，要搞清楚Excel表格坐标和matrix输入矩阵的索引的对应关系，比如上面用例中，输入的matrix矩阵为：[ [\"1\", \"=A1+C1\", \"3\"] ]\n其中“1”值，对应矩阵 martix[0][0]，而对应的Excel表格坐标是A1，其中A代表列号，1代表行号。\n因此，我们容易得到Excel表格坐标和matrix输入矩阵的索引的对应关系：\n\n解下来，我们需要弄清楚，如何将Excel坐标，如A1，B2，C3中的列号和行号解析出来，因为只有解析出来，才能方便处理，之后才能对应到matrix的索引。\n这里我们使用了正则表达式的捕获组，正则为：/^(A-Z)(\\d+)$/\n\n\n接下来，我们就可以实现根据Excel坐标，获取到matrix矩阵元素的逻辑了，我们定义一个方法getCell，入参Excel坐标，然后通过上面的正则解析出来对应列号、行号，然后再根据Excel列号、行号转化求得matrix矩阵的行索引、列索引，进而求得matrix矩阵对应索引的值。\n\n此时，取得的值有两类：\n1、非公式的值，比如1\n2、公式，以=开头\n\n对于非公式的值，直接将其转为数值后返回；\n对于公式，又分为三种情况：\n我们可以通过getCell方法获取到Excel坐标对应的值，然后再来运算\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Scanner;\n\npublic class Main {\n  static String[][] table; // 给定表格区域\n  static int rows; // 给定表格区域的行数\n  static int cols; // 给定表格区域的列数\n  static String start; // 选中区域的左上角位置\n  static String end; // 选中区域的右下角位置\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    rows = sc.nextInt();\n    cols = sc.nextInt();\n\n    table = new String[rows][cols];\n    for (int i = 0; i < rows; i++) {\n      for (int j = 0; j < cols; j++) {\n        table[i][j] = sc.next();\n      }\n    }\n\n    String[] range = sc.next().split(\":\");\n    start = range[0];\n    end = range[1];\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    int[] s = getPos(start);\n    int[] e = getPos(end);\n\n    int r1 = s[0], c1 = s[1];\n    int r2 = e[0], c2 = e[1];\n\n    int ans = 0;\n    for (int i = r1; i <= r2; i++) {\n      for (int j = c1; j <= c2; j++) {\n        ans += getCellVal(table[i][j]);\n      }\n    }\n\n    return ans;\n  }\n\n  // 获取单元格的值\n  public static int getCellVal(String cell) {\n    /*\n     * 单元格内容cell如果以'='开头，则必然是公式\n     * */\n    if (cell.charAt(0) == '=') {\n      // fn是公式内容\n      String fn = cell.substring(1);\n\n      // 如果公式内容fn包含“+”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n      if (fn.contains(\"+\")) {\n        return operate(fn.split(\"\\\\+\"), true);\n      }\n      // 如果公式内容fn包含“-”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n      else if (fn.contains(\"-\")) {\n        return operate(fn.split(\"-\"), false);\n      }\n      // 如果公式内容fn不包含“+”和“-”，则必然等于某单元格的值，例如=B12\n      else {\n        return getPosVal(getPos(fn));\n      }\n    }\n    /*\n     * 单元格内容cell如果不以'='开头，则必然是数字，且是非负正数\n     * */\n    else {\n      return Integer.parseInt(cell);\n    }\n  }\n\n  // 双目运算\n  public static int operate(String[] ops, boolean isAdd) {\n    int op1, op2;\n\n    if (isPos(ops[0])) {\n      // 如果操作数1是单元格\n      op1 = getPosVal(getPos(ops[0]));\n    } else {\n      // 如果操作数1是数字\n      op1 = Integer.parseInt(ops[0]);\n    }\n\n    if (isPos(ops[1])) {\n      // 如果操作数2是单元格\n      op2 = getPosVal(getPos(ops[1]));\n    } else {\n      // 如果操作数2是数字\n      op2 = Integer.parseInt(ops[1]);\n    }\n\n    if (isAdd) {\n      // 加法运算\n      return op1 + op2;\n    } else {\n      // 减法运算\n      return op1 - op2;\n    }\n  }\n\n  // 解析单元格坐标  为  矩阵坐标\n  public static int[] getPos(String pos) {\n    int c = pos.charAt(0) - 65;\n    int r = Integer.parseInt(pos.substring(1)) - 1;\n    return new int[] {r, c};\n  }\n\n  // 获取矩阵对应坐标的值，并且更新矩阵对应单元格的内容\n  public static int getPosVal(int[] pos) {\n    int r = pos[0], c = pos[1];\n    int val = getCellVal(table[r][c]);\n    table[r][c] = val + \"\";\n    return val;\n  }\n\n  // 判断一个内容是否为单元格坐标\n  public static boolean isPos(String str) {\n    char c = str.charAt(0);\n    return c <= 'Z' && c >= 'A';\n  }\n}",
      "python": "# 输入获取\nrows, cols = list(map(int, input().split()))\ntable = [input().split() for _ in range(rows)]\nstart, end = input().split(\":\")\n\n\n# 判断一个内容是否为单元格坐标\ndef isPos(pos):\n    return \"Z\" >= pos[0] >= 'A'\n\n\n# 解析单元格坐标  为  矩阵坐标\ndef getPos(pos):\n    c = ord(pos[0]) - 65\n    r = int(pos[1:]) - 1\n    return r, c\n\n\n# 获取矩阵对应坐标的值，并且更新矩阵对应单元格的内容\ndef getPosVal(pos):\n    r, c = pos\n    table[r][c] = getCellVal(table[r][c])\n    return table[r][c]\n\n\n# 双目运算\ndef operate(ops, isAdd):\n    op1 = 0\n    op2 = 0\n\n    if isPos(ops[0]):\n        # 如果操作数1是单元格\n        op1 = getPosVal(getPos(ops[0]))\n    else:\n        # 如果操作数1是数字\n        op1 = int(ops[0])\n\n    if isPos(ops[1]):\n        op2 = getPosVal(getPos(ops[1]))\n    else:\n        op2 = int(ops[1])\n\n    if isAdd:\n        return op1 + op2\n    else:\n        return op1 - op2\n\n\n# 获取单元格的值\ndef getCellVal(cell):\n    cell = str(cell)\n    # 单元格内容cell如果以'='开头，则必然是公式\n    if cell[0] == \"=\":\n        # fn是公式内容\n        fn = cell[1:]\n\n        # 如果公式内容fn包含“+”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n        if fn.find(\"+\") != -1:\n            return operate(fn.split(\"+\"), True)\n        # 如果公式内容fn包含“-”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n        elif fn.find(\"-\") != -1:\n            return operate(fn.split(\"-\"), False)\n        # 如果公式内容fn不包含“+”和“-”，则必然等于某单元格的值，例如=B12\n        else:\n            return getPosVal(getPos(fn))\n    # 单元格内容cell如果不以'='开头，则必然是数字，且是非负正数\n    else:\n        return int(cell)\n\n\n# 算法入口\ndef getResult():\n    r1, c1 = getPos(start)\n    r2, c2 = getPos(end)\n\n    ans = 0\n    for i in range(r1, r2 + 1):\n        for j in range(c1, c2 + 1):\n            ans += getCellVal(table[i][j])\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst { get } = require(\"http\");\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\n\nlet table, rows, cols, start, end;\n\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [rows, cols] = lines[0].split(\" \").map(Number);\n  }\n\n  if (rows && lines.length === rows + 2) {\n    lines.shift();\n    [start, end] = lines.pop().split(\":\");\n    table = lines.map((line) => line.split(\" \"));\n    console.log(getResult());\n    lines.length = 0;\n  }\n});\n\nfunction getResult() {\n  const [r1, c1] = getPos(start);\n  const [r2, c2] = getPos(end);\n\n  let ans = 0;\n  for (let i = r1; i <= r2; i++) {\n    for (let j = c1; j <= c2; j++) {\n      ans += getCellVal(table[i][j]);\n    }\n  }\n\n  return ans;\n}\n\n// 判断一个内容是否为单元格坐标\nfunction isPos(s) {\n  return s[0] <= \"Z\" && s[0] >= \"A\";\n}\n\n// 解析单元格坐标  为  矩阵坐标\nfunction getPos(pos) {\n  const c = pos[0].charCodeAt() - 65;\n  const r = pos.slice(1) - 1;\n  return [r, c];\n}\n\n// 获取矩阵对应坐标的值，并且更新矩阵对应单元格的内容\nfunction getPosVal(pos) {\n  const [r, c] = pos;\n  table[r][c] = getCellVal(table[r][c]);\n  return table[r][c];\n}\n\n// 双目运算\nfunction operate(ops, isAdd) {\n  let op1, op2;\n\n  if (isPos(ops[0])) {\n    // 如果操作数1是单元格\n    op1 = getPosVal(getPos(ops[0]));\n  } else {\n    // 如果操作数1是数字\n    op1 = parseInt(ops[0]);\n  }\n\n  if (isPos(ops[1])) {\n    // 如果操作数2是单元格\n    op2 = getPosVal(getPos(ops[1]));\n  } else {\n    // 如果操作数2是数字\n    op2 = parseInt(ops[1]);\n  }\n\n  if (isAdd) {\n    // 加法运算\n    return op1 + op2;\n  } else {\n    // 减法运算\n    return op1 - op2;\n  }\n}\n\n// 获取单元格的值\nfunction getCellVal(cell) {\n  /*\n   * 单元格内容cell如果以'='开头，则必然是公式\n   * */\n  if (cell[0] == \"=\") {\n    // fn是公式内容\n    const fn = cell.slice(1);\n\n    // 如果公式内容fn包含“+”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n    if (fn.indexOf(\"+\") != -1) {\n      return operate(fn.split(\"+\"), true);\n    } else if (fn.indexOf(\"-\") != -1) {\n      // 如果公式内容fn包含“-”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n      return operate(fn.split(\"-\"), false);\n    } else {\n      // 如果公式内容fn不包含“+”和“-”，则必然等于某单元格的值，例如=B12\n      return getPosVal(getPos(fn));\n    }\n  } else {\n    /*\n     * 单元格内容cell如果不以'='开头，则必然是数字，且是非负正数\n     * */\n    return parseInt(cell);\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "205",
    "title": "二维伞的雨滴效应",
    "examType": "B",
    "score": 200,
    "description": "普通的伞在二维平面世界中，左右两侧均有一条边，而两侧伞边最下面各有一个伞坠子，雨滴落到伞面，逐步流到伞坠处，会将伞坠的信息携带并落到地面，随着日积月累，地面会呈现伞坠的信息。\n1、为了模拟伞状雨滴效应，用二叉树来模拟二维平面伞（如下图所示），现在输入一串正整数数组序列（不含0，数组成员至少是1个），若此数组序列是二叉搜索树的前序遍历的结果，那么请输出一个返回值1，否则输出0。\n2、同时请将此序列构成的伞状效应携带到地面的数字信息输出来(左边伞坠信息，右边伞坠信息，详细参考示例图地面上数字)，若此树不存在左或右扇坠，则对应位置返回0。同时若非二叉排序树那么左右伞坠信息也返回0。\n\n\n",
    "inputDesc": "一个通过空格分割的整数序列字符串，数组不含0，数组成员至少1个，输入的数组的任意两个数字都互不相同，最多1000个正整数，正整数值范围1~65535\n",
    "outputDesc": "输出如下三个值，以空格分隔：是否二叉排序树，左侧地面呈现的伞坠数字值，右侧地面呈现的伞坠数字值。\n若是二叉排序树，则输出1，否则输出0（其左右伞坠值也直接赋值0）。\n若不存存在左侧或者右侧伞坠值，那么对应伞坠值直接赋值0。\n\n\n本题解题前需要先了解几个概念：\n\n什么是二叉搜索树？\n二叉搜索树，也叫二叉排序树，它具有如下特点：\n\n什么是前序遍历？\n二叉树的遍历方式有：前序遍历、中序遍历、后序遍历，这里的”前、中、后“指的是二叉树根节点的遍历顺序，\n下面举个例子帮助理解，\n\n上图二叉树的\n\n上图二叉树的\n\n知道上面概念后，我们再来看本题：\n给定一个二叉树的前序遍历的结果序列，判断该二叉树是否为二叉搜索树？\n我们知道前序遍历是：根左右，因此给定序列的第一个元素必然是根节点值。\n假设根节点对应的序列索引范围是[start, end]，那么根节点索引位置就是start。\n\n而二叉搜索树的特点是：\n因此，我们从start+1位置开始判断，如果satrt+1位置的元素值 < 根节点的元素值（start位置），那么start+1位置的元素就是根节点的左子树节点，按此逻辑，依次往后判断。\n假设在 i 位置，发现 i 位置的元素 ≮ 根节点的元素值（start位置），则当前根节点的左子树索引范围是[satrt + 1, i - 1]\n之后，我们从 i 位置开始判断，如果 i 位置的元素值 ＞ 根节点的元素值（start位置），那么 i 位置的元素就是 根节点的右子树节点，按此逻辑，依次完后判断。\n如果当前序列满足二叉搜索树前序遍历，那么最终，当前根节点的右子树索引范围必须是[i, end]，\n如果右子树索引范围的结束位置达不到end，则不合法。\n\n按照上面逻辑，我们可以得到根节点、根的左子树、根的右子树。\n之后，我们可以继续按上面逻辑递归的判断：根的左子树[satrt + 1, i - 1]、根的右子树[i, end]，他们对应索引范围的子序列，是否满足二叉搜索树前序遍历的特点（根节点的值 大于 其左子树的所有节点的值、根节点的值 小于 其右子树的所有节点的值）\n\n以上逻辑，是判断一个序列是否为二叉搜索树的前序遍历结果。但是本题还需要我们求解出：左边伞坠信息，右边伞坠信息\n这里思维上最简单的做法是，根据前面判断二叉搜索树前序遍历序列的逻辑，生成一颗二叉搜索树，还原出二叉搜索树后\n\n求解左边伞缀的逻辑：\n\n求解右边伞缀的逻辑和上面差不多，大家可以自行推导。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  // 二叉树的节点类定义\n  static class Node {\n    int val; // 节点值\n    Node left_child; // 当前节点的左子节点\n    Node right_child; // 当前节点的右子节点\n\n    public Node(int val) {\n      this.val = val;\n    }\n  }\n\n  // 二叉搜索树前序遍历的结果序列\n  static int[] preOrder;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    preOrder = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(getResult());\n  }\n\n  public static String getResult() {\n    // 二叉搜索树的根节点root\n    Node root = new Node(preOrder[0]);\n\n    if (isValid(root, 0, preOrder.length - 1)) {\n      return 1 + \" \" + getFarLeftBottomVal(root, 0) + \" \" + getFarRightBottomVal(root, 0);\n    } else {\n      return \"0 0 0\";\n    }\n  }\n\n  /**\n   * 判断preOrder数组是否为合法的二叉搜索树前序遍历结果序列，如果是，则根绝preOrder还原出对应二叉搜索树\n   *\n   * @param root 二叉搜索树的节点，每个二叉搜索树节点都对应preOrder序列中的一段子序列\n   * @param start 该子序列在preOrder中的范围的起始位置\n   * @param end 该子序列在preOrder中的范围的结束位置\n   * @return preOrder数组是否为合法的二叉搜索树前序遍历结果\n   */\n  public static boolean isValid(Node root, int start, int end) {\n    // 如果当前节点对应的序列范围长度为1，则当前节点为叶子节点，无法继续递归，需要结束递归，而单个节点本身就是前序遍历结果，因此返回true\n    if (start == end) return true;\n\n    // 前序遍历即：根左右，因此start位置是当前序列对应的子树的根节点位置，当前子树的左子子树从start+1位置开始判断\n    int i = start + 1;\n    // 二叉搜索树的特点是：当前节点的左子节点值 < 当前节点的值\n    while (i <= end && preOrder[i] < root.val) {\n      i++;\n    }\n\n    // i 最终指向左右子树的分界位置\n    int j = i;\n    // 二叉搜索树的特点是：当前节点的右子节点值 > 当前节点的值\n    while (j <= end && preOrder[j] > root.val) {\n      j++;\n    }\n\n    // j 最终指向右子树的终点位置的后一个位置，而右子树的终点位置必须在end，因此合法的二叉搜索树前序遍历结果 j > end\n    if (j <= end) return false;\n\n    // i 最终指向左右子树的分界位置\n    // 如果 i > start + 1，则存在左子树\n    if (i > start + 1) {\n      // 创建当前节点的左子树节点\n      root.left_child = new Node(preOrder[start + 1]);\n\n      // 递归判断左子树对应的序列范围是否为前序遍历结果\n      if (!isValid(root.left_child, start + 1, i - 1)) {\n        // 若不是，则preOrder无法还原出二叉搜索树\n        return false;\n      }\n    }\n\n    // i 最终指向左右子树的分界位置\n    // 如果 i <= end，则存在右子树\n    if (i <= end) {\n      // 创建当前节点的右子树节点\n      root.right_child = new Node(preOrder[i]);\n\n      // 如果右子树对应的序列是合法的前序遍历结果，结合前面左子树对应的序列也是合法的前序遍历结果，则preOrder整体就是合法的前序遍历结果\n      return isValid(root.right_child, i, end);\n    }\n\n    return true;\n  }\n\n  // 递归查找二叉树的左缀点，即二叉树最后一层中，最靠左的点\n  public static int getFarLeftBottomVal(Node root, int level) {\n    // 如果当前节点存在左子节点，则递归查找其左子节点\n    if (root.left_child != null) {\n      return getFarLeftBottomVal(root.left_child, level + 1);\n    }\n\n    // 如果当前节点没有左子节点，则检查当前节点处于哪一层\n    if (level > 0) {\n      if (root.right_child != null) {\n        // 如果当前节点不处于第0层，且存在右子节点，则递归查找其右子节点\n        return getFarLeftBottomVal(root.right_child, level + 1);\n      } else {\n        // 如果当前节点不处于第0层，且不存在右子节点，则当前节点即为左缀点\n        return root.val;\n      }\n    } else {\n      // 如果当前节点处于第0层，且没有左子节点，则没有左缀点，按题目要求返回0\n      return 0;\n    }\n  }\n\n  // 递归查找二叉树的右缀点，即二叉树最后一层中，最靠右的点\n  public static int getFarRightBottomVal(Node root, int level) {\n    if (root.right_child != null) {\n      return getFarRightBottomVal(root.right_child, level + 1);\n    }\n\n    if (level > 0) {\n      if (root.left_child != null) {\n        return getFarRightBottomVal(root.left_child, level + 1);\n      } else {\n        return root.val;\n      }\n    } else {\n      return 0;\n    }\n  }\n}",
      "python": "# 输入获取\npreOrder = list(map(int, input().split()))  # 二叉搜索树前序遍历的结果序列\n\n\n# 二叉树的节点类定义\nclass Node:\n    def __init__(self, val):\n        self.val = val  # 节点值\n        self.left_child = None  # 当前节点的左子节点\n        self.right_child = None  # 当前节点的右子节点\n\n\ndef isValid(root, start, end):\n    \"\"\"\n    判断preOrder数组是否为合法的二叉搜索树前序遍历结果序列，如果是，则根绝preOrder还原出对应二叉搜索树\n    :param root: 二叉搜索树的节点，每个二叉搜索树节点都对应preOrder序列中的一段子序列\n    :param start: 该子序列在preOrder中的范围的起始位置\n    :param end: 该子序列在preOrder中的范围的结束位置\n    :return: preOrder数组是否为合法的二叉搜索树前序遍历结果\n    \"\"\"\n\n    # 如果当前节点对应的序列范围长度为1，则当前节点为叶子节点，无法继续递归，需要结束递归，而单个节点本身就是前序遍历结果，因此返回true\n    if start == end:\n        return True\n\n    # 前序遍历即：根左右，因此start位置是当前序列对应的子树的根节点位置，当前子树的左子子树从start+1位置开始判断\n    i = start + 1\n    # 二叉搜索树的特点是：当前节点的左子节点值 < 当前节点的值\n    while i <= end and preOrder[i] < root.val:\n        i += 1\n\n    # i 最终指向左右子树的分界位置\n    j = i\n    # 二叉搜索树的特点是：当前节点的右子节点值 > 当前节点的值\n    while j <= end and preOrder[j] > root.val:\n        j += 1\n\n    # j 最终指向右子树的终点位置的后一个位置，而右子树的终点位置必须在end，因此合法的二叉搜索树前序遍历结果 j > end\n    if j <= end:\n        return False\n\n    # i 最终指向左右子树的分界位置\n    # 如果 i > start + 1，则存在左子树\n    if i > start + 1:\n        # 创建当前节点的左子树节点\n        root.left_child = Node(preOrder[start + 1])\n\n        # 递归判断左子树对应的序列范围是否为前序遍历结果\n        if not isValid(root.left_child, start + 1, i - 1):\n            # 若不是，则preOrder无法还原出二叉搜索树\n            return False\n\n    # i 最终指向左右子树的分界位置\n    # 如果 i <= end，则存在右子树\n    if i <= end:\n        # 创建当前节点的右子树节点\n        root.right_child = Node(preOrder[i])\n        # 如果右子树对应的序列是合法的前序遍历结果，结合前面左子树对应的序列也是合法的前序遍历结果，则preOrder整体就是合法的前序遍历结果\n        return isValid(root.right_child, i, end)\n\n    return True\n\n\n# 递归查找二叉树的左缀点，即二叉树最后一层中，最靠左的点\ndef getFarLeftBottomVal(root, level):\n    # 如果当前节点存在左子节点，则递归查找其左子节点\n    if root.left_child is not None:\n        return getFarLeftBottomVal(root.left_child, level + 1)\n\n    # 如果当前节点没有左子节点，则检查当前节点处于哪一层\n    if level > 0:\n        if root.right_child is not None:\n            # 如果当前节点不处于第0层，且存在右子节点，则递归查找其右子节点\n            return getFarLeftBottomVal(root.right_child, level + 1)\n        else:\n            # 如果当前节点不处于第0层，且不存在右子节点，则当前节点即为左缀点\n            return root.val\n    else:\n        # 如果当前节点处于第0层，且没有左子节点，则没有左缀点，按题目要求返回0\n        return 0\n\n\n# 递归查找二叉树的右缀点，即二叉树最后一层中，最靠右的点\ndef getFarRightBottomVal(root, level):\n    if root.right_child is not None:\n        return getFarRightBottomVal(root.right_child, level + 1)\n\n    if level > 0:\n        if root.left_child is not None:\n            return getFarRightBottomVal(root.left_child, level + 1)\n        else:\n            return root.val\n    else:\n        return 0\n\n\n# 核心代码\ndef getResult():\n    # 二叉搜索树的根节点root\n    root = Node(preOrder[0])\n\n    if isValid(root, 0, len(preOrder) - 1):\n        return f\"1 {getFarLeftBottomVal(root, 0)} {getFarRightBottomVal(root, 0)}\"\n    else:\n        return \"0 0 0\"\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "206",
    "title": "几何平均值最大子数组",
    "examType": "B",
    "score": 200,
    "description": "从一个长度为N的正数数组numbers中找出长度至少为L且几何平均值最大子数组，并输出其位置和大小。（K个数的几何平均值为K个数的乘积的K次方根）\n若有多个子数组的几何平均值均为最大值，则输出长度最小的子数组。\n若有多个长度相同的子数组的几何平均值均为最大值，则输出最前面的子数组。\n",
    "inputDesc": "第一行输入为N、L\nN表示numbers的大小（1 ≤ N ≤ 100000）L表示子数组的最小长度（1 ≤ L ≤ N）\n之后N行表示numbers中的N个数，每个一行（10^-9 ≤ numbers[i] ≤ 10^9）\n",
    "outputDesc": "输出子数组的位置（从0开始计数）和大小，中间用一个空格隔开。\n\n用例保证除几何平均值为最大值的子数组外，其他子数组的几何平均值至少比最大值小10^-10倍\n\n本题其实就是 LeetCode - 644 子数组最大平均数 II_伏城之外的博客-CSDN博客\n的变种题。但是本题更难。\n\n建议大家先把leetcode 644 这题做会了，再来看本题。\n本题和leetcode 644的区别在于，leetcode 644求解的长度大于等于k的 最大算术平均值 的连续子序列，而本题求解的是 长度大于等于k的 最大几何平均值 的连续子序列。\n\n一个数组的nums = [a1, a2, a3, ..., aN]的\n\n因此，在求解 长度大于等于k 的子序列时，我们不能在沿用leetcode 644的解法，leetcode 644解法如下\n首先，求出 0~i 子序列的和 sum\n然后，求出 0~0 到 0~i-k 中所有子序列的最小和 min_pre_sum\n最后，sum - min_pre_sum >= 0的话，说明midVal可能取小了\n本题需要换成除法\n首先，求出 0~i 子序列的所有元素乘积 fact\n然后，求出 0~0 到 0~i-k 中所有子序列的最小乘积 min_pre_fact\n最后，fact / min_pre_fact >= 1的话，说明midVal可能取小了\n\n原理如下：有一个数组nums = [a1, a2, a3, ..., aN]，假设其几何平均值为avg，则有等式如下：\nN √ （a1 * a2 * a3 * ... * aN） == avg\n再转换一下，如下：\na1 * a2 * a3 * ... * aN == avg ^ N\n再转换一下，如下：\n(a1 / avg) * (a2 / avg) * (a3 / avg) * ... * (aN / avg) == 1\n如果avg取大了，则 (a1 / avg) * (a2 / avg) * (a3 / avg) * ... * (aN / avg) < 1\n如果avg取小了，则 (a1 / avg) * (a2 / avg) * (a3 / avg) * ... * (aN / avg) > 1\n\n另外，本题需要输出最大几何平均值对应的子数组的起始位置和长度，这个很简单，只需要记录每次被挖去的最小平均值子数组的结尾索引即可，根据结尾索引min_pre_fact_end，即可得出最大平均值数组的起始索引和长度，计算公式如下\n\n\n2023.04.09 根据网友指正，本题之前的解法没有考虑：存在多个最大几何平均值的子数组的情况，比如用例2，就有多个最大几何平均值，下面用JS通过暴力解法，求出所有子数组的几何平均值\n\n如上图所示，最大几何平均值为0.2，而几何平均值到达0.2的子数组有多个，\n比如 [2, 2, '0.200000000000'] 的含义就是：起点索引2，长度2，的子数组的几何平均值就是0.2\n因此，基于上面算法，当我们可以保存最后一轮二分求得的avg对应的：所有子数组的起点和长度（保存进ans），然后进行排序：先按照长度（较短者排前面），再按照起点（靠前者排在前面）、\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Objects;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int l = sc.nextInt();\n\n    double[] numbers = new double[n];\n    for (int i = 0; i < n; i++) {\n      numbers[i] = sc.nextDouble();\n    }\n\n    System.out.println(getResult(n, l, numbers));\n  }\n\n  public static String getResult(int n, int l, double[] numbers) {\n    double minAvg = Integer.MAX_VALUE;\n    double maxAvg = Integer.MIN_VALUE;\n    for (double num : numbers) {\n      minAvg = Math.min(num, minAvg);\n      maxAvg = Math.max(num, maxAvg);\n    }\n\n    //    double diff = maxAvg / Math.pow(10, 10);\n\n    ArrayList<Integer[]> ans = new ArrayList<>();\n\n    // 其他子数组的几何平均值至少比最大值小10^-10倍\n    while (maxAvg - minAvg >= maxAvg / Math.pow(10, 10)) {\n      // 不保留历史avg对应的ans，只保留最后一个avg，即最大avg的ans\n      ans = new ArrayList<>();\n      double midAvg = (minAvg + maxAvg) / 2;\n\n      if (check(n, l, numbers, midAvg, ans)) {\n        minAvg = midAvg;\n      } else {\n        maxAvg = midAvg;\n      }\n    }\n\n    // 若有多个子数组的几何平均值均为最大值，则输出长度最小的子数组。\n    // 若有多个长度相同的子数组的几何平均值均为最大值，则输出最前面的子数组。\n    ans.sort((a, b) -> !Objects.equals(a[1], b[1]) ? a[1] - b[1] : a[0] - b[0]);\n\n    Integer[] tmp = ans.get(0);\n    return tmp[0] + \" \" + tmp[1];\n  }\n\n  public static boolean check(\n      int n, int l, double[] numbers, double avg, ArrayList<Integer[]> ans) {\n    // 该flag为True表示avg取小了，为False表示avg取大了，默认为False\n    boolean flag = false;\n    double fact = 1;\n\n    for (int i = 0; i < l; i++) {\n      fact *= numbers[i] / avg;\n    }\n\n    if (fact >= 1) {\n      flag = true;\n      // ans的元素含义：[目标子数组起始位置，目标子数组长度]\n      ans.add(new Integer[] {0, l});\n    }\n\n    double pre_fact = 1;\n    double min_pre_fact = Integer.MAX_VALUE;\n    int min_pre_fact_end = 0;\n\n    for (int i = l; i < n; i++) {\n      fact *= numbers[i] / avg; // 对应0~i区间\n      pre_fact *= numbers[i - l] / avg; // 对应0~i-l区间\n\n      if (pre_fact < min_pre_fact) {\n        min_pre_fact = pre_fact; // 对应0~i-l区间内 几何平均值最小的子数列\n        min_pre_fact_end = i - l;\n      }\n\n      if (fact / min_pre_fact >= 1) {\n        flag = true;\n        // ans的元素含义：[目标子数组起始位置，目标子数组长度]\n        ans.add(new Integer[] {min_pre_fact_end + 1, i - min_pre_fact_end});\n      }\n    }\n\n    return flag;\n  }\n}",
      "python": "import sys\n\n# 输入获取\nn, l = map(int, input().split())\nnumbers = [float(input()) for i in range(n)]\n\n\n# 算法入口\ndef getResult(n, l, numbers):\n    minAvg = min(numbers)\n    maxAvg = max(numbers)\n    # diff = maxAvg / 10 ** 10\n\n    ans = []\n\n    # 其他子数组的几何平均值至少比最大值小10^-10倍\n    while maxAvg - minAvg >= maxAvg / 10 ** 10:\n        # 不保留历史avg对应的ans，只保留最后一个avg，即最大avg的ans\n        ans = []\n        midAvg = (minAvg + maxAvg) / 2\n\n        if check(n, l, numbers, midAvg, ans):\n            minAvg = midAvg\n        else:\n            maxAvg = midAvg\n\n    # 若有多个子数组的几何平均值均为最大值，则输出长度最小的子数组。\n    # 若有多个长度相同的子数组的几何平均值均为最大值，则输出最前面的子数组。\n    ans.sort(key=lambda x: (x[1], x[0]))\n    return \" \".join(map(str, ans[0]))\n\n\ndef check(n, l, numbers, avg, ans):\n    # 该flag为True表示avg取小了，为False表示avg取大了，默认为False\n    flag = False\n    fact = 1\n\n    for i in range(l):\n        fact *= numbers[i] / avg\n\n    if fact >= 1:\n        flag = True\n        # ans的元素含义：[目标子数组起始位置，目标子数组长度]\n        ans.append([0, l])\n\n    pre_fact = 1\n    min_pre_fact = sys.maxsize\n    min_pre_fact_end = 0\n\n    for i in range(l, n):\n        fact *= numbers[i] / avg  # 对应0~i区间\n        pre_fact *= numbers[i - l] / avg  # 对应0~i-l区间\n\n        if pre_fact < min_pre_fact:\n            min_pre_fact = pre_fact  # 对应0~i-l区间内 几何平均值最小的子数列\n            min_pre_fact_end = i - l\n\n        if fact / min_pre_fact >= 1:\n            flag = True\n            # ans的元素含义：[目标子数组起始位置，目标子数组长度]\n            ans.append([min_pre_fact_end + 1, i - min_pre_fact_end])\n\n    return flag\n\n\n# 算法调用\nprint(getResult(n, l, numbers))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n, l;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [n, l] = lines[0].split(\" \").map(Number);\n  }\n\n  if (n && lines.length === n + 1) {\n    const numbers = lines.slice(1).map((line) => Number(line));\n    console.log(getResult(n, l, numbers));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(n, l, numbers) {\n  const sorted_numbers = numbers.slice().sort((a, b) => a - b);\n  let minAvg = sorted_numbers.at(0);\n  let maxAvg = sorted_numbers.at(-1);\n  // const diff = maxAvg / Math.pow(10, 10);\n\n  let ans = [];\n\n  // 其他子数组的几何平均值至少比最大值小10^-10倍\n  while (maxAvg - minAvg >= maxAvg / Math.pow(10, 10)) {\n    // 不保留历史avg对应的ans，只保留最后一个avg，即最大avg的ans\n    ans = [];\n    let midAvg = (minAvg + maxAvg) / 2;\n\n    if (check(n, l, numbers, midAvg, ans)) {\n      minAvg = midAvg;\n    } else {\n      maxAvg = midAvg;\n    }\n  }\n\n  // 若有多个子数组的几何平均值均为最大值，则输出长度最小的子数组。\n  // 若有多个长度相同的子数组的几何平均值均为最大值，则输出最前面的子数组。\n  ans.sort((a, b) => (a[1] != b[1] ? a[1] - b[1] : a[0] - b[0]));\n\n  return ans[0].join(\" \");\n}\n\nfunction check(n, l, numbers, avg, ans) {\n  // 该flag为True表示avg取小了，为False表示avg取大了，默认为False\n  let flag = false;\n  let fact = 1;\n\n  for (let i = 0; i < l; i++) {\n    fact *= numbers[i] / avg;\n  }\n\n  if (fact >= 1) {\n    flag = true;\n    // ans的元素含义：[目标子数组起始位置，目标子数组长度]\n    ans.push([0, l]);\n  }\n\n  let pre_fact = 1;\n  let min_pre_fact = Infinity;\n  let min_pre_fact_end = 0;\n\n  for (let i = l; i < n; i++) {\n    fact *= numbers[i] / avg; // 对应0~i区间\n    pre_fact *= numbers[i - l] / avg; // 对应0~i-l区间\n\n    if (pre_fact < min_pre_fact) {\n      min_pre_fact = pre_fact; // 对应0~i-l区间内 几何平均值最小的子数列\n      min_pre_fact_end = i - l;\n    }\n\n    if (fact / min_pre_fact >= 1) {\n      flag = true;\n      // ans的元素含义：[目标子数组起始位置，目标子数组长度]\n      ans.push([min_pre_fact_end + 1, i - min_pre_fact_end]);\n    }\n  }\n\n  return flag;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "207",
    "title": "区间交集",
    "examType": "B",
    "score": 200,
    "description": "给定一组闭区间，其中部分区间存在交集。\n任意两个给定区间的交集，称为公共区间(如:[1,2],[2,3]的公共区间为[2,2]，[3,5],[3,6]的公共区间为[3,5])。\n公共区间之间若存在交集，则需要合并(如:[1,3],[3,5]区间存在交集[3,3]，需合并为[1,5])。\n按升序排列输出合并后的区间列表。\n",
    "inputDesc": "一组区间列表，\n区间数为 N: 0<=N<=1000;\n区间元素为 X: -10000<=X<=10000。\n",
    "outputDesc": "升序排列的合并区间列表\n\n\n[0,3]和[1,3]的公共区间为[1,3]，\n[0,3]和[3,5]的公共区间为[3,3]，\n[0,3]和[3,6]的公共区间为[3,3]，\n[1,3]和[3,5]的公共区间为[3,3]，\n[1,3]和[3,6]的公共区间为[3,3]，\n[3,5]和[3,6]的公共区间为[3,5]，\n公共区间列表为[[1,3],[3,3],[3,5]]；\n[1,3],[3,3],[3,5]存在交集，须合并为[1,5]。\n4 0 3 1 4 4 7 5 8\n2 1 2 3 4\n\n本题主要考察：区间交集求解、以及区间合并。\n\n首先，我们要求解输入的多个区间中，任意两个区间的交集（公共区间）。\n然后，将这些公共区间进行合并后打印。\n\n两个区间的交集求解思路如下：\n将两个区间按照开始位置进行升序，假设排序后，两个区间顺序是：[[s1, e1]，[s2, e2]]\n那么必然 s1 <= s2，因此如果存在交集的话，即e1 >= s2\n则交集的左边界必然是s2，而交集的右边界取值Math.min(e1, e2)\n\n区间合并的逻辑可以参考：华为机试 - 路灯照明问题_伏城之外的博客-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    int[][] ranges = new int[n][2];\n    for (int i = 0; i < n; i++) {\n      ranges[i][0] = sc.nextInt();\n      ranges[i][1] = sc.nextInt();\n    }\n\n    getResult(n, ranges);\n  }\n\n  public static void getResult(int n, int[][] ranges) {\n    // 区间按照开始位置升序\n    Arrays.sort(ranges, (a, b) -> a[0] - b[0]);\n\n    // combine用于保存交集\n    ArrayList<int[]> combine = new ArrayList<>();\n\n    // 求任意两个区间之间的交集\n    for (int i = 0; i < n; i++) {\n      int s1 = ranges[i][0], e1 = ranges[i][1];\n      for (int j = i + 1; j < n; j++) {\n        int s2 = ranges[j][0], e2 = ranges[j][1];\n        if (s2 <= e1) {\n          combine.add(new int[] {s2, Math.min(e1, e2)});\n        } else {\n          // 由于ranges已经升序，因此如果ranges[i]和ranges[j]没有交集的话，则也不可能和ranges[j+1]区间有交集\n          break;\n        }\n      }\n    }\n\n    if (combine.size() == 0) {\n      System.out.println(\"None\");\n      return;\n    }\n\n    // 合并公共区间\n    combine.sort((a, b) -> a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]);\n\n    int[] pre = combine.get(0);\n    for (int i = 1; i < combine.size(); i++) {\n      int[] cur = combine.get(i);\n\n      if (pre[1] >= cur[0]) {\n        pre[1] = Math.max(cur[1], pre[1]);\n      } else {\n        System.out.println(pre[0] + \" \" + pre[1]);\n        pre = cur;\n      }\n    }\n\n    System.out.println(pre[0] + \" \" + pre[1]);\n  }\n}",
      "python": "# 输入获取\nn = int(input())\nranges = [list(map(int, input().split())) for _ in range(n)]\n\n\n# 算法入口\ndef getResult():\n    # 区间按照开始位置升序\n    ranges.sort(key=lambda x: x[0])\n\n    # combine用于保存公共区间\n    combine = []\n\n    for i in range(n):\n        s1, e1 = ranges[i]\n        for j in range(i + 1, n):\n            s2, e2 = ranges[j]\n            if s2 <= e1:\n                combine.append([s2, min(e1, e2)])\n            else:\n                # 由于ranges已经升序，因此如果ranges[i]和ranges[j]没有交集的话，则也不可能和ranges[j+1]区间有交集\n                break\n\n    if len(combine) == 0:\n        print(\"None\")\n        return\n\n    # 合并公共区间\n    combine.sort(key=lambda x: (x[0], -x[1]))\n\n    pre = combine[0]\n    for i in range(1, len(combine)):\n        cur = combine[i]\n\n        if pre[1] >= cur[0]:\n            pre[1] = max(cur[1], pre[1])\n        else:\n            print(\" \".join(map(str, pre)))\n            pre = cur\n\n    print(\" \".join(map(str, pre)))\n\n\n# 算法调用\ngetResult()",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = parseInt(lines[0]);\n\n    if (n == 0) {\n      console.log(\"None\");\n      lines.length = 0;\n    }\n  }\n\n  if (n && lines.length === n + 1) {\n    lines.shift();\n    const ranges = lines.map((line) => line.split(\" \").map(Number));\n\n    getResult(ranges);\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(ranges) {\n  // 区间按照开始位置升序\n  ranges.sort((a, b) => a[0] - b[0]);\n\n  // combine用于保存交集\n  const combine = [];\n\n  // 公共区间求解\n  for (let i = 0; i < ranges.length; i++) {\n    const [s1, e1] = ranges[i];\n    for (let j = i + 1; j < ranges.length; j++) {\n      const [s2, e2] = ranges[j];\n      if (s2 <= e1) {\n        combine.push([s2, Math.min(e1, e2)]);\n      } else {\n        // 由于ranges已经升序，因此如果ranges[i]和ranges[j]没有交集的话，则也不可能和ranges[j+1]区间有交集\n        break;\n      }\n    }\n  }\n\n  if (combine.length == 0) return console.log(\"None\");\n\n  // 合并公共区间\n  combine.sort((a, b) => (a[0] != b[0] ? a[0] - b[0] : b[1] - a[1]));\n\n  let pre = combine[0];\n  for (let i = 1; i < combine.length; i++) {\n    const cur = combine[i];\n\n    if (pre[1] >= cur[0]) {\n      pre[1] = Math.max(cur[1], pre[1]);\n    } else {\n      console.log(pre.join(\" \"));\n      pre = cur;\n    }\n  }\n\n  console.log(pre.join(\" \"));\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "208",
    "title": "基站维护工程师",
    "examType": "B",
    "score": 200,
    "description": "小王是一名基站维护工程师，负责某区域的基站维护。 某地方有 n 个基站(1 < n < 10)，已知各基站之间的距离 s(0 < s < 500)，并且基站 x 到基站 y 的距离，与基站 y 到基站 x 的距离并不一定会相同。 小王从基站 1 出发，途经每个基站 1 次，然后返回基站 1 ，需要请你为他选择一条距离最短的路。\n",
    "inputDesc": "站点数n和各站点之间的距离(均为整数)\n",
    "outputDesc": "最短路程的数值\n\n\n用例输入含义是，\n3 //有3个基站， 0 2 1 // 站点1到站点1的距离0，到站点2的距离2，到站点3的距离1 1 0 2 // 站点2到站点1的距离1，到站点2的距离0，到站点3的距离2 2 1 0 // 站点3到站点1的距离2，到站点2的距离1，到站点3的距离0\n图示如下\n\n可以发现，1 → 3 → 2 → 1 的路线距离是最短的，只有3距离。\n\n题目中说：\n小王从基站 1 出发，途经每个基站 1 次，然后返回基站 1\n并且按照题目输入来看，每个站点都与剩下的其他站点相连，因此本题其实就是求解n-1个站点（即2~n站点，起始站点1）的全排列。\n比如用例一共三个站点，从1站点出发，即求2，3站点的全排列：23，32\n因此一共有两种途径选择：1 → 2 → 3 → 1 和 1 → 3 → 2 → 1\n我们只要比较各排列路径中距离最小的即为题解。\n两个站点i，j之间距离，即为matrix[i-1][j-1]，比如求解1 → 2距离，起始就是matrix[0][1]。\n\n题目中说 1 < n < 10 ，也就是说最多有9个站点，而我们求解n-1个站点的全排列，即8个站点的全排列，一共有8！= 40320 个，每个排列求解距离要进行一个O(n)的遍历，即9次遍历。因此一共是差不多40w次循环，好在没什么计算量。\n我测试了一下10*10矩阵的用时为200ms左右，应该符合要求。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n\n        int[][] matrix = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = sc.nextInt();\n            }\n        }\n\n        System.out.println(getResult(matrix, n));\n    }\n\n    public static int getResult(int[][] matrix, int n) {\n        boolean[] used = new boolean[n];\n        LinkedList<Integer> path = new LinkedList<>();\n        ArrayList<LinkedList<Integer>> res = new ArrayList<>();\n\n        dfs(n, used, path, res);\n\n        int ans = Integer.MAX_VALUE;\n\n        for (LinkedList<Integer> pa : res) {\n            int dis = matrix[0][pa.get(0)];\n            for (int i = 0; i < pa.size() - 1; i++) {\n                int p = pa.get(i);\n                int c = pa.get(i + 1);\n                dis += matrix[p][c];\n            }\n            dis += matrix[pa.getLast()][0];\n            ans = Math.min(ans, dis);\n        }\n\n        return ans;\n    }\n\n    public static void dfs(int n, boolean[] used, LinkedList<Integer> path, ArrayList<LinkedList<Integer>> res) {\n        if (path.size() == n - 1) {\n            res.add((LinkedList<Integer>)path.clone());\n            return;\n        }\n\n        for (int i = 1; i < n; i++) {\n            if (!used[i]) {\n                path.push(i);\n                used[i] = true;\n                dfs(n, used, path, res);\n                used[i] = false;\n                path.pop();\n            }\n        }\n    }\n\n}",
      "python": "import sys\n\n# 输入获取\nn = int(input())\nmatrix = [list(map(int, input().split())) for i in range(n)]\n\n\n# 算法入口\ndef getResult(matrix, n):\n    res = []\n    dfs(n, [False] * n, [], res)\n\n    ans = sys.maxsize\n\n    for path in res:\n        dis = matrix[0][path[0]]\n        for i in range(len(path) - 1):\n            dis += matrix[path[i]][path[i + 1]]\n        dis += matrix[path[-1]][0]\n        ans = min(ans, dis)\n\n    return ans\n\n\ndef dfs(n, used, path, res):\n    if len(path) == n - 1:\n        return res.append(path[:])\n\n    for i in range(1, n):\n        if not used[i]:\n            path.append(i)\n            used[i] = True\n            dfs(n, used, path, res)\n            used[i] = False\n            path.pop()\n\n\n# 算法调用\nprint(getResult(matrix, n))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = lines[0] - 0;\n  }\n\n  if (n && lines.length === n + 1) {\n    lines.shift();\n    const matrix = lines.map((line) => line.split(\" \").map(Number));\n    console.log(getResult(matrix, n));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(matrix, n) {\n  const res = [];\n  dfs(n, [], [], res);\n\n  let ans = Infinity;\n\n  for (let path of res) {\n    let dis = matrix[0][path[0]];\n    path.reduce((p, c) => {\n      dis += matrix[p][c];\n      return c;\n    });\n    dis += matrix[path.at(-1)][0];\n    ans = Math.min(ans, dis);\n  }\n\n  return ans;\n}\n\nfunction dfs(n, used, path, res) {\n  if (path.length === n - 1) return res.push([...path]);\n\n  for (let i = 1; i < n; i++) {\n    if (!used[i]) {\n      path.push(i);\n      used[i] = true;\n      dfs(n, used, path, res);\n      used[i] = false;\n      path.pop();\n    }\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "209",
    "title": "士兵过河",
    "examType": "B",
    "score": 200,
    "description": "一支N个士兵的军队正在趁夜色逃亡，途中遇到一条湍急的大河。 敌军在T的时长后到达河面，没到过对岸的士兵都会被消灭。 现在军队只找到了1只小船，这船最多能同时坐上2个士兵。\n当1个士兵划船过河，用时为 a[i]；0 <= i < N当2个士兵坐船同时划船过河时，用时为max(a[j],a[i])两士兵中用时最长的。当2个士兵坐船1个士兵划船时，用时为 a[i]*10；a[i]为划船士兵用时。如果士兵下河游泳，则会被湍急水流直接带走，算作死亡。\n请帮忙给出一种解决方案，保证存活的士兵最多，且过河用时最短。\n",
    "inputDesc": "第一行：N 表示士兵数(0<N<1,000,000) 第二行：T 表示敌军到达时长(0 < T < 100,000,000) 第三行：a[0] a[1] … a[i]… a[N- 1] a[i]表示每个士兵的过河时长。 (10 < a[i]< 100; 0<= i< N）\n",
    "outputDesc": "第一行：”最多存活士兵数” “最短用时”\n\n1）两个士兵的同时划船时，如果划速不同则会导致船原地转圈圈；所以为保持两个士兵划速相同，则需要向划的慢的士兵看齐。 2）两个士兵坐船时，重量增加吃水加深，水的阻力增大；同样的力量划船速度会变慢； 3）由于河水湍急大量的力用来抵消水流的阻力，所以2）中过河用时不是a[i] *2， 而是a[i] * 10。\n\n可以达到或小于171的一种方案： 第一步：a[1] a[2] 过桥用时：13 第二步：a[1] 带火把返回用时：12 第三步：a[0] a[5] 过桥用时：35 第四步：a[2] 带火把返回用时：13 第五步：a[1] a[2] 过桥用时：13 第六步：a[1] 带火把返回用时：12 第七步：a[4] a[6] 过桥用时：20 第八步：a[2] 带火把返回用时：13 第九步：a[1] a[3] 过桥用时：15 第十步：a[1] 带火把返回用时：12 第十一步：a[1] a[2] 过桥用时：13\n所以输出为：\n7 171\n\n本题是 POJ - 1700 Crossing River_伏城之外的博客-CSDN博客 的变种题。\n建议大家先搞定这题，然后再来看本题。\n\n本题在前面这题的基础上，多了一个过河时间限制，以及要求最多存活士兵（即在限制时间内过最多的人）\n\n对于贪心解法，可以结合二分法来求解本题。\n即在0~N中尝试找到成功过河的人数，其中0指的是成功过河的人数为0个，N指的是成功过河的人数为N个。\n将二分法找到的可能人数mid带入上面POJ-1700的逻辑中，计算出mid个人都过河所需的最短时间need，将need和本题过河时间限制limit进行比较：\n\n对于动态规划解法，由于是从0人过河递推到N人过河，因此不需要二分尝试过河人数，而是可以直接基于dp[i]来实时比较T，如果超过了T，则说明只能过河 i 人，耗时dp[i-1]\n\n另外，本题中说：\n当2个士兵坐船1个士兵划船时，用时为 a[i]*10；a[i]为划船士兵用时。\n假设x士兵划船用时为a[x]，y士兵划船用时为a[y]，a[x] < a[y]\n这句话的意思是：如果x,y一起划船，有两种过河时间，分别是：\n如果a[y] > a[x] * 10，我们应该选择a[x] * 10，即让较快的士兵单独划船过河，这样耗时更短。\n\n但是，本题中又说：\n(10 < a[i]< 100; 0<= i< N）\n即\n那么必然：100 < a[x] * 10 < 1000\n即必然 a[x] * 10 > a[y]\n因此，我们不需要考虑上面那种两个士兵坐船，一个士兵划船的情况。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int t = sc.nextInt();\n\n    int[] times = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      times[i] = sc.nextInt();\n    }\n\n    System.out.println(getResult(n, t, times));\n  }\n\n  /**\n   * @param n 士兵数\n   * @param limit 过河时间上限\n   * @param times 数组，元素表示每个士兵的过河时长\n   * @return ”最多存活士兵数” “最短用时”\n   */\n  public static String getResult(int n, int limit, int[] times) {\n    // 过河时间升序\n    Arrays.sort(times);\n\n    // 最少成功过河人数\n    int min = 0;\n    // 最多成功过河人数\n    int max = n;\n\n    // 记录题解\n    String ans = \"\";\n\n    // 二分法取可能成功的过河人数\n    while (min <= max) {\n      // mid是过河人数\n      int mid = (min + max) / 2;\n      // 计算mid个人过河所需的最短时间need\n      int need = getMinCrossRiverTime(mid, Arrays.copyOfRange(times, 0, mid));\n\n      // 如果need超过了过河时间上限limit，那么说明能成功过河的人没这么多\n      if (need > limit) {\n        max = mid - 1;\n      } else if (need < limit) {\n        // 如果need小于过河时间上限limit，那么说明mid个最快的人可以在limit时间内成功过河\n        ans = mid + \" \" + need;\n        // 但是可能还可以过更多人\n        min = mid + 1;\n      } else {\n        // 如果need == limit，那么说明过河人数刚好可以在limit时间内成功过河，此时可以直接返回\n        ans = mid + \" \" + need;\n        break;\n      }\n    }\n\n    return ans;\n  }\n\n  // 计算将n个人运到河对岸所需要花费的最少时间\n  public static int getMinCrossRiverTime(int n, int[] t) {\n    int cost = 0;\n\n    while (n > 0) {\n      if (n == 1) {\n        cost += t[0];\n        break;\n      } else if (n == 2) {\n        cost += t[1];\n        break;\n      } else if (n == 3) {\n        cost += t[1] + t[0] + t[2];\n        break;\n      } else {\n        cost += Math.min(t[n - 1] + t[0] + t[n - 2] + t[0], t[1] + t[0] + t[n - 1] + t[1]);\n        n -= 2;\n      }\n    }\n\n    return cost;\n  }\n}",
      "python": "# 输入获取\nn = int(input())\nt = int(input())\ntimes = list(map(int, input().split()))\n\n\n# 计算n个人运到河对岸所需要花费的最少时间\ndef getMinCrossRiverTime(n, t):\n    cost = 0\n\n    while n > 0:\n        if n == 1:\n            cost += t[0]\n            break\n        elif n == 2:\n            cost += t[1]\n            break\n        elif n == 3:\n            cost += t[1] + t[0] + t[2]\n            break\n        else:\n            cost += min(t[n - 1] + t[0] + t[n - 2] + t[0], t[1] + t[0] + t[n - 1] + t[1])\n            n -= 2\n\n    return cost\n\n\n# 算法入口\ndef getResult(n, limit, times):\n    \"\"\"\n    :param n: 士兵数\n    :param limit: 过河时间上限\n    :param times: 数组，元素表示每个士兵的过河时长\n    :return: ”最多存活士兵数” “最短用时”\n    \"\"\"\n    times.sort()\n\n    # 最少成功过河人数\n    low = 0\n    # 最多成功过河人数\n    high = n\n\n    # 记录题解\n    ans = \"\"\n\n    # 二分法取可能成功的过河人数\n    while low <= high:\n        # mid是过河人数\n        mid = (low + high) // 2\n        # 计算mid个人过河所需的最短时间need\n        need = getMinCrossRiverTime(mid, times[:mid])\n\n        # 如果need超过了过河时间上限limit，那么说明能成功过河的人没这么多\n        if need > limit:\n            high = mid - 1\n        elif need < limit:\n            # 如果need小于过河时间上限limit，那么说明mid个最快的人可以在limit时间内成功过河\n            ans = f\"{mid} {need}\"\n            # 但是可能还可以过更多人\n            low = mid + 1\n        else:\n            # 如果need == limit，那么说明过河人数刚好可以在limit时间内成功过河，此时可以直接返回\n            ans = f\"{mid} {need}\"\n            break\n\n    return ans\n\n\n# 算法调用\nprint(getResult(n, t, times))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 3) {\n    const N = lines[0] - 0;\n    const T = lines[1] - 0;\n    const times = lines[2].split(\" \").map(Number);\n    console.log(getResult(N, T, times));\n    lines.length = 0;\n  }\n});\n\n/**\n *\n * @param {*} n 士兵数\n * @param {*} limit 过河时间上限\n * @param {*} times 数组，元素表示每个士兵的过河时长\n * @return {*} ”最多存活士兵数” “最短用时”\n */\nfunction getResult(n, limit, times) {\n  // 过河时间升序\n  times.sort((a, b) => a - b);\n\n  // 最少成功过河人数\n  let min = 0;\n  // 最多成功过河人数\n  let max = n;\n\n  // 记录题解\n  let ans = \"\";\n\n  // 二分法取可能成功的过河人数\n  while (min <= max) {\n    // mid是过河人数\n    const mid = Math.floor((min + max) / 2);\n    // 计算mid个人过河所需的最短时间need\n    const need = getMinCrossRiverTime(mid, times.slice(0, mid));\n\n    // 如果need超过了过河时间上限limit，那么说明能成功过河的人没这么多\n    if (need > limit) {\n      max = mid - 1;\n    } else if (need < limit) {\n      // 如果need小于过河时间上限limit，那么说明mid个最快的人可以在limit时间内成功过河\n      ans = `${mid} ${need}`;\n      // 但是可能还可以过更多人\n      min = mid + 1;\n    } else {\n      // 如果need == limit，那么说明过河人数刚好可以在limit时间内成功过河，此时可以直接返回\n      ans = `${mid} ${need}`;\n      break;\n    }\n  }\n\n  return ans;\n}\n\n// 计算n个人运到河对岸所需要花费的最少时间\nfunction getMinCrossRiverTime(n, t) {\n  let cost = 0;\n\n  while (n > 0) {\n    if (n == 1) {\n      cost += t[0];\n      break;\n    } else if (n == 2) {\n      cost += t[1];\n      break;\n    } else if (n == 3) {\n      cost += t[1] + t[0] + t[2];\n      break;\n    } else {\n      cost += Math.min(\n        t[n - 1] + t[0] + t[n - 2] + t[0],\n        t[1] + t[0] + t[n - 1] + t[1]\n      );\n      n -= 2;\n    }\n  }\n\n  return cost;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "210",
    "title": "天然蓄水库",
    "examType": "B",
    "score": 200,
    "description": "公元2919年，人类终于发现了一颗宜居星球——X星。 现想在X星一片连绵起伏的山脉间建一个天热蓄水库，如何选取水库边界，使蓄水量最大？\n要求：\n山脉用正整数数组s表示，每个元素代表山脉的高度。选取山脉上两个点作为蓄水库的边界，则边界内的区域可以蓄水，蓄水量需排除山脉占用的空间蓄水量的高度为两边界的最小值。如果出现多个满足条件的边界，应选取距离最近的一组边界。\n输出边界下标（从0开始）和最大蓄水量；如果无法蓄水，则返回0，此时不返回边界。 例如，当山脉为s=[3,1,2]时，则选取s[0]和s[2]作为水库边界，则蓄水量为1，此时输出：0 2:1 当山脉s=[3,2,1]时，不存在合理的边界，此时输出：0。\n",
    "inputDesc": "一行正整数，用空格隔开，例如输入\n1 2 3\n表示s=[1,2,3]\n",
    "outputDesc": "当存在合理的水库边界时，输出左边界、空格、右边界、英文冒号、蓄水量；例如\n0 2:1\n当不存在合理的书库边界时，输出0；例如\n0\n\n\n\n用例1图示如下：\n\n选择山峰1和山峰6作为边界，则可获得最大蓄水量19\n\n\n用例2图示如下\n\n\n选择山峰1和山峰6作为边界，则可获得最大蓄水量15\n\n其实用例2还可以选择山峰1和山峰8作为边界，也可以获得最大蓄水量15，如下图所示\n\n但是此时两边界山峰的距离是6，相较于选择山峰1，6作为边界时距离4而言，更远。\n按照题目要求，我们需要找到：蓄水量最大的，且距离最近的两个边界山峰。\n\n我一开始的解题思路是双指针，类似于下面这题\n华为OD机试 - 太阳能板最大面积（Java & JS & Python）_伏城之外的博客-CSDN博客\n\n但是经过如下几个用例测试，发现本题无法像上面链接题目一样找到一个O(n)的解法，双边指针无法找到一个固定的策略进行运动。\n\n\n\n因此，我开始寻找其他的思路，直到发现了LeetCode - 42 接雨水_伏城之外的博客-CSDN博客\n\n其实，我们不应该从横向来思考本题，可以从纵向来思考本题。什么意思呢？\n我们按照接雨水那个思路，把用例1中所有能接水的山峰全部接满，即如下图所示\n\n此时从纵向来看只有有两条水位线，如下图所示\n\n\n\n从上图可以看出，每条水位线都有都可能与多个山峰相交，但是我们只需要关注：\n如下图所示：\n\n上图中，L山峰和R山峰是可以达到该水位线要求的最外层的两端山峰，此时这两座山峰之间的每个山峰的储水量就是该水位线最大的储水量。\n而此时边界山峰为L-1，和R+1。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    Integer[] h =\n        Arrays.stream(sc.nextLine().split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    System.out.println(getResult(h));\n  }\n\n  public static String getResult(Integer[] h) {\n    int n = h.length;\n\n    // left[i] 记录 第 i 个山峰左边的最高山峰\n    int[] left = new int[n];\n    for (int i = 1; i < n; i++) left[i] = Math.max(left[i - 1], h[i - 1]);\n\n    // right[i] 记录 第 i 个山峰右边的最高山峰\n    int[] right = new int[n];\n    for (int i = n - 2; i >= 0; i--) right[i] = Math.max(right[i + 1], h[i + 1]);\n\n    // lines[i] 记录 第 i 个山峰的水位线高度\n    int[] lines = new int[n];\n    // lineSet记录有哪些水位线\n    HashSet<Integer> lineSet = new HashSet<>();\n    for (int i = 1; i < n - 1; i++) {\n      int water = Math.max(0, Math.min(left[i], right[i]) - h[i]); // water 记录 第 i 个山峰可以储存多少水\n\n      if (water != 0) {\n        // 第 i 个山峰的水位线高度\n        lines[i] = water + h[i];\n        lineSet.add(lines[i]);\n      }\n    }\n\n    // ans数组含义：[左边界， 右边界， 储水量]\n    int[] ans = {0, 0, 0};\n\n    // 遍历每一个水位线\n    for (int line : lineSet) {\n\n      // 满足该水位线的最左侧山峰位置l\n      int l = 0;\n      while (lines[l] < line || h[l] >= line) {\n        l++;\n      }\n\n      // 满足该水位线的最右侧山峰位置r\n      int r = n - 1;\n      while (lines[r] < line || h[r] >= line) {\n        r--;\n      }\n\n      // 该水位线的总储水量\n      int sum = 0;\n      for (int i = l; i <= r; i++) {\n        sum += Math.max(0, line - h[i]);\n      }\n\n      // 记录最大的储水量\n      if (sum > ans[2]) {\n        ans[0] = l - 1;\n        ans[1] = r + 1;\n        ans[2] = sum;\n      }\n      // 如果有多个最多储水量选择，则选择边界山峰距离最短的\n      else if (sum == ans[2]) {\n        int curDis = r - l + 1;\n        int minDis = ans[1] - ans[0] - 1;\n\n        if (curDis < minDis) {\n          ans[0] = l - 1;\n          ans[1] = r + 1;\n        }\n      }\n    }\n\n    if (ans[2] == 0) return \"0\";\n\n    return ans[0] + \" \" + ans[1] + \":\" + ans[2];\n  }\n}",
      "python": "# 输入获取\nh = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult(h):\n    n = len(h)\n\n    # left[i] 记录 第 i 个山峰左边的最高山峰\n    left = [0] * n\n    for i in range(1, n):\n        left[i] = max(left[i - 1], h[i - 1])\n\n    # right[i] 记录 第 i 个山峰右边的最高山峰\n    right = [0] * n\n    for i in range(n - 2, -1, -1):\n        right[i] = max(right[i + 1], h[i + 1])\n\n    # lines[i] 记录 第 i 个山峰的水位线高度\n    lines = [0] * n\n    # lineSet记录有哪些水位线\n    lineSet = set()\n    for i in range(1, n - 1):\n        # water 记录 第 i 个山峰可以储存多少水\n        water = max(0, min(left[i], right[i]) - h[i])\n\n        # 如果第 i 个山峰可以储存水，则必然有一个水位线，记录到lines中\n        if water != 0:\n            # 第 i 个山峰的水位线高度\n            lines[i] = water + h[i]\n            lineSet.add(lines[i])\n\n    # ans数组含义：[左边界， 右边界， 储水量]\n    ans = [0, 0, 0]\n\n    # 遍历每一个水位线\n    for line in lineSet:\n        # 满足该水位线的最左侧山峰位置l\n        l = 0\n        while lines[l] < line or h[l] >= line:\n            l += 1\n\n        # 满足该水位线的最右侧山峰位置r\n        r = n - 1\n        while lines[r] < line or h[r] >= line:\n            r -= 1\n\n        # 该水位线的总储水量\n        total = 0\n        for i in range(l, r + 1):\n            total += max(0, line - h[i])\n\n        # 记录最大的储水量\n        if total > ans[2]:\n            ans[0] = l - 1\n            ans[1] = r + 1\n            ans[2] = total\n        # 如果有多个最多储水量选择，则选择边界山峰距离最短的\n        elif total == ans[2]:\n            curDis = r - l + 1\n            minDis = ans[1] - ans[0] - 1\n\n            if curDis < minDis:\n                ans[0] = l - 1\n                ans[1] = r + 1\n\n    if ans[2] == 0:\n        return \"0\"\n\n    return str(ans[0]) + \" \" + str(ans[1]) + \":\" + str(ans[2])\n\n\n# 算法调用\nprint(getResult(h))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const h = line.split(\" \").map(Number);\n\n  console.log(getResult(h));\n});\n\nfunction getResult(h) {\n  const n = h.length;\n\n  // left[i] 记录 第 i 个山峰左边的最高山峰\n  const left = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    left[i] = Math.max(left[i - 1], h[i - 1]);\n  }\n\n  // right[i] 记录 第 i 个山峰右边的最高山峰\n  const right = new Array(n).fill(0);\n  for (let i = n - 2; i >= 0; i--) {\n    right[i] = Math.max(right[i + 1], h[i + 1]);\n  }\n\n  // lines[i] 记录 第 i 个山峰的水位线高度\n  const lines = new Array(n).fill(0);\n  // lineSet记录有哪些水位线\n  const lineSet = new Set();\n  for (let i = 1; i < n - 1; i++) {\n    const water = Math.max(0, Math.min(left[i], right[i]) - h[i]); // water 记录 第 i 个山峰可以储存多少水\n\n    if (water != 0) {\n      // 第 i 个山峰的水位线高度\n      lines[i] = water + h[i];\n      lineSet.add(lines[i]);\n    }\n  }\n\n  // ans数组含义：[左边界， 右边界， 储水量]\n  let ans = [0, 0, 0];\n\n  // 遍历每一个水位线\n  for (let line of lineSet) {\n    // 满足该水位线的最左侧山峰位置l\n    let l = 0;\n    while (lines[l] < line || h[l] >= line) {\n      l++;\n    }\n\n    // 满足该水位线的最右侧山峰位置r\n    let r = n - 1;\n    while (lines[r] < line || h[r] >= line) {\n      r--;\n    }\n\n    // 该水位线的总储水量\n    let sum = 0;\n    for (let i = l; i <= r; i++) {\n      sum += Math.max(0, line - h[i]);\n    }\n\n    // 记录最大的储水量\n    if (sum > ans[2]) {\n      ans[0] = l - 1;\n      ans[1] = r + 1;\n      ans[2] = sum;\n    }\n    // 如果有多个最多储水量选择，则选择边界山峰距离最短的\n    else if (sum == ans[2]) {\n      const curDis = r - l + 1;\n      const minDis = ans[1] - ans[0] - 1;\n\n      if (curDis < minDis) {\n        ans[0] = l - 1;\n        ans[1] = r + 1;\n      }\n    }\n  }\n\n  if (ans[2] == 0) return \"0\";\n\n  return ans[0] + \" \" + ans[1] + \":\" + ans[2];\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "211",
    "title": "寻找最大价值的矿堆",
    "examType": "B",
    "score": 200,
    "description": "给你一个由 '0' (空地)、'1' (银矿)、'2'(金矿) 组成的的地图，矿堆只能由上下左右相邻的金矿或银矿连接形成。超出地图范围可以认为是空地。\n假设银矿价值1，金矿价值2 ，请你找出地图中最大价值的矿堆并输出该矿堆的价值。\n",
    "inputDesc": "地图元素信息如：\n22220 00000 00000 11111\n地图范围最大 300*3000 ≤ 地图元素 ≤ 2\n",
    "outputDesc": "矿堆的最大价值\n\n\n本题可以使用深度优先搜索解决。\n首先，根据输入得到一个地图矩阵。\n然后，定义一个visited集合，用于记录访问过的点的坐标，或者将访问过的点赋值为0，避免一些点被二次访问。\n之后，开始遍历矩阵的每一个元素，如果\n那么就可以从该点向上、下、左、右四个方向开始深搜，对于新点依旧按照上面规则判断是否可以继续深搜。\n2023.05.25\n经过测试，本题的深度优先搜索（递归实现）在地图矩阵达到50*50以上时就会发生栈内存溢出，因此本题可以使用深度优先搜索（栈实现）。\n深度优先搜索的栈实现，非常类似于广度优先搜索，其实就是将广度优先搜索的队列结构，换成栈结构，具体区别可以看：\n华为OD机试 - 计算疫情扩散时间（Java & JS & Python）_伏城之外的博客-CSDN博客\n\n在线OJ - 寻找最大价值的矿堆\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class Main {\n  // 地图矩阵\n  static ArrayList<ArrayList<Integer>> matrix;\n\n  // 记录地图矩阵的行数row，列数col\n  static int row;\n  static int col;\n\n  // 上下左右，四个方向的偏移量\n  static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    matrix = new ArrayList<>();\n\n    // 假设存在空行作为输入截止条件\n    //    while (sc.hasNextLine()) {\n    //      String line = sc.nextLine();\n    //\n    //      // 由于本题没有说明输入截止条件，因此使用空行作为输入截止条件\n    //      if (\"\".equals(line)) {\n    //        System.out.println(getResult());\n    //        break;\n    //      } else {\n    //        matrix.add(\n    //            new ArrayList<>(\n    //\n    // Arrays.stream(line.split(\"\")).map(Integer::parseInt).collect(Collectors.toList())));\n    //      }\n    //    }\n\n    // 没有空行作为输入截止条件\n    while (sc.hasNextLine()) {\n      matrix.add(\n          new ArrayList<>(\n              Arrays.stream(sc.nextLine().split(\"\"))\n                  .map(Integer::parseInt)\n                  .collect(Collectors.toList())));\n    }\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    row = matrix.size();\n    if (row == 0) return 0;\n\n    col = matrix.get(0).size();\n\n    // 记录最大矿堆价值\n    int ans = 0;\n\n    // 遍历矩阵元素\n    for (int i = 0; i < row; i++) {\n      for (int j = 0; j < col; j++) {\n        // 如果点(i,j)没有被访问过，且点(i,j)上有矿，则进入深搜\n        if (matrix.get(i).get(j) > 0) {\n          ans = Math.max(ans, dfs(i, j));\n        }\n      }\n    }\n\n    return ans;\n  }\n\n  public static int dfs(int i, int j) {\n    int sum = matrix.get(i).get(j);\n    matrix.get(i).set(j, 0);\n\n    LinkedList<int[]> stack = new LinkedList<>();\n    stack.add(new int[] {i, j});\n\n    while (stack.size() > 0) {\n      int[] pos = stack.removeLast();\n      int x = pos[0], y = pos[1];\n\n      for (int[] offset : offsets) {\n        int newX = x + offset[0];\n        int newY = y + offset[1];\n\n        if (newX >= 0 && newX < row && newY >= 0 && newY < col && matrix.get(newX).get(newY) > 0) {\n          sum += matrix.get(newX).get(newY);\n          matrix.get(newX).set(newY, 0);\n          stack.add(new int[] {newX, newY});\n        }\n      }\n    }\n\n    return sum;\n  }\n}",
      "python": "# 上下左右，四个方向的偏移量\noffsets = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n\n# 广搜\ndef dfs(x, y, matrix, row, col):\n    total = matrix[x][y]\n    matrix[x][y] = 0\n\n    stack = [[x, y]]\n\n    while len(stack) > 0:\n        x, y = stack.pop()\n\n        for offset in offsets:\n            newX = x + offset[0]\n            newY = y + offset[1]\n\n            if row > newX >= 0 and col > newY >= 0 and matrix[newX][newY] > 0:\n                total += matrix[newX][newY]\n                matrix[newX][newY] = 0\n                stack.append([newX, newY])\n\n    return total\n\n\n# 算法入口\ndef getResult(matrix):\n    # 记录地图矩阵的行数row\n    row = len(matrix)\n\n    if row == 0:\n        return 0\n\n    # 记录地图矩阵的行数col\n    col = len(matrix[0])\n\n    # 记录最大矿堆价值\n    ans = 0\n\n    # 遍历矩阵元素\n    for i in range(row):\n        for j in range(col):\n            # 如果点(i,j)没有被访问过，且点(i,j)上有矿，则进入深搜\n            if matrix[i][j] > 0:\n                ans = max(ans, dfs(i, j, matrix, row, col))\n\n    return ans\n\n\n# 输入获取\nmatrix = []\n\n# 假设存在空行作为输入截止条件\n# while True:\n#     line = input()\n#\n#     if line == \"\":\n#         print(getResult(matrix))\n#         break\n#     else:\n#         matrix.append(list(map(int, list(line))))\n\n# 没有空行作为输入截止条件\nwhile True:\n    try:\n        matrix.append(list(map(int, list(input()))))\n    except:\n        break\nprint(getResult(matrix))",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "212",
    "title": "抢7游戏",
    "examType": "B",
    "score": 200,
    "description": "A、B两个人玩抢7游戏，游戏规则为：\nA先报一个起始数字 X（10 ≤ 起始数字 ≤ 10000），B报下一个数字 Y （X - Y < 3），A再报一个数字 Z（Y - Z < 3），以此类推，直到其中一个抢到7，抢到7即为胜者；\n在B赢得比赛的情况下，一共有多少种组合？\n",
    "inputDesc": "起始数字 M\n10 ≤ M ≤ 10000\n如：\n100\n",
    "outputDesc": "B能赢得比赛的组合次数\n\n\n下面模拟M为10~14时，B能够获胜的一些情况：\n\n看完上图，我们可以发现：\n抛开A首次叫的数字M，剩下的 M - 7 长度（上图中有颜色的），必须发生奇数次叫，才能保证B获胜。\n原因是：奇数次叫中，第一次必然是B，由于是奇数次，因此最后一次也必然是B，比如\nBAB\nBABAB\n都是奇数次。\n因此我们只需要将整数 M - 7 划分为奇数块即可，且每块取值只能是1或2。\n\n我们可以假设初始时，一共发生了M-7次叫（M-7可能不是奇数），即每块长度都是1，此时我们设\n然后检查 oneCount + twoCount 的和（一共叫几次）：\n之后，我们应该合并两个1为一个2，即：\n此时就会产生一种新的叫声情况，将新的oneCount和twoCount带入前面逻辑，进行循环处理，知道oneCount < 0 停止。\n\n本题的数量级很大，10 ≤ M ≤ 10000，因此满足要求的情况数量可能极端大，此时我们应该使用大数记录结果。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n  static BigInteger[] factor;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n\n    initFactor(m - 7);\n\n    int oneCount = m - 7;\n    int twoCount = 0;\n\n    // 记录B赢的情况数\n    BigInteger ans = new BigInteger(\"0\");\n\n    while (oneCount >= 0) {\n      // 叫的次数为奇数时，才能B赢\n      if ((oneCount + twoCount) % 2 != 0) {\n        ans = ans.add(getPermutationCount(oneCount, twoCount));\n      }\n\n      // 合并两个1为一个2\n      oneCount -= 2;\n      twoCount += 1;\n    }\n\n    System.out.println(ans);\n  }\n\n  // 求解不重复的全排列数\n  public static BigInteger getPermutationCount(int oneCount, int twoCount) {\n    if (oneCount == 0 || twoCount == 0) { // 即 1 1 1 1 1 或 2 2 2 这种情况，此时只有一种排列\n      return new BigInteger(\"1\");\n    } else {\n      // 排列数去重，比如 1 1 1 2 2 的不重复排列数为 5! / 3! / 2! = 10\n      return factor[oneCount + twoCount].divide(factor[oneCount].multiply(factor[twoCount]));\n    }\n  }\n\n  // 阶乘\n  public static void initFactor(int n) {\n    factor = new BigInteger[n + 1];\n    factor[0] = new BigInteger(\"1\");\n    for (int i = 1; i <= n; i++) {\n      factor[i] = factor[i - 1].multiply(new BigInteger(i + \"\"));\n    }\n  }\n}",
      "python": "import decimal  # 超大数运算内置库\nfrom decimal import Decimal\ndecimal.setcontext(decimal.Context(prec=2500))  # 设置超大数精度\n\nm = int(input())\nfactor = []\n\n\n# 阶乘\ndef initFactor(n):\n    factor.append(Decimal(1))\n\n    for i in range(1, n+1):\n        factor.append(Decimal(i) * factor[-1])\n\n\n# 求解不重复的全排列数\ndef getPermutationCount(oneCount, twoCount):\n    if oneCount == 0 or twoCount == 0:\n        # 即 1 1 1 1 1 或 2 2 2 这种情况，此时只有一种排列\n        return 1\n    else:\n        # 排列数去重，比如 1 1 1 2 2 的不重复排列数为 5! / 3! / 2! = 10\n        return factor[oneCount + twoCount] / factor[oneCount] / factor[twoCount]\n\n\ndef getResult():\n    initFactor(m - 7)\n\n    oneCount = m - 7\n    twoCount = 0\n\n    # 记录B赢的情况数\n    ans = Decimal(0)\n\n    while oneCount >= 0:\n        # 叫的次数为奇数时，才能B赢\n        if (oneCount + twoCount) % 2 != 0:\n            ans += getPermutationCount(oneCount, twoCount)\n\n        # 合并两个1为一个2\n        oneCount -= 2\n        twoCount += 1\n\n    return ans\n\n\nprint(\"{:.0f}\".format(getResult()))",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "213",
    "title": "无向图染色",
    "examType": "B",
    "score": 200,
    "description": "给一个无向图染色，可以填红黑两种颜色，必须保证相邻两个节点不能同时为红色，输出有多少种不同的染色方案？\n",
    "inputDesc": "第一行输入M(图中节点数) N(边数)\n后续N行格式为：V1 V2表示一个V1到V2的边。\n数据范围：1 <= M <= 15,0 <= N <= M * 3，不能保证所有节点都是连通的。\n",
    "outputDesc": "输出一个数字表示染色方案的个数。\n\n4个节点，4条边，1号节点和2号节点相连，\n2号节点和4号节点相连，3号节点和4号节点相连，\n1号节点和3号节点相连，\n若想必须保证相邻两个节点不能同时为红色，总共7种方案。\n\n2022.12.25 更正解析说明，感谢Andy___Zhong指出错误。\n本题其实就是求解连通图的染色方案，\n目前我想到的最好方式是暴力法，即通过回溯算法，求解出染红节点的全组合，\nn个数的全组合数量一共有 (2^n) - 1。\n比如：1,2,3的全组合情况有：1、2、3、12、13、23、123，即 (2^3) - 1 = 7个。\n本题中节点一共有m个，而1 <= m <= 15，即最多有 (2^15) - 1 = 32767 个组合情况，这个数量级不算多。 因此暴力法可行。\n\n我们需要尝试对组合中的节点进行染红色，但是相邻节点不能同时染成红色。因此，在求解全组合时，还可以进行剪枝优化，即判断新加入的节点 是否和 已存在的节点相邻，如果相邻，则剪枝，如果不相邻则继续递归。\n\n本题，到此还未结束，因为题目中有一句话：\n不能保证所有节点都是连通的\n这说明什么呢？即对应用例4的情况，用例4对应的无向图如下：\n\n此时一共有8种染色方案如下：\n\n\n\n其实就是先求解无向图的各个连通分量，比如用例4的无向图就有两个连通分量，分别是：\n然后求解各连通分量各自的染色方案，比如\n那么总染色方案数目就是2*4=8种\n\n因此，本题还考察了连通分量的求解。\n连通分量的求解可以使用并查集，关于并查集知识请看：华为机试 - 发广播_伏城之外的博客-CSDN博客\n\n但是本题实现上可以取巧，即不需要使用并查集去求解连通分量，而是完全依赖于暴力，因为不管节点是否在一个连通分量中，还是不在一个连通分量中，他们的染色都要满足：\n相邻节点不能同时为红色\n因此，处于两个连通分量中的节点必然不相连，则必然可以同时染红，因此直接用前面求染红节点组合就可以，不需要用并查集。\n\n补充一个边界用例情况：\n4 3 2 3 2 4 3 4\n输出应该是8\n\n但是节点1和任何其他节点不相连，也没有在边，因此下面代码，统计connect时，即统计每个节点的相邻节点，必然统计不到节点1，即connect[1] 的值为null，因此后续获取节点1的相邻节点时会得到null，此时我们应该要特殊处理null。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n\n    int[][] edges = new int[n][2];\n    for (int i = 0; i < n; i++) {\n      edges[i][0] = sc.nextInt();\n      edges[i][1] = sc.nextInt();\n    }\n\n    System.out.println(getResult(edges, m));\n  }\n\n  /**\n   * @param edges 边，即[v1, v2]\n   * @param m 点数量\n   * @return\n   */\n  public static int getResult(int[][] edges, int m) {\n    // connect用于存放每个节点的相邻节点\n    HashMap<Integer, HashSet<Integer>> connect = new HashMap<>();\n\n    for (int[] edge : edges) {\n      connect.putIfAbsent(edge[0], new HashSet<>());\n      connect.get(edge[0]).add(edge[1]);\n\n      connect.putIfAbsent(edge[1], new HashSet<>());\n      connect.get(edge[1]).add(edge[0]);\n    }\n\n    // 节点从index=1开始，必有count=1个的全黑染色方案\n    return dfs(connect, m, 1, 1, new LinkedList<>());\n  }\n\n  // 该方法用于求解给定多个节点染红的全组合数\n  public static int dfs(\n      HashMap<Integer, HashSet<Integer>> connect,\n      int m,\n      int index,\n      int count,\n      LinkedList<HashSet<Integer>> path) {\n    if (path.size() == m) return count;\n\n    outer:\n    for (int i = index; i <= m; i++) {\n      // 如果新加入节点i和已有节点j相邻，则说明新加入节点不能染成红色，需要进行剪枝\n      for (HashSet<Integer> p : path) {\n        if (p.contains(i)) continue outer;\n      }\n\n      count++;\n\n      if (connect.containsKey(i)) {\n        path.addLast(connect.get(i));\n        count = dfs(connect, m, i + 1, count, path);\n        path.removeLast();\n      } else {\n        count = dfs(connect, m, i + 1, count, path);\n      }\n    }\n\n    return count;\n  }\n}",
      "python": "# 输入获取\nm, n = map(int, input().split())\narr = [list(map(int, input().split())) for i in range(n)]\n\n\n# 算法入口\ndef getResult(arr, m):\n    \"\"\"\n    :param arr: 边，即[v1, v2]\n    :param m: 点数量\n    :return: 染色方案数\n    \"\"\"\n\n    # connect用于存放每个节点的相邻节点\n    connect = {}\n\n    for v1, v2 in arr:\n        if connect.get(v1) is None:\n            connect[v1] = set()\n        connect[v1].add(v2)\n\n        if connect.get(v2) is None:\n            connect[v2] = set()\n        connect[v2].add(v1)\n\n    # 节点从1开始\n    return dfs(m, 1, [], 1, connect)\n\n\n# 求解染红节点的全组合情况\ndef dfs(m, index, path, count, connect):\n    \"\"\"\n    :param m: 点数量，点从1计数\n    :param index: 当前第几个点\n    :param path: 保存点的容器\n    :param count: 染色方案数量\n    :param connect: 每个节点的相邻节点\n    :return: 染色方案数量\n    \"\"\"\n    if len(path) == m:\n        return count\n\n    flag = False\n\n    for i in range(index, m + 1):\n        #  如果新加入节点和已有节点相邻，则说明新加入节点不能染成红色，需要进行剪枝\n        for p in path:\n            if i in p:\n                flag = True\n                break\n\n        if flag:\n            flag = False\n            continue\n\n        count += 1\n\n        if connect.get(i) is not None:\n            path.append(connect.get(i))\n            count = dfs(m, i + 1, path, count, connect)\n            path.pop()\n        else:\n            count = dfs(m, i + 1, path, count, connect)\n\n    return count\n\n\n# 算法调用\nprint(getResult(arr, m))",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet m, n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [m, n] = lines[0].split(\" \").map(Number);\n  }\n\n  if (n !== undefined && lines.length === n + 1) {\n    const arr = lines.slice(1).map((line) => line.split(\" \").map(Number));\n\n    console.log(getResult(arr, m));\n\n    lines.length = 0;\n  }\n});\n\n/**\n *\n * @param {*} arr 边，即[v1, v2]\n * @param {*} m 点数量\n */\nfunction getResult(arr, m) {\n  // connect用于存放每个节点的相邻节点\n  const connect = {};\n\n  for (let [v1, v2] of arr) {\n    connect[v1] ? connect[v1].add(v2) : (connect[v1] = new Set([v2]));\n    connect[v2] ? connect[v2].add(v1) : (connect[v2] = new Set([v1]));\n  }\n\n  // 必有一种全黑的染色方案\n  let count = 1;\n\n  // 求解染红节点的全组合情况\n  function dfs(m, index, path) {\n    if (path.length === m) return;\n\n    outer: for (let i = index; i <= m; i++) {\n      // 如果新加入节点和已有节点相邻，则说明新加入节点不能染成红色，需要进行剪枝\n      for (let j = 0; j < path.length; j++) {\n        if (path[j].has(i)) continue outer;\n      }\n\n      count++;\n\n      if (connect[i] != undefined) {\n        path.push(connect[i]);\n        dfs(m, i + 1, path);\n        path.pop();\n      } else {\n        dfs(m, i + 1, path);\n      }\n    }\n  }\n\n  // 节点从1开始\n  dfs(m, 1, []);\n\n  return count;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "214",
    "title": "最小循环子数组",
    "examType": "B",
    "score": 200,
    "description": "给定一个由若干整数组成的数组nums，请检查数组是否是由某个子数组重复循环拼接而成，请输出这个最小的子数组。\n",
    "inputDesc": "第一行输入数组中元素个数n，1 ≤ n ≤ 100000\n第二行输入数组的数字序列nums，以空格分割，0 ≤ nums[i] < 10\n",
    "outputDesc": "输出最小的子数组的数字序列，以空格分割；\n\n数组本身是其最大的子数组，循环1次可生成的自身；\n\n\n本题可以转化为最小重复子串问题，利用KMP算法求解。\n\n比如，有一个字符串\"abababab\"，该字符串可以看成是某个子串重复多次产生的，比如这个重复子串可以是\"ab\"，也可以是\"abab\"。其中\"ab\"就是最小重复子串。\n\n而求解最小重复子串问题，具有一定的技巧：\n字符串S，长度为n，如果确定了S是由某子串重复产生的，则我们可以求解求解出字符串S的最长相同前后缀的长度m，则n-m就是最小重复子串的长度，而字符串S的0~n-m范围的子串就是其最小重复子串。\n\n上面逻辑中，由一个“最长相同前后缀”的概念，首先大家需要知道字符串s的前缀、后缀的定义：\n比如我们可以列出字符串\"abababab\"的所有前、后缀：\n先画图看下几个例子：\n长度为1的前缀（绿色部分）、后缀（橙色部分）\n\n长度为2的前缀（绿色部分）、后缀（橙色部分）\n\n长度为3的前缀（绿色部分）、后缀（橙色部分）\n\n长度为6的前缀（绿色部分），后缀（橙色部分）\n\n所有的前后缀情况如下表：\n根据上面表，我们可以知道，\n最长且相同的前、后缀是，长度为6的\"ababab\"\n\n那么根据前面的技巧，\n如果字符串s是由最小重复子串x重复产生的，则最小重复子串x的长度 = s.length - 最长相同前后缀.length\n即字符串\"abababab\"的最小重复子串长度为2。\n\n下面我们来推导下，为什么：最小重复子串的长度 = s.length - 最长相同前后缀.length\n假设，字符串S的最小重复子串为x，且字符串S一共由k个最小重复子串x组成\n\n那么字符串S的最长相同前、后缀必然是(k-1)个x\n\n这里，大家推导一下，\n假设上面：\n前缀（绿色部分）再扩展一点，即侵入最后一个x串的左边部分，那么为了保持相同的前后缀，则后缀部分（橙色部分）必然需要再侵入第一个x的右边部分\n那么有没有办法将x分为左L、右R两部分，使得下面等式成立呢？\n( k - 1) * x + L == R + ( k - 1) * x；其中L + R == x\n我们再简化下上面等式，即将(k-1) * x 替换为Y\nY + L == R + Y；其中L + R == x\n其实上面等式的唯一成立条件就是：L = R\n但是这是不可能的，因为x本身已经是最小重复子串了，因此本身不可能是由两个重复部分组成的。\n\n现在，我们已经验证了：\n如果字符串s是由最小重复子串x重复产生的，则最小重复子串x的长度 = s.length - 最长相同前后缀.length\n\n那么，接下来，还有两个难点要解决：\n1、如何求解字符串的最长相同前后缀的长度\n关于最长相同前后缀的长度求解，我们可以基于KMP算法求解，具体请看：\n算法设计 - KMP算法_伏城之外的博客-CSDN博客\n中前缀表生成逻辑，以及getNext代码实现的逻辑。\n2、如何证明一个字符串s是重复子串x生成的\n假设字符串S是重复子串产生的，字符串S的长度为n，其最长相同前后缀长度为m，则 n - m 就是最小重复子串的长度，则这个最小重复字符串长度一定可以被字符串长度整除。\n因此，我们只需要验证 n % (n - m) == 0 即可判断字符串S是否是重复的。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(getResult(n, nums));\n  }\n\n  public static String getResult(int n, int[] nums) {\n    // KMP算法 前缀表求解\n    int[] next = getNext(n, nums);\n\n    // 最长相同前后缀长度\n    int m = next[n - 1];\n\n    // 最小重复子串的长度\n    int len = n % (n - m) == 0 ? n - m : n;\n\n    StringJoiner sj = new StringJoiner(\" \");\n    for (int i = 0; i < len; i++) sj.add(nums[i] + \"\");\n    return sj.toString();\n  }\n\n  public static int[] getNext(int n, int[] nums) {\n    int[] next = new int[n];\n\n    int j = 1;\n    int k = 0;\n\n    while (j < n) {\n      if (nums[j] == nums[k]) {\n        next[j] = k + 1;\n        j++;\n        k++;\n      } else {\n        if (k > 0) {\n          k = next[k - 1];\n        } else {\n          j++;\n        }\n      }\n    }\n\n    return next;\n  }\n}",
      "python": "# 输入获取\nn = int(input())\nnums = list(map(int, input().split()))\n\n\ndef getNext():\n    nxt = [0] * n\n\n    j = 1\n    k = 0\n\n    while j < n:\n        if nums[j] == nums[k]:\n            nxt[j] = k + 1\n            j += 1\n            k += 1\n        else:\n            if k > 0:\n                k = nxt[k - 1]\n            else:\n                j += 1\n\n    return nxt\n\n\n# 算法入口\ndef getResult():\n    # KMP算法 前缀表求解\n    nxt = getNext()\n\n    # 最长相同前后缀长度\n    m = nxt[n-1]\n\n    # 最小重复子串的长度\n    length = n - m if n % (n - m) == 0 else n\n\n    return \" \".join(map(str, nums[0:length]))\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "215",
    "title": "最长的顺子",
    "examType": "B",
    "score": 200,
    "description": "斗地主起源于湖北十堰房县，据说是一位叫吴修全的年轻人根据当地流行的扑克玩法“跑得快”改编的，如今已风靡整个中国，并流行于互联网上。\n牌型：单顺，又称顺子，最少5张牌，最多12张牌(3…A)不能有2，也不能有大小王，不计花色。\n例如： 3-4-5-6-7-8，7-8-9-10-J-Q，3-4-5-6-7-8-9-10-J-Q-K-A\n可用的牌 3<4<5<6<7<8<9<10<J<Q<K<A<2<B(小王)<C(大王)，每种牌除大小王外有四种花色\n(共有13×4+2张牌)\n输入：\n手上有的牌已经出过的牌(包括对手出的和自己出的牌)\n输出：\n对手可能构成的最长的顺子(如果有相同长度的顺子，输出牌面最大的那一个)，如果无法构成顺子，则输出 NO-CHAIN。\n",
    "inputDesc": "输入的第一行为当前手中的牌\n输入的第二行为已经出过的牌\n",
    "outputDesc": "最长的顺子\n\n本题我的解题思路分为两步：\n首先，对手的牌 = 总牌 - 我的牌 - 已打出的牌\n这里主要难点在于，如何记录牌面对应的牌数量。我的思路是：\n定义一个数组count，将数组count的索引和牌面关联（定义一个字典mapToV），数组count的元素值就是对应牌面的数量。\n这样可以得出一个数组：\n然后，就可以很简单的完成：对手的牌 = 总牌 - 我的牌 - 已打出的牌\n\n比如用例1，对手的牌就可以表示为：\nint[] count = {0, 0, 0, 1, 1, 2, 2, 0, 3, 3, 3, 3, 3, 3, 3, 0, 4, 1, 1};\n接下来我们可以定义一个 L 指针，作为顺子的左边界，L指针的运动范围是count数组的索引3~索引10。\n因为，顺子只能由牌面3~牌面A组成，因此左边界起始位置是牌面3，即索引3。而顺子至少要由5张牌组成，因此，左边界的结束位置是牌面10，即索引10，对应的顺子是10,J,Q,K,A。\n之后，定义一个临时右边界指针R，区间[L,R]之间就是顺子的范围，R的从L位置开始扫描：\n当顺子发生中断，则下一次L的扫描位置，应该是R+1，比如下面标红的范围，L=3，R=6，当R=7时，顺子中断，则下个顺子从L=4位置开始扫描的话，依旧不能组成顺子，因此我们应该让下个顺子的L直接跳到R+1=8的位置开始扫描。\nint[] count = {0, 0, 0, 1, 1, 2, 2, 0, 3, 3, 3, 3, 3, 3, 3, 0, 4, 1, 1};\n最后，将最长的顺子输出即可。\n需要注意的是，我们可以在上面过程中，实时保存最长顺子，当遇到同长度的顺子时，必然是后面的顺子更优。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String[] my = sc.nextLine().split(\"-\");\n    String[] used = sc.nextLine().split(\"-\");\n\n    System.out.println(getResult(my, used));\n  }\n\n  public static String getResult(String[] my, String[] used) {\n    // 牌面值 映射为 count列表索引值\n    HashMap<String, Integer> mapToV = new HashMap<>();\n    mapToV.put(\"3\", 3);\n    mapToV.put(\"4\", 4);\n    mapToV.put(\"5\", 5);\n    mapToV.put(\"6\", 6);\n    mapToV.put(\"7\", 7);\n    mapToV.put(\"8\", 8);\n    mapToV.put(\"9\", 9);\n    mapToV.put(\"10\", 10);\n    mapToV.put(\"J\", 11);\n    mapToV.put(\"Q\", 12);\n    mapToV.put(\"K\", 13);\n    mapToV.put(\"A\", 14);\n    mapToV.put(\"2\", 16);\n    mapToV.put(\"B\", 17);\n    mapToV.put(\"C\", 18);\n\n    // count每个索引值对应一个牌面值，count元素值就是对应牌面的数量\n    // 牌面值             3  4  5  6  7  8  9  10 J  Q  K  A     2  B  C\n    // 索引值             3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18\n    int[] count = {0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 1, 1};\n\n    // count列表索引值 隐射为 牌面值\n    HashMap<Integer, String> mapToK = new HashMap<>();\n    mapToK.put(3, \"3\");\n    mapToK.put(4, \"4\");\n    mapToK.put(5, \"5\");\n    mapToK.put(6, \"6\");\n    mapToK.put(7, \"7\");\n    mapToK.put(8, \"8\");\n    mapToK.put(9, \"9\");\n    mapToK.put(10, \"10\");\n    mapToK.put(11, \"J\");\n    mapToK.put(12, \"Q\");\n    mapToK.put(13, \"K\");\n    mapToK.put(14, \"A\");\n    mapToK.put(16, \"2\");\n    mapToK.put(17, \"B\");\n    mapToK.put(18, \"C\");\n\n    // 总牌数 减去 自己手中牌数\n    for (String k : my) {\n      count[mapToV.get(k)] -= 1;\n    }\n\n    // 总牌数 减去 已打出去的牌数\n    for (String k : used) {\n      count[mapToV.get(k)] -= 1;\n    }\n\n    String ans = \"NO-CHAIN\";\n    int maxLen = 0;\n\n    // l为顺子的左边界，[3,10]，即顺子的左边界值最少是count索引3，最多是count索引10\n    int l = 3;\n    while (l <= 10) {\n      ArrayList<String> tmp = new ArrayList<>();\n      StringJoiner sj = new StringJoiner(\"-\");\n      for (int r = l; r < 16; r++) {\n        // 如果对应牌数>=1，则可以组顺子\n        if (count[r] >= 1) {\n          tmp.add(mapToK.get(r));\n          sj.add(mapToK.get(r));\n        } else {\n          // 如果对应牌数 == 0，则顺子中断\n          // 顺子必须大于五张牌，且总是记录最长，遇到长度相同的，记录后面发现的顺子\n          if (tmp.size() >= 5 && tmp.size() >= maxLen) {\n            maxLen = tmp.size();\n            ans = sj.toString();\n          }\n          // 顺子中断处+1，即为下一次顺子的起始位置\n          l = r;\n          break;\n        }\n      }\n      l++;\n    }\n\n    return ans;\n  }\n}",
      "python": "# 输入获取\nmy = input().split(\"-\")\nused = input().split(\"-\")\n\n\n# 算法入口\ndef getResult():\n    # 牌面值 映射为 count列表索引值\n    mapToV = {\n        \"3\": 3,\n        \"4\": 4,\n        \"5\": 5,\n        \"6\": 6,\n        \"7\": 7,\n        \"8\": 8,\n        \"9\": 9,\n        \"10\": 10,\n        \"J\": 11,\n        \"Q\": 12,\n        \"K\": 13,\n        \"A\": 14,\n        \"2\": 16,\n        \"B\": 17,\n        \"C\": 18\n    }\n\n    # count每个索引值对应一个牌面值，count元素值就是对应牌面的数量\n    # 牌面值           3  4  5  6  7  8  9  10 J  Q  K  A     2  B  C\n    # 索引值           3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18\n    count = [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 1, 1]\n\n    # count列表索引值 隐射为 牌面值\n    mapToK = {\n        3: \"3\",\n        4: \"4\",\n        5: \"5\",\n        6: \"6\",\n        7: \"7\",\n        8: \"8\",\n        9: \"9\",\n        10: \"10\",\n        11: \"J\",\n        12: \"Q\",\n        13: \"K\",\n        14: \"A\",\n        16: \"2\",\n        17: \"B\",\n        18: \"C\"\n    }\n\n    # 总牌数 减去 自己手中牌数\n    for k in my:\n        count[mapToV[k]] -= 1\n\n    # 总牌数 减去 已打出去的牌数\n    for k in used:\n        count[mapToV[k]] -= 1\n\n    ans = \"NO-CHAIN\"\n    maxLen = 0\n\n    # l为顺子的左边界，[3,10]，即顺子的左边界值最少是count索引3，最多是count索引10\n    l = 3\n    while l <= 10:\n        tmp = []\n        for r in range(l, 16):\n            # 如果对应牌数>=1，则可以组顺子\n            if count[r] >= 1:\n                tmp.append(mapToK[r])\n            # 如果对应牌数 == 0，则顺子中断\n            else:\n                # 顺子必须大于五张牌，且总是记录最长，遇到长度相同的，记录后面发现的顺子\n                if len(tmp) >= 5 and len(tmp) >= maxLen:\n                    maxLen = len(tmp)\n                    ans = \"-\".join(tmp)\n                # 顺子中断处+1，即为下一次顺子的起始位置\n                l = r\n                break\n        l += 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const my = lines[0].split(\"-\");\n    const used = lines[1].split(\"-\");\n    console.log(getResult(my, used));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(my, used) {\n  // 牌面值 映射为 count列表索引值\n  const mapToV = new Map([\n    [\"3\", 3],\n    [\"4\", 4],\n    [\"5\", 5],\n    [\"6\", 6],\n    [\"7\", 7],\n    [\"8\", 8],\n    [\"9\", 9],\n    [\"10\", 10],\n    [\"J\", 11],\n    [\"Q\", 12],\n    [\"K\", 13],\n    [\"A\", 14],\n    [\"2\", 16],\n    [\"B\", 17],\n    [\"C\", 18],\n  ]);\n\n  /* count每个索引值对应一个牌面值，count元素值就是对应牌面的数量\n     牌面值               3  4  5  6  7  8  9  10 J  Q  K  A     2  B  C\n     索引值               3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 */\n  const count = [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 1, 1];\n\n  // count列表索引值 隐射为 牌面值\n  const mapToK = new Map([\n    [3, \"3\"],\n    [4, \"4\"],\n    [5, \"5\"],\n    [6, \"6\"],\n    [7, \"7\"],\n    [8, \"8\"],\n    [9, \"9\"],\n    [10, \"10\"],\n    [11, \"J\"],\n    [12, \"Q\"],\n    [13, \"K\"],\n    [14, \"A\"],\n    [16, \"2\"],\n    [17, \"B\"],\n    [18, \"C\"],\n  ]);\n\n  // 总牌数 减去 自己手中牌数\n  for (let k of my) {\n    count[mapToV.get(k)] -= 1;\n  }\n\n  // 总牌数 减去 已打出去的牌数\n  for (let k of used) {\n    count[mapToV.get(k)] -= 1;\n  }\n\n  let ans = \"NO-CHAIN\";\n  let maxLen = 0;\n\n  // l为顺子的左边界，[3,10]，即顺子的左边界值最少是count索引3，最多是count索引10\n  let l = 3;\n  while (l <= 10) {\n    const tmp = [];\n    for (let r = l; r < 16; r++) {\n      // 如果对应牌数>=1，则可以组顺子\n      if (count[r] >= 1) {\n        tmp.push(mapToK.get(r));\n      } else {\n        // 如果对应牌数 == 0，则顺子中断\n        // 顺子必须大于五张牌，且总是记录最长，遇到长度相同的，记录后面发现的顺子\n        if (tmp.length >= 5 && tmp.length >= maxLen) {\n          maxLen = tmp.length;\n          ans = tmp.join(\"-\");\n        }\n        // 顺子中断处+1，即为下一次顺子的起始位置\n        l = r;\n        break;\n      }\n    }\n    l++;\n  }\n\n  return ans;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "216",
    "title": "服务中心选址",
    "examType": "B",
    "score": 200,
    "description": "一个快递公司希望在一条街道建立新的服务中心。公司统计了该街道中所有区域在地图上的位置，并希望能够以此为依据为新的服务中心选址：使服务中心到所有区域的距离的总和最小。\n给你一个数组positions，其中positions[i] = [left, right] 表示第 i 个区域在街道上的位置，其中left代表区域的左侧的起点，right代表区域的右侧终点，假设服务中心的位置为location：\n如果第 i 个区域的右侧终点right满足 right < location，则第 i 个区域到服务中心的距离为 location - right；如果第 i 个区域的左侧起点left 满足 left > location，则第 i 个区域到服务中心的距离为left - location；如果第 i 个区域的两侧left，right满足left <= location <= right，则第 i 个区域到服务中心的距离为0\n选择最佳的服务中心位置为location，请返回最佳的服务中心位置到所有区域的距离总和的最小值。\n",
    "inputDesc": "先输入区域数组positions的长度n（1 ≤ n ≤ 10^5）\n接下来 n 行每行输入成对的left和right值，以空格隔开\n-10^9 ＜left ≤ 10^9-10^9 ＜right ≤ 10^9\n",
    "outputDesc": "输出为location\n\n\n根据网友反馈进行分析得出，本题中各区域应该是有交集的。\n我想了很久，如何求解某个点到有交集区域的最小距离和，但是没有什么好的办法，直到我死心准备用暴力法求解时，发现了一丝丝生机。下面是暴力法测试过程：\n测试用例：含区域交集情况\n11 -10 10 1 2 3 4 5 10 6 8 7 12 9 13 15 20 31 41 22 35 34 50\n\nJavaScript暴力实现\n\n可以发现，当服务中心选址10位置时，到各区间距离之和最小为78\n\nJava暴力实现\n\n可以发现，当服务中心选址10位置时，到各区间距离之和最小为78\n\nPython暴力实现\n\n可以发现，当服务中心选址10位置时，到各区间距离之和最小为78\n\n上面暴力法过程中，我首先获得了所有区间中最左边的点min，和最右边的点max，并遍历这两个点之间每一个点作为服务中心地址 i ，并求每个服务中心地址到各区域的距离之和 dis，然后将它们成对打印出来，结果发现一个现象：\n\n随着 服务中心位置 i 的变化，服务中心到各区域的距离之和 dis 呈现上图U型曲线。\n即，一定存在一个 i ，其左边点 i-0.5 的，和其右边点 i+0.5 到各区域的距离和大于它。\n\n因此，我想是否可以用二分法求解，即取min点和max点的中间点mid作为服务中心位置，：\n这样一搞，我们最终就可以找到最低dis的mid点。\n\n2023.04.12 上面的二分策略存在问题，本题要求解凹函数的极值，应该使用三分法求解。\n关于三分法请看：https://blog.csdn.net/qfc_128220/article/details/130097676\n\n2023.04.19 今天又有考友考到这题了，上面解法还是27%通过率。我已经emo了。\n然后我又读了一遍题目，发现：\n难道实际机试系统要求输出的是：服务中心的位置？\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n  static double[][] positions;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    positions = new double[n][2];\n    for (int i = 0; i < n; i++) {\n      positions[i][0] = sc.nextDouble();\n      positions[i][1] = sc.nextDouble();\n    }\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    ArrayList<Double> tmp = new ArrayList<>();\n    for (double[] pos : positions) {\n      tmp.add(pos[0]);\n      tmp.add(pos[1]);\n    }\n    tmp.sort(Double::compareTo);\n\n    double l = tmp.get(0);\n    double r = tmp.get(tmp.size() - 1);\n    double eps = 1e-5;\n\n    while (r - l >= eps) {\n      double k = (r - l) / 3;\n      double ml = l + k;\n      double mr = r - k;\n\n      if (getDistance(ml) < getDistance(mr)) {\n        r = mr;\n      } else {\n        l = ml;\n      }\n    }\n\n    return (int) getDistance(l);\n  }\n\n  public static double getDistance(double t) {\n    double dis = 0;\n    for (double[] pos : positions) {\n      double l = pos[0];\n      double r = pos[1];\n      if (r < t) dis += t - r;\n      else if (t < l) dis += l - t;\n    }\n    return dis;\n  }\n}",
      "python": "import math\n\n# 输入获取\nn = int(input())\npositions = [list(map(float, input().split())) for _ in range(n)]\n\n\n# 算法入口\ndef getResult():\n    tmp = []\n    for pos in positions:\n        tmp.extend(pos)\n    tmp.sort()\n\n    l = tmp[0]\n    r = tmp[-1]\n    eps = 1e-5\n\n    while r - l >= eps:\n        k = (r - l) / 3\n        ml = l + k\n        mr = r - k\n\n        if getDistance(ml) < getDistance(mr):\n            r = mr\n        else:\n            l = ml\n\n    return int(getDistance(l))\n\n\ndef getDistance(t):\n    dis = 0\n    for l, r in positions:\n        if r < t:\n            dis += t - r\n        elif t < l:\n            dis += l - t\n    return dis\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n, positions;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = lines[0] - 0;\n  }\n\n  if (n && lines.length === n + 1) {\n    positions = lines.slice(1).map((line) => line.split(\" \").map(Number));\n    console.log(getResult(n, positions));\n    lines.length = 0;\n  }\n});\n\nfunction getResult() {\n  const tmp = positions.flat(2).sort((a, b) => a - b);\n\n  let l = tmp.at(0);\n  let r = tmp.at(-1);\n  const eps = 1e-5;\n\n  while (r - l >= eps) {\n    const k = (r - l) / 3;\n    const ml = l + k;\n    const mr = r - k;\n\n    if (getDistance(ml) < getDistance(mr)) {\n      r = mr;\n    } else {\n      l = ml;\n    }\n  }\n\n  return Math.floor(getDistance(l));\n}\n\nfunction getDistance(t) {\n  let dis = 0;\n  for (let [l, r] of positions) {\n    if (r < t) dis += t - r;\n    else if (t < l) dis += l - t;\n  }\n  return dis;\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "217",
    "title": "欢乐的周末",
    "examType": "B",
    "score": 200,
    "description": "小华和小为是很要好的朋友，他们约定周末一起吃饭。\n通过手机交流，他们在地图上选择了多个聚餐地点（由于自然地形等原因，部分聚餐地点不可达），求小华和小为都能到达的聚餐地点有多少个？\n",
    "inputDesc": "第一行输入 m 和 n\nm 代表地图的长度n 代表地图的宽度\n第二行开始具体输入地图信息，地图信息包含：\n0 为通畅的道路1 为障碍物（且仅1为障碍物）2 为小华或者小为，地图中必定有且仅有2个 （非障碍物）3 为被选中的聚餐地点（非障碍物）\n",
    "outputDesc": "可以被两方都到达的聚餐地点数量，行末无空格。\n\n地图的长宽为 m 和 n，其中：\n聚餐的地点数量为 k，则\n\n第一行输入地图的长宽为3和4。\n第二行开始为具体的地图，其中：3代表小华和小明选择的聚餐地点；2代表小华或者小明（确保有2个）；0代表可以通行的位置；1代表不可以通行的位置。\n此时两者能都能到达的聚餐位置有2处。\n第一行输入地图的长宽为4和4。\n第二行开始为具体的地图，其中：3代表小华和小明选择的聚餐地点；2代表小华或者小明（确保有2个）；0代表可以通行的位置；1代表不可以通行的位置。\n由于图中小华和小为之间有个阻隔，此时，没有两人都能到达的聚餐地址，故而返回0。\n\n\n本题可以使用并查集解题。\n小华和小为想去同一个餐厅，那么必然小华和小为和餐厅是可以连通，如果它们不能连通，则去不了同一个餐厅。\n因此，我们可以遍历矩阵中每一个元素，将它和其上下左右元素进行连接，需要注意的是如果遍历的元素本身是1，或者其上下左右的元素是1，则不进行连接。\n这样的话，遍历完矩阵后，就可以得到一个连通图。\n同时在遍历矩阵过程中，记录小华、小为（值为2），以及餐厅（值为3）的位置，遍历结束后，首先看小华和小为是不是同一个祖先，若不是，则二者不可连通，就更别说去同一个餐厅了，因此返回0。若二者可以连通，则再看每一个餐厅的祖先是否和华为的祖先相同，若相同则计数++，这样就可以得到小华，小为去的同一个餐厅的数量了。\n2023.11.30 请特别注意下：\n本题输入中\n长度 m 指的是地图矩阵的行数，宽度 n 指的是地图矩阵的列数。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    // 长度m表示行数\n    int m = sc.nextInt();\n    // 宽度n表示列数\n    int n = sc.nextInt();\n\n    int[][] matrix = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    System.out.println(getResult(matrix));\n  }\n\n  public static int getResult(int[][] matrix) {\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n\n    UnionFindSet ufs = new UnionFindSet(rows * cols);\n\n    // 记录小华，小为的位置\n    ArrayList<Integer> huawei = new ArrayList<>();\n    // 记录餐厅的位置\n    ArrayList<Integer> restaurants = new ArrayList<>();\n\n    // 上下左右四个方向偏移量\n    int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for (int i = 0; i < rows; i++) {\n      for (int j = 0; j < cols; j++) {\n        if (matrix[i][j] != 1) {\n          // 二维坐标(i, j) 转为 一维坐标pos\n          int pos = i * cols + j;\n\n          if (matrix[i][j] == 2) {\n            // 收集小华，小为的位置\n            huawei.add(pos);\n          } else if (matrix[i][j] == 3) {\n            // 收集餐厅的位置\n            restaurants.add(pos);\n          }\n\n          for (int[] offset : offsets) {\n            int newI = i + offset[0];\n            int newJ = j + offset[1];\n            if (newI >= 0 && newI < rows && newJ >= 0 && newJ < cols && matrix[newI][newJ] != 1) {\n              // 如果(i,j)和（newI,newJ）位置都是非1，则合并\n              ufs.union(pos, newI * cols + newJ);\n            }\n          }\n        }\n      }\n    }\n\n    // 小华所在连通分量的根\n    int hua_fa = ufs.find(huawei.get(0));\n    // 小为所在连通分量的根\n    int wei_fa = ufs.find(huawei.get(1));\n\n    // 如果小华和小为的不属于同一个连通分量，则二人无法去往相同餐厅\n    if (hua_fa != wei_fa) {\n      return 0;\n    }\n\n    // 找出和小华、小为在同一个连通分量里面的餐厅\n    int ans = 0;\n    for (Integer restaurant : restaurants) {\n      if (ufs.find(restaurant) == hua_fa) {\n        ans++;\n      }\n    }\n\n    return ans;\n  }\n}\n\n// 并查集实现\nclass UnionFindSet {\n  int[] fa;\n\n  public UnionFindSet(int n) {\n    fa = new int[n];\n    for (int i = 0; i < n; i++) fa[i] = i;\n  }\n\n  public int find(int x) {\n    if (x != this.fa[x]) {\n      this.fa[x] = this.find(this.fa[x]);\n      return this.fa[x];\n    }\n    return x;\n  }\n\n  public void union(int x, int y) {\n    int x_fa = this.find(x);\n    int y_fa = this.find(y);\n\n    if (x_fa != y_fa) {\n      this.fa[y_fa] = x_fa;\n    }\n  }\n}",
      "python": "# 输入获取\nm, n = map(int, input().split())  # 长度m是行数， 宽度n是列数\nmatrix = [list(map(int, input().split())) for _ in range(m)]\n\n\n# 并查集实现\nclass UnionFindSet:\n    def __init__(self, n):\n        self.fa = [i for i in range(n)]\n\n    def find(self, x):\n        if x != self.fa[x]:\n            self.fa[x] = self.find(self.fa[x])\n            return self.fa[x]\n        return x\n\n    def union(self, x, y):\n        x_fa = self.find(x)\n        y_fa = self.find(y)\n        if x_fa != y_fa:\n            self.fa[y_fa] = x_fa\n\n\n# 算法入口\ndef getResult():\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    ufs = UnionFindSet(rows * cols)\n\n    #  记录小华，小为的位置\n    huawei = []\n    # 记录餐厅的位置\n    restaurants = []\n    # 上下左右四个方向偏移量\n    offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] != 1:\n                # 二维坐标(i, j) 转为 一维坐标pos\n                pos = i * cols + j\n\n                if matrix[i][j] == 2:\n                    # 收集小华，小为的位置\n                    huawei.append(pos)\n                elif matrix[i][j] == 3:\n                    # 收集餐厅的位置\n                    restaurants.append(pos)\n\n                for offset in offsets:\n                    newI = i + offset[0]\n                    newJ = j + offset[1]\n\n                    if 0 <= newI < rows and 0 <= newJ < cols and matrix[newI][newJ] != 1:\n                        # 如果(i,j)和（newI,newJ）位置都是非1，则合并\n                        ufs.union(pos, newI * cols + newJ)\n\n    # 小华所在连通分量的根\n    hua_fa = ufs.find(huawei[0])\n    # 小为所在连通分量的根\n    wei_fa = ufs.find(huawei[1])\n\n    # 如果小华和小为的不属于同一个连通分量，则二人无法去往相同餐厅\n    if hua_fa != wei_fa:\n        return 0\n\n    # 找出和小华、小为在同一个连通分量里面的餐厅\n    ans = 0\n    for r in restaurants:\n        if ufs.find(r) == hua_fa:\n            ans += 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "const rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid (async function () {\n  // 长度m是行数， 宽度n是列数\n  const [m, n] = (await readline()).split(\" \").map(Number);\n\n  const matrix = [];\n  for (let i = 0; i < m; i++) {\n    matrix.push((await readline()).split(\" \").map(Number));\n  }\n\n  console.log(getResult(matrix));\n})();\n\nfunction getResult(matrix) {\n  const rows = matrix.length;\n  const cols = matrix[0].length;\n\n  const ufs = new UnionFindSet(rows * cols);\n\n  // 记录小华，小为的位置\n  const huawei = [];\n  // 记录餐厅的位置\n  const restrant = [];\n\n  // 上下左右四个方向偏移量\n  const offsets = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n  ];\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (matrix[i][j] !== 1) {\n        // 二维坐标(i, j) 转为 一维坐标pos\n        const pos = i * cols + j;\n\n        if (matrix[i][j] === 2) {\n          // 收集小华，小为的位置\n          huawei.push(pos);\n        } else if (matrix[i][j] === 3) {\n          // 收集餐厅的位置\n          restrant.push(pos);\n        }\n\n        for (let [offsetX, offsetY] of offsets) {\n          const newI = i + offsetX;\n          const newJ = j + offsetY;\n          if (\n            newI >= 0 &&\n            newI < rows &&\n            newJ >= 0 &&\n            newJ < cols &&\n            matrix[newI][newJ] != 1\n          ) {\n            // 如果(i,j)和（newI,newJ）位置都是非1，则合并\n            ufs.union(pos, newI * cols + newJ);\n          }\n        }\n      }\n    }\n  }\n\n  const [hua, wei] = huawei;\n\n  // 小华所在连通分量的根\n  const hua_fa = ufs.find(hua);\n\n  // 小为所在连通分量的根\n  const wei_fa = ufs.find(wei);\n\n  // 如果小华和小为的不属于同一个连通分量，则二人无法去往相同餐厅\n  if (hua_fa !== wei_fa) {\n    return 0;\n  }\n\n  // 找出和小华、小为在同一个连通分量里面的餐厅\n  return restrant.filter((r) => ufs.find(r) === hua_fa).length;\n}\n\n// 并查集实现\nclass UnionFindSet {\n  constructor(n) {\n    this.fa = new Array(n).fill(0).map((_, idx) => idx);\n  }\n\n  find(x) {\n    if (x !== this.fa[x]) {\n      return (this.fa[x] = this.find(this.fa[x]));\n    }\n    return x;\n  }\n\n  union(x, y) {\n    const x_fa = this.find(x);\n    const y_fa = this.find(y);\n\n    if (x_fa !== y_fa) {\n      this.fa[y_fa] = x_fa;\n    }\n  }\n}",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "218",
    "title": "猜密码",
    "examType": "B",
    "score": 200,
    "description": "小杨申请了一个保密柜，但是他忘记了密码。只记得密码都是数字，而且所有数字都是不重复的。\n请你根据他记住的数字范围和密码的最小数字数量，帮他算下有哪些可能的组合，规则如下：\n输出的组合都是从可选的数字范围中选取的，且不能重复；输出的密码数字要按照从小到大的顺序排列，密码组合需要按照字母顺序，从小到大的顺序排序。输出的每一个组合的数字的数量要大于等于密码最小数字数量；如果可能的组合为空，则返回“None”\n",
    "inputDesc": "输入的第一行是可能的密码数字列表，数字间以半角逗号分隔 输入的第二行是密码最小数字数量\n",
    "outputDesc": "可能的密码组合，每种组合显示成一行，每个组合内部的数字以半角逗号分隔，从小到大的顺序排列。\n输出的组合间需要按照字典序排序。 比如：2,3,4放到2,4的前面\n\n字典序是指按照单词出现在字典的顺序进行排序的方法，比如：\n\n最小密码数量是两个，可能有三种组合： 2,3 2,4 3,4\n三个密码有一种： 2,3,4\n\n本题是一道求组合问题。可以利用回溯算法求解。\n\n本题求组合时有如下要求：\n\n输出时：\n\n另外本题没有说明输入的数字是否为单位数，因此需要考虑多位数情况。\n\n本题中树层去重的逻辑可以参考：\n华为OD机试 - 篮球比赛（Java & JS & Python & C）-CSDN博客\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  static int[] nums;\n  static int level;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    nums = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n    level = Integer.parseInt(sc.nextLine());\n\n    System.out.println(getResult());\n  }\n\n  public static String getResult() {\n    // 按照数值大小升序，这样后续形成的组合的内部就是按照数值大小升序的\n    Arrays.sort(nums);\n\n    // 求不重复组合\n    ArrayList<String> res = new ArrayList<>();\n    dfs(0, new LinkedList<>(), res);\n\n    if (res.size() > 0) {\n      // 组合间按照字典序排序\n      res.sort(String::compareTo);\n      return String.join(\"\\n\", res);\n    } else {\n      return \"None\";\n    }\n  }\n\n  public static void dfs(int index, LinkedList<String> path, ArrayList<String> res) {\n    if (path.size() >= level) {\n      // 如果path层数到达level层，则记录该组合\n      res.add(String.join(\",\", path));\n    }\n\n    for (int i = index; i < nums.length; i++) {\n      // 树层去重\n      if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n      path.add(nums[i] + \"\");\n      dfs(i + 1, path, res);\n      path.removeLast();\n    }\n  }\n}",
      "python": "# 输入获取\nnums = list(map(int, input().split(\",\")))\nlevel = int(input())\n\n\ndef dfs(index, path, res):\n    if len(path) >= level:\n        # 如果path层数到达level层，则记录该组合\n        res.append(\",\".join(map(str, path)))\n\n    for i in range(index, len(nums)):\n        # 树层去重\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n\n        path.append(nums[i])\n        dfs(i + 1, path, res)\n        path.pop()\n\n\n# 算法入口\ndef getResult():\n    # 按照数值大小升序，这样后续形成的组合的内部就是按照数值大小升序的\n    nums.sort()\n\n    # 求不重复组合\n    res = []\n    dfs(0, [], res)\n\n    if len(res) > 0:\n        # 组合间按照字典序排序\n        res.sort()\n        return \"\\n\".join(res)\n    else:\n        return \"None\"\n\n\n# 调用算法\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "219",
    "title": "竖直四子棋",
    "examType": "B",
    "score": 200,
    "description": "竖直四子棋的棋盘是竖立起来的，双方轮流选择棋盘的一列下子，棋子因重力落到棋盘底部或者其他棋子之上，当一列的棋子放满时，无法再在这列上下子。\n一方的4个棋子横、竖或者斜方向连成一线时获胜。\n现给定一个棋盘和红蓝对弈双方的下子步骤，判断红方或蓝方是否在某一步获胜。\n下面以一个6×5的棋盘图示说明落子过程：\n\n下面给出横、竖和斜方向四子连线的图示：\n\n",
    "inputDesc": "输入为2行，第一行指定棋盘的宽和高，为空格分隔的两个数字；\n第二行依次间隔指定红蓝双方的落子步骤，第1步为红方的落子，第2步为蓝方的落子，第3步为红方的落子，以此类推。\n步骤由空格分隔的一组数字表示，每个数字为落子的列的编号（最左边的列编号为1，往右递增）。用例保证数字均为32位有符号数。\n",
    "outputDesc": "如果落子过程中红方获胜，输出 N,red ；\n如果落子过程中蓝方获胜，输出 N,blue ；\n如果出现非法的落子步骤，输出 N,error。\nN为落子步骤的序号，从1开始。如果双方都没有获胜，输出 0,draw 。\n非法落子步骤有两种，一是列的编号超过棋盘范围，二是在一个已经落满子的列上落子。\nN和单词red、blue、draw、error之间是英文逗号连接。\n\n\n纯逻辑题，我们只需要构造一个矩阵，并按照第二行输入来落子，需要注意的是，当第7个及以后的落子，才可能会产生四连击，因此四连击判断放在step>=7中判断。\n另外，关于四连击的判断，要检查四个方向：\n同时，需要以落子位置为中心，向当前方向两端发散检查。\n\n自测用例\n5 5\n1 2 1 3 1 1 2 4 5 3 3 4 4 2 5 1\n输出：14,blue\n2023.07.31\n考虑到可能存在超过四子连珠的情况，因此isFour函数判断中，对应连续数量判断应该改为>=4更稳妥。\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int[] tmp = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    int n = tmp[0];\n    int m = tmp[1];\n\n    int[] cols = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n    System.out.println(getResult(n, m, cols));\n  }\n\n  /**\n   * @param n 宽 ，矩阵列数\n   * @param m 高，矩阵行数\n   * @param cols 落子的列的编号\n   */\n  public static String getResult(int n, int m, int[] cols) {\n    int r = m;\n    int c = n;\n\n    // 构造棋盘，注意棋盘长宽都+1了，方便后面棋子获取\n    int[][] matrix = new int[r + 1][c + 1];\n\n    // 这里i对应第几步，由于题目是从第1步开始算，而这里 i 从0开始算，因此最终返回要i+1\n    for (int i = 0; i < cols.length; i++) {\n      // cols[i]代表第 i 步下在第几列\n      if (cols[i] < 1 || cols[i] > c) return i + 1 + \",error\";\n\n      // player落子颜色：1代表红色，2代表蓝色\n      int player = i % 2 == 0 ? 1 : 2;\n\n      // 落子逻辑\n      int x = m;\n      int y = cols[i];\n      while (matrix[x][y] > 0) {\n        x--; // 如果当前列底部有棋子，则需要往上查找\n        if (x < 1) return i + 1 + \",error\"; // 如果当前列已经放满棋子，则报错\n      }\n      matrix[x][y] = player; // 如果当前列底部没有棋子，则可以放入\n\n      // i >= 6，即第七步及之后落子时，才可能产生四连击\n      if (i >= 6 && isFour(x, y, player, matrix, r, c)) {\n        return i + 1 + \",\" + (player == 1 ? \"red\" : \"blue\");\n      }\n    }\n\n    // 双方都没有获胜\n    return \"0,draw\";\n  }\n\n  // 上，左，左上，左下\n  static int[][] offsets = {{-1, 0}, {0, -1}, {-1, -1}, {-1, 1}};\n\n  public static boolean isFour(int x, int y, int player, int[][] matrix, int r, int c) {\n    for (int[] offset : offsets) {\n      int len = 1;\n\n      // 向着某个方向延申判断是否存在相同子\n      int x1 = x, y1 = y;\n      while (true) {\n        x1 += offset[0];\n        y1 += offset[1];\n\n        if (x1 >= 1 && x1 <= r && y1 >= 1 && y1 <= c && matrix[x1][y1] == player) {\n          len++;\n        } else {\n          break;\n        }\n      }\n\n      // 向着上面方向的反方向延申判断是否存在相同子（两个相反方向其实处于一条线上）\n      int x2 = x, y2 = y;\n      while (true) {\n        x2 -= offset[0];\n        y2 -= offset[1];\n\n        if (x2 >= 1 && x2 <= r && y2 >= 1 && y2 <= c && matrix[x2][y2] == player) {\n          len++;\n        } else {\n          break;\n        }\n      }\n\n      // 如果此线可以形成四子连击，则直接返回true\n      if (len >= 4) return true;\n    }\n\n    return false;\n  }\n}",
      "python": "# 输入获取\nc, r = map(int, input().split())\ncols = list(map(int, input().split()))\n\n# 构造棋盘，注意棋盘长宽都+1了，方便后面棋子获取\nmatrix = [[0] * (c + 1) for _ in range(r + 1)]\n# 上，左，左上，左下 偏移量\noffsets = ((-1, 0), (0, -1), (-1, -1), (-1, 1))\n\n\ndef isFour(x, y, player):\n    for offsetX, offsetY in offsets:\n        long = 1\n\n        # 向着某个方向延申判断是否存在相同子\n        x1, y1 = x, y\n        while True:\n            x1 += offsetX\n            y1 += offsetY\n            if r >= x1 >= 1 and c >= y1 >= 1 and matrix[x1][y1] == player:\n                long += 1\n            else:\n                break\n\n        # 向着上面方向的反方向延申判断是否存在相同子（两个相反方向其实处于一条线上）\n        x2, y2 = x, y\n        while True:\n            x2 -= offsetX\n            y2 -= offsetY\n            if r >= x2 >= 1 and c >= y2 >= 1 and matrix[x2][y2] == player:\n                long += 1\n            else:\n                break\n\n        # 如果此线可以形成四子连击，则直接返回true\n        if long >= 4:\n            return True\n\n    return False\n\n\n# 算法入口\ndef getResult():\n    # 这里i对应第几步，由于题目是从第1步开始算，而这里 i 从0开始算，因此最终返回要i+1\n    for i in range(len(cols)):\n        #  cols[i]代表第 i 步下在第几列\n        if cols[i] < 1 or cols[i] > c:\n            return f\"{i + 1},error\"\n\n        # player落子颜色：1代表红色，2代表蓝色\n        player = 1 if i % 2 == 0 else 2\n\n        # 落子逻辑\n        x, y = r, cols[i]\n        while matrix[x][y] > 0:\n            x -= 1  # 如果当前列底部有棋子，则需要往上查找\n            if x < 1:\n                return f\"{i + 1},error\"  # 如果当前列已经放满棋子，则报错\n\n        matrix[x][y] = player  # 如果当前列底部没有棋子，则可以放入\n\n        # i >= 6，即第七步及之后落子时，才可能产生四连击\n        if i >= 6 and isFour(x, y, player):\n            return f\"{i + 1},{'red' if player == 1 else 'blue'}\"\n\n    # 双方都没有获胜\n    return \"0,draw\"\n\n\n# 调用算法\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "220",
    "title": "计算误码率",
    "examType": "B",
    "score": 200,
    "description": "误码率是最常用的数据通信传输质量指标。它可以理解为“在多少位数据中出现一位差错”。\n移动通信网络中的误码率主要是指比特误码率，其计算公式如下: 比特误码率=错误比特数/传输总比特数，\n为了简单，我们使用字符串来标识通信的信息，一个字符错误了，就认为出现了一个误码\n输入一个标准的字符串，和一个传输后的字符串，计算误码率\n字符串会被压缩， 例:“2A3B4D5X1Z”表示\"AABBBDDDDXXXXXZ\" 用例会保证两个输入字符串解压后长度一致，解压前的长度不一定一致\n每个生成后的字符串长度<100000000。\n",
    "inputDesc": "两行，分别为两种字符串的压缩形式。\n每行字符串 (压缩后的) 长度<100000\n",
    "outputDesc": "一行，错误的字等数量/展开后的总长度\n\n注意：展开后的字符串不含数字\n\n\n本题最简单的做法就是将压缩字符串解压，然后利用一次for循环，对比两个等长的压缩字符串，看有多少个位置的字符不相同。\n但是本题解压后的字符串，最大长度为1 0000 0000，这个数量级对于O(n)时间复杂度来说也会超时。\n另外，解压后的字符串，内存会占到 1 0000 0000 * 1 byte ≈ 96M, 两个字符串就是将近200M，这种方案在内存上也是不友好的。\n\n因此，我们不应该优先考虑上面方案，而是应该考虑基于压缩字符串找不同字符数量。\n\n我的解题思路如下：\n定义两个变量diff和same，分别用于记录输入的两个字符串中不同字符的数量，以及相同字符的数量。\n以用例1举例：\n\n我们可以比较s1,s2的头部压缩字符串，其中，\n压缩字符串由两部分组成：压缩次数num + 压缩字符c\n当前s1,s2的头部压缩字符串是不等长的，因此我们应该取二者最小长度作为比对长度，即\ncompareCount = min(num1, num2)\n之后，继续检查num1, num2的大小关系，如果二者不等的话：\n然后，s1，s2变为了\n\n然后继续，按照上面逻辑处理，直到s1或s2为空。\n\n当然，为了避免频繁的字符串操作，我们可以将s1,s2解析为灵活度更高的链表，链表节点元素即为压缩字符串转化的对象，类似于下面这种\n{ num: 3, c: 'A' }\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  static class ZipStr {\n    int num;\n    char c;\n\n    public ZipStr(int num, char c) {\n      this.num = num;\n      this.c = c;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String s1 = sc.nextLine();\n    String s2 = sc.nextLine();\n\n    System.out.println(getResult(s1, s2));\n  }\n\n  public static String getResult(String s1, String s2) {\n    LinkedList<ZipStr> link1 = getZipStrLink(s1);\n    LinkedList<ZipStr> link2 = getZipStrLink(s2);\n\n    int diff = 0;\n    int same = 0;\n\n    while (link1.size() > 0) {\n      ZipStr zipStr1 = link1.removeFirst();\n      ZipStr zipStr2 = link2.removeFirst();\n\n      int compareCount = Math.min(zipStr1.num, zipStr2.num);\n\n      if (zipStr1.c != zipStr2.c) {\n        diff += compareCount;\n      } else {\n        same += compareCount;\n      }\n\n      if (zipStr1.num > compareCount) {\n        zipStr1.num -= compareCount;\n        link1.addFirst(zipStr1);\n        continue;\n      }\n\n      if (zipStr2.num > compareCount) {\n        zipStr2.num -= compareCount;\n        link2.addFirst(zipStr2);\n      }\n    }\n\n    return diff + \"/\" + (diff + same);\n  }\n\n  public static LinkedList<ZipStr> getZipStrLink(String s) {\n    LinkedList<ZipStr> link = new LinkedList<>();\n\n    StringBuilder num = new StringBuilder();\n\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n\n      if (c >= '0' && c <= '9') {\n        num.append(c);\n      } else {\n        link.add(new ZipStr(Integer.parseInt(num.toString()), c));\n        num = new StringBuilder();\n      }\n    }\n\n    return link;\n  }\n}",
      "python": "# 输入获取\ns1 = input()\ns2 = input()\n\n\ndef getZipStrLink(s):\n    link = []\n\n    num = []\n\n    for i in range(len(s)):\n        c = s[i]\n\n        if c.isdigit():\n            num.append(c)\n        else:\n            link.append([int(\"\".join(num)), c])\n            num.clear()\n\n    return link\n\n\n# 算法入口\ndef getResult():\n    link1 = getZipStrLink(s1)\n    link2 = getZipStrLink(s2)\n\n    diff = 0\n    same = 0\n\n    while len(link1) > 0:\n        num1, c1 = link1.pop(0)\n        num2, c2 = link2.pop(0)\n\n        compareCount = min(num1, num2)\n\n        if c1 != c2:\n            diff += compareCount\n        else:\n            same += compareCount\n\n        if num1 > num2:\n            link1.insert(0, [num1 - num2, c1])\n        elif num1 < num2:\n            link2.insert(0, [num2 - num1, c2])\n\n    return f\"{diff}/{diff + same}\"\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "221",
    "title": "贪吃的猴子",
    "examType": "B",
    "score": 200,
    "description": "一只贪吃的猴子，来到一个果园，发现许多串香蕉排成一行，每串香蕉上有若干根香蕉。每串香蕉的根数由数组numbers给出。\n猴子获取香蕉，每次都只能从行的开头或者末尾获取，并且只能获取N次，求猴子最多能获取多少根香蕉。\n",
    "inputDesc": "第一行为数组numbers的长度\n第二行为数组numbers的值每个数字通过空格分开\n第三行输入为N，表示获取的次数\n",
    "outputDesc": "按照题目要求能获取的最大数值\n\n\n\n本题我第一个思路是通过分支递归+缓存优化求解\n但是经过测试，1 ≤ numbers.length ≤ 100000 数量级下，递归操作会StackOverflow，缓存cache数组占用的内存会超出限制。\n\n后面思考了一下，无论我们怎么选，左边选择的，以及右边选择的，必然都是连续的，且是从头尾开始的连续，即不可出现下面情况：\n\n\n因此，本题其实可以简化为，将n次分解为左边选择的个数，以及右边选择的个数。\n以用例1画图示：\n初始时，假设左边选择了0个，右边选择了n=3个，（黄色部分代表选择）：\n\n之后，左边选择1个，右边选择2个\n\n之后，左边选择2，右边选择1个\n\n最后，左边选择3个，右边选择0个\n\n\n上面图示逻辑，我们除了需要计算初始时的leftSum和rightSum外，之后的状态均可以基于前一个状态求解，如下图所示\n\n更多细节请看下面代码和注释。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int len = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    int n = Integer.parseInt(sc.nextLine());\n\n    System.out.println(getResult(len, nums, n));\n  }\n\n  public static int getResult(int len, int[] nums, int n) {\n    // 初始时，左边选择0个，因此左边选择的香蕉数为 0\n    int leftSum = 0;\n\n    // 初始时，右边选择n个，因此右边选择的香蕉数为 nums[len-n] ~ nums[len - 1] 这个n个元素之和\n    int rightSum = 0;\n    for (int i = len - n; i < len; i++) {\n      rightSum += nums[i];\n    }\n\n    // 如果选择数n == len，即全选，此时直接返回初始rightSum\n    if (len == n) {\n      return rightSum;\n    }\n\n    // 如果不是全选\n    // sum记录当前选择结果\n    int sum = leftSum + rightSum;\n    // ans记录所有选择结果中最大的\n    int ans = sum;\n\n    // l指向左边将要获得的，即左边获得一个\n    int l = 0;\n    // r指向右边将要失去的，即右边失去一个\n    int r = len - n;\n\n    while (l < n) {\n      sum += nums[l++] - nums[r++];\n      ans = Math.max(ans, sum);\n    }\n\n    return ans;\n  }\n}",
      "python": "# 输入获取\nlength = int(input())\nnums = list(map(int, input().split()))\nn = int(input())\n\n\n# 算法入口\ndef getResult():\n    # 初始时，左边选择0个，因此左边选择的香蕉数为 0\n    leftSum = 0\n    # 初始时，右边选择n个，因此右边选择的香蕉数为 nums[len-n] ~ nums[len - 1] 这个n个元素之和\n    rightSum = sum(nums[length - n:])\n\n    # 如果选择数n == len，即全选，此时直接返回初始rightSum\n    if length == n:\n        return rightSum\n\n    # 如果不是全选\n    # sum记录当前选择结果\n    sumV = leftSum + rightSum\n    # ans记录所有选择结果中最大的\n    ans = sumV\n\n    # l指向左边将要获得的，即左边获得一个\n    l = 0\n    # r指向右边将要失去的，即右边失去一个\n    r = length - n\n\n    while l < n:\n        sumV += nums[l] - nums[r]\n        ans = max(ans, sumV)\n        l += 1\n        r += 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  },
  {
    "id": "222",
    "title": "贪心歌手",
    "examType": "B",
    "score": 200,
    "description": "一个歌手准备从A城去B城参加演出。\n按照合同，他必须在 T 天内赶到歌手途经 N 座城市歌手不能往回走每两座城市之间需要的天数都可以提前获知。歌手在每座城市都可以在路边卖唱赚钱。 经过调研，歌手提前获知了每座城市卖唱的收入预期： 如果在一座城市第一天卖唱可以赚M，后续每天的收入会减少D（第二天赚的钱是 M - D，第三天是 M - 2D ...）。如果收入减少到 0 就不会再少了。歌手到达后的第二天才能开始卖唱。如果今天卖过唱，第二天才能出发。\n贪心的歌手最多可以赚多少钱？\n",
    "inputDesc": "第一行两个数字 T 和 N，中间用空格隔开。\nT 代表总天数，0 < T < 1000N 代表路上经过 N 座城市，0 < N < 100\n第二行 N+1 个数字，中间用空格隔开。代表每两座城市之间耗费的时间。\n其总和 ≤ T。\n接下来 N 行，每行两个数字 M 和 D，中间用空格隔开。代表每个城市的输入预期。\n0 < M < 10000 < D < 100\n",
    "outputDesc": "一个数字。代表歌手最多可以赚多少钱。以回车结束。\n\n总共10天，路上经过2座城市。\n路上共花 1+1+2=4 天\n剩余6天最好的计划是在第一座城市待3天，在第二座城市待3天。\n在第一座城市赚的钱：120 + 100 + 80 = 300\n在第二座城市赚的钱：90 + 80 + 70 = 240\n一共 300 + 240 = 540。\n\n本题歌手必须从A到B，因此输入的第二行各个城市间的花费的路程时间之和roadCost是必须的，即可用于卖唱赚钱的时间 remain 为 T - roadCost。\n\n我们需要规划 remain 时间，合理分配给各个城市，保证时间分配方案能够赚的钱最多。\n按照题目意思，每个城市停留的第一天赚m钱，后面每天减少d，\n每个城市停留Y天，那么这Y天中赚的钱是严格递减的，且最后一天（第Y天）赚的钱最少\n\n假设歌手目前在X市\n如果 x > y，则我们应该将前面赚 y 钱的时间，空闲出来，用于当天赚 x 元，这种替换逻辑，不会改变歌手的行程顺序\n如果 x <= y，则X市就没有必要待下去了，因为继续待下去赚的钱只会比x少\n上面逻辑中，在前面城市（前面时间）中找一个最小赚的钱，非常适合使用优先队列。因此我们可以使用优先队列记录已经赚的钱（按天），如果当天停留会超出remain限制，那么就取出优先队列中最小赚的钱，和当天停留可以赚的钱比较，如果当天停留可以赚更多钱，则弹出优先队列中最小赚的钱（含义是：将赚最少钱的那天时间空出来）。\n\n",
    "examples": [],
    "solution": "",
    "codes": {
      "java": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n  static int t;\n  static int n;\n  static int roadCost;\n  static int[][] mds;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    t = sc.nextInt();\n    n = sc.nextInt();\n\n    // roadCost是A~B城市必需的路程时间\n    roadCost = 0;\n    for (int i = 0; i < n + 1; i++) {\n      roadCost += sc.nextInt();\n    }\n\n    mds = new int[n][2];\n    for (int i = 0; i < n; i++) {\n      mds[i][0] = sc.nextInt();\n      mds[i][1] = sc.nextInt();\n    }\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    // remain是刨去必要的路程时间后，剩余可以用于赚钱的时间\n    int remain = t - roadCost;\n\n    // 如果没有剩余时间可以用，则赚不到钱\n    if (remain <= 0) {\n      return 0;\n    }\n\n    // 优先队列（小顶堆）记录赚到的钱, 即堆顶是某天赚的最少的钱\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> a - b);\n\n    for (int[] md : mds) {\n      // 第一天卖唱可以赚m，后续每天的收入会减少d\n      int m = md[0];\n      int d = md[1];\n\n      // 只要在当前城市还有钱赚，那么就继续待\n      while (m > 0) {\n        // 只有remain天可以赚钱，超出的时间不能赚钱，因此需要比较超出的时间赚的钱m，和前面时间中赚的最少的钱pq.peek\n        if (pq.size() >= remain) {\n          // pq.peek只可能是某座城市停留的最后一天的赚的钱，因为每座城市都是停留的最后一天赚的钱最少\n          if (m > pq.peek()) {\n            // 如果当前城市当天赚的钱m，比前面天里面赚的最少的pq.peek多，那么就赚pq.peek钱的那天时间节约下来，给当天用\n            pq.poll();\n          } else {\n            // 如果当前城市当天赚的钱m，比前面天里面赚的最少的pq.peek还少，则当前城市继续待下去赚的钱只会更少，因此没必要呆下去了\n            break;\n          }\n        }\n\n        // 如果所有城市停留时间没有超出remain天，或者当天是超出的时间，但是比前面赚的最少的一天的赚的更多，则赚m更优\n        pq.add(m);\n\n        //  每天收入减少d\n        m -= d;\n      }\n    }\n\n    return pq.stream().reduce(Integer::sum).orElse(0);\n  }\n}",
      "python": "import heapq\n\n# 输入获取\nt, n = map(int, input().split())\nroadCost = sum(map(int, input().split()))\nmds = [list(map(int, input().split())) for _ in range(n)]\n\n\n# 算法入口\ndef getResult():\n    # remain是刨去必要的路程时间后，剩余可以用于赚钱的时间\n    remain = t - roadCost\n\n    # 如果没有剩余时间可以用，则赚不到钱\n    if remain <= 0:\n        return 0\n\n    # 优先队列（小顶堆）记录赚到的钱, 即堆顶是某天赚的最少的钱\n    pq = []\n    # 第一天卖唱可以赚m，后续每天的收入会减少d\n    for m, d in mds:\n        # 只要在当前城市还有钱赚，那么就继续待\n        while m > 0:\n            # 只有remain天可以赚钱，超出的时间不能赚钱，因此需要比较超出的时间赚的钱m，和前面时间中赚的最少的钱pq[0]\n            if len(pq) >= remain:\n                # pq[0]只可能是某座城市停留的最后一天的赚的钱，因为每座城市都是停留的最后一天赚的钱最少\n                if m > pq[0]:\n                    # 如果当前城市当天赚的钱m，比前面天里面赚的最少的pq[0]多，那么就赚pq[0]钱的那天时间节约下来，给当天用\n                    heapq.heappop(pq)\n                else:\n                    # 如果当前城市当天赚的钱m，比前面天里面赚的最少的pq[0]还少，则当前城市继续待下去赚的钱只会更少，因此没必要呆下去了\n                    break\n\n            # 如果所有城市停留时间没有超出remain天，或者当天是超出的时间，但是比前面赚的最少的一天的赚的更多，则赚m更优\n            heapq.heappush(pq, m)\n\n            # 每天收入减少d\n            m -= d\n\n    return sum(pq)\n\n\n# 算法调用\nprint(getResult())",
      "javascript": "",
      "cpp": "",
      "c": ""
    }
  }
]