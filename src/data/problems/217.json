{
  "id": "217",
  "title": "欢乐的周末",
  "examType": "B",
  "score": 200,
  "description": "小华和小为是很要好的朋友，他们约定周末一起吃饭。\n通过手机交流，他们在地图上选择了多个聚餐地点（由于自然地形等原因，部分聚餐地点不可达），求小华和小为都能到达的聚餐地点有多少个？\n",
  "inputDesc": "第一行输入 m 和 n\nm 代表地图的长度n 代表地图的宽度\n第二行开始具体输入地图信息，地图信息包含：\n0 为通畅的道路1 为障碍物（且仅1为障碍物）2 为小华或者小为，地图中必定有且仅有2个 （非障碍物）3 为被选中的聚餐地点（非障碍物）\n",
  "outputDesc": "可以被两方都到达的聚餐地点数量，行末无空格。\n\n地图的长宽为 m 和 n，其中：\n聚餐的地点数量为 k，则\n\n第一行输入地图的长宽为3和4。\n第二行开始为具体的地图，其中：3代表小华和小明选择的聚餐地点；2代表小华或者小明（确保有2个）；0代表可以通行的位置；1代表不可以通行的位置。\n此时两者能都能到达的聚餐位置有2处。\n第一行输入地图的长宽为4和4。\n第二行开始为具体的地图，其中：3代表小华和小明选择的聚餐地点；2代表小华或者小明（确保有2个）；0代表可以通行的位置；1代表不可以通行的位置。\n由于图中小华和小为之间有个阻隔，此时，没有两人都能到达的聚餐地址，故而返回0。\n\n\n本题可以使用并查集解题。\n小华和小为想去同一个餐厅，那么必然小华和小为和餐厅是可以连通，如果它们不能连通，则去不了同一个餐厅。\n因此，我们可以遍历矩阵中每一个元素，将它和其上下左右元素进行连接，需要注意的是如果遍历的元素本身是1，或者其上下左右的元素是1，则不进行连接。\n这样的话，遍历完矩阵后，就可以得到一个连通图。\n同时在遍历矩阵过程中，记录小华、小为（值为2），以及餐厅（值为3）的位置，遍历结束后，首先看小华和小为是不是同一个祖先，若不是，则二者不可连通，就更别说去同一个餐厅了，因此返回0。若二者可以连通，则再看每一个餐厅的祖先是否和华为的祖先相同，若相同则计数++，这样就可以得到小华，小为去的同一个餐厅的数量了。\n2023.11.30 请特别注意下：\n本题输入中\n长度 m 指的是地图矩阵的行数，宽度 n 指的是地图矩阵的列数。\n",
  "examples": [],
  "solution": "",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    // 长度m表示行数\n    int m = sc.nextInt();\n    // 宽度n表示列数\n    int n = sc.nextInt();\n\n    int[][] matrix = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    System.out.println(getResult(matrix));\n  }\n\n  public static int getResult(int[][] matrix) {\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n\n    UnionFindSet ufs = new UnionFindSet(rows * cols);\n\n    // 记录小华，小为的位置\n    ArrayList<Integer> huawei = new ArrayList<>();\n    // 记录餐厅的位置\n    ArrayList<Integer> restaurants = new ArrayList<>();\n\n    // 上下左右四个方向偏移量\n    int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for (int i = 0; i < rows; i++) {\n      for (int j = 0; j < cols; j++) {\n        if (matrix[i][j] != 1) {\n          // 二维坐标(i, j) 转为 一维坐标pos\n          int pos = i * cols + j;\n\n          if (matrix[i][j] == 2) {\n            // 收集小华，小为的位置\n            huawei.add(pos);\n          } else if (matrix[i][j] == 3) {\n            // 收集餐厅的位置\n            restaurants.add(pos);\n          }\n\n          for (int[] offset : offsets) {\n            int newI = i + offset[0];\n            int newJ = j + offset[1];\n            if (newI >= 0 && newI < rows && newJ >= 0 && newJ < cols && matrix[newI][newJ] != 1) {\n              // 如果(i,j)和（newI,newJ）位置都是非1，则合并\n              ufs.union(pos, newI * cols + newJ);\n            }\n          }\n        }\n      }\n    }\n\n    // 小华所在连通分量的根\n    int hua_fa = ufs.find(huawei.get(0));\n    // 小为所在连通分量的根\n    int wei_fa = ufs.find(huawei.get(1));\n\n    // 如果小华和小为的不属于同一个连通分量，则二人无法去往相同餐厅\n    if (hua_fa != wei_fa) {\n      return 0;\n    }\n\n    // 找出和小华、小为在同一个连通分量里面的餐厅\n    int ans = 0;\n    for (Integer restaurant : restaurants) {\n      if (ufs.find(restaurant) == hua_fa) {\n        ans++;\n      }\n    }\n\n    return ans;\n  }\n}\n\n// 并查集实现\nclass UnionFindSet {\n  int[] fa;\n\n  public UnionFindSet(int n) {\n    fa = new int[n];\n    for (int i = 0; i < n; i++) fa[i] = i;\n  }\n\n  public int find(int x) {\n    if (x != this.fa[x]) {\n      this.fa[x] = this.find(this.fa[x]);\n      return this.fa[x];\n    }\n    return x;\n  }\n\n  public void union(int x, int y) {\n    int x_fa = this.find(x);\n    int y_fa = this.find(y);\n\n    if (x_fa != y_fa) {\n      this.fa[y_fa] = x_fa;\n    }\n  }\n}",
    "python": "# 输入获取\nm, n = map(int, input().split())  # 长度m是行数， 宽度n是列数\nmatrix = [list(map(int, input().split())) for _ in range(m)]\n\n\n# 并查集实现\nclass UnionFindSet:\n    def __init__(self, n):\n        self.fa = [i for i in range(n)]\n\n    def find(self, x):\n        if x != self.fa[x]:\n            self.fa[x] = self.find(self.fa[x])\n            return self.fa[x]\n        return x\n\n    def union(self, x, y):\n        x_fa = self.find(x)\n        y_fa = self.find(y)\n        if x_fa != y_fa:\n            self.fa[y_fa] = x_fa\n\n\n# 算法入口\ndef getResult():\n    rows = len(matrix)\n    cols = len(matrix[0])\n\n    ufs = UnionFindSet(rows * cols)\n\n    #  记录小华，小为的位置\n    huawei = []\n    # 记录餐厅的位置\n    restaurants = []\n    # 上下左右四个方向偏移量\n    offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] != 1:\n                # 二维坐标(i, j) 转为 一维坐标pos\n                pos = i * cols + j\n\n                if matrix[i][j] == 2:\n                    # 收集小华，小为的位置\n                    huawei.append(pos)\n                elif matrix[i][j] == 3:\n                    # 收集餐厅的位置\n                    restaurants.append(pos)\n\n                for offset in offsets:\n                    newI = i + offset[0]\n                    newJ = j + offset[1]\n\n                    if 0 <= newI < rows and 0 <= newJ < cols and matrix[newI][newJ] != 1:\n                        # 如果(i,j)和（newI,newJ）位置都是非1，则合并\n                        ufs.union(pos, newI * cols + newJ)\n\n    # 小华所在连通分量的根\n    hua_fa = ufs.find(huawei[0])\n    # 小为所在连通分量的根\n    wei_fa = ufs.find(huawei[1])\n\n    # 如果小华和小为的不属于同一个连通分量，则二人无法去往相同餐厅\n    if hua_fa != wei_fa:\n        return 0\n\n    # 找出和小华、小为在同一个连通分量里面的餐厅\n    ans = 0\n    for r in restaurants:\n        if ufs.find(r) == hua_fa:\n            ans += 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "const rl = require(\"readline\").createInterface({ input: process.stdin });\nvar iter = rl[Symbol.asyncIterator]();\nconst readline = async () => (await iter.next()).value;\n\nvoid (async function () {\n  // 长度m是行数， 宽度n是列数\n  const [m, n] = (await readline()).split(\" \").map(Number);\n\n  const matrix = [];\n  for (let i = 0; i < m; i++) {\n    matrix.push((await readline()).split(\" \").map(Number));\n  }\n\n  console.log(getResult(matrix));\n})();\n\nfunction getResult(matrix) {\n  const rows = matrix.length;\n  const cols = matrix[0].length;\n\n  const ufs = new UnionFindSet(rows * cols);\n\n  // 记录小华，小为的位置\n  const huawei = [];\n  // 记录餐厅的位置\n  const restrant = [];\n\n  // 上下左右四个方向偏移量\n  const offsets = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n  ];\n\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      if (matrix[i][j] !== 1) {\n        // 二维坐标(i, j) 转为 一维坐标pos\n        const pos = i * cols + j;\n\n        if (matrix[i][j] === 2) {\n          // 收集小华，小为的位置\n          huawei.push(pos);\n        } else if (matrix[i][j] === 3) {\n          // 收集餐厅的位置\n          restrant.push(pos);\n        }\n\n        for (let [offsetX, offsetY] of offsets) {\n          const newI = i + offsetX;\n          const newJ = j + offsetY;\n          if (\n            newI >= 0 &&\n            newI < rows &&\n            newJ >= 0 &&\n            newJ < cols &&\n            matrix[newI][newJ] != 1\n          ) {\n            // 如果(i,j)和（newI,newJ）位置都是非1，则合并\n            ufs.union(pos, newI * cols + newJ);\n          }\n        }\n      }\n    }\n  }\n\n  const [hua, wei] = huawei;\n\n  // 小华所在连通分量的根\n  const hua_fa = ufs.find(hua);\n\n  // 小为所在连通分量的根\n  const wei_fa = ufs.find(wei);\n\n  // 如果小华和小为的不属于同一个连通分量，则二人无法去往相同餐厅\n  if (hua_fa !== wei_fa) {\n    return 0;\n  }\n\n  // 找出和小华、小为在同一个连通分量里面的餐厅\n  return restrant.filter((r) => ufs.find(r) === hua_fa).length;\n}\n\n// 并查集实现\nclass UnionFindSet {\n  constructor(n) {\n    this.fa = new Array(n).fill(0).map((_, idx) => idx);\n  }\n\n  find(x) {\n    if (x !== this.fa[x]) {\n      return (this.fa[x] = this.find(this.fa[x]));\n    }\n    return x;\n  }\n\n  union(x, y) {\n    const x_fa = this.find(x);\n    const y_fa = this.find(y);\n\n    if (x_fa !== y_fa) {\n      this.fa[y_fa] = x_fa;\n    }\n  }\n}",
    "cpp": "",
    "c": ""
  }
}