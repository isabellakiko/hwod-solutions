{
  "id": "214",
  "title": "最小循环子数组",
  "examType": "B",
  "score": 200,
  "description": "给定一个由若干整数组成的数组nums，请检查数组是否是由某个子数组重复循环拼接而成，请输出这个最小的子数组。\n",
  "inputDesc": "第一行输入数组中元素个数n，1 ≤ n ≤ 100000\n第二行输入数组的数字序列nums，以空格分割，0 ≤ nums[i] < 10\n",
  "outputDesc": "输出最小的子数组的数字序列，以空格分割；\n\n数组本身是其最大的子数组，循环1次可生成的自身；\n\n\n本题可以转化为最小重复子串问题，利用KMP算法求解。\n\n比如，有一个字符串\"abababab\"，该字符串可以看成是某个子串重复多次产生的，比如这个重复子串可以是\"ab\"，也可以是\"abab\"。其中\"ab\"就是最小重复子串。\n\n而求解最小重复子串问题，具有一定的技巧：\n字符串S，长度为n，如果确定了S是由某子串重复产生的，则我们可以求解求解出字符串S的最长相同前后缀的长度m，则n-m就是最小重复子串的长度，而字符串S的0~n-m范围的子串就是其最小重复子串。\n\n上面逻辑中，由一个“最长相同前后缀”的概念，首先大家需要知道字符串s的前缀、后缀的定义：\n比如我们可以列出字符串\"abababab\"的所有前、后缀：\n先画图看下几个例子：\n长度为1的前缀（绿色部分）、后缀（橙色部分）\n\n长度为2的前缀（绿色部分）、后缀（橙色部分）\n\n长度为3的前缀（绿色部分）、后缀（橙色部分）\n\n长度为6的前缀（绿色部分），后缀（橙色部分）\n\n所有的前后缀情况如下表：\n根据上面表，我们可以知道，\n最长且相同的前、后缀是，长度为6的\"ababab\"\n\n那么根据前面的技巧，\n如果字符串s是由最小重复子串x重复产生的，则最小重复子串x的长度 = s.length - 最长相同前后缀.length\n即字符串\"abababab\"的最小重复子串长度为2。\n\n下面我们来推导下，为什么：最小重复子串的长度 = s.length - 最长相同前后缀.length\n假设，字符串S的最小重复子串为x，且字符串S一共由k个最小重复子串x组成\n\n那么字符串S的最长相同前、后缀必然是(k-1)个x\n\n这里，大家推导一下，\n假设上面：\n前缀（绿色部分）再扩展一点，即侵入最后一个x串的左边部分，那么为了保持相同的前后缀，则后缀部分（橙色部分）必然需要再侵入第一个x的右边部分\n那么有没有办法将x分为左L、右R两部分，使得下面等式成立呢？\n( k - 1) * x + L == R + ( k - 1) * x；其中L + R == x\n我们再简化下上面等式，即将(k-1) * x 替换为Y\nY + L == R + Y；其中L + R == x\n其实上面等式的唯一成立条件就是：L = R\n但是这是不可能的，因为x本身已经是最小重复子串了，因此本身不可能是由两个重复部分组成的。\n\n现在，我们已经验证了：\n如果字符串s是由最小重复子串x重复产生的，则最小重复子串x的长度 = s.length - 最长相同前后缀.length\n\n那么，接下来，还有两个难点要解决：\n1、如何求解字符串的最长相同前后缀的长度\n关于最长相同前后缀的长度求解，我们可以基于KMP算法求解，具体请看：\n算法设计 - KMP算法_伏城之外的博客-CSDN博客\n中前缀表生成逻辑，以及getNext代码实现的逻辑。\n2、如何证明一个字符串s是重复子串x生成的\n假设字符串S是重复子串产生的，字符串S的长度为n，其最长相同前后缀长度为m，则 n - m 就是最小重复子串的长度，则这个最小重复字符串长度一定可以被字符串长度整除。\n因此，我们只需要验证 n % (n - m) == 0 即可判断字符串S是否是重复的。\n\n",
  "examples": [],
  "solution": "",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = Integer.parseInt(sc.nextLine());\n    int[] nums = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    System.out.println(getResult(n, nums));\n  }\n\n  public static String getResult(int n, int[] nums) {\n    // KMP算法 前缀表求解\n    int[] next = getNext(n, nums);\n\n    // 最长相同前后缀长度\n    int m = next[n - 1];\n\n    // 最小重复子串的长度\n    int len = n % (n - m) == 0 ? n - m : n;\n\n    StringJoiner sj = new StringJoiner(\" \");\n    for (int i = 0; i < len; i++) sj.add(nums[i] + \"\");\n    return sj.toString();\n  }\n\n  public static int[] getNext(int n, int[] nums) {\n    int[] next = new int[n];\n\n    int j = 1;\n    int k = 0;\n\n    while (j < n) {\n      if (nums[j] == nums[k]) {\n        next[j] = k + 1;\n        j++;\n        k++;\n      } else {\n        if (k > 0) {\n          k = next[k - 1];\n        } else {\n          j++;\n        }\n      }\n    }\n\n    return next;\n  }\n}",
    "python": "# 输入获取\nn = int(input())\nnums = list(map(int, input().split()))\n\n\ndef getNext():\n    nxt = [0] * n\n\n    j = 1\n    k = 0\n\n    while j < n:\n        if nums[j] == nums[k]:\n            nxt[j] = k + 1\n            j += 1\n            k += 1\n        else:\n            if k > 0:\n                k = nxt[k - 1]\n            else:\n                j += 1\n\n    return nxt\n\n\n# 算法入口\ndef getResult():\n    # KMP算法 前缀表求解\n    nxt = getNext()\n\n    # 最长相同前后缀长度\n    m = nxt[n-1]\n\n    # 最小重复子串的长度\n    length = n - m if n % (n - m) == 0 else n\n\n    return \" \".join(map(str, nums[0:length]))\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}