{
  "id": "84",
  "title": "矩阵扩散",
  "examType": "A",
  "score": 100,
  "description": "存在一个m×n的二维数组，其成员取值范围为0或1。\n其中值为1的成员具备扩散性，每经过1S，将上下左右值为0的成员同化为1。\n二维数组的成员初始值都为0，将第[i,j]和[k,l]两个个位置上元素修改成1后，求矩阵的所有元素变为1需要多长时间。\n",
  "inputDesc": "输入数据中的前2个数字表示这是一个m×n的矩阵，m和n不会超过1024大小；\n中间两个数字表示一个初始扩散点位置为i,j；\n最后2个数字表示另一个扩散点位置为k,l。\n",
  "outputDesc": "输出矩阵的所有元素变为1所需要秒数。",
  "examples": [
    {
      "input": "4,4,0,0,3,3",
      "output": "3",
      "explanation": "4×4矩阵，扩散点在(0,0)和(3,3)对角，各需3秒到达中心，总共3秒。"
    },
    {
      "input": "3,3,1,1,1,1",
      "output": "2",
      "explanation": "3×3矩阵，两个扩散点重合在中心(1,1)，向四周扩散2秒覆盖全部。"
    },
    {
      "input": "2,2,0,0,1,1",
      "output": "1",
      "explanation": "2×2矩阵，扩散点在对角，1秒后全部覆盖。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**多源BFS**问题。\n\n**算法步骤：**\n1. 初始化矩阵，将两个扩散点标记为1\n2. 将两个扩散点加入BFS队列\n3. 每轮遍历队列中所有点，向上下左右扩散\n4. 新被扩散的点加入下一轮队列\n5. 统计轮数直到所有点被覆盖\n\n**时间复杂度**：O(M×N)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    Integer[] arr =\n        Arrays.stream(sc.next().split(\",\")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    System.out.println(getResult(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]));\n  }\n\n  /**\n   * @param m m m×n的二维数组\n   * @param n n m×n的二维数组\n   * @param i 扩散点位置为i,j\n   * @param j 扩散点位置为i,j\n   * @param k 扩散点位置为k,l\n   * @param l 扩散点位置为k,l\n   * @return 扩散所有点需要的时间\n   */\n  public static int getResult(int m, int n, int i, int j, int k, int l) {\n    int[][] matrix = new int[m][n];\n    matrix[i][j] = 1;\n    matrix[k][l] = 1;\n\n    // count记录未被扩散的点的数量\n    int count = m * n - 2;\n\n    // 多源BFS实现队列\n    LinkedList<int[]> queue = new LinkedList<>();\n    queue.addLast(new int[] {i, j});\n    queue.addLast(new int[] {k, l});\n\n    // 上下左右偏移量\n    int[][] offsets = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    int day = 0;\n    // 如果扩散点没有了，或者所有点已被扩散，则停止循环\n    while (queue.size() > 0 && count > 0) {\n      LinkedList<int[]> newQueue = new LinkedList<>();\n\n      for (int[] pos : queue) {\n        int x = pos[0];\n        int y = pos[1];\n\n        for (int[] offset : offsets) {\n          int newX = x + offset[0];\n          int newY = y + offset[1];\n\n          if (newX >= 0 && newX < m && newY >= 0 && newY < n && matrix[newX][newY] == 0) {\n            // 将点被扩散的时间记录为该点的值\n            matrix[newX][newY] = 1;\n            // 被扩散到的点将变为新的扩散源\n            newQueue.addLast(new int[] {newX, newY});\n            // 未被扩散点的数量--\n            count--;\n          }\n        }\n      }\n\n      queue = newQueue;\n      day++;\n    }\n\n    return day;\n  }\n}",
    "python": "# 输入获取\nm, n, i, j, k, l = map(int, input().split(\",\"))\n\n\n# 算法入口\ndef getResult(m, n, i, j, k, l):\n    \"\"\"\n    :param m: 矩阵行数\n    :param n: 矩阵列数\n    :param i: 扩散点1行号\n    :param j: 扩散点1列好\n    :param k: 扩散点2行号\n    :param l: 扩散点2列号\n    :return: 矩阵的所有元素变为1所需要秒数\n    \"\"\"\n    matrix = [[0 for _ in range(n)] for _ in range(m)]\n    matrix[i][j] = 1\n    matrix[k][l] = 1\n\n    # count记录未被扩散的点的数量\n    count = m * n - 2\n\n    # 多源BFS实现队列\n    queue = [[i, j], [k, l]]\n\n    # 上下左右偏移量\n    offsets = ((1, 0), (-1, 0), (0, 1), (0, -1))\n\n    day = 0\n\n    # 如果扩散点没有了，或者所有点已被扩散，则停止循环\n    while len(queue) > 0 and count > 0:\n        newQueue = []\n\n        for x, y in queue:\n            for offsetX, offsetY in offsets:\n                newX = x + offsetX\n                newY = y + offsetY\n\n                if 0 <= newX < m and 0 <= newY < n and matrix[newX][newY] == 0:\n                    # 将点被扩散的时间记录为该点的值\n                    matrix[newX][newY] = 1\n                    # 被扩散到的点将变为新的扩散源\n                    newQueue.append([newX, newY])\n                    # 未被扩散点的数量--\n                    count -= 1\n\n        queue = newQueue\n        day += 1\n\n    return day\n\n\n# 算法调用\nprint(getResult(m, n, i, j, k, l))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const [m, n, i, j, k, l] = line.split(\",\").map(Number);\n  console.log(getResult(m, n, i, j, k, l));\n});\n\n/**\n * @param {*} m m×n的二维数组\n * @param {*} n m×n的二维数组\n * @param {*} i 扩散点位置为i,j\n * @param {*} j 扩散点位置为i,j\n * @param {*} k 扩散点位置为k,l\n * @param {*} l 扩散点位置为k,l\n */\nfunction getResult(m, n, i, j, k, l) {\n  const matrix = new Array(m).fill(0).map(() => new Array(n).fill(0));\n  matrix[i][j] = 1;\n  matrix[k][l] = 1;\n\n  // count记录未被扩散的点的数量\n  let count = m * n - 2;\n\n  // 多源BFS实现队列\n  let queue = [\n    [i, j],\n    [k, l],\n  ];\n\n  // 上下左右偏移量\n  const offsets = [\n    [1, 0],\n    [-1, 0],\n    [0, 1],\n    [0, -1],\n  ];\n\n  let day = 0;\n\n  // 如果扩散点没有了，或者所有点已被扩散，则停止循环\n  while (queue.length > 0 && count > 0) {\n    const newQueue = [];\n\n    for (const [x, y] of queue) {\n      for (let [offsetX, offsetY] of offsets) {\n        const newX = x + offsetX;\n        const newY = y + offsetY;\n\n        if (\n          newX >= 0 &&\n          newX < m &&\n          newY >= 0 &&\n          newY < n &&\n          matrix[newX][newY] == 0\n        ) {\n          // 将点被扩散的时间记录为该点的值\n          matrix[newX][newY] = 1;\n          // 被扩散到的点将变为新的扩散源\n          newQueue.push([newX, newY]);\n          // 未被扩散点的数量--\n          count--;\n        }\n      }\n    }\n\n    queue = newQueue;\n    day++;\n  }\n\n  return day;\n}",
    "cpp": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    string line;\n    getline(cin, line);\n    \n    int arr[6], idx = 0;\n    stringstream ss(line);\n    string token;\n    while (getline(ss, token, ',')) {\n        arr[idx++] = stoi(token);\n    }\n    \n    int m = arr[0], n = arr[1];\n    int i = arr[2], j = arr[3], k = arr[4], l = arr[5];\n    \n    vector<vector<int>> matrix(m, vector<int>(n, 0));\n    matrix[i][j] = 1;\n    matrix[k][l] = 1;\n    \n    int count = m * n - 2;\n    queue<pair<int,int>> q;\n    q.push({i, j});\n    q.push({k, l});\n    \n    int offsets[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n    int day = 0;\n    \n    while (!q.empty() && count > 0) {\n        int size = q.size();\n        for (int s = 0; s < size; s++) {\n            auto [x, y] = q.front();\n            q.pop();\n            for (auto& off : offsets) {\n                int nx = x + off[0], ny = y + off[1];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && matrix[nx][ny] == 0) {\n                    matrix[nx][ny] = 1;\n                    q.push({nx, ny});\n                    count--;\n                }\n            }\n        }\n        day++;\n    }\n    \n    cout << day << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char line[100];\n    fgets(line, sizeof(line), stdin);\n    \n    int arr[6], idx = 0;\n    char* token = strtok(line, \",\");\n    while (token) {\n        arr[idx++] = atoi(token);\n        token = strtok(NULL, \",\");\n    }\n    \n    int m = arr[0], n = arr[1];\n    int si = arr[2], sj = arr[3], sk = arr[4], sl = arr[5];\n    \n    int matrix[1024][1024] = {0};\n    matrix[si][sj] = 1;\n    matrix[sk][sl] = 1;\n    \n    int count = m * n - 2;\n    int queueX[1024*1024], queueY[1024*1024];\n    int front = 0, rear = 0;\n    queueX[rear] = si; queueY[rear++] = sj;\n    queueX[rear] = sk; queueY[rear++] = sl;\n    \n    int offsets[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n    int day = 0;\n    \n    while (front < rear && count > 0) {\n        int size = rear - front;\n        for (int s = 0; s < size; s++) {\n            int x = queueX[front], y = queueY[front++];\n            for (int d = 0; d < 4; d++) {\n                int nx = x + offsets[d][0], ny = y + offsets[d][1];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && matrix[nx][ny] == 0) {\n                    matrix[nx][ny] = 1;\n                    queueX[rear] = nx;\n                    queueY[rear++] = ny;\n                    count--;\n                }\n            }\n        }\n        day++;\n    }\n    \n    printf(\"%d\\n\", day);\n    return 0;\n}"
  }
}