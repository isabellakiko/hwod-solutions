{
  "id": "120",
  "title": "字符串拼接",
  "examType": "A",
  "score": 200,
  "description": "给定 M（0 < M ≤ 30）个字符（a-z），从中取出任意字符（每个字符只能用一次）拼接成长度为 N（0 < N ≤ 5）的字符串，\n要求相同的字符不能相邻，计算出给定的字符列表能拼接出多少种满足条件的字符串，\n输入非法或者无法拼接出满足条件的字符串则返回0。",
  "inputDesc": "给定的字符列表和结果字符串长度，中间使用空格(\" \")拼接",
  "outputDesc": "满足条件的字符串个数\n输入\n输出\n说明\n只能构成ab,ba。\n输入\n输出\n说明\n可以构成：ab ac ba bc ca cb 。",
  "examples": [
    {
      "input": "ab 2",
      "output": "2",
      "explanation": "可构成ab、ba两种，相邻不同"
    },
    {
      "input": "abc 2",
      "output": "6",
      "explanation": "可构成ab、ac、ba、bc、ca、cb共6种"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**回溯+剪枝**问题。\n\n**核心思路：**\n- 从M个字符中选N个排列\n- 相邻字符不能相同\n- 用used数组标记已使用字符\n\n**剪枝条件：**\n- 当前字符已被使用\n- 当前字符与上一个相同\n- 相同字符去重（排序后跳过）\n\n**算法步骤：**\n1. 遍历所有字符\n2. 检查是否可用（未用且与前一个不同）\n3. 标记使用，递归下一层\n4. 回溯，取消标记\n\n**时间复杂度**：O(M!/(M-N)!)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个Scanner对象来读取用户的输入\n        Scanner sc = new Scanner(System.in);\n        // 读取用户输入的字符串\n        String input = sc.nextLine();\n        // 将输入的字符串按空格分割为两部分，分别为字符串和长度\n        String[] parts = input.split(\" \");\n        String str = parts[0]; // 获取输入的字符串\n        int length = Integer.parseInt(parts[1]); // 将输入的长度部分转换为整数\n\n        // 调用countDistinctStrings方法计算满足条件的不同字符串的数量\n        int count = countDistinctStrings(str, length);\n        // 输出计算结果\n        System.out.println(count);\n    }\n\n    // 计算满足条件的不同字符串的数量\n    public static int countDistinctStrings(String str, int length) {\n        // 创建一个HashSet来存储不同的字符串\n        HashSet<String> set = new HashSet<>();\n        // 创建一个boolean数组来标记字符串中的字符是否已经被使用\n        boolean[] used = new boolean[str.length()];\n        // 调用generateDistinctStrings方法生成满足条件的不同字符串\n        generateDistinctStrings(str, length, \"\", set, used);\n        // 打印生成的所有不同的字符串\n        // for(String str1 : set){\n           // System.out.println(str1);\n        // }\n        // 返回不同字符串的数量\n        return set.size();\n    }\n\n    // 递归生成满足条件的不同字符串\n    public static void generateDistinctStrings(String str, int length, String current, HashSet<String> set, boolean[] used) {\n        // 当生成的字符串长度等于指定长度时，将其加入到HashSet中\n        if (current.length() == length) {\n            set.add(current);\n            return;\n        }\n\n        // 遍历字符串中的字符\n        for (int i = 0; i < str.length(); i++) {\n            // 判断字符是否已经被使用，或者当前字符与前一个字符相同\n            if (used[i] || (current.length() > 0 && current.charAt(current.length() - 1) == str.charAt(i))) {\n                continue; // 如果字符已被使用或与前一个字符相同，则跳过当前字符\n            }\n            used[i] = true; // 标记当前字符为已使用\n            // 递归调用生成下一个字符\n            generateDistinctStrings(str, length, current + str.charAt(i), set, used);\n            used[i] = false; // 取消标记当前字符的使用状态，以便下一次遍历\n        }\n    }\n}",
    "python": "# 导入所需的模块\nfrom collections import defaultdict\n\n# 递归生成满足条件的不同字符串\ndef generate_distinct_strings(s, length, current, result, used):\n    # 当生成的字符串长度等于指定长度时，将其加入到结果集中\n    if len(current) == length:\n        result.add(current)\n        return\n\n    # 遍历字符串中的字符\n    for i in range(len(s)):\n        # 判断字符是否已经被使用，或者当前字符与前一个字符相同\n        if used[i] or (len(current) > 0 and current[-1] == s[i]):\n            continue  # 如果字符已被使用或与前一个字符相同，则跳过当前字符\n        used[i] = True  # 标记当前字符为已使用\n        # 递归调用生成下一个字符\n        generate_distinct_strings(s, length, current + s[i], result, used)\n        used[i] = False  # 取消标记当前字符的使用状态，以便下一次遍历\n\n# 计算满足条件的不同字符串的数量\ndef count_distinct_strings(s, length):\n    # 创建一个集合来存储不同的字符串\n    distinct_strings = set()\n    # 创建一个列表来标记字符串中的字符是否已经被使用\n    used = [False] * len(s)\n    # 调用generate_distinct_strings方法生成满足条件的不同字符串\n    generate_distinct_strings(s, length, \"\", distinct_strings, used)\n    # 打印生成的所有不同的字符串\n    # for string in distinct_strings:\n       # print(string)\n    # 返回不同字符串的数量\n    return len(distinct_strings)\n\n# 读取用户输入的字符串\ninput_str = input()\n# 将输入的字符串按空格分割为两部分，分别为字符串和长度\nparts = input_str.split(\" \")\ns = parts[0]  # 获取输入的字符串\nlength = int(parts[1])  # 将输入的长度部分转换为整数\n\n# 调用count_distinct_strings方法计算满足条件的不同字符串的数量\ncount = count_distinct_strings(s, length)\n# 输出计算结果\nprint(count)",
    "javascript": "",
    "cpp": "#include <iostream>\n#include <unordered_set>\n#include <vector>\n#include <sstream>\n\nusing namespace std;\n\n// 递归生成满足条件的不同字符串\nvoid generateDistinctStrings(string s, int length, string current, unordered_set<string>& result, vector<bool>& used) {\n    // 当生成的字符串长度等于指定长度时，将其加入到结果集中\n    if (current.length() == length) {\n        result.insert(current);\n        return;\n    }\n\n    // 遍历字符串中的字符\n    for (int i = 0; i < s.length(); i++) {\n        // 判断字符是否已经被使用，或者当前字符与前一个字符相同\n        if (used[i] || (current.length() > 0 && current.back() == s[i])) {\n            continue;  // 如果字符已被使用或与前一个字符相同，则跳过当前字符\n        }\n        used[i] = true;  // 标记当前字符为已使用\n        // 递归调用生成下一个字符\n        generateDistinctStrings(s, length, current + s[i], result, used);\n        used[i] = false;  // 取消标记当前字符的使用状态，以便下一次遍历\n    }\n}\n\n// 计算满足条件的不同字符串的数量\nint countDistinctStrings(string s, int length) {\n    // 创建一个集合来存储不同的字符串\n    unordered_set<string> distinctStrings;\n    // 创建一个列表来标记字符串中的字符是否已经被使用\n    vector<bool> used(s.length(), false);\n    // 调用generateDistinctStrings方法生成满足条件的不同字符串\n    generateDistinctStrings(s, length, \"\", distinctStrings, used);\n    // 打印生成的所有不同的字符串\n    // for (auto& str : distinctStrings) {\n       // cout << str << endl;\n    // }\n    // 返回不同字符串的数量\n    return distinctStrings.size();\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n    // 将输入的字符串按空格分割为两部分，分别为字符串和长度\n    string str;\n    int length;\n    istringstream iss(input);\n    iss >> str >> length;\n\n    // 调用countDistinctStrings方法计算满足条件的不同字符串的数量\n    int count = countDistinctStrings(str, length);\n    // 输出计算结果\n    cout <<  count << endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 31\n\nchar inputString[MAX_SIZE];  // 存储输入的字符串\nint stringLength;            // 存储输入字符串的长度\nint targetLength;            // 目标排列的长度\nint validCount = 0;          // 符合条件的排列个数\n\n// 比较函数，用于qsort\nint compare(const void *a, const void *b) {\n    return (*(char *)a - *(char *)b);\n}\n\nvoid generateDistinctStrings(int lastUsedIndex, int currentLength, int usedFlags[]) {\n    if (currentLength == targetLength) {\n        validCount++;\n        return;\n    }\n\n    for (int i = 0; i < stringLength; i++) {\n        if (usedFlags[i]) continue;\n        if (lastUsedIndex >= 0 && inputString[i] == inputString[lastUsedIndex]) continue;\n        // 优化的树层去重逻辑\n        if (i > 0 && inputString[i] == inputString[i - 1] && !usedFlags[i - 1]) continue;\n\n        usedFlags[i] = 1;\n        generateDistinctStrings(i, currentLength + 1, usedFlags);\n        usedFlags[i] = 0;\n    }\n}\n\nint main() {\n    scanf(\"%s %d\", inputString, &targetLength);\n    stringLength = strlen(inputString);\n\n    // 对输入字符串排序\n    qsort(inputString, stringLength, sizeof(char), compare);\n\n    int usedFlags[MAX_SIZE] = {0};\n    generateDistinctStrings(-1, 0, usedFlags);\n\n    printf(\"%d\\n\", validCount);\n\n    return 0;\n}"
  }
}