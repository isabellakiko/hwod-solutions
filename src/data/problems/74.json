{
  "id": "74",
  "title": "整数编码",
  "examType": "A",
  "score": 100,
  "description": "实现一种整数编码方法，使得待编码的数字越小，编码后所占用的字节数越小。\n编码规则如下:\n编码时7位一组，每个字节的低7位用于存储待编码数字的补码字节的最高位表示后续是否还有字节，置1表示后面还有更多的字节，置0表示当前字节为最后一个字节。采用小端序编码，低位和低字节放在低地址上。编码结果按16进制数的字符格式输出，小写字母需转换为大写字母\n",
  "inputDesc": "输入的为一个字符串表示的非负整数\n",
  "outputDesc": "输出一个字符串，表示整数编码的16进制码流（大写字母）。",
  "examples": [
    {
      "input": "100",
      "output": "64",
      "explanation": "100二进制为1100100，只需1个字节，最高位置0，结果为01100100=64。"
    },
    {
      "input": "1000",
      "output": "E807",
      "explanation": "1000二进制为1111101000，需2个字节。低7位1101000加最高位1得E8，高位0000111得07。小端序E807。"
    },
    {
      "input": "0",
      "output": "00",
      "explanation": "0编码为单字节00。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**进制转换**问题（VLQ编码）。\n\n**算法步骤：**\n1. 将数字转为二进制字符串\n2. 从低位开始，每7位一组\n3. 如果后面还有更多组，最高位置1，否则置0\n4. 每组转为2位16进制字符串（大写）\n5. 小端序输出（低字节在前）\n\n**时间复杂度**：O(log N)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLong()));\n  }\n\n  public static String getResult(long num) {\n    String bin = Long.toBinaryString(num);\n\n    StringBuilder ans = new StringBuilder();\n\n    int end = bin.length();\n    while (end - 7 > 0) {\n      ans.append(getHexString(\"1\" + bin.substring(end - 7, end)));\n      end -= 7;\n    }\n\n    if (end >= 0) {\n      ans.append(getHexString(bin.substring(0, end)));\n    }\n\n    return ans.toString();\n  }\n\n  public static String getHexString(String binStr) {\n    String hexStr = Integer.toHexString(Integer.parseInt(binStr, 2));\n    if (hexStr.length() == 1) hexStr = \"0\" + hexStr;\n    return hexStr.toUpperCase();\n  }\n}",
    "python": "# 输入获取\nnum = int(input())\n\n\ndef getHexString(binStr):\n    # bin函数可以将十进制数转为16进制字符串，但是开头会带0x,因此下面做了字符串截取操作\n    hexStr = hex(int(binStr, 2))[2:]\n    if len(hexStr) == 1:\n        hexStr = \"0\" + hexStr\n    return hexStr.upper()\n\n\n# 算法入口\ndef getResult():\n    # bin函数可以将十进制数转为二进制字符串，但是开头会带0b,因此下面做了字符串截取操作\n    binStr = bin(num)[2:]\n\n    ans = []\n\n    end = len(binStr)\n    while end - 7 > 0:\n        ans.append(getHexString(\"1\" + binStr[end-7:end]))\n        end -= 7\n\n    if end >= 0:\n        ans.append(getHexString(binStr[:end]))\n\n    return \"\".join(ans)\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', (line) => {\n    const num = BigInt(line);\n    let bin = num.toString(2);\n    \n    let ans = '';\n    let end = bin.length;\n    \n    while (end - 7 > 0) {\n        const segment = '1' + bin.substring(end - 7, end);\n        ans += parseInt(segment, 2).toString(16).toUpperCase().padStart(2, '0');\n        end -= 7;\n    }\n    \n    if (end >= 0) {\n        const segment = bin.substring(0, end) || '0';\n        ans += parseInt(segment, 2).toString(16).toUpperCase().padStart(2, '0');\n    }\n    \n    console.log(ans);\n    rl.close();\n});",
    "cpp": "#include <iostream>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring getHexString(string binStr) {\n    int val = stoi(binStr, nullptr, 2);\n    char hex[3];\n    sprintf(hex, \"%02X\", val);\n    return string(hex);\n}\n\nint main() {\n    unsigned long long num;\n    cin >> num;\n    \n    string bin;\n    if (num == 0) bin = \"0\";\n    else {\n        unsigned long long tmp = num;\n        while (tmp > 0) {\n            bin = char('0' + tmp % 2) + bin;\n            tmp /= 2;\n        }\n    }\n    \n    string ans;\n    int end = bin.length();\n    \n    while (end - 7 > 0) {\n        ans += getHexString(\"1\" + bin.substr(end - 7, 7));\n        end -= 7;\n    }\n    \n    if (end >= 0) {\n        ans += getHexString(bin.substr(0, end));\n    }\n    \n    cout << ans << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    unsigned long long num;\n    scanf(\"%llu\", &num);\n    \n    char bin[65];\n    int binLen = 0;\n    \n    if (num == 0) {\n        bin[0] = '0';\n        binLen = 1;\n    } else {\n        unsigned long long tmp = num;\n        while (tmp > 0) {\n            bin[binLen++] = '0' + tmp % 2;\n            tmp /= 2;\n        }\n        // 反转\n        for (int i = 0; i < binLen / 2; i++) {\n            char t = bin[i];\n            bin[i] = bin[binLen - 1 - i];\n            bin[binLen - 1 - i] = t;\n        }\n    }\n    bin[binLen] = '\\0';\n    \n    char ans[100];\n    int ansLen = 0;\n    int end = binLen;\n    \n    while (end - 7 > 0) {\n        char segment[9] = \"1\";\n        strncat(segment, bin + end - 7, 7);\n        int val = strtol(segment, NULL, 2);\n        sprintf(ans + ansLen, \"%02X\", val);\n        ansLen += 2;\n        end -= 7;\n    }\n    \n    if (end >= 0) {\n        char segment[9] = {0};\n        strncpy(segment, bin, end);\n        int val = strtol(segment, NULL, 2);\n        sprintf(ans + ansLen, \"%02X\", val);\n    }\n    \n    printf(\"%s\\n\", ans);\n    return 0;\n}"
  }
}