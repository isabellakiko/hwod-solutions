{
  "id": "28",
  "title": "数字涂色",
  "examType": "A",
  "score": 100,
  "description": "疫情过后，希望小学终于又重新开学了，三年二班开学第一天的任务是将后面的黑板报重新制作。\n黑板上已经写上了N个正整数，同学们需要给这每个数分别上一种颜色。\n为了让黑板报既美观又有学习意义，老师要求同种颜色的所有数都可以被这种颜色中最小的那个数整除。\n现在请你帮帮小朋友们，算算最少需要多少种颜色才能给这N个数进行上色。",
  "inputDesc": "第一行有一个正整数N，表示数字个数（1≤N≤100）。\n第二行有N个int型数(保证输入数据在[1,100]范围中)，表示黑板上各个正整数的值。",
  "outputDesc": "输出只有一个整数，为最少需要的颜色种数。",
  "examples": [
    {
      "input": "3\n2 4 6",
      "output": "1",
      "explanation": "3个数字：2、4、6，都能被2整除，所以只需要1种颜色。"
    },
    {
      "input": "4\n2 3 4 9",
      "output": "2",
      "explanation": "4个数字排序后：2、3、4、9。\n2单独一组；3不能被2整除，新开一组；4能被2整除，归入2的组；9能被3整除，归入3的组。\n最终：{2,4}和{3,9}两组，需要2种颜色。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心 + 整除分组**问题。\n\n**核心思想：**\n- 同种颜色的数都能被该颜色中最小的数整除\n- 为使颜色数最少，应尽可能将数字归入已有的组\n\n**算法步骤：**\n\n1. **排序**：将数字从小到大排序，保证先处理小数\n2. **贪心分组**：遍历每个数字\n   - 检查能否被某个已有组的最小数整除\n   - 如果能，归入该组\n   - 如果不能，新建一个组（当前数字作为该组最小数）\n3. **统计组数**：最终的组数即为答案\n\n**示例演示（2,3,4,9）：**\n- 2：新建组，colors=[2]\n- 3：不能被2整除，新建组，colors=[2,3]\n- 4：能被2整除，归入2的组\n- 9：能被3整除，归入3的组\n- 结果：2种颜色\n\n**时间复杂度**：O(n²)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n \n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);   \n        int N = input.nextInt();  // 读取整数N，表示黑板上数字的数量\n        int[] numList = new int[N];  // 创建一个数组存储N个数字\n        for (int i = 0; i < N; i++) {\n            numList[i] = input.nextInt();  // 读取N个数字并存储在numList数组中\n        }\n        Arrays.sort(numList);  // 对numList数组进行从小到大排序\n        \n        int[] colors = new int[N];  // 创建一个数组colors来存储颜色组的最小数\n        int colorCount = 0;  // 记录使用的颜色种数\n        for (int i = 0; i < N; i++) {\n            boolean foundColor = false;  // 标志位，用于检查当前数字是否找到合适的颜色组\n            for (int j = 0; j < colorCount; j++) {\n                if (numList[i] % colors[j] == 0) {  // 检查当前数字能否被已有颜色组的最小数整除\n                    foundColor = true;  // 如果找到合适的颜色组，标志位置为true\n                    break;  // 跳出循环\n                }\n            }\n            if (!foundColor) {  // 如果没有找到合适的颜色组\n                colors[colorCount] = numList[i];  // 将当前数字作为一个新的颜色组的最小数\n                colorCount++;  // 增加颜色组数量\n            }\n        }\n        \n        System.out.println(colorCount);  // 输出最少需要的颜色种数\n    }\n}",
    "python": "import sys\n\nN = int(input())  # 读取整数N，表示黑板上数字的数量\nnumList = list(map(int, input().split()))  # 读取N个数字并存储在列表numList中\nnumList.sort()  # 对numList进行从小到大排序\n\ncolors = []  # 创建一个列表colors来存储颜色组的最小数\ncolorCount = 0  # 记录使用的颜色种数\nfor i in range(N):\n    foundColor = False  # 标志位，用于检查当前数字是否找到合适的颜色组\n    for j in range(colorCount):\n        if numList[i] % colors[j] == 0:  # 检查当前数字能否被已有颜色组的最小数整除\n            foundColor = True  # 如果找到合适的颜色组，标志位置为True\n            break  # 跳出循环\n    if not foundColor:  # 如果没有找到合适的颜色组\n        colors.append(numList[i])  # 将当前数字作为一个新的颜色组的最小数添加到colors列表中\n        colorCount += 1  # 增加颜色组数量\n\nprint(colorCount)  # 输出最少需要的颜色种数",
    "javascript": "const readline = require('readline');  // 导入readline模块以读取标准输入\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (N) => {  // 读取第一行输入，表示数字数量N\n  let numList = [];  // 用于存储输入的数字列表\n  let colorCount = 0;  // 记录使用的颜色种数\n\n  rl.on('line', (numbers) => {  // 读取第二行输入的N个数字\n    numList = numbers.split(' ').map(Number);  // 将输入的字符串转化为数字数组\n    numList.sort((a, b) => a - b);  // 对数字数组进行从小到大排序\n\n    let colors = new Array(N).fill(0);  // 创建一个数组用于存储颜色组的最小数\n\n    for (let i = 0; i < N; i++) {\n      let foundColor = false;  // 标志位，用于检查当前数字是否找到合适的颜色组\n      for (let j = 0; j < colorCount; j++) {\n        if (numList[i] % colors[j] === 0) {  // 检查当前数字能否被已有颜色组的最小数整除\n          foundColor = true;  // 如果找到合适的颜色组，标志位置为true\n          break;  // 跳出循环\n        }\n      }\n      if (!foundColor) {  // 如果没有找到合适的颜色组\n        colors[colorCount] = numList[i];  // 将当前数字作为一个新的颜色组的最小数\n        colorCount++;  // 增加颜色组数量\n      }\n    }\n\n    console.log(colorCount);  // 输出最少需要的颜色种数\n    rl.close();  // 关闭输入接口\n  });\n});",
    "cpp": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;  // 读取整数N，表示黑板上数字的数量\n    int* numList = new int[N];  // 动态分配一个数组用于存储N个数字\n    for (int i = 0; i < N; i++) {\n        cin >> numList[i];  // 读取N个数字并存储在numList数组中\n    }\n    sort(numList, numList + N);  // 对numList数组进行从小到大排序\n    \n    int* colors = new int[N];  // 动态分配一个数组用于存储颜色组的最小数\n    int colorCount = 0;  // 记录使用的颜色种数\n    for (int i = 0; i < N; i++) {\n        bool foundColor = false;  // 标志位，用于检查当前数字是否找到合适的颜色组\n        for (int j = 0; j < colorCount; j++) {\n            if (numList[i] % colors[j] == 0) {  // 检查当前数字能否被已有颜色组的最小数整除\n                foundColor = true;  // 如果找到合适的颜色组，标志位置为true\n                break;  // 跳出循环\n            }\n        }\n        if (!foundColor) {  // 如果没有找到合适的颜色组\n            colors[colorCount] = numList[i];  // 将当前数字作为一个新的颜色组的最小数\n            colorCount++;  // 增加颜色组数量\n        }\n    }\n    \n    cout << colorCount << endl;  // 输出最少需要的颜色种数\n    \n    delete[] numList;  // 释放动态分配的numList数组\n    delete[] colors;  // 释放动态分配的colors数组\n    \n    return 0;\n}",
    "c": "#include <stdio.h>    \n#include <stdlib.h>    \n#include <stdbool.h>   \n#include <string.h>    \n\n// 定义比较函数，用于qsort的排序\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);  // 比较两个整数的大小\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);  // 读取整数N，表示黑板上数字的数量\n\n    // 动态分配一个数组用于存储N个数字\n    int* numList = (int*)malloc(N * sizeof(int));\n \n\n    // 读取N个数字并存储在numList数组中\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &numList[i]);\n    }\n\n    // 使用qsort对numList数组进行从小到大排序\n    qsort(numList, N, sizeof(int), compare);\n\n    // 动态分配一个数组用于存储颜色组的最小数\n    int* colors = (int*)malloc(N * sizeof(int));\n \n\n    int colorCount = 0;  // 记录使用的颜色种数\n\n    // 遍历numList中的每个数字，决定是否能归入已有颜色组\n    for (int i = 0; i < N; i++) {\n        bool foundColor = false;  // 标志位，用于检查当前数字是否找到合适的颜色组\n\n        // 检查当前数字是否可以加入已有的颜色组\n        for (int j = 0; j < colorCount; j++) {\n            if (numList[i] % colors[j] == 0) {  // 如果能被已有颜色组的最小数整除\n                foundColor = true;  // 找到合适的颜色组，标志位设为true\n                break;  // 跳出循环，不再需要检查其他颜色组\n            }\n        }\n\n        // 如果没有找到合适的颜色组，创建新的颜色组\n        if (!foundColor) {\n            colors[colorCount] = numList[i];  // 将当前数字作为一个新的颜色组的最小数\n            colorCount++;  // 增加颜色组数量\n        }\n    }\n\n    // 输出最少需要的颜色种数\n    printf(\"%d\\n\", colorCount);\n\n \n\n    return 0;  // 程序正常结束\n}"
  }
}