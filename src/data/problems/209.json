{
  "id": "209",
  "title": "士兵过河",
  "examType": "B",
  "score": 200,
  "description": "一支N个士兵的军队正在趁夜色逃亡，途中遇到一条湍急的大河。 敌军在T的时长后到达河面，没到过对岸的士兵都会被消灭。 现在军队只找到了1只小船，这船最多能同时坐上2个士兵。\n当1个士兵划船过河，用时为 a[i]；0 <= i < N当2个士兵坐船同时划船过河时，用时为max(a[j],a[i])两士兵中用时最长的。当2个士兵坐船1个士兵划船时，用时为 a[i]*10；a[i]为划船士兵用时。如果士兵下河游泳，则会被湍急水流直接带走，算作死亡。\n请帮忙给出一种解决方案，保证存活的士兵最多，且过河用时最短。\n",
  "inputDesc": "第一行：N 表示士兵数(0<N<1,000,000) 第二行：T 表示敌军到达时长(0 < T < 100,000,000) 第三行：a[0] a[1] … a[i]… a[N- 1] a[i]表示每个士兵的过河时长。 (10 < a[i]< 100; 0<= i< N）\n",
  "outputDesc": "第一行：”最多存活士兵数” “最短用时”\n\n1）两个士兵的同时划船时，如果划速不同则会导致船原地转圈圈；所以为保持两个士兵划速相同，则需要向划的慢的士兵看齐。 2）两个士兵坐船时，重量增加吃水加深，水的阻力增大；同样的力量划船速度会变慢； 3）由于河水湍急大量的力用来抵消水流的阻力，所以2）中过河用时不是a[i] *2， 而是a[i] * 10。\n\n可以达到或小于171的一种方案： 第一步：a[1] a[2] 过桥用时：13 第二步：a[1] 带火把返回用时：12 第三步：a[0] a[5] 过桥用时：35 第四步：a[2] 带火把返回用时：13 第五步：a[1] a[2] 过桥用时：13 第六步：a[1] 带火把返回用时：12 第七步：a[4] a[6] 过桥用时：20 第八步：a[2] 带火把返回用时：13 第九步：a[1] a[3] 过桥用时：15 第十步：a[1] 带火把返回用时：12 第十一步：a[1] a[2] 过桥用时：13\n所以输出为：\n7 171\n\n本题是 POJ - 1700 Crossing River_伏城之外的博客-CSDN博客 的变种题。\n建议大家先搞定这题，然后再来看本题。\n\n本题在前面这题的基础上，多了一个过河时间限制，以及要求最多存活士兵（即在限制时间内过最多的人）\n\n对于贪心解法，可以结合二分法来求解本题。\n即在0~N中尝试找到成功过河的人数，其中0指的是成功过河的人数为0个，N指的是成功过河的人数为N个。\n将二分法找到的可能人数mid带入上面POJ-1700的逻辑中，计算出mid个人都过河所需的最短时间need，将need和本题过河时间限制limit进行比较：\n\n对于动态规划解法，由于是从0人过河递推到N人过河，因此不需要二分尝试过河人数，而是可以直接基于dp[i]来实时比较T，如果超过了T，则说明只能过河 i 人，耗时dp[i-1]\n\n另外，本题中说：\n当2个士兵坐船1个士兵划船时，用时为 a[i]*10；a[i]为划船士兵用时。\n假设x士兵划船用时为a[x]，y士兵划船用时为a[y]，a[x] < a[y]\n这句话的意思是：如果x,y一起划船，有两种过河时间，分别是：\n如果a[y] > a[x] * 10，我们应该选择a[x] * 10，即让较快的士兵单独划船过河，这样耗时更短。\n\n但是，本题中又说：\n(10 < a[i]< 100; 0<= i< N）\n即\n那么必然：100 < a[x] * 10 < 1000\n即必然 a[x] * 10 > a[y]\n因此，我们不需要考虑上面那种两个士兵坐船，一个士兵划船的情况。\n",
  "examples": [
    {
      "input": "7\n171\n12 13 15 20 35 24 17",
      "output": "7 171",
      "explanation": "全部7人可在171时间内过河"
    },
    {
      "input": "3\n20\n11 12 13",
      "output": "2 12",
      "explanation": "时间20只够2人过河，最短用时12"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二分+贪心过河**问题（POJ-1700变种）。\n\n**核心思路：**\n- 二分搜索能过河的人数\n- 贪心计算n人过河最短时间\n\n**算法步骤：**\n1. 排序过河时间\n2. 二分搜索可过河人数\n3. 贪心策略：最快两人送最慢两人\n4. 返回最多人数和最短时间\n\n**时间复杂度**：O(N*logN)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int t = sc.nextInt();\n\n    int[] times = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      times[i] = sc.nextInt();\n    }\n\n    System.out.println(getResult(n, t, times));\n  }\n\n  /**\n   * @param n 士兵数\n   * @param limit 过河时间上限\n   * @param times 数组，元素表示每个士兵的过河时长\n   * @return ”最多存活士兵数” “最短用时”\n   */\n  public static String getResult(int n, int limit, int[] times) {\n    // 过河时间升序\n    Arrays.sort(times);\n\n    // 最少成功过河人数\n    int min = 0;\n    // 最多成功过河人数\n    int max = n;\n\n    // 记录题解\n    String ans = \"\";\n\n    // 二分法取可能成功的过河人数\n    while (min <= max) {\n      // mid是过河人数\n      int mid = (min + max) / 2;\n      // 计算mid个人过河所需的最短时间need\n      int need = getMinCrossRiverTime(mid, Arrays.copyOfRange(times, 0, mid));\n\n      // 如果need超过了过河时间上限limit，那么说明能成功过河的人没这么多\n      if (need > limit) {\n        max = mid - 1;\n      } else if (need < limit) {\n        // 如果need小于过河时间上限limit，那么说明mid个最快的人可以在limit时间内成功过河\n        ans = mid + \" \" + need;\n        // 但是可能还可以过更多人\n        min = mid + 1;\n      } else {\n        // 如果need == limit，那么说明过河人数刚好可以在limit时间内成功过河，此时可以直接返回\n        ans = mid + \" \" + need;\n        break;\n      }\n    }\n\n    return ans;\n  }\n\n  // 计算将n个人运到河对岸所需要花费的最少时间\n  public static int getMinCrossRiverTime(int n, int[] t) {\n    int cost = 0;\n\n    while (n > 0) {\n      if (n == 1) {\n        cost += t[0];\n        break;\n      } else if (n == 2) {\n        cost += t[1];\n        break;\n      } else if (n == 3) {\n        cost += t[1] + t[0] + t[2];\n        break;\n      } else {\n        cost += Math.min(t[n - 1] + t[0] + t[n - 2] + t[0], t[1] + t[0] + t[n - 1] + t[1]);\n        n -= 2;\n      }\n    }\n\n    return cost;\n  }\n}",
    "python": "# 输入获取\nn = int(input())\nt = int(input())\ntimes = list(map(int, input().split()))\n\n\n# 计算n个人运到河对岸所需要花费的最少时间\ndef getMinCrossRiverTime(n, t):\n    cost = 0\n\n    while n > 0:\n        if n == 1:\n            cost += t[0]\n            break\n        elif n == 2:\n            cost += t[1]\n            break\n        elif n == 3:\n            cost += t[1] + t[0] + t[2]\n            break\n        else:\n            cost += min(t[n - 1] + t[0] + t[n - 2] + t[0], t[1] + t[0] + t[n - 1] + t[1])\n            n -= 2\n\n    return cost\n\n\n# 算法入口\ndef getResult(n, limit, times):\n    \"\"\"\n    :param n: 士兵数\n    :param limit: 过河时间上限\n    :param times: 数组，元素表示每个士兵的过河时长\n    :return: ”最多存活士兵数” “最短用时”\n    \"\"\"\n    times.sort()\n\n    # 最少成功过河人数\n    low = 0\n    # 最多成功过河人数\n    high = n\n\n    # 记录题解\n    ans = \"\"\n\n    # 二分法取可能成功的过河人数\n    while low <= high:\n        # mid是过河人数\n        mid = (low + high) // 2\n        # 计算mid个人过河所需的最短时间need\n        need = getMinCrossRiverTime(mid, times[:mid])\n\n        # 如果need超过了过河时间上限limit，那么说明能成功过河的人没这么多\n        if need > limit:\n            high = mid - 1\n        elif need < limit:\n            # 如果need小于过河时间上限limit，那么说明mid个最快的人可以在limit时间内成功过河\n            ans = f\"{mid} {need}\"\n            # 但是可能还可以过更多人\n            low = mid + 1\n        else:\n            # 如果need == limit，那么说明过河人数刚好可以在limit时间内成功过河，此时可以直接返回\n            ans = f\"{mid} {need}\"\n            break\n\n    return ans\n\n\n# 算法调用\nprint(getResult(n, t, times))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 3) {\n    const N = lines[0] - 0;\n    const T = lines[1] - 0;\n    const times = lines[2].split(\" \").map(Number);\n    console.log(getResult(N, T, times));\n    lines.length = 0;\n  }\n});\n\n/**\n *\n * @param {*} n 士兵数\n * @param {*} limit 过河时间上限\n * @param {*} times 数组，元素表示每个士兵的过河时长\n * @return {*} ”最多存活士兵数” “最短用时”\n */\nfunction getResult(n, limit, times) {\n  // 过河时间升序\n  times.sort((a, b) => a - b);\n\n  // 最少成功过河人数\n  let min = 0;\n  // 最多成功过河人数\n  let max = n;\n\n  // 记录题解\n  let ans = \"\";\n\n  // 二分法取可能成功的过河人数\n  while (min <= max) {\n    // mid是过河人数\n    const mid = Math.floor((min + max) / 2);\n    // 计算mid个人过河所需的最短时间need\n    const need = getMinCrossRiverTime(mid, times.slice(0, mid));\n\n    // 如果need超过了过河时间上限limit，那么说明能成功过河的人没这么多\n    if (need > limit) {\n      max = mid - 1;\n    } else if (need < limit) {\n      // 如果need小于过河时间上限limit，那么说明mid个最快的人可以在limit时间内成功过河\n      ans = `${mid} ${need}`;\n      // 但是可能还可以过更多人\n      min = mid + 1;\n    } else {\n      // 如果need == limit，那么说明过河人数刚好可以在limit时间内成功过河，此时可以直接返回\n      ans = `${mid} ${need}`;\n      break;\n    }\n  }\n\n  return ans;\n}\n\n// 计算n个人运到河对岸所需要花费的最少时间\nfunction getMinCrossRiverTime(n, t) {\n  let cost = 0;\n\n  while (n > 0) {\n    if (n == 1) {\n      cost += t[0];\n      break;\n    } else if (n == 2) {\n      cost += t[1];\n      break;\n    } else if (n == 3) {\n      cost += t[1] + t[0] + t[2];\n      break;\n    } else {\n      cost += Math.min(\n        t[n - 1] + t[0] + t[n - 2] + t[0],\n        t[1] + t[0] + t[n - 1] + t[1]\n      );\n      n -= 2;\n    }\n  }\n\n  return cost;\n}",
    "cpp": "",
    "c": ""
  }
}