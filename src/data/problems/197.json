{
  "id": "197",
  "title": "精准核酸检测",
  "examType": "B",
  "score": 100,
  "description": "为了达到新冠疫情精准防控的需要，为了避免全员核酸检测带来的浪费，需要精准圈定可能被感染的人群。\n现在根据传染病流调以及大数据分析，得到了每个人之间在时间、空间上是否存在轨迹交叉。\n现在给定一组确诊人员编号（X1,X2,X3,...,Xn），在所有人当中，找出哪些人需要进行核酸检测，输出需要进行核酸检测的人数。（注意：确诊病例自身不需要再做核酸检测）\n需要进行核酸检测的人，是病毒传播链条上的所有人员，即有可能通过确诊病例所能传播到的所有人。\n例如：A是确诊病例，A和B有接触、B和C有接触、C和D有接触、D和E有接触，那么B\\C\\D\\E都是需要进行核酸检测的人。\n",
  "inputDesc": "第一行为总人数 N\n第二行为确认病例人员编号（确诊病例人员数量 < N），用逗号分割\n第三行开始，为一个 N * N 的矩阵，表示每个人员之间是否有接触，0表示没有接触，1表示有接触。\n",
  "outputDesc": "整数：需要做核酸检测的人数\n\n\n编号为1、2号的人员，为确诊病例。\n1号和0号有接触，0号和3号有接触。\n2号和4号有接触。\n所以，需要做核酸检测的人是0号、3号、4号，总计3人需要进行核酸检测。\n\n本题可以用并查集解题。关于并查集的实现可以看：\n华为校招机试 - 发广播（20210310）_华为机试 发广播 伏城之外-CSDN博客\n\n即将有接触的人进行合并操作，纳入到同一个连通分量中。比如matrix[i]][j] == 1，即 i 和 j 就处于同一个连通分量中，需要进行合并。\n另外，本题的接触关系矩阵matrix是沿对角线对称的，因此只需要遍历对角线一边即可。\n当遍历完所有接触关系后，就可以求解每一个连通分量中的节点数，即每个接触群体的人数，求解原理如下：\n并查集底层的fa数组，fa数组索引代表每个节点，fa数组元素代表对应索引的节点的根节点，而同一个连通分量中的节点的根都是相同的，因此，我们需要对fa每一个数组索引找一下根，这里可以使用并查集的find操作（递归实现），最后统计同一个根下的节点数量，即为同一个接触群体的人数。\n\n当每个接触群体人数求解出来后，我们只需要统计”确诊病例人员编号“对应的根（连通分量）下的人数即可。\n最后的统计的总人数需要减去确诊病例的数量，因为题目说：\n确诊病例自身不需要再做核酸检测\n\n本题需要注意的是，有可能多个确诊病人在同一个连通分量重，此时需要注意避免重复统计。\n\n",
  "examples": [
    {
      "input": "5\n1,2\n0,1,0,0,0\n1,0,1,0,0\n0,1,0,0,0\n0,0,0,0,1\n0,0,0,1,0",
      "output": "3",
      "explanation": "确诊1、2号，1-0-2-3构成接触链，4-5构成接触链，需检测0、3、4共3人"
    },
    {
      "input": "3\n0\n0,1,0\n1,0,1\n0,1,0",
      "output": "2",
      "explanation": "确诊0号，0-1-2构成接触链，需检测1、2共2人"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**并查集**问题。\n\n**核心思路：**\n- 有接触的人合并到同一个连通分量\n- 统计确诊者所在连通分量的人数\n\n**算法步骤：**\n1. 遍历接触矩阵，有接触则并查集合并\n2. 统计每个连通分量的人数\n3. 找出所有确诊者所在的连通分量\n4. 累加人数并减去确诊者数量\n\n**时间复杂度**：O(N²)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = Integer.parseInt(sc.nextLine());\n\n    int[] confirmed = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n\n    int[][] matrix = new int[n][n];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n    }\n\n    System.out.println(getResult(n, confirmed, matrix));\n  }\n\n  public static int getResult(int n, int[] confirmed, int[][] matrix) {\n    UnionFindSet ufs = new UnionFindSet(n);\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i; j < n; j++) {\n        if (matrix[i][j] == 1) {\n          // 有过接触的人进行合并\n          ufs.union(i, j);\n        }\n      }\n    }\n\n    // 统计每个接触群体（连通分量）中的人数\n    int[] cnts = new int[n];\n    for (int i = 0; i < n; i++) {\n      int fa = ufs.find(i);\n      cnts[fa]++;\n    }\n\n    // 记录已统计过的感染群体\n    HashSet<Integer> confirmed_fa = new HashSet<>();\n\n    // 将有感染者的接触群体的人数统计出来\n    int ans = 0;\n    for (int i : confirmed) {\n      int fa = ufs.find(i);\n\n      // 如果该感染群体已统计过，则不再统计\n      if (confirmed_fa.contains(fa)) continue;\n      confirmed_fa.add(fa);\n\n      ans += cnts[fa];\n    }\n\n    // 最终需要做核酸的人数，不包括已感染的人\n    return ans - confirmed.length;\n  }\n}\n\n// 并查集实现\nclass UnionFindSet {\n  int[] fa;\n\n  public UnionFindSet(int n) {\n    this.fa = new int[n];\n    for (int i = 0; i < n; i++) fa[i] = i;\n  }\n\n  public int find(int x) {\n    if (x != this.fa[x]) {\n      this.fa[x] = this.find(this.fa[x]);\n      return this.fa[x];\n    }\n    return x;\n  }\n\n  public void union(int x, int y) {\n    int x_fa = this.find(x);\n    int y_fa = this.find(y);\n\n    if (x_fa != y_fa) {\n      this.fa[y_fa] = x_fa;\n    }\n  }\n}",
    "python": "# 并查集实现\nclass UnionFindSet:\n    def __init__(self, n):\n        self.fa = [i for i in range(n)]\n\n    def find(self, x):\n        if x != self.fa[x]:\n            self.fa[x] = self.find(self.fa[x])\n            return self.fa[x]\n        return x\n\n    def union(self, x, y):\n        x_fa = self.find(x)\n        y_fa = self.find(y)\n\n        if x_fa != y_fa:\n            self.fa[y_fa] = x_fa\n\n\n# 输入获取\nn = int(input())\nconfirmed = list(map(int, input().split(\",\")))\nmatrix = [list(map(int, input().split(\",\"))) for _ in range(n)]\n\n\n# 算法入口\ndef getResult():\n    ufs = UnionFindSet(n)\n\n    for i in range(n):\n        for j in range(i, n):\n            if matrix[i][j] == 1:\n                # 有过接触的人进行合并\n                ufs.union(i, j)\n\n    # 统计每个接触群体（连通分量）中的人数\n    cnts = [0] * n\n    for i in range(n):\n        fa = ufs.find(i)\n        cnts[fa] += 1\n\n    # 记录已统计过的可能感染群体\n    confirmed_fa = set()\n\n    # 将有感染者的接触群体的人数统计出来\n    ans = 0\n    for i in confirmed:\n        fa = ufs.find(i)\n\n        # 已统计过的可能感染群体不再统计\n        if fa in confirmed_fa:\n            continue\n        confirmed_fa.add(fa)\n\n        ans += cnts[fa]\n\n    # 最终需要做核酸的人数，不包括已感染的人\n    return ans - len(confirmed)\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}