{
  "id": "123",
  "title": "战场索敌",
  "examType": "A",
  "score": 200,
  "description": "有一个大小是N*M的战场地图，被墙壁 ‘#’ 分隔成大小不同的区域，上下左右四个方向相邻的空地 ‘.’ 属于同一个区域，只有空地上可能存在敌人’E”，\n请求出地图上总共有多少区域里的敌人数小于K。",
  "inputDesc": "第一行输入为N,M,K；\nN表示地图的行数，M表示地图的列数， K表示目标敌人数量N，M<=100\n之后为一个NxM大小的字符数组。",
  "outputDesc": "敌人数小于K的区域数量",
  "examples": [
    {
      "input": "3 5 2\n..#EE\nE.#E.\n###..",
      "output": "1",
      "explanation": "地图被#分为两个区域，左边1个敌人<2，右边3个敌人>=2，符合条件的区域数为1"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**DFS连通区域**问题。\n\n**核心思路：**\n- 用DFS遍历每个连通区域\n- 统计区域内敌人E的数量\n- 敌人数<K的区域计入答案\n\n**算法步骤：**\n1. 遍历地图每个格子\n2. 未访问且非墙壁时启动DFS\n3. DFS统计该连通区域的敌人数\n4. 敌人数<K则答案+1\n\n**时间复杂度**：O(N×M)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n    // 定义地图的行数、列数和目标敌人数量\n    private static int n, m, k;\n    // 定义存储地图的二维字符数组\n    private static char[][] matrix;\n    // 定义标记访问状态的二维数组\n    private static int[][] visited;\n    // 记录当前区域的敌人数量\n    private static int enemyCount;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // 读取地图的行数n、列数m和目标敌人数量k\n        n = scanner.nextInt();\n        m = scanner.nextInt();\n        k = scanner.nextInt();\n\n        // 初始化地图矩阵和访问标记数组\n        matrix = new char[n][m];\n        visited = new int[n][m];\n\n        // 读取地图矩阵数据\n        for (int i = 0; i < n; i++) {\n            String row = scanner.next();\n            for (int j = 0; j < m; j++) {\n                matrix[i][j] = row.charAt(j); // 逐字符读取地图\n            }\n        }\n\n        int ans = 0; // 初始化符合条件的区域计数\n\n        // 遍历地图中的每个位置\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                // 如果当前格子已经访问过或是墙壁，跳过\n                if (visited[i][j] != 0 || matrix[i][j] == '#') {\n                    continue;\n                }\n                enemyCount = 0; // 初始化当前区域的敌人计数\n                dfs(i, j); // 深度优先搜索该区域\n                // 如果该区域的敌人数小于k，则该区域符合条件\n                ans += enemyCount < k ? 1 : 0;\n            }\n        }\n\n        // 输出符合条件的区域数量\n        System.out.println(ans);\n    }\n\n    // 深度优先搜索函数，从(i, j)位置开始计算敌人数\n    public static void dfs(int i, int j) {\n        visited[i][j] = 1; // 将当前位置标记为已访问\n\n        // 如果当前位置是敌人，增加敌人计数\n        if (matrix[i][j] == 'E') {\n            enemyCount++;\n        }\n\n        // 定义四个方向的偏移量：上、下、左、右\n        int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        // 遍历四个相邻方向\n        for (int[] offset : offsets) {\n            int newX = i + offset[0];\n            int newY = j + offset[1];\n\n            // 检查相邻位置是否在地图范围内，未访问过且不是墙壁\n            if (newX >= 0 && newX < n && newY >= 0 && newY < m && visited[newX][newY] == 0 && matrix[newX][newY] != '#') {\n                dfs(newX, newY); // 递归访问相邻位置\n            }\n        }\n    }\n}",
    "python": "import sys\n\ndef dfs(i, j):\n    visited[i][j] = 1  # 标记当前位置已访问\n\n    if matrix[i][j] == 'E':  # 如果当前位置是敌人，增加敌人数量\n        global enemyCount\n        enemyCount += 1\n\n    offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]]  # 定义上下左右四个方向\n\n    # 遍历四个方向，检查相邻格子\n    for offset in offsets:\n        newX = i + offset[0]\n        newY = j + offset[1]\n\n        # 检查相邻格子是否在范围内、未访问且不是墙壁\n        if newX >= 0 and newX < n and newY >= 0 and newY < m and visited[newX][newY] == 0 and matrix[newX][newY] != '#':\n            dfs(newX, newY)  # 递归访问相邻格子\n\n# 读取地图行数、列数和目标敌人数量\nn, m, k = map(int, input().split())\n\nmatrix = []  # 初始化地图矩阵\nvisited = [[0] * m for _ in range(n)]  # 初始化访问标记数组\n\n# 读取地图数据\nfor _ in range(n):\n    row = input()\n    matrix.append(list(row))\n\nans = 0  # 初始化符合条件的区域计数\n\n# 遍历地图的每个格子\nfor i in range(n):\n    for j in range(m):\n        # 如果该格子已访问或是墙壁，跳过\n        if visited[i][j] != 0 or matrix[i][j] == '#':\n            continue\n        enemyCount = 0  # 初始化敌人数量\n        dfs(i, j)  # 深度优先搜索\n        # 如果该区域敌人数小于k，则符合条件\n        ans += 1 if enemyCount < k else 0\n\n# 输出符合条件的区域数量\nprint(ans)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet n, m, k;\nlet matrix = [];\nlet visited = [];\n\nrl.on('line', (line) => {\n  if (!n) {\n    [n, m, k] = line.split(' ').map(Number);  // 读取地图行数、列数和敌人数量\n    visited = Array.from({ length: n }, () => Array(m).fill(false));  // 初始化访问标记数组\n  } else {\n    matrix.push(line.split(''));  // 读取地图矩阵\n  }\n}).on('close', () => {\n  const enemyCount = { count: 0 };  // 用于记录敌人数量的对象\n\n  // 深度优先搜索函数\n  function dfs(i, j) {\n    visited[i][j] = true;  // 标记为已访问\n\n    if (matrix[i][j] === 'E') {\n      enemyCount.count++;  // 如果是敌人，增加计数\n    }\n\n    const offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]];  // 定义四个方向\n\n    // 遍历四个相邻方向\n    for (const offset of offsets) {\n      const newX = i + offset[0];\n      const newY = j + offset[1];\n\n      // 检查是否在地图范围内且未访问\n      if (newX >= 0 && newX < n && newY >= 0 && newY < m && !visited[newX][newY] && matrix[newX][newY] !== '#') {\n        dfs(newX, newY);  // 递归搜索\n      }\n    }\n  }\n\n  let ans = 0;  // 记录符合条件的区域数量\n\n  // 遍历地图的每个格子\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (visited[i][j] || matrix[i][j] === '#') {\n        continue;  // 如果已访问或是墙壁，跳过\n      }\n      enemyCount.count = 0;  // 初始化敌人计数\n      dfs(i, j);  // 深度优先搜索\n      ans += enemyCount.count < k ? 1 : 0;  // 判断是否符合条件\n    }\n  }\n\n  console.log(ans);  // 输出结果\n});",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n, m, k;  // 地图行数、列数和目标敌人数量\nvector<vector<char>> matrix;  // 存储地图的二维数组\nvector<vector<int>> visited;  // 标记访问状态的二维数组\nint enemyCount;  // 记录当前区域敌人的数量\n\n// 深度优先搜索函数，从(i, j)开始计算该区域的敌人数\nvoid dfs(int i, int j) {\n    visited[i][j] = 1;  // 标记当前位置为已访问\n    \n    if (matrix[i][j] == 'E') {\n        enemyCount++;  // 如果当前位置是敌人，增加计数\n    }\n    \n    vector<vector<int>> offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // 定义四个方向\n\n    // 遍历相邻的四个方向\n    for (vector<int> offset : offsets) {\n        int newX = i + offset[0];\n        int newY = j + offset[1];\n        \n        // 检查新位置是否在地图范围内，且未访问过且不是墙壁\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && visited[newX][newY] == 0 && matrix[newX][newY] != '#') {\n            dfs(newX, newY);  // 递归访问相邻位置\n        }\n    }\n}\n\nint main() {\n    cin >> n >> m >> k;  // 读取地图行数、列数和目标敌人数量\n    \n    matrix.resize(n, vector<char>(m));  // 初始化地图矩阵\n    visited.resize(n, vector<int>(m));  // 初始化访问标记数组\n    \n    // 读取地图数据\n    for (int i = 0; i < n; i++) {\n        string row;\n        cin >> row;\n        for (int j = 0; j < m; j++) {\n            matrix[i][j] = row[j];  // 将地图数据存入矩阵\n        }\n    }\n    \n    int ans = 0;  // 记录符合条件的区域数量\n    \n    // 遍历地图的每个格子\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (visited[i][j] != 0 || matrix[i][j] == '#') {\n                continue;  // 如果已经访问或是墙壁，跳过\n            }\n            enemyCount = 0;  // 初始化敌人计数\n            dfs(i, j);  // 深度优先搜索\n            ans += enemyCount < k ? 1 : 0;  // 判断该区域是否符合条件\n        }\n    }\n    \n    cout << ans << endl;  // 输出符合条件的区域数量\n    \n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint n, m, k;  // 地图行数、列数和目标敌人数量\nchar **matrix;  // 存储地图的二维数组\nint **visited;  // 标记访问状态的二维数组\nint enemyCount;  // 记录当前区域敌人的数量\n\n// 深度优先搜索函数，从(i, j)开始计算该区域的敌人数\nvoid dfs(int i, int j) {\n    visited[i][j] = 1;  // 标记当前位置为已访问\n\n    if (matrix[i][j] == 'E') {\n        enemyCount++;  // 如果当前位置是敌人，增加计数\n    }\n\n    int offsets[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};  // 定义四个方向\n\n    // 遍历相邻的四个方向\n    for (int d = 0; d < 4; d++) {\n        int newX = i + offsets[d][0];\n        int newY = j + offsets[d][1];\n\n        // 检查新位置是否在地图范围内，且未访问过且不是墙壁\n        if (newX >= 0 && newX < n && newY >= 0 && newY < m && visited[newX][newY] == 0 && matrix[newX][newY] != '#') {\n            dfs(newX, newY);  // 递归访问相邻位置\n        }\n    }\n}\n\nint main() {\n    // 读取地图行数、列数和目标敌人数量\n    scanf(\"%d %d %d\", &n, &m, &k);\n\n    // 初始化地图矩阵\n    matrix = (char **)malloc(n * sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        matrix[i] = (char *)malloc((m + 1) * sizeof(char));  // 额外分配1个字符存储字符串终止符\n    }\n\n    // 初始化访问标记数组\n    visited = (int **)malloc(n * sizeof(int *));\n    for (int i = 0; i < n; i++) {\n        visited[i] = (int *)malloc(m * sizeof(int));\n    }\n\n    // 读取地图数据\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", matrix[i]);  // 直接读取一整行字符串\n    }\n\n    int ans = 0;  // 记录符合条件的区域数量\n\n    // 遍历地图的每个格子\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (visited[i][j] != 0 || matrix[i][j] == '#') {\n                continue;  // 如果已经访问或是墙壁，跳过\n            }\n            enemyCount = 0;  // 初始化敌人计数\n            dfs(i, j);  // 深度优先搜索\n            ans += (enemyCount < k) ? 1 : 0;  // 判断该区域是否符合条件\n        }\n    }\n\n    printf(\"%d\\n\", ans);  // 输出符合条件的区域数量\n\n    // 释放动态分配的内存\n    for (int i = 0; i < n; i++) {\n        free(matrix[i]);\n        free(visited[i]);\n    }\n    free(matrix);\n    free(visited);\n\n    return 0;\n}"
  }
}