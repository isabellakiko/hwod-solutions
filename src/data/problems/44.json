{
  "id": "44",
  "title": "矩形相交的面积",
  "examType": "A",
  "score": 100,
  "description": "给出3组点坐标(x, y, w, h)，-1000<x,y<1000，w,h为正整数。\n(x, y, w, h)表示平面直角坐标系中的一个矩形：\nx, y为矩形左上角坐标点，w, h向右w，向下h。\n(x, y, w, h)表示x轴(x, x+w)和y轴(y, y-h)围成的矩形区域；\n(0, 0, 2, 2)表示 x轴(0, 2)和y 轴(0, -2)围成的矩形区域；\n(3, 5, 4, 6)表示x轴(3, 7)和y轴(5, -1)围成的矩形区域；\n求3组坐标构成的矩形区域重合部分的面积。",
  "inputDesc": "3行输入分别为3个矩形的位置，分别代表“左上角x坐标”，“左上角y坐标”，“矩形宽”，“矩形高” -1000 <= x,y < 1000",
  "outputDesc": "输出3个矩形相交的面积，不相交的输出0。",
  "examples": [
    {
      "input": "1 6 4 4\n3 5 4 4\n2 4 4 2",
      "output": "2",
      "explanation": "矩形1: (1,6,4,4) → x:[1,5], y:[2,6]\n矩形2: (3,5,4,4) → x:[3,7], y:[1,5]\n矩形3: (2,4,4,2) → x:[2,6], y:[2,4]\n三者x交集:[3,5], y交集:[2,4]\n面积 = 2 × 1 = 2"
    },
    {
      "input": "0 0 2 2\n1 1 2 2\n2 2 2 2",
      "output": "0",
      "explanation": "矩形1: x:[0,2], y:[-2,0]\n矩形2: x:[1,3], y:[-1,1]\n矩形3: x:[2,4], y:[0,2]\n三个矩形没有公共重叠区域，面积为0。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**几何+模拟**问题。\n\n**矩形表示：**\n- 输入(x, y, w, h)表示左上角坐标和宽高\n- x范围：[x, x+w]\n- y范围：[y-h, y]（向下延伸）\n\n**算法步骤：**\n\n1. 解析3个矩形，计算各自的坐标范围\n2. 建立二维数组表示整个坐标区域\n3. 遍历每个矩形，在其覆盖区域+1\n4. 统计值为3的格子数量（被3个矩形同时覆盖）\n\n**优化思路：**\n- 可用坐标压缩减少空间\n- 也可直接计算交集区间\n\n**时间复杂度**：O(w×h)，w、h为坐标范围",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> x_coords = new ArrayList<>();  // 存储所有矩形的x坐标\n        List<Integer> y_coords = new ArrayList<>();  // 存储所有矩形的y坐标\n        List<int[]> rectangles = new ArrayList<>();  // 存储所有矩形的左上角和右下角坐标\n        Scanner scanner = new Scanner(System.in);\n        for (int i = 0; i < 3; i++) {\n            int x1 = scanner.nextInt();\n            int y1 = scanner.nextInt();\n            int w = scanner.nextInt();\n            int h = scanner.nextInt();\n\n            int x2 = x1 + w;  // 计算矩形的右上角x坐标\n            int y2 = y1 - h;  // 计算矩形的右上角y坐标\n            x_coords.add(x1);\n            x_coords.add(x2);\n            y_coords.add(y1);\n            y_coords.add(y2);\n            rectangles.add(new int[]{x1, y1, x2, y2});\n        }\n\n        int min_x_coord = Integer.MAX_VALUE;\n        int max_x_coord = Integer.MIN_VALUE;\n        int min_y_coord = Integer.MAX_VALUE;\n        int max_y_coord = Integer.MIN_VALUE;\n        for (int x : x_coords) {\n            min_x_coord = Math.min(min_x_coord, x);\n            max_x_coord = Math.max(max_x_coord, x);\n        }\n        for (int y : y_coords) {\n            min_y_coord = Math.min(min_y_coord, y);\n            max_y_coord = Math.max(max_y_coord, y);\n        }\n\n        int x_offset = 0 - min_x_coord;  // 计算x坐标的偏移量\n        int y_offset = 0 - min_y_coord;  // 计算y坐标的偏移量\n\n        int[][] intersection_area = new int[Math.abs(max_x_coord - min_x_coord)][Math.abs(max_y_coord - min_y_coord)];  // 创建表示矩形区域的二维数组\n\n        for (int[] rectangle : rectangles) {\n            int x1 = rectangle[0];\n            int y1 = rectangle[1];\n            int x2 = rectangle[2];\n            int y2 = rectangle[3];\n            for (int i = Math.min(x2, x1) + x_offset; i < Math.max(x2, x1) + x_offset; i++) {\n                for (int j = Math.min(y2, y1) + y_offset; j < Math.max(y2, y1) + y_offset; j++) {\n                    intersection_area[i][j] += 1;  // 在相应的区域加1\n                }\n            }\n        }\n\n        int ret = 0;\n        for (int i = 0; i < intersection_area.length; i++) {\n            for (int j = 0; j < intersection_area[0].length; j++) {\n                if (intersection_area[i][j] == 3) {  // 统计值为3的区域的个数\n                    ret += 1;\n                }\n            }\n        }\n\n        System.out.println(ret);  // 输出相交的面积\n    }\n}",
    "python": "x_coords = []  # 存储所有矩形的x坐标\ny_coords = []  # 存储所有矩形的y坐标\nrectangles = []  # 存储所有矩形的左上角和右下角坐标\nfor _ in range(3):\n    x1, y1, w, h = list(map(int, input().split()))\n \n    x2 = x1 + w  # 计算矩形的右上角x坐标\n    y2 = y1 - h  # 计算矩形的右上角y坐标\n    x_coords += [x1, x2]\n    y_coords += [y1, y2]\n    rectangles.append((x1, y1, x2, y2))\n\nmin_x_coord, max_x_coord = min(x_coords), max(x_coords)  # 计算矩形区域的最小和最大x坐标\nmin_y_coord, max_y_coord = min(y_coords), max(y_coords)  # 计算矩形区域的最小和最大y坐标\nx_offset = 0 - min_x_coord  # 计算x坐标的偏移量\ny_offset = 0 - min_y_coord  # 计算y坐标的偏移量\n\nintersection_area = [[0] * abs(max_y_coord - min_y_coord) for _ in range(abs(max_x_coord - min_x_coord))]  # 创建表示矩形区域的二维数组\n\nfor x1, y1, x2, y2 in rectangles:\n    for i in range(min((x2, x1)) + x_offset, max((x2, x1)) + x_offset):\n        for j in range(min((y2, y1)) + y_offset, max((y2, y1)) + y_offset):\n            intersection_area[i][j] += 1  # 在相应的区域加1\n\nret = 0\nfor i in range(len(intersection_area)):\n    for j in range(len(intersection_area[0])):\n        if intersection_area[i][j] == 3:  #  区域值为3时表示3个矩形重合\n            ret += 1\n\nprint(ret)  # 输出相交的面积",
    "javascript": "var readline = require('readline');\n\n// 创建接口用于读取标准输入\nvar rl = readline.createInterface({\n  input: process.stdin, // 输入来自标准输入（键盘输入）\n  output: process.stdout // 输出到标准输出（控制台）\n});\n\nvar x_coords = []; // 用于存储所有矩形的x坐标\nvar y_coords = []; // 用于存储所有矩形的y坐标\nvar rectangles = []; // 用于存储每个矩形的左上角和右下角坐标\n\n// 监听每行输入的事件\nrl.on('line', function(line){\n  // 将输入的每一行按空格分割，并将其转换为数字数组\n  var inputs = line.split(' ').map(Number);\n  var x1 = inputs[0]; // 矩形左上角的x坐标\n  var y1 = inputs[1]; // 矩形左上角的y坐标\n  var w = inputs[2];  // 矩形的宽度\n  var h = inputs[3];  // 矩形的高度\n\n  var x2 = x1 + w;  // 计算矩形右下角的x坐标\n  var y2 = y1 - h;  // 计算矩形右下角的y坐标\n\n  // 将矩形的x坐标加入x_coords数组\n  x_coords.push(x1, x2);\n  // 将矩形的y坐标加入y_coords数组\n  y_coords.push(y1, y2);\n  // 将矩形的完整坐标（左上角和右下角）存入rectangles数组\n  rectangles.push([x1, y1, x2, y2]);\n\n  // 当已经读取到三个矩形时，结束输入\n  if(rectangles.length === 3){\n    rl.close(); // 关闭输入流\n  }\n});\n\n// 当输入结束时触发此事件\nrl.on('close', function(){\n  // 计算所有矩形的x坐标中的最小值和最大值\n  var min_x_coord = Math.min(...x_coords);\n  var max_x_coord = Math.max(...x_coords);\n  // 计算所有矩形的y坐标中的最小值和最大值\n  var min_y_coord = Math.min(...y_coords);\n  var max_y_coord = Math.max(...y_coords);\n\n  // 计算x坐标和y坐标的偏移量，将所有坐标平移到非负范围\n  var x_offset = 0 - min_x_coord;\n  var y_offset = 0 - min_y_coord;\n\n  // 创建一个二维数组 intersection_area，表示整个区域\n  // 数组的大小为矩形的最大x和最小x之间的差值，以及最大y和最小y之间的差值\n  var intersection_area = new Array(Math.abs(max_x_coord - min_x_coord))\n    .fill(0)\n    .map(() => new Array(Math.abs(max_y_coord - min_y_coord)).fill(0));\n\n  // 遍历每个矩形\n  for(var i = 0; i < rectangles.length; i++){\n    var x1 = rectangles[i][0]; // 矩形左上角的x坐标\n    var y1 = rectangles[i][1]; // 矩形左上角的y坐标\n    var x2 = rectangles[i][2]; // 矩形右下角的x坐标\n    var y2 = rectangles[i][3]; // 矩形右下角的y坐标\n\n    // 遍历矩形的x坐标范围，填充到二维数组中\n    for(var j = Math.min(x2, x1) + x_offset; j < Math.max(x2, x1) + x_offset; j++){\n      // 遍历矩形的y坐标范围，填充到二维数组中\n      for(var k = Math.min(y2, y1) + y_offset; k < Math.max(y2, y1) + y_offset; k++){\n        intersection_area[j][k]++; // 对应的二维数组位置计数加1，表示该区域被覆盖\n      }\n    }\n  }\n\n  var ret = 0; // 用于存储同时被三个矩形覆盖的区域的数量\n\n  // 遍历整个二维数组，统计被三个矩形同时覆盖的区域\n  for(var i = 0; i < intersection_area.length; i++){\n    for(var j = 0; j < intersection_area[0].length; j++){\n      if(intersection_area[i][j] === 3){ // 如果该区域被三个矩形覆盖\n        ret++; // 计数增加\n      }\n    }\n  }\n\n  // 输出最终结果，即重叠的面积\n  console.log(ret);\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    vector<int> x_coords;  // 存储所有矩形的x坐标\n    vector<int> y_coords;  // 存储所有矩形的y坐标\n    vector<vector<int>> rectangles;  // 存储所有矩形的左上角和右下角坐标\n    for (int i = 0; i < 3; i++) {\n        int x1, y1, w, h;\n        cin >> x1 >> y1 >> w >> h;\n\n        int x2 = x1 + w;  // 计算矩形的右上角x坐标\n        int y2 = y1 - h;  // 计算矩形的右上角y坐标\n        x_coords.push_back(x1);\n        x_coords.push_back(x2);\n        y_coords.push_back(y1);\n        y_coords.push_back(y2);\n        rectangles.push_back({x1, y1, x2, y2});\n    }\n\n    int min_x_coord = *min_element(x_coords.begin(), x_coords.end());  // 计算矩形区域的最小x坐标\n    int max_x_coord = *max_element(x_coords.begin(), x_coords.end());  // 计算矩形区域的最大x坐标\n    int min_y_coord = *min_element(y_coords.begin(), y_coords.end());  // 计算矩形区域的最小y坐标\n    int max_y_coord = *max_element(y_coords.begin(), y_coords.end());  // 计算矩形区域的最大y坐标\n    int x_offset = 0 - min_x_coord;  // 计算x坐标的偏移量\n    int y_offset = 0 - min_y_coord;  // 计算y坐标的偏移量\n\n    vector<vector<int>> intersection_area(abs(max_x_coord - min_x_coord), vector<int>(abs(max_y_coord - min_y_coord), 0));  // 创建表示矩形区域的二维数组\n\n    for (vector<int>& rectangle : rectangles) {\n        int x1 = rectangle[0];\n        int y1 = rectangle[1];\n        int x2 = rectangle[2];\n        int y2 = rectangle[3];\n        for (int i = min(x2, x1) + x_offset; i < max(x2, x1) + x_offset; i++) {\n            for (int j = min(y2, y1) + y_offset; j < max(y2, y1) + y_offset; j++) {\n                intersection_area[i][j] += 1;  // 在相应的区域加1\n            }\n        }\n    }\n\n    int ret = 0;\n    for (int i = 0; i < intersection_area.size(); i++) {\n        for (int j = 0; j < intersection_area[0].size(); j++) {\n            if (intersection_area[i][j] == 3) {  // 域值为3时表示3个矩形重合\n                ret += 1;\n            }\n        }\n    }\n\n    cout << ret << endl;  // 输出相交的面积\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>  // 用于定义最大和最小整数值\n\n#define MAX_RECTANGLES 3  // 矩形数量\n\nint main() {\n    int x_coords[MAX_RECTANGLES * 2];  // 存储所有矩形的x坐标（每个矩形有2个x坐标）\n    int y_coords[MAX_RECTANGLES * 2];  // 存储所有矩形的y坐标（每个矩形有2个y坐标）\n    int rectangles[MAX_RECTANGLES][4];  // 存储所有矩形的左上角和右下角坐标 (x1, y1, x2, y2)\n    int x1, y1, w, h;\n    int x2, y2;\n\n    // 输入三个矩形的信息\n    for (int i = 0; i < MAX_RECTANGLES; i++) {\n        scanf(\"%d %d %d %d\", &x1, &y1, &w, &h);  // 读取每个矩形的左上角坐标和宽高\n        x2 = x1 + w;  // 计算矩形的右下角x坐标\n        y2 = y1 - h;  // 计算矩形的右下角y坐标\n\n        // 存储矩形的x坐标\n        x_coords[i * 2] = x1;\n        x_coords[i * 2 + 1] = x2;\n\n        // 存储矩形的y坐标\n        y_coords[i * 2] = y1;\n        y_coords[i * 2 + 1] = y2;\n\n        // 存储矩形的坐标 (x1, y1, x2, y2)\n        rectangles[i][0] = x1;\n        rectangles[i][1] = y1;\n        rectangles[i][2] = x2;\n        rectangles[i][3] = y2;\n    }\n\n    // 初始化最小和最大坐标值\n    int min_x_coord = INT_MAX;\n    int max_x_coord = INT_MIN;\n    int min_y_coord = INT_MAX;\n    int max_y_coord = INT_MIN;\n\n    // 寻找x轴的最小值和最大值\n    for (int i = 0; i < MAX_RECTANGLES * 2; i++) {\n        if (x_coords[i] < min_x_coord) {\n            min_x_coord = x_coords[i];\n        }\n        if (x_coords[i] > max_x_coord) {\n            max_x_coord = x_coords[i];\n        }\n    }\n\n    // 寻找y轴的最小值和最大值\n    for (int i = 0; i < MAX_RECTANGLES * 2; i++) {\n        if (y_coords[i] < min_y_coord) {\n            min_y_coord = y_coords[i];\n        }\n        if (y_coords[i] > max_y_coord) {\n            max_y_coord = y_coords[i];\n        }\n    }\n\n    // 计算x和y的偏移量，将坐标平移至非负范围\n    int x_offset = 0 - min_x_coord;\n    int y_offset = 0 - min_y_coord;\n\n    // 计算二维数组的大小\n    int width = abs(max_x_coord - min_x_coord);\n    int height = abs(max_y_coord - min_y_coord);\n\n    // 动态分配用于表示矩形区域的二维数组\n    int** intersection_area = (int**)malloc(width * sizeof(int*));\n    for (int i = 0; i < width; i++) {\n        intersection_area[i] = (int*)calloc(height, sizeof(int));  // 初始化数组元素为0\n    }\n\n    // 遍历每个矩形，填充二维数组区域\n    for (int i = 0; i < MAX_RECTANGLES; i++) {\n        int rect_x1 = rectangles[i][0];\n        int rect_y1 = rectangles[i][1];\n        int rect_x2 = rectangles[i][2];\n        int rect_y2 = rectangles[i][3];\n\n        // 遍历每个矩形的区域，并在二维数组中标记被覆盖的区域\n        for (int x = (rect_x1 + x_offset); x < (rect_x2 + x_offset); x++) {\n            for (int y = (rect_y2 + y_offset); y < (rect_y1 + y_offset); y++) {\n                intersection_area[x][y] += 1;  // 增加覆盖计数\n            }\n        }\n    }\n\n    int ret = 0;  // 用于存储重叠的区域面积\n\n    // 遍历二维数组，统计同时被三个矩形覆盖的区域数\n    for (int i = 0; i < width; i++) {\n        for (int j = 0; j < height; j++) {\n            if (intersection_area[i][j] == 3) {  // 如果区域被三个矩形覆盖\n                ret += 1;  // 增加计数\n            }\n        }\n    }\n\n    // 输出结果\n    printf(\"%d\\n\", ret);\n\n    // 释放二维数组的内存\n    for (int i = 0; i < width; i++) {\n        free(intersection_area[i]);\n    }\n    free(intersection_area);\n\n    return 0;\n}"
  }
}