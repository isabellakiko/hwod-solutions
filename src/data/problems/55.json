{
  "id": "55",
  "title": "转盘寿司",
  "examType": "A",
  "score": 100,
  "description": "寿司店周年庆，正在举办优惠活动回馈新老客户。\n寿司转盘上总共有 n 盘寿司，prices[i] 是第 i 盘寿司的价格，\n如果客户选择了第 i 盘寿司，寿司店免费赠送客户距离第 i 盘寿司最近的下一盘寿司 j，前提是 prices[j] < prices[i]，如果没有满足条件的 j，则不赠送寿司。\n每个价格的寿司都可无限供应。",
  "inputDesc": "输入的每一个数字代表每盘寿司的价格，每盘寿司的价格之间使用空格分隔，例如:\n3 15 6 14\n表示：\n第 0 盘寿司价格 prices[0] 为 3第 1 盘寿司价格 prices[1] 为 15第 2 盘寿司价格 prices[2] 为 6第 3 盘寿司价格 prices[3] 为 14寿司的盘数 n 范围为：1 ≤ n ≤ 500\n每盘寿司的价格 price 范围为：1 ≤ price ≤ 1000",
  "outputDesc": "输出享受优惠后的一组数据，每个值表示客户选择第 i 盘寿司时实际得到的寿司的总价格。使用空格进行分隔，例如：\n3 21 9 17\n根据题目的描述，客户选择了第 i 盘寿司，寿司店免费赠送距离第 i 盘寿司最近的下一盘寿司 j，且 prices[j] < prices[i]。如果没有满足条件的 j，则不赠送寿司。因此，对于每一盘寿司，我们需要找到其价格右侧第一个比它小的寿司的价格，并将其加到当前寿司的价格上。\n给定输入 3 15 6 14，我们来逐个分析：\n综合以上，输出结果为 3 21 9 17。\n通过这个用例，可以得出数组是可以循环到头部继续寻找",
  "examples": [
    {
      "input": "3 15 6 14",
      "output": "3 21 9 17",
      "explanation": "分析每盘寿司：\n价格3：右边没有更便宜的→3\n价格15：右边第一个更便宜的是6→15+6=21\n价格6：循环找到3→6+3=9\n价格14：循环找到3→14+3=17"
    },
    {
      "input": "5 2 8 3",
      "output": "7 2 11 5",
      "explanation": "分析每盘寿司：\n价格5：右边第一个更便宜的是2→5+2=7\n价格2：没有更便宜的→2\n价格8：右边第一个更便宜的是3→8+3=11\n价格3：循环找到2→3+2=5"
    },
    {
      "input": "10 10 10",
      "output": "10 10 10",
      "explanation": "所有价格相同，没有更便宜的寿司，不赠送。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**单调栈+循环数组**问题。\n\n**问题本质：**\n找每个元素右边第一个比它小的元素（循环数组）。\n\n**算法步骤：**\n\n1. 使用单调栈存储待处理元素的索引\n2. 遍历2n-1次处理循环数组\n3. 当栈顶元素价格大于当前价格时，找到了更便宜的寿司\n4. 栈中剩余元素表示没有更便宜的，保持原价\n\n**时间复杂度**：O(N)\n**空间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 使用Scanner从控制台读取输入\n        Scanner sc = new Scanner(System.in);\n        // 读取一行输入，按空格分割，然后将每个数字字符串转换为整数，并收集到数组中\n        int[] prices = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 获取寿司价格数组的长度，代表寿司盘数\n        int n = prices.length;\n        \n        // 创建一个数组来存储结果，即每个寿司盘享受优惠后的总价格\n        int[] res = new int[n];\n        // 创建一个双端队列作为栈使用，用于跟踪寿司价格的索引\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        // 遍历每个寿司盘的价格，由于寿司盘是循环的，需要遍历两倍长度减一次\n        for (int j = 0; j < n * 2 - 1; j++) {\n            // 计算当前索引，由于数组是循环的，使用模运算得到实际索引\n            int index = j % n;\n            // 当栈不为空且栈顶元素的价格大于当前索引对应的价格时\n            while (!stack.isEmpty() && prices[stack.peek()] > prices[index]) {\n                // 弹出栈顶元素的索引\n                int topIndex = stack.pop();\n                // 计算栈顶元素享受优惠后的价格，并更新结果数组\n                res[topIndex] = prices[topIndex] + prices[index];\n            }\n            // 第一轮遍历时，将索引压入栈中\n            if (j < n) {\n                stack.push(index);\n            }\n        }\n \n        // 遍历完成后，栈中剩余的元素代表它们右侧没有更小的价格\n        // 直接将它们自身的价格作为结果\n        while (!stack.isEmpty()) {\n            int topIndex = stack.pop();\n            res[topIndex] = prices[topIndex];\n        }\n\n        // 使用StringBuilder构建输出结果\n        StringBuilder sb = new StringBuilder();\n        for (int num : res) {\n            // 将每个价格添加到StringBuilder中，并加上空格\n            sb.append(num).append(\" \");\n        }\n        // 输出结果，并去除末尾的空格\n        System.out.println(sb.toString().trim());\n    }\n}",
    "python": "# 读取一行输入，按空格分割，然后将每个数字字符串转换为整数，并收集到列表中\nprices = list(map(int, input().split()))\n# 获取寿司价格列表的长度，代表寿司盘数\nn = len(prices)\n\n# 创建一个列表来存储结果，即每个寿司盘享受优惠后的总价格\nres = [0] * n\n# 创建一个列表作为栈使用，用于跟踪寿司价格的索引\nstack = []\n\n# 遍历每个寿司盘的价格，由于寿司盘是循环的，需要遍历两倍长度减一次\nfor j in range(n * 2 - 1):\n    # 计算当前索引，由于列表是循环的，使用模运算得到实际索引\n    index = j % n\n    # 当栈不为空且栈顶元素的价格大于当前索引对应的价格时\n    while stack and prices[stack[-1]] > prices[index]:\n        # 弹出栈顶元素的索引\n        top_index = stack.pop()\n        # 计算栈顶元素享受优惠后的价格，并更新结果列表\n        res[top_index] = prices[top_index] + prices[index]\n    # 第一轮遍历时，将索引压入栈中\n    if j < n:\n        stack.append(index)\n\n# 遍历完成后，栈中剩余的元素代表它们右侧没有更小的价格\n# 直接将它们自身的价格作为结果\nwhile stack:\n    top_index = stack.pop()\n    res[top_index] = prices[top_index]\n\n# 输出结果，每个价格后加上空格\nprint(' '.join(map(str, res)))",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', (line) => {\n    // 读取价格数组\n    const prices = line.split(' ').map(Number);\n    const n = prices.length;\n    \n    // 创建结果数组和栈\n    const res = new Array(n).fill(0);\n    const stack = [];\n    \n    // 遍历2n-1次处理循环数组\n    for (let j = 0; j < n * 2 - 1; j++) {\n        const index = j % n;\n        // 当栈顶价格大于当前价格时，找到了更便宜的寿司\n        while (stack.length > 0 && prices[stack[stack.length - 1]] > prices[index]) {\n            const topIndex = stack.pop();\n            res[topIndex] = prices[topIndex] + prices[index];\n        }\n        // 第一轮遍历时入栈\n        if (j < n) {\n            stack.push(index);\n        }\n    }\n    \n    // 栈中剩余元素没有更便宜的，保持原价\n    while (stack.length > 0) {\n        const topIndex = stack.pop();\n        res[topIndex] = prices[topIndex];\n    }\n    \n    console.log(res.join(' '));\n    rl.close();\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <sstream>\n\nint main() {\n    // 使用iostream从控制台读取输入\n    std::string line;\n    std::getline(std::cin, line);\n    std::istringstream iss(line);\n\n    // 读取一行输入，按空格分割，然后将每个数字字符串转换为整数，并收集到vector中\n    std::vector<int> prices;\n    int price;\n    while (iss >> price) {\n        prices.push_back(price);\n    }\n\n    // 获取寿司价格数组的长度，代表寿司盘数\n    int n = prices.size();\n    \n    // 创建一个数组来存储结果，即每个寿司盘享受优惠后的总价格\n    std::vector<int> res(n, 0);\n    // 创建一个栈来跟踪寿司价格的索引\n    std::stack<int> stack;\n\n    // 遍历每个寿司盘的价格，由于寿司盘是循环的，需要遍历两倍长度减一次\n    for (int j = 0; j < n * 2 - 1; ++j) {\n        // 计算当前索引，由于数组是循环的，使用模运算得到实际索引\n        int index = j % n;\n        // 当栈不为空且栈顶元素的价格大于当前索引对应的价格时\n        while (!stack.empty() && prices[stack.top()] > prices[index]) {\n            // 弹出栈顶元素的索引\n            int topIndex = stack.top();\n            stack.pop();\n            // 计算栈顶元素享受优惠后的价格，并更新结果数组\n            res[topIndex] = prices[topIndex] + prices[index];\n        }\n        // 第一轮遍历时，将索引压入栈中\n        if (j < n) {\n            stack.push(index);\n        }\n    }\n\n    // 遍历完成后，栈中剩余的元素代表它们右侧没有更小的价格\n    // 直接将它们自身的价格作为结果\n    while (!stack.empty()) {\n        int topIndex = stack.top();\n        stack.pop();\n        res[topIndex] = prices[topIndex];\n    }\n\n    // 输出结果，每个价格后加上空格\n    for (int num : res) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n\n#define MAX_N 500\n\nint main() {\n    int prices[MAX_N]; // 创建一个数组，用于存储每盘寿司的价格\n    int n = 0; // 初始化寿司盘数为0\n\n    // 从控制台读取每盘寿司的价格，直到读取到换行符\n    while (scanf(\"%d\", &prices[n]) == 1) {\n        n++; // 每读取一个价格，寿司盘数加1\n    }\n\n    int res[MAX_N]; // 创建一个数组，用于存储每个寿司盘享受优惠后的总价格\n    int stack[MAX_N]; // 创建一个数组作为栈使用，用于跟踪寿司价格的索引\n    int top = -1; // 初始化栈顶指针为-1，表示栈为空\n\n    // 遍历每个寿司盘的价格，由于寿司盘是循环的，需要遍历两倍长度减一次\n    for (int j = 0; j < n * 2 - 1; j++) {\n        // 计算当前索引，由于数组是循环的，使用模运算得到实际索引\n        int index = j % n;\n        // 当栈不为空且栈顶元素的价格大于当前索引对应的价格时\n        while (top >= 0 && prices[stack[top]] > prices[index]) {\n            // 弹出栈顶元素的索引\n            int topIndex = stack[top--];\n            // 计算栈顶元素享受优惠后的价格，并更新结果数组\n            res[topIndex] = prices[topIndex] + prices[index];\n        }\n        // 第一轮遍历时，将索引压入栈中\n        if (j < n) {\n            stack[++top] = index;\n        }\n    }\n\n    // 遍历完成后，栈中剩余的元素代表它们右侧没有更小的价格\n    // 直接将它们自身的价格作为结果\n    while (top >= 0) {\n        int topIndex = stack[top--];\n        res[topIndex] = prices[topIndex];\n    }\n\n    // 输出每个寿司盘享受优惠后的总价格\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", res[i]);\n    }\n\n    return 0;\n}"
  }
}