{
  "id": "157",
  "title": "最佳的出牌方法",
  "examType": "A",
  "score": 200,
  "description": "手上有一副扑克牌，每张牌按牌面数字记分（J=11,Q=12,K=13，没有大小王)，出牌时按照以下规则记分：\n出单张，记牌面分数，例如出一张2，得分为2出对或3张，记牌面分数总和再x2，例如出3张3，得分为(3+3+3)x2=18出5张顺，记牌面分数总和再x2，例如出34567顺，得分为(3+4+5+6+7)x2=50出4张炸弹，记牌面分数总和再x3，例如出4张4，得分为4x4x3=48\n求出一副牌最高的得分数\n",
  "inputDesc": "按顺序排好的一副牌，最少1张，最多15张。 1-9输入为数字1-9，10输入为数字0，JQK输入为大写字母JQK. 无需考虑输入非法的情况，例如输入字符不在[0-9JQK]范围或某一张牌超过4张\n",
  "outputDesc": "最高的得分数\n\n积分规则中没有的出牌方式不支持，例如不支持3带1、4带2，不支持5张以上的顺，且10JQKA (0JQK1) 不算顺。\n\n出对3、对4、对7，单张5、6，得分为67;\n出34567顺，再出单张3、4、7，得分为64\n因此最高得分是按对出，可得到最高分67，输出结果67\n\n本题数量级不大，可以考虑暴力破解。\n\n首先定义一个数组card_count，数组索引就是牌分数，数组元素就是牌数量\n因为本题中牌面是不连续的，比如0代表10，但是牌分数是连续的。\n因此，将牌分数作为数组索引来看的话，就可以用一个长度为5的滑窗来在card_count中找顺子。\n由于K牌面分数是13，因此我们只需要定义card_count数组长度为14即可，题目用例可得数组如下：\n\n\n有了card_count之后，我们就可以开始遍历每一种牌（即遍历card_count数组的索引 i ）：\n对于上面这些出牌策略，我们都可以选或者不选，\n比如当前card_count[i] >= 2，那么我们可以选择出对子，也可以选择不出对子\n只有这样，我们才能尝试出所有出牌的策略组合，这里明显需要用到递归和回溯。\n\n2023.10.29\n之前的代码逻辑中，如下（C语言代码，其他语言的考友可以当成伪代码看）\n\n上面代码逻辑是存在重复探索的。\nstartIdx 位置的牌，可以从 for 循环进入出牌逻辑，也可以从 递归进入出牌逻辑，这会产生冗余探索。\n我们可以只基于递归来完成所有出牌策略的探索。只是需要增加 card_count[startIdx] == 0 时，即 startIdx 位置没有牌时，自动递归到 startIdx + 1 位置出牌的逻辑。\n",
  "examples": [
    {
      "input": "334477",
      "output": "67",
      "explanation": "出对3、对4、对7得(3*2+4*2+7*2)*2=56+4+6+1=67"
    },
    {
      "input": "34567",
      "output": "50",
      "explanation": "出34567顺子得(3+4+5+6+7)*2=50"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**回溯搜索**问题。\n\n**核心思路：**\n- 枚举所有出牌策略组合\n- 单张得牌面分，对子/三张得分*2，炸弹得分*3，顺子得分*2\n- 回溯找最大得分\n\n**算法步骤：**\n1. 统计各牌面数量(0=10,J=11,Q=12,K=13)\n2. 从牌面1开始递归尝试各种出法\n3. 每种出法：单张、对子、三张、炸弹、顺子\n4. 回溯更新最大得分\n\n**时间复杂度**：O(指数级)，但牌数≤15可接受",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  // 保存最大分数\n  static int max_score = 0;\n\n  public static int getResult(String cards) {\n    // 数组索引是牌面分数, 数组元素是牌面数量, 其中 0 索引不用\n    int[] card_count = new int[14];\n\n    // 统计各种牌的数量\n    for (int i = 0; i < cards.length(); i++) {\n      char card = cards.charAt(i);\n\n      // 1-9输入为数字1-9，10输入为数字0，JQK输入为大写字母JQK\n      // 1-9 牌面分数就是 1-9, 0的牌面分数是 10, J=11,Q=12,K=13, 可以发现牌面分数是连续的，可以和card_count数组的索引对应起来\n      if (card == '0') card_count[10]++;\n      else if (card == 'J') card_count[11]++;\n      else if (card == 'Q') card_count[12]++;\n      else if (card == 'K') card_count[13]++;\n      else card_count[card - '0']++;\n    }\n\n    getMaxScore(card_count, cards.length(), 1, 0);\n\n    return max_score;\n  }\n\n  /**\n   * 获取最大分数\n   *\n   * @param card_count 各种牌的数量\n   * @param unused_card_count 剩余牌的总数量\n   * @param startIdx 从哪个位置开始选牌\n   * @param score 此时已获得的总分数\n   */\n  public static void getMaxScore(int[] card_count, int unused_card_count, int startIdx, int score) {\n    // 所有牌都打完了\n    if (unused_card_count == 0) {\n      // 则比较此时出牌策略获得的总分score，和历史最高分max_score，保留较大者\n      max_score = Math.max(score, max_score);\n      return;\n    }\n\n    // 没有可以出的牌，则继续递归到startIdx+1开始出牌\n    if (card_count[startIdx] == 0) {\n      getMaxScore(card_count, unused_card_count, startIdx + 1, score);\n    }\n\n    // 还有可以出的牌，则从startIdx开始出牌\n    // 如果当前牌的数量至少1张\n    if (card_count[startIdx] >= 1) {\n      // 策略1、可以尝试出顺子，由于最大的顺子是9,10,J,Q,K,因此 i 作为顺子起始牌的话，不能超过9，且后续牌面 i+1, i+2, i+3, i+4 的数量都至少有1张\n      if (startIdx <= 9\n          && card_count[startIdx + 1] >= 1\n          && card_count[startIdx + 2] >= 1\n          && card_count[startIdx + 3] >= 1\n          && card_count[startIdx + 4] >= 1) {\n        card_count[startIdx] -= 1;\n        card_count[startIdx + 1] -= 1;\n        card_count[startIdx + 2] -= 1;\n        card_count[startIdx + 3] -= 1;\n        card_count[startIdx + 4] -= 1;\n        // 顺子是5张牌，因此出掉顺子后，可用牌数量减少5张，总分增加 (i + (i+1) + (i+2) + (i+3) + (i+4)) * 2\n        getMaxScore(card_count, unused_card_count - 5, startIdx, score + (5 * startIdx + 10) * 2);\n        // 回溯\n        card_count[startIdx] += 1;\n        card_count[startIdx + 1] += 1;\n        card_count[startIdx + 2] += 1;\n        card_count[startIdx + 3] += 1;\n        card_count[startIdx + 4] += 1;\n      }\n\n      // 策略2、出单张\n      card_count[startIdx] -= 1;\n      getMaxScore(card_count, unused_card_count - 1, startIdx, score + startIdx);\n      card_count[startIdx] += 1;\n    }\n\n    // 如果当前牌的数量至少2张，那么可以出对子\n    if (card_count[startIdx] >= 2) {\n      card_count[startIdx] -= 2;\n      getMaxScore(card_count, unused_card_count - 2, startIdx, score + startIdx * 2 * 2);\n      card_count[startIdx] += 2;\n    }\n\n    // 如果当前牌的数量至少3张，那么可以出三张\n    if (card_count[startIdx] >= 3) {\n      card_count[startIdx] -= 3;\n      getMaxScore(card_count, unused_card_count - 3, startIdx, score + startIdx * 3 * 2);\n      card_count[startIdx] += 3;\n    }\n\n    // 当前当前牌的数量至少4张，那么可以出炸弹\n    if (card_count[startIdx] >= 4) {\n      card_count[startIdx] -= 4;\n      getMaxScore(card_count, unused_card_count - 4, startIdx, score + startIdx * 4 * 3);\n      card_count[startIdx] += 4;\n    }\n  }\n}",
    "python": "# 输入获取\ncards = input()\n\n# 保存最大分数\nmax_score = 0\n\n\n# 获取牌的最大得分\ndef getMaxScore(card_count, unused_card_count, i, score):\n    \"\"\"\n    获取最大分数\n    :param card_count: 各种牌的数量\n    :param unused_card_count: 剩余牌的总数量\n    :param i: 从哪个位置开始选牌\n    :param score: 此时已获得的总分数\n    \"\"\"\n    global max_score\n\n    # 所有牌都打完了\n    if unused_card_count == 0:\n        # 则比较此时出牌策略获得的总分score，和历史最高分max_score，保留较大者\n        max_score = max(max_score, score)\n        return\n\n    # 没有可以出的牌，则继续递归到i+1开始出牌\n    if card_count[i] == 0:\n        getMaxScore(card_count, unused_card_count, i + 1, score);\n\n    # 还有可以出的牌，则从i开始出牌\n    # 如果当前牌的数量至少1张\n    if card_count[i] >= 1:\n        # 策略1、可以尝试出顺子，由于最大的顺子是9,10,J,Q,K,因此 i 作为顺子起始牌的话，不能超过9，且后续牌面 i+1, i+2, i+3, i+4 的数量都至少有1张\n        if i <= 9 and card_count[i + 1] >= 1 and card_count[i + 2] >= 1 and card_count[i + 3] >= 1 and card_count[i + 4] >= 1:\n            card_count[i] -= 1\n            card_count[i + 1] -= 1\n            card_count[i + 2] -= 1\n            card_count[i + 3] -= 1\n            card_count[i + 4] -= 1\n            # 顺子是5张牌，因此出掉顺子后，可用牌数量减少5张，总分增加 (i + (i+1) + (i+2) + (i+3) + (i+4)) * 2\n            getMaxScore(card_count, unused_card_count - 5, i, score + (5 * i + 10) * 2)\n            # 回溯\n            card_count[i] += 1\n            card_count[i + 1] += 1\n            card_count[i + 2] += 1\n            card_count[i + 3] += 1\n            card_count[i + 4] += 1\n\n        # 策略2、出单张\n        card_count[i] -= 1\n        getMaxScore(card_count, unused_card_count - 1, i, score + i)\n        card_count[i] += 1\n\n    # 如果当前牌的数量至少2张，那么可以出对子\n    if card_count[i] >= 2:\n        card_count[i] -= 2\n        getMaxScore(card_count, unused_card_count - 2, i, score + i * 2 * 2)\n        card_count[i] += 2\n\n    # 如果当前牌的数量至少3张，那么可以出三张\n    if card_count[i] >= 3:\n        card_count[i] -= 3\n        getMaxScore(card_count, unused_card_count - 3, i, score + i * 3 * 2)\n        card_count[i] += 3\n\n    # 当前当前牌的数量至少4张，那么可以出炸弹\n    if card_count[i] >= 4:\n        card_count[i] -= 4\n        getMaxScore(card_count, unused_card_count - 4, i, score + i * 4 * 3)\n        card_count[i] += 4\n\n\n# 算法入口\ndef getResult():\n    # 数组索引是牌面分数, 数组元素是牌面数量, 其中 0 索引不用\n    card_count = [0] * 14\n\n    # 统计各种牌的数量\n    for card in cards:\n        # 1-9输入为数字1-9，10输入为数字0，JQK输入为大写字母JQK\n        # 1-9 牌面分数就是 1-9, 0的牌面分数是 10, J=11,Q=12,K=13, 可以发现牌面分数是连续的，可以和card_count数组的索引对应起来\n        if card == '0':\n            card_count[10] += 1\n        elif card == 'J':\n            card_count[11] += 1\n        elif card == 'Q':\n            card_count[12] += 1\n        elif card == 'K':\n            card_count[13] += 1\n        else:\n            i = ord(card) - ord('0')\n            card_count[i] += 1\n\n    getMaxScore(card_count, len(cards), 1, 0)\n\n    return max_score\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}