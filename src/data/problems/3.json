{
  "id": "3",
  "title": "VLAN资源池",
  "examType": "A",
  "score": 100,
  "description": "VLAN是一种对局域网设备进行逻辑划分的技术，为了标识不同的VLAN，引入VLAN ID(1-4094之间的整数)的概念。\n\n定义一个VLAN ID的资源池(下称VLAN资源池)，资源池中连续的VLAN用`开始VLAN-结束VLAN`表示，不连续的用单个整数表示，所有的VLAN用英文逗号连接起来。\n\n现在有一个VLAN资源池，业务需要从资源池中申请一个VLAN，需要你输出从VLAN资源池中移除申请的VLAN后的资源池。",
  "inputDesc": "第一行为字符串格式的VLAN资源池\n第二行为业务要申请的VLAN，VLAN的取值范围为[1,4094]之间的整数",
  "outputDesc": "从输入VLAN资源池中移除申请的VLAN后字符串格式的VLAN资源池，输出要求满足题目描述中的格式，并且按照VLAN从小到大升序输出。\n\n如果申请的VLAN不在原VLAN资源池内，输出原VLAN资源池升序排序后的字符串即可。",
  "examples": [
    {
      "input": "1-5\n2",
      "output": "1,3-5",
      "explanation": "原VLAN资源池中有VLAN 1、2、3、4、5，从资源池中移除2后，剩下VLAN 1、3、4、5，按照题目描述格式并升序后的结果为1,3-5"
    },
    {
      "input": "20-21,15,18,30,5-10\n15",
      "output": "5-10,18,20-21,30",
      "explanation": "原VLAN资源池中有VLAN 5、6、7、8、9、10、15、18、20、21、30，从资源池中移除15后，资源池中剩下的VLAN为 5、6、7、8、9、10、18、20、21、30，按照题目描述格式并升序后的结果为5-10,18,20-21,30"
    },
    {
      "input": "5,1-3\n10",
      "output": "1-3,5",
      "explanation": "原VLAN资源池中有VLAN 1、2、3、5，申请的VLAN 10不在原资源池中，将原资源池按照题目描述格式并按升序排序后输出的结果为1-3,5"
    }
  ],
  "solution": "**解题思路：**\n\n1. **解析VLAN资源池**：将输入字符串按逗号分割，对于每个部分：\n   - 如果包含`-`，表示连续范围，解析起始和结束值，展开为所有VLAN\n   - 否则是单个VLAN ID\n\n2. **移除目标VLAN**：从解析后的VLAN集合中移除要申请的VLAN\n\n3. **格式化输出**：将剩余的VLAN排序后，合并连续的VLAN为范围格式\n   - 连续的VLAN用`start-end`表示\n   - 不连续的用逗号分隔\n\n**关键点：**\n- 注意处理边界情况：VLAN不在池中、池为空等\n- 输出必须升序排列\n- 连续VLAN的范围表示要正确",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String input = sc.nextLine();\n        int destVlan = Integer.parseInt(sc.nextLine());\n\n        // 解析VLAN资源池\n        List<Integer> vlanPool = parseVlanPool(input);\n        Collections.sort(vlanPool);\n\n        // 移除申请的VLAN\n        vlanPool.remove(Integer.valueOf(destVlan));\n\n        // 格式化输出\n        System.out.println(formatVlanPool(vlanPool));\n    }\n\n    private static List<Integer> parseVlanPool(String input) {\n        List<Integer> pool = new ArrayList<>();\n        String[] groups = input.split(\",\");\n        for (String group : groups) {\n            if (group.contains(\"-\")) {\n                String[] range = group.split(\"-\");\n                int start = Integer.parseInt(range[0]);\n                int end = Integer.parseInt(range[1]);\n                for (int i = start; i <= end; i++) {\n                    pool.add(i);\n                }\n            } else {\n                pool.add(Integer.parseInt(group));\n            }\n        }\n        return pool;\n    }\n\n    private static String formatVlanPool(List<Integer> pool) {\n        if (pool.isEmpty()) return \"\";\n        \n        StringBuilder result = new StringBuilder();\n        int start = pool.get(0);\n        int prev = start;\n\n        for (int i = 1; i < pool.size(); i++) {\n            if (pool.get(i) == prev + 1) {\n                prev = pool.get(i);\n            } else {\n                appendRange(result, start, prev);\n                result.append(\",\");\n                start = pool.get(i);\n                prev = start;\n            }\n        }\n        appendRange(result, start, prev);\n        return result.toString();\n    }\n\n    private static void appendRange(StringBuilder sb, int start, int end) {\n        if (start == end) {\n            sb.append(start);\n        } else {\n            sb.append(start).append(\"-\").append(end);\n        }\n    }\n}",
    "python": "def parse_vlan_pool(input_str):\n    pool = []\n    for group in input_str.split(','):\n        if '-' in group:\n            start, end = map(int, group.split('-'))\n            pool.extend(range(start, end + 1))\n        else:\n            pool.append(int(group))\n    return pool\n\ndef format_vlan_pool(pool):\n    if not pool:\n        return \"\"\n    \n    pool = sorted(pool)\n    result = []\n    start = prev = pool[0]\n    \n    for vlan in pool[1:]:\n        if vlan == prev + 1:\n            prev = vlan\n        else:\n            if start == prev:\n                result.append(str(start))\n            else:\n                result.append(f\"{start}-{prev}\")\n            start = prev = vlan\n    \n    # 处理最后一组\n    if start == prev:\n        result.append(str(start))\n    else:\n        result.append(f\"{start}-{prev}\")\n    \n    return ','.join(result)\n\n# 主程序\nvlan_input = input()\ndest_vlan = int(input())\n\npool = parse_vlan_pool(vlan_input)\nif dest_vlan in pool:\n    pool.remove(dest_vlan)\n\nprint(format_vlan_pool(pool))",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nfunction parseVlanPool(input) {\n  const pool = [];\n  for (const group of input.split(',')) {\n    if (group.includes('-')) {\n      const [start, end] = group.split('-').map(Number);\n      for (let i = start; i <= end; i++) {\n        pool.push(i);\n      }\n    } else {\n      pool.push(Number(group));\n    }\n  }\n  return pool;\n}\n\nfunction formatVlanPool(pool) {\n  if (pool.length === 0) return '';\n  \n  pool.sort((a, b) => a - b);\n  const result = [];\n  let start = pool[0], prev = start;\n  \n  for (let i = 1; i < pool.length; i++) {\n    if (pool[i] === prev + 1) {\n      prev = pool[i];\n    } else {\n      result.push(start === prev ? String(start) : `${start}-${prev}`);\n      start = prev = pool[i];\n    }\n  }\n  result.push(start === prev ? String(start) : `${start}-${prev}`);\n  return result.join(',');\n}\n\nlet lines = [];\nrl.on('line', (line) => {\n  lines.push(line);\n  if (lines.length === 2) {\n    const pool = parseVlanPool(lines[0]);\n    const destVlan = Number(lines[1]);\n    const idx = pool.indexOf(destVlan);\n    if (idx !== -1) pool.splice(idx, 1);\n    console.log(formatVlanPool(pool));\n    rl.close();\n  }\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nvector<int> parseVlanPool(const string& input) {\n    vector<int> pool;\n    stringstream ss(input);\n    string group;\n    while (getline(ss, group, ',')) {\n        size_t pos = group.find('-');\n        if (pos != string::npos) {\n            int start = stoi(group.substr(0, pos));\n            int end = stoi(group.substr(pos + 1));\n            for (int i = start; i <= end; i++) {\n                pool.push_back(i);\n            }\n        } else {\n            pool.push_back(stoi(group));\n        }\n    }\n    return pool;\n}\n\nstring formatVlanPool(vector<int>& pool) {\n    if (pool.empty()) return \"\";\n    \n    sort(pool.begin(), pool.end());\n    string result;\n    int start = pool[0], prev = start;\n    \n    for (size_t i = 1; i < pool.size(); i++) {\n        if (pool[i] == prev + 1) {\n            prev = pool[i];\n        } else {\n            if (!result.empty()) result += \",\";\n            result += (start == prev) ? to_string(start) : to_string(start) + \"-\" + to_string(prev);\n            start = prev = pool[i];\n        }\n    }\n    if (!result.empty()) result += \",\";\n    result += (start == prev) ? to_string(start) : to_string(start) + \"-\" + to_string(prev);\n    return result;\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n    int destVlan;\n    cin >> destVlan;\n    \n    vector<int> pool = parseVlanPool(input);\n    pool.erase(remove(pool.begin(), pool.end(), destVlan), pool.end());\n    cout << formatVlanPool(pool) << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_VLAN 4096\n\nint pool[MAX_VLAN];\nint poolSize = 0;\n\nvoid parseVlanPool(char* input, int destVlan) {\n    char* token = strtok(input, \",\");\n    while (token != NULL) {\n        char* dash = strchr(token, '-');\n        if (dash) {\n            int start = atoi(token);\n            int end = atoi(dash + 1);\n            for (int i = start; i <= end; i++) {\n                if (i != destVlan) pool[poolSize++] = i;\n            }\n        } else {\n            int vlan = atoi(token);\n            if (vlan != destVlan) pool[poolSize++] = vlan;\n        }\n        token = strtok(NULL, \",\");\n    }\n}\n\nint compare(const void* a, const void* b) {\n    return (*(int*)a - *(int*)b);\n}\n\nvoid formatVlanPool() {\n    if (poolSize == 0) return;\n    \n    qsort(pool, poolSize, sizeof(int), compare);\n    \n    int start = pool[0], prev = start;\n    int first = 1;\n    \n    for (int i = 1; i < poolSize; i++) {\n        if (pool[i] == prev + 1) {\n            prev = pool[i];\n        } else {\n            if (!first) printf(\",\");\n            if (start == prev) printf(\"%d\", start);\n            else printf(\"%d-%d\", start, prev);\n            first = 0;\n            start = prev = pool[i];\n        }\n    }\n    if (!first) printf(\",\");\n    if (start == prev) printf(\"%d\", start);\n    else printf(\"%d-%d\", start, prev);\n    printf(\"\\n\");\n}\n\nint main() {\n    char input[1000];\n    int destVlan;\n    \n    fgets(input, sizeof(input), stdin);\n    input[strcspn(input, \"\\n\")] = 0;\n    scanf(\"%d\", &destVlan);\n    \n    parseVlanPool(input, destVlan);\n    formatVlanPool();\n    return 0;\n}"
  }
}
