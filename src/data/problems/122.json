{
  "id": "122",
  "title": "寻找符合要求的最长子串",
  "examType": "A",
  "score": 200,
  "description": "给定一个字符串s，找出这样一个子串：\n该子串中任意一个字符最多出现2次该子串不包含指定某个字符\n请你找出满足该条件的最长子串的长度",
  "inputDesc": "第一行为：要求不包含的指定字符，为单个字符，取值范围[0-9a-zA-Z]\n第二行为：字符串s，每个字符范围[0-9a-zA-Z]，长度范围[1, 10000]",
  "outputDesc": "第一行为：要求不包含的指定字符，为单个字符，取值范围[0-9a-zA-Z]\n第二行为：字符串s，每个字符范围[0-9a-zA-Z]，长度范围[1, 10000]",
  "examples": [
    {
      "input": "D\nABC123",
      "output": "6",
      "explanation": "整个字符串不含D，且每个字符最多出现1次，满足条件"
    },
    {
      "input": "D\nABACA123D",
      "output": "7",
      "explanation": "最长子串为ACA123（或ABACA12），长度7，不含D且每字符最多2次"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**滑动窗口**问题。\n\n**核心思路：**\n- 维护窗口内每个字符出现次数≤2\n- 遇到排除字符时重置窗口\n- 记录最大窗口长度\n\n**算法步骤：**\n1. 右指针扩展窗口\n2. 遇到排除字符：更新答案，左指针跳过\n3. 字符出现>2次：左指针收缩至该字符首次出现位置+1\n4. 记录窗口下标，取余更新\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 输入exclude和s\n        String exclude = scanner.next();\n        String s = scanner.next();\n\n        // 获取要排除的字符\n        char excludeChar = exclude.charAt(0);\n\n        // 存储每个字符出现的下标\n        Map<Character, List<Integer>> charIndexMap = new HashMap<>();\n\n        // 定义左右指针\n        int left = 0, right = 0;\n\n        // 定义最长子串长度\n        int maxLength = 0;\n\n        // 遍历字符串\n        while (right < s.length()) {\n            char currentChar = s.charAt(right);\n\n            // 如果当前字符是要排除的字符\n            if (excludeChar == currentChar) {\n                // 如果左右指针不在同一位置，说明存在符合条件的子串\n                if (right > left) {\n                    maxLength = Math.max(maxLength, right - left);\n                }\n                // 将左右指针都移动到下一个位置\n                right++;\n                left = right;\n            } else {\n                // 如果当前字符不是要排除的字符\n                // 先将当前字符在map中初始化\n                charIndexMap.computeIfAbsent(currentChar, k -> new ArrayList<>());\n                List<Integer> charIndexes = charIndexMap.get(currentChar);\n                // 如果当前字符的出现次数已经超过2次\n                if (charIndexes.size() == 2) {\n                    // 更新最长子串长度\n                    maxLength = Math.max(maxLength, right - left);\n                    // 将左指针移动到当前字符上一次出现的位置的下一个位置\n                    left = charIndexes.get(0) + 1;\n                    // 删除当前字符在map中的第一个下标\n                    charIndexes.remove(0);\n                }\n                // 将当前字符的下标加入map中\n                charIndexes.add(right);\n                // 右指针向后移动\n                right++;\n            }\n        }\n\n        // 检查最后一个子串是否符合条件\n        maxLength = Math.max(maxLength, right - left);\n\n        // 输出最长子串长度\n        System.out.println(maxLength);\n    }\n}",
    "python": "from collections import defaultdict\n\n# 输入exclude和s\nexclude = input()\ns = input()\n# 获取要排除的字符\nexcludeChar = exclude[0]\n\n# 存储每个字符出现的下标\ncharIndexMap = defaultdict(list)\n\n# 定义左右指针\nleft = 0\nright = 0\n\n# 定义最长子串长度\nmaxLength = 0\n\n# 遍历字符串\nwhile right < len(s):\n    currentChar = s[right]\n\n    # 如果当前字符是要排除的字符\n    if excludeChar == currentChar:\n        # 如果左右指针不在同一位置，说明存在符合条件的子串\n        if right > left:\n            maxLength = max(maxLength, right - left)\n        # 将左右指针都移动到下一个位置\n        right += 1\n        left = right\n    else:\n        # 如果当前字符不是要排除的字符\n        # 先将当前字符在map中初始化\n        charIndexMap[currentChar]\n        charIndexes = charIndexMap[currentChar]\n        # 如果当前字符的出现次数已经超过2次\n        if len(charIndexes) == 2:\n            # 更新最长子串长度\n            maxLength = max(maxLength, right - left)\n            # 将左指针移动到当前字符上一次出现的位置的下一个位置\n            left = charIndexes[0] + 1\n            # 删除当前字符在map中的第一个下标\n            charIndexes.pop(0)\n        # 将当前字符的下标加入map中\n        charIndexes.append(right)\n        # 右指针向后移动\n        right += 1\n\n# 检查最后一个子串是否符合条件\nmaxLength = max(maxLength, right - left)\n\n# 输出最长子串长度\nprint(maxLength)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet exclude = '';\nlet s = '';\n\nrl.on('line', (input) => {\n  if (!exclude) {\n    exclude = input;\n  } else {\n    s = input;\n\n    // 获取要排除的字符\n    const excludeChar = exclude[0];\n\n    // 存储每个字符出现的下标\n    const charIndexMap = {};\n\n    // 定义左右指针\n    let left = 0;\n    let right = 0;\n\n    // 定义最长子串长度\n    let maxLength = 0;\n\n    // 遍历字符串\n    while (right < s.length) {\n      const currentChar = s[right];\n\n      // 如果当前字符是要排除的字符\n      if (excludeChar === currentChar) {\n        // 如果左右指针不在同一位置，说明存在符合条件的子串\n        if (right > left) {\n          maxLength = Math.max(maxLength, right - left);\n        }\n        // 将左右指针都移动到下一个位置\n        right++;\n        left = right;\n      } else {\n        // 如果当前字符不是要排除的字符\n        // 先将当前字符在map中初始化\n        charIndexMap[currentChar] = charIndexMap[currentChar] || [];\n        const charIndexes = charIndexMap[currentChar];\n        // 如果当前字符的出现次数已经超过2次\n        if (charIndexes.length === 2) {\n          // 更新最长子串长度\n          maxLength = Math.max(maxLength, right - left);\n          // 将左指针移动到当前字符上一次出现的位置的下一个位置\n          left = charIndexes[0] + 1;\n          // 删除当前字符在map中的第一个下标\n          charIndexes.shift();\n        }\n        // 将当前字符的下标加入map中\n        charIndexes.push(right);\n        // 右指针向后移动\n        right++;\n      }\n    }\n\n    // 检查最后一个子串是否符合条件\n    maxLength = Math.max(maxLength, right - left);\n\n    // 输出最长子串长度\n    console.log(maxLength);\n\n    rl.close();\n  }\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    // 输入exclude和s\n    string exclude, s;\n    cin >> exclude >> s;\n    // 获取要排除的字符\n    char excludeChar = exclude[0];\n\n    // 存储每个字符出现的下标\n    unordered_map<char, vector<int>> charIndexMap;\n\n    // 定义左右指针\n    int left = 0, right = 0;\n\n    // 定义最长子串长度\n    int maxLength = 0;\n\n    // 遍历字符串\n    while (right < s.length()) {\n        char currentChar = s[right];\n\n        // 如果当前字符是要排除的字符\n        if (excludeChar == currentChar) {\n            // 如果左右指针不在同一位置，说明存在符合条件的子串\n            if (right > left) {\n                maxLength = max(maxLength, right - left);\n            }\n            // 将左右指针都移动到下一个位置\n            right++;\n            left = right;\n        } else {\n            // 如果当前字符不是要排除的字符\n            // 先将当前字符在map中初始化\n            charIndexMap[currentChar];\n            vector<int>& charIndexes = charIndexMap[currentChar];\n            // 如果当前字符的出现次数已经超过2次\n            if (charIndexes.size() == 2) {\n                // 更新最长子串长度\n                maxLength = max(maxLength, right - left);\n                // 将左指针移动到当前字符上一次出现的位置的下一个位置\n                left = charIndexes[0] + 1;\n                // 删除当前字符在map中的第一个下标\n                charIndexes.erase(charIndexes.begin());\n            }\n            // 将当前字符的下标加入map中\n            charIndexes.push_back(right);\n            // 右指针向后移动\n            right++;\n        }\n    }\n\n    // 检查最后一个子串是否符合条件\n    maxLength = max(maxLength, right - left);\n\n    // 输出最长子串长度\n    cout << maxLength << endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LENGTH 10000\n\n// 用于存储每个字符的出现下标\nint charIndexMap[128][3];\n\nint main() {\n    char excludeChar;\n    char s[MAX_LENGTH + 1];\n\n    // 读取排除字符和字符串\n    scanf(\"%c\", &excludeChar);\n    scanf(\"%s\", s);\n\n    // 初始化存储字符下标的数组\n    for (int i = 0; i < 128; i++) {\n        charIndexMap[i][0] = charIndexMap[i][1] = -1;\n    }\n\n    int left = 0, right = 0;\n    int maxLength = 0;\n    int length = strlen(s);\n\n    // 遍历字符串\n    while (right < length) {\n        char currentChar = s[right];\n\n        // 如果当前字符是要排除的字符\n        if (currentChar == excludeChar) {\n            if (right > left) {\n                maxLength = right - left > maxLength ? right - left : maxLength;\n            }\n            right++;\n            left = right;\n        } else {\n            // 如果当前字符不是要排除的字符\n            int* charIndexes = charIndexMap[currentChar];\n\n            // 如果当前字符的出现次数已经超过2次\n            if (charIndexes[1] != -1) {\n                maxLength = right - left > maxLength ? right - left : maxLength;\n                left = charIndexes[0] + 1;\n                charIndexes[0] = charIndexes[1];\n                charIndexes[1] = -1;\n            }\n\n            // 将当前字符的下标加入到数组中\n            if (charIndexes[0] == -1) {\n                charIndexes[0] = right;\n            } else {\n                charIndexes[1] = right;\n            }\n\n            // 右指针向后移动\n            right++;\n        }\n    }\n\n    // 检查最后一个子串是否符合条件\n    maxLength = right - left > maxLength ? right - left : maxLength;\n\n    // 输出最长子串长度\n    printf(\"%d\\n\", maxLength);\n\n    return 0;\n}"
  }
}