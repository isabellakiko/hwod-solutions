{
  "id": "192",
  "title": "最大数字",
  "examType": "B",
  "score": 100,
  "description": "给定一个由纯数字组成以字符串表示的数值，现要求字符串中的每个数字最多只能出现2次，超过的需要进行删除；\n删除某个重复的数字后，其它数字相对位置保持不变。\n如”34533″，数字3重复超过2次，需要删除其中一个3，删除第一个3后获得最大数值”4533″\n请返回经过删除操作后的最大的数值，以字符串表示。\n",
  "inputDesc": "第一行为一个纯数字组成的字符串，长度范围：[1,100000]\n",
  "outputDesc": "输出经过删除操作后的最大的数值\n\n本题最优解题思路是利用栈结构。\n\n首先，我们需要定义两个map，分别是unused和reserve，其中：\n然后对他们进行初始化，初始时unused就是统计输入字符串中各数字字符的出现次数，而reserve每个数字字符的个数都初始化为0。\n\n接下来，遍历出输入字符串的每个字符c：\n如果此时stack栈顶没有元素，则将遍历的c直接压入栈，然后unused[c]--，reserve[c]++\n如果此时stack栈顶有元素，假设为top，则：\n",
  "examples": [
    {
      "input": "34533",
      "output": "4533",
      "explanation": "3出现3次超过2次，删除第一个3得到最大数值4533"
    },
    {
      "input": "5445795045",
      "output": "9795545",
      "explanation": "4和5各出现超过2次，保留使数值最大的组合"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**单调栈**问题。\n\n**核心思路：**\n- 每个数字最多保留2个\n- 贪心地让高位尽可能大\n\n**算法步骤：**\n1. 统计各数字的可用数量和已保留数量\n2. 遍历数字，若已保留2个则跳过\n3. 若当前数字大于栈顶且栈顶还有可用，则弹出栈顶\n4. 将当前数字入栈\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String str = sc.next();\n\n    System.out.println(getResult(str));\n  }\n\n  public static String getResult(String str) {\n    // 每个数字字符的可用个数\n    HashMap<Character, Integer> unused = new HashMap<>();\n    // 每个数字字符的保留个数\n    HashMap<Character, Integer> reserve = new HashMap<>();\n\n    // 初始时，每个数字有多少个，就可用多少个，由于还未使用，因此保留个数为0\n    for (int i = 0; i < str.length(); i++) {\n      char c = str.charAt(i);\n      unused.put(c, unused.getOrDefault(c, 0) + 1);\n      reserve.putIfAbsent(c, 0);\n    }\n\n    // 定义一个栈\n    LinkedList<Character> stack = new LinkedList<>();\n\n    // 遍历输入字符串的每个数字字符c\n    for (int i = 0; i < str.length(); i++) {\n      char c = str.charAt(i);\n\n      // 如果该字符已经保留了2个了，则后续再出现该数字字符可以不保留\n      if (reserve.get(c) == 2) {\n        // 则可用c数字个数--\n        unused.put(c, unused.get(c) - 1);\n        continue;\n      }\n\n      // 比较当前数字c和栈顶数字top，如果c>top，那么需要考虑将栈顶数字弹出\n      while (stack.size() > 0) {\n        char top = stack.getLast();\n\n        // 如果栈顶数字被弹出后，已保留的top字符数量和未使用的top字符数量之和大于等于2，则可以弹出，否则不可以\n        if (top < c && unused.get(top) + reserve.get(top) - 1 >= 2) {\n          stack.removeLast();\n          reserve.put(top, reserve.get(top) - 1);\n        } else {\n          break;\n        }\n      }\n\n      // 选择保留当前遍历的数字c\n      stack.add(c);\n      // 则可用c数字个数--\n      unused.put(c, unused.get(c) - 1);\n      // 已保留c数字个数++\n      reserve.put(c, reserve.get(c) + 1);\n    }\n\n    StringBuilder sb = new StringBuilder();\n    for (Character c : stack) {\n      sb.append(c);\n    }\n    return sb.toString();\n  }\n}",
    "python": "# 输入获取\ns = input()\n\n\n# 算法入口\ndef getResult(s):\n    # 每个数字字符的可用个数\n    unused = {}\n    # 每个数字字符的保留个数\n    reserve = {}\n\n    # 初始时，每个数字有多少个，就可用多少个，由于还未使用，因此保留个数为0\n    for c in s:\n        if unused.get(c) is None:\n            unused[c] = 0\n\n        if reserve.get(c) is None:\n            reserve[c] = 0\n\n        unused[c] += 1\n\n    # 定义一个栈\n    stack = []\n\n    # 遍历输入字符串的每个数字字符c\n    for c in s:\n        # 如果该字符已经保留了2个了，则后续再出现该数字字符可以不保留\n        if reserve[c] == 2:\n            # 则可用c数字个数--\n            unused[c] -= 1\n            continue\n\n        # 比较当前数字c和栈顶数字top，如果c>top，那么需要考虑将栈顶数字弹出\n        while len(stack) > 0:\n            top = stack[-1]\n\n            # 如果栈顶数字被弹出后，已保留的top字符数量和未使用的top字符数量之和大于等于2，则可以弹出，否则不可以\n            if top < c and unused[top] + reserve[top] - 1 >= 2:\n                stack.pop()\n                reserve[top] -= 1\n            else:\n                break\n\n        # 选择保留当前遍历的数字c\n        stack.append(c)\n        # 则可用c数字个数--\n        unused[c] -= 1\n        # 已保留c数字个数++\n        reserve[c] += 1\n\n    return \"\".join(stack)\n\n\n# 算法调用\nprint(getResult(s))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  console.log(getResult(line));\n});\n\nfunction getResult(str) {\n  // 每个数字字符的可用个数\n  const unused = {};\n  // 每个数字字符的保留个数\n  const reserve = {};\n\n  // 初始时，每个数字有多少个，就可用多少个，由于还未使用，因此保留个数为0\n  for (let c of str) {\n    unused[c] ? unused[c]++ : (unused[c] = 1);\n    reserve[c] = 0;\n  }\n\n  // 定义一个栈\n  const stack = [];\n\n  // 遍历输入字符串的每个数字字符c\n  for (let c of str) {\n    // 如果该字符已经保留了2个了，则后续再出现该数字字符可以不保留\n    if (reserve[c] == 2) {\n      // 则可用c数字个数--\n      unused[c]--;\n      continue;\n    }\n\n    // 比较当前数字c和栈顶数字top，如果c>top，那么需要考虑将栈顶数字弹出\n    while (stack.length) {\n      const top = stack.at(-1);\n\n      // 如果栈顶数字被弹出后，已保留的top字符数量和未使用的top字符数量之和大于等于2，则可以弹出，否则不可以\n      if (top < c && unused[top] + reserve[top] - 1 >= 2) {\n        stack.pop();\n        reserve[top]--;\n      } else {\n        break;\n      }\n    }\n\n    // 选择保留当前遍历的数字c\n    stack.push(c);\n    // 则可用c数字个数--\n    unused[c]--;\n    // 已保留c数字个数++\n    reserve[c]++;\n  }\n\n  return stack.join(\"\");\n}\n;",
    "cpp": "",
    "c": ""
  }
}