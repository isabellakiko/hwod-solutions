{
  "id": "19",
  "title": "开心消消乐",
  "examType": "A",
  "score": 100,
  "description": "给定一个N行M列的二维矩阵，矩阵中每个位置的数字取值为0或1。矩阵示例如：\n1234\n现需要将矩阵中所有的1进行反转为0，规则如下：\n当点击一个1时，该1便被反转为0，同时相邻的上、下、左、右，以及左上、左下、右上、右下8 个方向的1（如果存在1）均会自动反转为0；进一步地，一个位置上的1被反转为0时，与其相邻的8个方向的1（如果存在1）均会自动反转为0；\n按照上述规则示例中的矩阵只最少需要点击2次后，所有值均为0。\n请问，给定一个矩阵，最少需要点击几次后，所有数字均为0？",
  "inputDesc": "第一行为两个整数，分别表示句子的行数 N 和列数 M，取值范围均为 [1, 100]\n接下来 N 行表示矩阵的初始值，每行均为 M 个数，取值范围 [0, 1]",
  "outputDesc": "输出一个整数，表示最少需要点击的次数",
  "examples": [
    {
      "input": "3 3\n0 1 0\n1 1 1\n0 1 0",
      "output": "1",
      "explanation": "3x3矩阵，中间的1与四周的1都连通（8方向），形成一个连通块，点击一次即可全部变0。"
    },
    {
      "input": "4 3\n1 0 0\n0 0 1\n0 1 1\n1 1 1",
      "output": "2",
      "explanation": "4x3矩阵。\n左上角的1(0,0)孤立，是一个连通块。\n右边的1组成另一个连通块：(0,2)→(1,2)→(2,1)→(2,2)→(3,0)→(3,1)→(3,2)都连通。\n共2个连通块，需要点击2次。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**DFS/BFS 连通块计数**问题，类似于 LeetCode 200.岛屿数量。\n\n**核心思想：**\n- 点击一个1，会将其所在的整个8方向连通块全部变为0\n- 因此，最少点击次数 = 矩阵中1的连通块数量\n\n**算法步骤：**\n\n1. 遍历矩阵的每个位置\n2. 遇到1时，连通块计数+1\n3. 从该位置进行DFS，将整个连通块的1全部标记为0（已访问）\n4. 继续遍历直到结束\n\n**8个方向**：上、下、左、右、左上、左下、右上、右下\n\n**时间复杂度**：O(N*M)，每个格子最多访问一次",
  "codes": {
    "java": "import java.util.Scanner;\n\nclass Main {\n    public static void main(String[] args) {\n        // 处理输入\n        Scanner in = new Scanner(System.in);\n        int rows = in.nextInt(); // 输入矩阵的行数\n        int cols = in.nextInt(); // 输入矩阵的列数\n        int[][] matrix = new int[rows][cols]; // 定义一个rows行cols列的矩阵\n        for (int i = 0; i < rows; i++) { // 遍历矩阵的每一行\n            for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n                matrix[i][j] = in.nextInt(); // 读入矩阵的每一个元素\n            }\n        }\n\n        int result = 0; // 定义结果变量，表示矩阵中1的连通块数量\n        for (int i = 0; i < rows; i++) { // 遍历矩阵的每一行\n            for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n                // 从任意一个位置的1开始遍历\n                if (matrix[i][j] == 1) { // 如果当前位置是1\n                    result++; // 连通块数量加1\n                    dfs(matrix, i, j); // 对以当前位置为起点的连通块进行深度优先遍历\n                }\n            }\n        }\n        System.out.println(result); // 输出矩阵中1的连通块数量\n    }\n\n    public static void dfs(int[][] matrix, int x, int y) {\n        matrix[x][y] = 0; // 将当前位置的值设为0，表示已经遍历过\n        int rows = matrix.length; // 矩阵的行数\n        int cols = matrix[0].length; // 矩阵的列数\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}}; // 定义8个方向的偏移量\n        for (int[] dir : directions) { // 遍历8个方向\n            int nextX = x + dir[0]; // 计算下一个位置的行坐标\n            int nextY = y + dir[1]; // 计算下一个位置的列坐标\n            if (nextX >= 0 && nextX < rows && nextY >= 0 && nextY < cols && matrix[nextX][nextY] == 1) { // 如果下一个位置在矩阵范围内且值为1\n                dfs(matrix, nextX, nextY); // 对下一个位置进行深度优先遍历\n            }\n        }\n    }\n}",
    "python": "def dfs(matrix, x, y):\n    matrix[x][y] = 0 # 将当前位置的值设为0，表示已经遍历过\n    rows, cols = len(matrix), len(matrix[0]) # 矩阵的行数和列数\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] # 定义8个方向的偏移量\n    for dir in directions: # 遍历8个方向\n        nextX, nextY = x + dir[0], y + dir[1] # 计算下一个位置的行坐标和列坐标\n        if 0 <= nextX < rows and 0 <= nextY < cols and matrix[nextX][nextY] == 1: # 如果下一个位置在矩阵范围内且值为1\n            dfs(matrix, nextX, nextY) # 对下一个位置进行深度优先遍历\nrows, cols = map(int, input().split()) # 输入矩阵的行数和列数\nmatrix = [] # 定义一个空列表存放矩阵\nfor i in range(rows): # 遍历矩阵的每一行\n    row = list(map(int, input().split())) # 读入矩阵的每一行\n    matrix.append(row) # 将每一行添加到矩阵中\n\nresult = 0 # 定义结果变量，表示矩阵中1的连通块数量\nfor i in range(rows): # 遍历矩阵的每一行\n    for j in range(cols): # 遍历矩阵的每一列\n        # 从任意一个位置的1开始遍历\n        if matrix[i][j] == 1: # 如果当前位置是1\n            result += 1 # 连通块数量加1\n            dfs(matrix, i, j) # 对以当前位置为起点的连通块进行深度优先遍历\n\nprint(result) # 输出矩阵中1的连通块数量",
    "javascript": "function dfs(matrix, x, y) {\n  matrix[x][y] = 0; // 将当前位置的值设为0，表示已经遍历过\n  const rows = matrix.length;\n  const cols = matrix[0].length; // 矩阵的行数和列数\n  const directions = [\n    [-1, 0],\n    [1, 0],\n    [0, -1],\n    [0, 1],\n    [-1, -1],\n    [-1, 1],\n    [1, -1],\n    [1, 1],\n  ]; // 定义8个方向的偏移量\n  for (let dir of directions) {\n    // 遍历8个方向\n    const nextX = x + dir[0];\n    const nextY = y + dir[1]; // 计算下一个位置的行坐标和列坐标\n    if (\n      nextX >= 0 &&\n      nextX < rows &&\n      nextY >= 0 &&\n      nextY < cols &&\n      matrix[nextX][nextY] === 1\n    ) {\n      // 如果下一个位置在矩阵范围内且值为1\n      dfs(matrix, nextX, nextY); // 对下一个位置进行深度优先遍历\n    }\n  }\n}\n\nconst readline = require(\"readline\");\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nlet rows, cols;\nlet matrix = []; // 定义一个空列表存放矩阵\n\nrl.on(\"line\", (line) => {\n  if (!rows && !cols) {\n    [rows, cols] = line.split(\" \").map(Number); // 输入矩阵的行数和列数\n  } else {\n    const row = line.split(\" \").map(Number); // 读入矩阵的每一行\n    matrix.push(row); // 将每一行添加到矩阵中\n    if (matrix.length === rows) {\n      let result = 0; // 定义结果变量，表示矩阵中1的连通块数量\n      for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n          // 从任意一个位置的1开始遍历\n          if (matrix[i][j] === 1) {\n            // 如果当前位置是1\n            result += 1; // 连通块数量加1\n            dfs(matrix, i, j); // 对以当前位置为起点的连通块进行深度优先遍历\n          }\n        }\n      }\n      console.log(result); // 输出矩阵中1的连通块数量\n      rl.close();\n    }\n  }\n});",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid dfs(vector<vector<int>>& matrix, int x, int y) {\n    matrix[x][y] = 0; // 将当前位置的值设为0，表示已经遍历过\n    int rows = matrix.size(); // 矩阵的行数\n    int cols = matrix[0].size(); // 矩阵的列数\n    vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}, {-1, -1}, {-1, 1}, {1, -1}, {1, 1}}; // 定义8个方向的偏移量\n    for (auto dir : directions) { // 遍历8个方向\n        int nextX = x + dir[0]; // 计算下一个位置的行坐标\n        int nextY = y + dir[1]; // 计算下一个位置的列坐标\n        if (nextX >= 0 && nextX < rows && nextY >= 0 && nextY < cols && matrix[nextX][nextY] == 1) { // 如果下一个位置在矩阵范围内且值为1\n            dfs(matrix, nextX, nextY); // 对下一个位置进行深度优先遍历\n        }\n    }\n}\n\nint main() {\n    // 处理输入\n    int rows, cols;\n    cin >> rows >> cols; // 输入矩阵的行数和列数\n    vector<vector<int>> matrix(rows, vector<int>(cols)); // 定义一个rows行cols列的矩阵\n    for (int i = 0; i < rows; i++) { // 遍历矩阵的每一行\n        for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n            cin >> matrix[i][j]; // 读入矩阵的每一个元素\n        }\n    }\n\n    int result = 0; // 定义结果变量，表示矩阵中1的连通块数量\n    for (int i = 0; i < rows; i++) { // 遍历矩阵的每一行\n        for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n            // 从任意一个位置的1开始遍历\n            if (matrix[i][j] == 1) { // 如果当前位置是1\n                result++; // 连通块数量加1\n                dfs(matrix, i, j); // 对以当前位置为起点的连通块进行深度优先遍历\n            }\n        }\n    }\n    cout << result << endl; // 输出矩阵中1的连通块数量\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n\n#define MAXN 100\n\nint matrix[MAXN][MAXN];\nint rows, cols;\n\n// 8个方向的移动向量\nint directions[8][2] = {\n    {-1, 0}, {1, 0}, {0, -1}, {0, 1}, \n    {-1, -1}, {-1, 1}, {1, -1}, {1, 1}\n};\n\n// 深度优先搜索\nvoid dfs(int x, int y) {\n    // 将当前位置的值设为0，表示已经遍历过\n    matrix[x][y] = 0;\n\n    // 遍历8个方向\n    for (int i = 0; i < 8; i++) {\n        int nextX = x + directions[i][0];\n        int nextY = y + directions[i][1];\n\n        // 判断下一个位置是否在矩阵范围内且值为1\n        if (nextX >= 0 && nextX < rows && nextY >= 0 && nextY < cols && matrix[nextX][nextY] == 1) {\n            dfs(nextX, nextY);\n        }\n    }\n}\n\nint main() {\n    // 处理输入\n    scanf(\"%d %d\", &rows, &cols);\n\n    // 读入矩阵的每一个元素\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n\n    int result = 0; // 定义结果变量，表示矩阵中1的连通块数量\n\n    // 遍历矩阵的每一个元素\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            // 从任意一个位置的1开始遍历\n            if (matrix[i][j] == 1) {\n                result++; // 连通块数量加1\n                dfs(i, j); // 对以当前位置为起点的连通块进行深度优先遍历\n            }\n        }\n    }\n\n    // 输出结果\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}"
  }
}