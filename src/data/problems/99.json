{
  "id": "99",
  "title": "斗地主之顺子",
  "examType": "A",
  "score": 100,
  "description": "在斗地主扑克牌游戏中， 扑克牌由小到大的顺序为：3,4,5,6,7,8,9,10,J,Q,K,A,2，玩家可以出的扑克牌阵型有：单张、对子、顺子、飞机、炸弹等。\n其中顺子的出牌规则为：由至少5张由小到大连续递增的扑克牌组成，且不能包含2。\n例如：{3,4,5,6,7}、{3,4,5,6,7,8,9,10,J,Q,K,A}都是有效的顺子；而{J,Q,K,A,2}、 {2,3,4,5,6}、{3,4,5,6}、{3,4,5,6,8}等都不是顺子。\n给定一个包含13张牌的数组，如果有满足出牌规则的顺子，请输出顺子。\n如果存在多个顺子，请每行输出一个顺子，且需要按顺子的第一张牌的大小（必须从小到大）依次输出。\n如果没有满足出牌规则的顺子，请输出No。",
  "inputDesc": "13张任意顺序的扑克牌，每张扑克牌数字用空格隔开，每张扑克牌的数字都是合法的，并且不包括大小王：\n2 9 J 2 3 4 K A 7 9 A 5 6\n不需要考虑输入为异常字符的情况",
  "outputDesc": "组成的顺子，每张扑克牌数字用空格隔开：\n3 4 5 6 7",
  "examples": [
    {
      "input": "2 9 J 2 3 4 K A 7 9 A 5 6",
      "output": "3 4 5 6 7",
      "explanation": "13张牌中，可以组成的顺子只有1组：3 4 5 6 7。"
    },
    {
      "input": "2 9 J 10 3 4 K A 7 Q A 5 6",
      "output": "3 4 5 6 7\n9 10 J Q K A",
      "explanation": "13张牌中，可以组成2组顺子：3 4 5 6 7 和 9 10 J Q K A。"
    },
    {
      "input": "2 9 9 9 3 4 K A 10 Q A 5 6",
      "output": "No",
      "explanation": "13张牌中，无法组成至少5张的顺子。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心+排序**问题。\n\n**核心思路：**\n- 顺子：至少5张连续递增的牌，不含2\n- 排序后贪心构建最长顺子\n\n**算法步骤：**\n1. 将牌面映射为数字（3-14，2映射为16排除）\n2. 按牌面大小排序\n3. 遍历牌，尝试加入现有顺子或新建顺子\n4. 筛选长度>=5的顺子输出\n\n**时间复杂度**：O(N log N)",
  "codes": {
    "java": "import java.util.*;\nimport java.util.stream.Collectors;\n\npublic class Main {\n    // 静态初始化一个用于映射扑克牌面到数字的HashMap，以方便后续比较大小\n    private static final Map<String, Integer> CARD_TO_NUMBER;\n\n    static {\n        // 初始化HashMap\n        CARD_TO_NUMBER = new HashMap<>();\n        // 将每张扑克牌对应的面值映射到一个整数，其中2被认为是最大的牌\n        CARD_TO_NUMBER.put(\"3\", 3);\n        CARD_TO_NUMBER.put(\"4\", 4);\n        CARD_TO_NUMBER.put(\"5\", 5);\n        CARD_TO_NUMBER.put(\"6\", 6);\n        CARD_TO_NUMBER.put(\"7\", 7);\n        CARD_TO_NUMBER.put(\"8\", 8);\n        CARD_TO_NUMBER.put(\"9\", 9);\n        CARD_TO_NUMBER.put(\"10\", 10);\n        CARD_TO_NUMBER.put(\"J\", 11);\n        CARD_TO_NUMBER.put(\"Q\", 12);\n        CARD_TO_NUMBER.put(\"K\", 13);\n        CARD_TO_NUMBER.put(\"A\", 14);\n        CARD_TO_NUMBER.put(\"2\", 16);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);  // 创建Scanner对象用于读取输入\n        String[] cards = sc.nextLine().split(\" \");  // 读取一行输入，并按空格分割成数组\n        // 对输入的扑克牌按照定义的牌面大小进行排序\n        Arrays.sort(cards, (a, b) -> CARD_TO_NUMBER.get(a) - CARD_TO_NUMBER.get(b));\n\n        ArrayList<LinkedList<String>> straights = new ArrayList<>();  // 用于存储所有可能的顺子序列\n        LinkedList<String> currentStraight = new LinkedList<>();  // 初始化当前正在检查的顺子序列\n        currentStraight.add(cards[0]);  // 将排序后的第一张牌加入到当前顺子序列中\n        straights.add(currentStraight);  // 将当前顺子序列加入到顺子列表中\n\n        // 从第二张牌开始遍历所有牌\n        for (int i = 1; i < cards.length; i++) {\n            String card = cards[i];\n            boolean added = false;  // 标记当前牌是否已被添加到某个顺子中\n\n            // 遍历当前已存在的所有顺子序列，尝试将当前牌加入\n            for (LinkedList<String> straight : straights) {\n                // 判断当前牌是否可以追加到顺子的末尾\n                if (CARD_TO_NUMBER.get(card) - CARD_TO_NUMBER.get(straight.getLast()) == 1) {\n                    straight.add(card);\n                    added = true;\n                    break;\n                }\n            }\n\n            // 如果当前牌没有加入到任何顺子中，创建一个新的顺子序列\n            if (!added) {\n                LinkedList<String> newStraight = new LinkedList<>();\n                newStraight.add(card);\n                straights.add(newStraight);\n            }\n        }\n\n        // 筛选出长度至少为5的有效顺子序列\n        List<LinkedList<String>> validStraights =\n            straights.stream().filter(straight -> straight.size() >= 5).collect(Collectors.toList());\n\n        // 如果没有找到有效的顺子序列，输出\"No\"\n        if (validStraights.isEmpty()) {\n            System.out.println(\"No\");\n        } else {\n            // 将所有有效的顺子按照起始牌的大小进行排序并输出\n            validStraights.stream()\n                .sorted((a, b) -> CARD_TO_NUMBER.get(a.getFirst()) - CARD_TO_NUMBER.get(b.getFirst()))\n                .forEach(straight -> System.out.println(String.join(\" \", straight)));\n        }\n    }\n}",
    "python": "# 导入Python标准库\nfrom collections import deque\n\n# 定义一个字典，用于映射扑克牌的牌面到数字，方便比较大小\nCARD_TO_NUMBER = {\n    '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8,\n    '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13,\n    'A': 14, '2': 16\n}\n\n \n# 使用input函数读取一行输入，并用split方法按空格分割字符串，得到牌面数组\ncards = input().split()\n# 根据牌面大小对牌进行排序\ncards.sort(key=lambda x: CARD_TO_NUMBER[x])\n\nstraights = []  # 存储所有可能的顺子序列\ncurrent_straight = deque([cards[0]])  # 初始化当前顺子序列，使用deque提高效率\nstraights.append(current_straight)  # 将当前顺子序列添加到列表中\n\n# 遍历输入的牌，从第二张牌开始\nfor card in cards[1:]:\n    added = False  # 标记当前牌是否已被添加到某个顺子中\n\n    # 尝试将当前牌加入到已存在的顺子序列中\n    for straight in straights:\n        # 判断当前牌是否可以追加到顺子末尾\n        if CARD_TO_NUMBER[card] - CARD_TO_NUMBER[straight[-1]] == 1:\n            straight.append(card)\n            added = True\n            break\n    \n    # 如果当前牌没有加入到任何顺子中，创建一个新的顺子序列\n    if not added:\n        new_straight = deque([card])\n        straights.append(new_straight)\n\n# 筛选出长度至少为5的有效顺子序列\nvalid_straights = [list(straight) for straight in straights if len(straight) >= 5]\n\n# 如果没有找到有效的顺子序列，输出\"No\"\nif not valid_straights:\n    print(\"No\")\nelse:\n    # 对所有有效的顺子进行排序，并输出\n    valid_straights.sort(key=lambda x: CARD_TO_NUMBER[x[0]])\n    for straight in valid_straights:\n        print(\" \".join(straight))",
    "javascript": "// 引入 readline 模块并创建接口用于读取来自标准输入(stdin)的数据\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 定义一个映射扑克牌面到数字的对象，方便后续比较大小\nconst CARD_TO_NUMBER = {\n    '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8,\n    '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13,\n    'A': 14, '2': 16\n};\n\n// 读取一行输入\nrl.on('line', (input) => {\n    // 按空格分割输入的字符串，得到牌的数组\n    let cards = input.split(' ');\n    // 根据牌面大小对牌进行排序\n    cards.sort((a, b) => CARD_TO_NUMBER[a] - CARD_TO_NUMBER[b]);\n\n    let straights = [];  // 存储所有可能的顺子序列\n    let currentStraight = [cards[0]];  // 初始化当前顺子序列\n    straights.push(currentStraight);  // 将当前顺子序列加入到列表中\n\n    // 从第二张牌开始遍历所有牌\n    for (let i = 1; i < cards.length; i++) {\n        let card = cards[i];\n        let added = false;  // 标记当前牌是否已被添加到某个顺子中\n\n        // 尝试将当前牌加入到已存在的顺子序列中\n        for (let straight of straights) {\n            // 判断当前牌是否可以追加到顺子的末尾\n            if (CARD_TO_NUMBER[card] - CARD_TO_NUMBER[straight[straight.length - 1]] === 1) {\n                straight.push(card);\n                added = true;\n                break;\n            }\n        }\n\n        // 如果当前牌没有加入到任何顺子中，创建一个新的顺子序列\n        if (!added) {\n            let newStraight = [card];\n            straights.push(newStraight);\n        }\n    }\n\n    // 筛选出长度至少为5的有效顺子序列\n    let validStraights = straights.filter(straight => straight.length >= 5);\n\n    // 如果没有找到有效的顺子序列，输出\"No\"\n    if (validStraights.length === 0) {\n        console.log(\"No\");\n    } else {\n        // 对所有有效的顺子进行排序，并输出\n        validStraights.sort((a, b) => CARD_TO_NUMBER[a[0]] - CARD_TO_NUMBER[b[0]]);\n        validStraights.forEach(straight => console.log(straight.join(' ')));\n    }\n\n    rl.close(); // 关闭readline接口\n});",
    "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <list>\n\nusing namespace std;\nint main() {\n    // 定义一个映射扑克牌面到数字的map，方便后续比较大小\n    map<string, int> card_to_number = {\n        {\"3\", 3}, {\"4\", 4}, {\"5\", 5}, {\"6\", 6}, {\"7\", 7},\n        {\"8\", 8}, {\"9\", 9}, {\"10\", 10}, {\"J\", 11}, {\"Q\", 12},\n        {\"K\", 13}, {\"A\", 14}, {\"2\", 16}\n    };\n\n    // 从标准输入读取一行数据\n    string input;\n    getline(cin, input);\n    istringstream iss(input);\n    vector<string> cards;\n    string card;\n\n    // 将输入的扑克牌存入vector\n    while (iss >> card) {\n        cards.push_back(card);\n    }\n\n    // 根据定义的牌面大小对牌进行排序\n    sort(cards.begin(), cards.end(), [&card_to_number](const string& a, const string& b) {\n        return card_to_number[a] < card_to_number[b];\n    });\n\n    // 用于存储所有可能的顺子序列\n    vector<list<string>> straights;\n    list<string> current_straight;\n    current_straight.push_back(cards[0]);\n    straights.push_back(current_straight);\n\n    // 从第二张牌开始遍历所有牌\n    for (size_t i = 1; i < cards.size(); i++) {\n        bool added = false;  // 标记当前牌是否已被添加到某个顺子中\n        for (auto& straight : straights) {\n            // 判断当前牌是否可以追加到顺子的末尾\n            if (card_to_number[cards[i]] - card_to_number[straight.back()] == 1) {\n                straight.push_back(cards[i]);\n                added = true;\n                break;\n            }\n        }\n\n        // 如果当前牌没有加入到任何顺子中，创建一个新的顺子序列\n        if (!added) {\n            list<string> new_straight;\n            new_straight.push_back(cards[i]);\n            straights.push_back(new_straight);\n        }\n    }\n\n    // 筛选出长度至少为5的有效顺子序列\n    vector<list<string>> valid_straights;\n    for (const auto& straight : straights) {\n        if (straight.size() >= 5) {\n            valid_straights.push_back(straight);\n        }\n    }\n\n    // 如果没有找到有效的顺子序列，输出\"No\"\n    if (valid_straights.empty()) {\n        cout << \"No\\n\";\n    } else {\n        // 输出所有有效的顺子序列\n        for (const auto& straight : valid_straights) {\n            for (const auto& card : straight) {\n                cout << card << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义扑克牌与其数值的映射关系结构体\ntypedef struct {\n    char card[3];  // 扑克牌面（考虑到\"10\"有两个字符，所以数组大小为3）\n    int value;     // 对应的数值\n} CardMap;\n\n// 扑克牌面到数值的映射表\nCardMap card_to_number[] = {\n    {\"3\", 3}, {\"4\", 4}, {\"5\", 5}, {\"6\", 6}, {\"7\", 7}, {\"8\", 8}, {\"9\", 9}, \n    {\"10\", 10}, {\"J\", 11}, {\"Q\", 12}, {\"K\", 13}, {\"A\", 14}, {\"2\", 16}\n};\nint card_map_size = sizeof(card_to_number) / sizeof(card_to_number[0]);\n\n// 用于比较扑克牌的函数\nint compare_cards(const void *a, const void *b) {\n    const char *card1 = *(const char **)a;\n    const char *card2 = *(const char **)b;\n    int value1 = 0, value2 = 0;\n\n    for (int i = 0; i < card_map_size; ++i) {\n        if (strcmp(card_to_number[i].card, card1) == 0) {\n            value1 = card_to_number[i].value;\n        }\n        if (strcmp(card_to_number[i].card, card2) == 0) {\n            value2 = card_to_number[i].value;\n        }\n    }\n\n    return value1 - value2;\n}\n\nint main() {\n    char input[100];  // 存储输入字符串\n    char *cards[20];  // 存储分割后的扑克牌字符串指针\n    int count = 0;    // 扑克牌数量\n\n    // 读取一行输入\n    fgets(input, sizeof(input), stdin);\n    input[strcspn(input, \"\\n\")] = 0;  // 移除换行符\n\n    // 分割输入字符串\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        cards[count++] = token;\n        token = strtok(NULL, \" \");\n    }\n\n    // 对扑克牌进行排序\n    qsort(cards, count, sizeof(char *), compare_cards);\n\n    // 动态分配二维数组来存储可能的顺子序列\n    char **straights[count];\n    int lengths[count];  // 存储每个顺子的长度\n    for (int i = 0; i < count; ++i) {\n        straights[i] = malloc(count * sizeof(char *));\n        straights[i][0] = cards[i];\n        lengths[i] = 1;\n    }\n    int num_straights = count;\n\n    // 生成顺子序列\n    for (int i = 0; i < count; ++i) {\n        for (int j = 0; j < num_straights; ++j) {\n            if (compare_cards(&cards[i], &straights[j][lengths[j] - 1]) == 1) {\n                straights[j][lengths[j]++] = cards[i];\n                break;\n            }\n        }\n    }\n\n    // 输出长度至少为5的顺子序列\n    int found = 0;\n    for (int i = 0; i < num_straights; ++i) {\n        if (lengths[i] >= 5) {\n            found = 1;\n            for (int j = 0; j < lengths[i]; ++j) {\n                printf(\"%s \", straights[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        free(straights[i]);\n    }\n\n    if (!found) {\n        printf(\"No\\n\");\n    }\n\n    return 0;\n}"
  }
}