{
  "id": "165",
  "title": "字母组合过滤组合字符串",
  "examType": "A",
  "score": 200,
  "description": "每个数字关联多个字母，关联关系如下：\n0 关联 “a”,”b”,”c”1 关联 “d”,”e”,”f”2 关联 “g”,”h”,”i”3 关联 “j”,”k”,”l”4 关联 “m”,”n”,”o”5 关联 “p”,”q”,”r”6 关联 “s”,”t”7 关联 “u”,”v”8 关联 “w”,”x”9 关联 “y”,”z”\n输入一串数字后，通过数字和字母的对应关系可以得到多个字母字符串（要求按照数字的顺序组合字母字符串）；\n屏蔽字符串：屏蔽字符串中的所有字母不能同时在输出的字符串出现，如屏蔽字符串是abc，则要求字符串中不能同时出现a,b,c，但是允许同时出现a,b或a,c或b,c等；\n给定一个数字字符串和一个屏蔽字符串，输出所有可能的字符组合；\n例如输入数字字符串78和屏蔽字符串ux，输出结果为uw，vw，vx；数字字符串78，可以得到如下字符串uw，ux，vw，vx；由于ux是屏蔽字符串，因此排除ux，最终的输出是uw，vw，vx;",
  "inputDesc": "第一行输入为一串数字字符串，数字字符串中的数字不允许重复，数字字符串的长度大于0，小于等于5；\n第二行输入是屏蔽字符串，屏蔽字符串的长度一定小于数字字符串的长度，屏蔽字符串中字符不会重复；",
  "outputDesc": "输出可能的字符串组合\n注：字符串之间使用逗号隔开，最后一个字符串后携带逗号",
  "examples": [
    {
      "input": "78\nux",
      "output": "uw,vw,vx,",
      "explanation": "ux完全包含屏蔽字符串ux，因此剔除"
    },
    {
      "input": "78\nx",
      "output": "uw,vw,",
      "explanation": ""
    }
  ],
  "solution": "这个题目的核心在于根据映射关系生成组合，然后剔除包含屏蔽字符串的组合。\n数字与字母的映射关系：每个数字都映射到一组字母，例如数字0映射到字母’a’, ‘b’, ‘c’，数字1映射到’d’, ‘e’, ‘f’，以此类推。这个映射关系可以看作是类似于传统手机键盘上的数字与字母的对应关系。生成字母组合：用户输入一串不重复的数字字符串，题目要求按照数字的顺序生成所有可能的字母组合。例如，输入\"78\"，7对应’u’, ‘v’，8对应’w’, ‘x’，那么可以生成的组合是：uw, ux, vw, vx。屏蔽字符串的限制：屏蔽字符串中的所有字母不能同时出现在生成的字母组合中。也就是说，如果一个字母组合包含了屏蔽字符串中的所有字符，这个组合就需要被剔除。例如，如果屏蔽字符串是\"ux\"，那么组合中的ux会被剔除。",
  "codes": {
    "java": "import java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n    static String[] map = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 输入数字字符串\n        char[] digits = sc.next().toCharArray();\n        // 输入屏蔽字符串\n        String filter = sc.next();\n\n        // 根据数字字符串得到每个数字对应的字母字符串\n        String[] letters = new String[digits.length];\n        for (int i = 0; i < digits.length; i++) {\n            letters[i] = map[digits[i] - '0'];\n        }\n\n        // 用于存储结果的字符串\n        StringBuilder sb = new StringBuilder();\n        // 开始进行深度优先搜索\n        dfs(letters, 0, new StringBuilder(), sb, filter, new HashSet<>());\n\n        // 输出结果\n        System.out.println(sb.toString());\n    }\n\n    public static void dfs(\n            String[] letters, int index, StringBuilder path, StringBuilder res, String filter, HashSet<Character> used) {\n        if (index == letters.length) {\n            // 过滤包含屏蔽字符串的路径\n            if (!path.toString().contains(filter)) {\n                res.append(path).append(\",\");\n            }\n            return;\n        }\n\n        // 对于每个数字，遍历其对应的字母字符串\n        for (int i = 0; i < letters[index].length(); i++) {\n            char c = letters[index].charAt(i);\n            if (!used.contains(c)) {\n                path.append(c);\n                used.add(c);\n                dfs(letters, index + 1, path, res, filter, used);\n                path.deleteCharAt(path.length() - 1);\n                used.remove(c);\n            }\n        }\n    }\n}",
    "python": "import sys\n\n# 定义数字到字母的映射关系，map[0] 对应 'abc', map[1] 对应 'def'，依此类推\nmap = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"]\n\n# 深度优先搜索 (DFS) 递归函数\ndef dfs(letters, index, path, res, filter, used):\n    # 如果当前索引等于字母组的长度，说明已经生成了一个完整的字母组合\n    if index == len(letters):\n        # 如果生成的组合不包含屏蔽字符串，则将其加入结果集\n        if filter not in path:\n            res.append(path + \",\")\n        return\n    \n    # 遍历当前索引位置对应的所有字母\n    for i in range(len(letters[index])):\n        c = letters[index][i]  # 当前字母\n        # 如果当前字母尚未被使用\n        if c not in used:\n            path += c  # 将字母加入当前路径\n            used.add(c)  # 标记字母为已使用\n            # 递归调用下一层，处理下一个索引\n            dfs(letters, index + 1, path, res, filter, used)\n            path = path[:-1]  # 回溯，移除最后添加的字母\n            used.remove(c)  # 取消字母的使用标记\n\n\ndigits = input().strip()  # 读取输入的数字字符串，并去除首尾空格\nfilter = input().strip()  # 读取输入的屏蔽字符串，并去除首尾空格\n\n# 将输入的数字字符串转换为对应的字母组，如\"78\" -> ['uv', 'wx']\nletters = [map[int(digit)] for digit in digits]\n\nsb = \"\"  # 初始化一个空字符串，用于存储当前路径\nres = []  # 结果列表，存储所有符合条件的字母组合\ndfs(letters, 0, sb, res, filter, set())  # 调用DFS函数，开始递归搜索\n\n# 输出结果，将结果列表中的元素连接成一个字符串并打印\nprint(\"\".join(res))",
    "javascript": "const readline = require('readline');\n\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 定义数字到字母的映射关系，类似于传统手机键盘上的字母排列\nconst map = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"];\n\n// 监听用户输入的第一行内容，即数字字符串\nrl.on(\"line\", (digits) => {\n  // 监听用户输入的第二行内容，即屏蔽字符串\n  rl.on(\"line\", (filter) => {\n    // 初始化一个数组，用于存储根据输入数字映射得到的字母组\n    const letters = new Array(digits.length);\n    for (let i = 0; i < digits.length; i++) {\n      // 将每个数字转换成对应的字母组并存入数组\n      letters[i] = map[parseInt(digits[i])];\n    }\n\n    const sb = []; // 存储最终的结果组合\n    dfs(letters, 0, \"\", sb, filter, new Set()); // 调用DFS函数进行深度优先搜索\n\n    // 输出结果，用逗号分隔各个字母组合\n    console.log(sb.join(\",\"));\n    rl.close(); // 关闭读取接口\n  });\n});\n\n// 深度优先搜索 (DFS) 递归函数\nfunction dfs(letters, index, path, res, filter, used) {\n  // 如果当前索引等于字母组的长度，说明已经生成了一个完整的字母组合\n  if (index === letters.length) {\n    // 如果生成的组合不包含屏蔽字符串，则将其加入结果集\n    if (!path.includes(filter)) {\n      res.push(path);\n    }\n    return;\n  }\n\n  // 遍历当前索引位置对应的所有字母\n  for (let i = 0; i < letters[index].length; i++) {\n    const c = letters[index][i];  // 当前字母\n    // 如果当前字母尚未被使用\n    if (!used.has(c)) {\n      path += c;  // 将字母加入当前路径\n      used.add(c);  // 标记字母为已使用\n      // 递归调用下一层，处理下一个索引\n      dfs(letters, index + 1, path, res, filter, used);\n      path = path.slice(0, -1);  // 回溯，移除最后添加的字母\n      used.delete(c);  // 取消字母的使用标记\n    }\n  }\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nvector<string> map = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"};\n\nvoid dfs(\n        vector<string>& letters, int index, string path, string& res, string& filter, unordered_set<char>& used) {\n    if (index == letters.size()) {\n        // 过滤包含屏蔽字符串的路径\n        if (path.find(filter) == string::npos) {\n            res += path + \",\";\n        }\n        return;\n    }\n\n    // 对于每个数字，遍历其对应的字母字符串\n    for (int i = 0; i < letters[index].length(); i++) {\n        char c = letters[index][i];\n        if (used.find(c) == used.end()) {\n            path += c;\n            used.insert(c);\n            dfs(letters, index + 1, path, res, filter, used);\n            path.pop_back();\n            used.erase(c);\n        }\n    }\n}\n\nint main() {\n    string digits;\n    cin >> digits;\n    string filter;\n    cin >> filter;\n\n    // 根据数字字符串得到每个数字对应的字母字符串\n    vector<string> letters(digits.length());\n    for (int i = 0; i < digits.length(); i++) {\n        letters[i] = map[digits[i] - '0'];\n    }\n\n    // 用于存储结果的字符串\n    string res = \"\";\n    // 开始进行深度优先搜索\n    unordered_set<char> used;\n    dfs(letters, 0, \"\", res, filter, used);\n\n    // 输出结果\n    cout << res << endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 100\n#define RES_LEN 1000\n\n// 定义一个常量映射数组，用于将数字映射到对应的字母字符串\nconst char *map[] = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"st\", \"uv\", \"wx\", \"yz\"};\n\n// DFS函数声明\nvoid dfs(char letters[][MAX_LEN], int num_digits, int index, char *path, int path_len, char *res, char *filter, int *used);\n\nint main() {\n    char digits[MAX_LEN];  // 用于存储输入的数字字符串\n    char filter[MAX_LEN];  // 用于存储输入的屏蔽字符串\n\n    // 输入数字字符串和屏蔽字符串\n    scanf(\"%s\", digits);\n    scanf(\"%s\", filter);\n\n    int length = strlen(digits);\n    char letters[length][MAX_LEN];  // 用于存储每个数字对应的字母字符串\n\n    // 根据输入的数字字符串生成对应的字母字符串\n    for (int i = 0; i < length; i++) {\n        strcpy(letters[i], map[digits[i] - '0']);\n    }\n\n    char res[RES_LEN] = \"\";  // 用于存储结果的字符串\n    char path[MAX_LEN] = \"\";  // 用于存储当前路径的字符串\n    int used[128] = {0};  // 用于标记当前路径中已使用的字符\n\n    // 开始进行深度优先搜索\n    dfs(letters, length, 0, path, 0, res, filter, used);\n\n    // 输出结果\n    printf(\"%s\\n\", res);\n\n    return 0;\n}\n\n// DFS函数定义\nvoid dfs(char letters[][MAX_LEN], int num_digits, int index, char *path, int path_len, char *res, char *filter, int *used) {\n    // 如果当前索引等于字母组的长度，说明已经生成了一个完整的字母组合\n    if (index == num_digits) {\n        // 判断生成的路径是否包含屏蔽字符串\n        if (strstr(path, filter) == NULL) {\n            if (strlen(res) > 0) {\n                strcat(res, \",\");  // 添加逗号分隔符\n            }\n            strcat(res, path);\n        }\n        return;\n    }\n\n    // 遍历当前索引位置对应的所有字母\n    for (int i = 0; letters[index][i] != '\\0'; i++) {\n        char c = letters[index][i];  // 当前字母\n        if (!used[(int)c]) {  // 如果当前字母尚未被使用\n            path[path_len] = c;  // 将字母加入当前路径\n            path[path_len + 1] = '\\0';\n            used[(int)c] = 1;  // 标记字母为已使用\n            // 递归调用下一层，处理下一个索引\n            dfs(letters, num_digits, index + 1, path, path_len + 1, res, filter, used);\n            // 回溯，移除最后添加的字母\n            path[path_len] = '\\0';\n            used[(int)c] = 0;  // 取消字母的使用标记\n        }\n    }\n}"
  }
}