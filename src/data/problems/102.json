{
  "id": "102",
  "title": "最大报酬",
  "examType": "A",
  "score": 100,
  "description": "小明每周上班都会拿到自己的工作清单，工作清单内包含 n 项工作，每项工作都有对应的耗时时间（单位 h）和报酬，工作的总报酬为所有已完成工作的报酬之和，那么请你帮小明安排一下工作，保证小明在指定的工作时间内工作收入最大化。",
  "inputDesc": "T 代表工作时长（单位 h， 0 < T < 1000000）， n 代表工作数量（ 1 < n ≤ 3000）。 接下来是 n 行，每行包含两个整数 t，w。 t 代表该工作消耗的时长（单位 h， t > 0），w 代表该项工作的报酬。",
  "outputDesc": "输出小明指定工作时长内工作可获得的最大报酬。",
  "examples": [
    {
      "input": "40 3\n20 10\n20 20\n20 5",
      "output": "30",
      "explanation": "工作时长40小时，3项工作。选择工作1(20h,10元)和工作2(20h,20元)，总耗时40h，报酬30元。"
    },
    {
      "input": "20 2\n10 5\n15 8",
      "output": "13",
      "explanation": "选择两项工作耗时25h超时。选工作1+部分时间或只选工作2。选工作1(10h,5元)+工作2(15h,8元)超时，只能选其中组合，最优为两者都选=13元。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**01背包**问题。\n\n**核心思路：**\n- 工作时长T = 背包容量\n- 工作耗时 = 物品重量\n- 工作报酬 = 物品价值\n\n**状态转移：**\n- dp[i][j] = 前i项工作在j时间内的最大报酬\n- dp[i][j] = max(dp[i-1][j], dp[i-1][j-t]+w)\n\n**时间复杂度**：O(N×T)",
  "codes": {
    "java": "import java.util.Scanner;\nimport java.util.*;\n\nclass Main {\n    \n\tpublic static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt(); // 工作时长\n        int n = scanner.nextInt(); // 工作数量\n        int[][] works = new int[n][2]; // 工作清单，每个工作包含耗时和报酬\n        for (int i = 0; i < n; i++) {\n            works[i][0] = scanner.nextInt(); // 耗时\n            works[i][1] = scanner.nextInt(); // 报酬\n        }\n \n        int minTime = Integer.MAX_VALUE; // 记录工作清单中最小的耗时\n        for (int[] work : works) {\n            minTime = Math.min(minTime, work[0]);\n        }\n \n        int[][] dp = new int[n + 1][T + 1]; // 动态规划数组\n        for (int i = 1; i <= n; i++) {\n            for (int j = minTime; j <= T; j++) {\n                int last = dp[i - 1][j]; // 不选当前工作\n                int current = works[i - 1][0] > j ? 0 : works[i - 1][1] + dp[i - 1][j - works[i - 1][0]]; // 选当前工作\n                dp[i][j] = Math.max(last, current); // 取最大值\n            }\n        }\n        System.out.print(dp[n][T]); // 输出最大报酬\n        \n    }\n \n}",
    "python": "import sys\ninput = sys.stdin.readline\n\nwork_time, n = map(int, input().split()) # 工作时间和工作数量\ntasks = [] # 存储每项工作的耗时时间和报酬\nfor i in range(n):\n    tasks.append(list(map(int, input().split())))\n\nmin_time = float('inf') # 找到所有工作中耗时最短的那个min_time\nfor task in tasks:\n    min_time = min(min_time, task[0])\n\ndp = [[0] * (work_time + 1) for _ in range(n + 1)] # 初始化dp数组\nfor i in range(1, n + 1):\n    for j in range(min_time, work_time + 1):\n        last = dp[i - 1][j] # 上一项工作在j时间内能获得的最大报酬\n        current = 0 if tasks[i - 1][0] > j else tasks[i - 1][1] + dp[i - 1][j - tasks[i - 1][0]] # 当前工作在j时间内能获得的最大报酬\n        dp[i][j] = max(last, current) # 取上一项工作和当前工作在j时间内能获得的最大报酬的最大值\n\nprint(dp[n][work_time]) # 输出前n项工作在T时间内能获得的最大报酬",
    "javascript": "const readline = require('readline');\n// 创建 readline 接口实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 用于存储输入的数据\nconst lines = [];\nlet workTime, n;\n// 监听每行输入的数据\nrl.on(\"line\", (line) => {\n  // 将输入的数据存入 lines 数组中\n  lines.push(line);\n  // 当 lines 数组长度为 1 时，表示输入的是工作时长和工作数量\n  if (lines.length === 1) {\n    [workTime, n] = lines[0].split(\" \").map(Number);\n  }\n  // 当 lines 数组长度为 n + 1 时，表示输入的是 n 个工作的耗时时间和报酬\n  if (n && lines.length === n + 1) {\n    // 删除 lines 数组中的第一个元素，即工作耗时时间和报酬的数量\n    lines.shift();\n    // 将每个工作的耗时时间和报酬存入 tasks 数组中\n    const tasks = lines.map((line) => line.split(\" \").map(Number));\n    // 找出所有工作中的最小耗时时间\n    let minTime = Infinity;\n    for (const task of tasks) {\n      minTime = Math.min(minTime, task[0]);\n    }\n    // 创建 dp 数组，用于存储不同工作在不同时间下的最大报酬\n    const dp = new Array(n + 1).fill().map(() => new Array(workTime + 1).fill(0));\n    // 遍历所有工作，计算在不同时间下的最大报酬\n    for (let i = 1; i <= n; i++) {\n      for (let j = minTime; j <= workTime; j++) {\n        // 当前工作不在可用时间内，无法完成，报酬为 0\n        if (tasks[i - 1][0] > j) {\n          dp[i][j] = dp[i - 1][j];\n        } else {\n          // 当前工作在可用时间内，可完成，计算完成后的总报酬\n          const last = dp[i - 1][j];\n          const current = tasks[i - 1][1] + dp[i - 1][j - tasks[i - 1][0]];\n          dp[i][j] = Math.max(last, current);\n        }\n      }\n    }\n    // 输出在指定工作时间内的最大报酬\n    console.log(dp[n][workTime]);\n  }\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int work_time, n; // 工作时间和工作数量\n    cin >> work_time >> n;\n    vector<vector<int>> tasks(n, vector<int>(2)); // 存储每项工作的耗时时间和报酬\n    for (int i = 0; i < n; i++) {\n        cin >> tasks[i][0] >> tasks[i][1];\n    }\n\n    int min_time = INT_MAX; // 找到所有工作中耗时最短的那个min_time\n    for (auto task : tasks) {\n        min_time = min(min_time, task[0]);\n    }\n\n    vector<vector<int>> dp(n + 1, vector<int>(work_time + 1)); // 初始化dp数组\n    for (int i = 1; i <= n; i++) {\n        for (int j = min_time; j <= work_time; j++) {\n            int last = dp[i - 1][j]; // 上一项工作在j时间内能获得的最大报酬\n            int current = tasks[i - 1][0] > j ? 0 : tasks[i - 1][1] + dp[i - 1][j - tasks[i - 1][0]]; // 当前工作在j时间内能获得的最大报酬\n            dp[i][j] = max(last, current); // 取上一项工作和当前工作在j时间内能获得的最大报酬的最大值\n        }\n    }\n    cout << dp[n][work_time] << endl; // 输出前n项工作在T时间内能获得的最大报酬\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\nint main() {\n    int work_time, n; // 工作时间和工作数量\n    scanf(\"%d %d\", &work_time, &n);\n    int tasks[n][2]; // 存储每项工作的耗时时间和报酬\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &tasks[i][0], &tasks[i][1]);\n    }\n\n    int min_time = INT_MAX; // 找到所有工作中耗时最短的那个min_time\n    for (int i = 0; i < n; i++) {\n        if (tasks[i][0] < min_time) {\n            min_time = tasks[i][0];\n        }\n    }\n\n    // 动态规划数组\n    int **dp = (int**) malloc((n + 1) * sizeof(int*));\n    for (int i = 0; i <= n; i++) {\n        dp[i] = (int*) malloc((work_time + 1) * sizeof(int));\n        for (int j = 0; j <= work_time; j++) {\n            dp[i][j] = 0;\n        }\n    }\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = min_time; j <= work_time; j++) {\n            int last = dp[i - 1][j]; // 上一项工作在j时间内能获得的最大报酬\n            int current = tasks[i - 1][0] > j ? 0 : tasks[i - 1][1] + dp[i - 1][j - tasks[i - 1][0]]; // 当前工作在j时间内能获得的最大报酬\n            dp[i][j] = (last > current) ? last : current; // 取上一项工作和当前工作在j时间内能获得的最大报酬的最大值\n        }\n    }\n\n    printf(\"%d\\n\", dp[n][work_time]); // 输出前n项工作在T时间内能获得的最大报酬\n\n    // 释放动态分配的内存\n    for (int i = 0; i <= n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n\n    return 0;\n}"
  }
}