{
  "id": "159",
  "title": "符号运算",
  "examType": "A",
  "score": 200,
  "description": "给定一个表达式，求其分数计算结果。\n\n表达式的限制如下：\n所有的输入数字皆为正整数（包括0）仅支持四则运算（+-*/）和括号结果为整数或分数，分数必须化为最简格式（比如6，3/4，7/8，90/7）除数可能为0，如果遇到这种情况，直接输出\"ERROR\"输入和最终计算结果中的数字都不会超出整型范围\n用例输入一定合法，不会出现括号匹配的情况\n",
  "inputDesc": "字符串格式的表达式，仅支持+-*/，数字可能超过两位，可能带有空格，没有负数\n长度小于200个字符\n",
  "outputDesc": "表达式结果，以最简格式表达\n\n\n本题是经典的中缀表达式计算问题。\n\n关于中缀表达式计算，通常是定义两个栈结构：\n下面我们通过几个例子来说明两个栈的工作原理：\n\n\n\n\n\n\n\n\n\n通过上面流程，我们可以发现，每次出栈oper_sign_stack一个运算符，那么就要出栈oper_num_stack两个操作数。\n那么如果存在下面这种情况，是否支持这样的出栈运算逻辑呢？\n\n上面运算出错的问题就在于，当+入栈oper_sign_stack前，我们应该比较要入栈的'+'运算，和栈顶的'*'运算，哪个优先级更高，如果栈顶运算符优先级更高，此时我们应该先将栈顶运算符出栈运算，即如下：\n\n\n\n\n\n另外，对于运算符入栈时，对比oper_sign_stack栈顶的运算符，如果二者优先级一样，则也需要将oper_sign_stack栈顶运算先出栈运算。\n且只要oper_sign_stack栈顶的运算符 的优先级>= 需要入栈的运算符，则oper_sign_stack就需要不停的出栈运算。\n\n\n\n因此，总结一下就是，如果扫描到了运算符，此时需要和oper_sign_stack栈顶的运算符比较优先级，如果栈顶运算符优先级 >= 当前扫描运算符，则栈顶运算符需要出栈运算，直到oper_sign_stack栈顶运算符优先级小于当前扫描运算符。\n\n另外，本题表达式中还可能出现()，那么遇到括号该怎么处理呢？\n\n\n\n也就是说：\n'(' 对于 +-*/ 运算的入栈oper_sign_stack的逻辑不产生影响，仅用于扫描到')'时oper_sign_stack的出栈结束界定。\n需要注意的时，()内的+-*/运算依旧按照之前的逻辑入栈oper_sign_stack。\n\n以上就是中缀表达式的基于双栈的解题思路。更具体的逻辑，请看代码实现。\n\n本题还对中缀表达式计算做了一些改动，即要求的除法不是整除，而是保留最简分数结果。\n比如 1 / 2 + 3 / 4 的结果不是0，而是 5 / 4。\n\n解决方案很简单，我们之前在 oper_num_stack 中记录的都是整数操作数，现在我们只要改为分数操作数即可。\n但是编程语言中并不支持分数，因此我们可以将分数拆分为分子和分母两部分，进行记录。即可以定义一个类，有如下属性：\n{ ch:, // 分子 fa:, // 分母 }\n分数的分子和分母必然是整数。\n\n如果入栈的元素是一个整数num，则将其转化为如下分数后入栈oper_num_stack\n{ ch: num, fa: 1, }\n\n当我们需要进行出栈运算时，取出的oper_num_stack栈顶的两个操作数，假设分别为a,b，则：\n对于加法运算的结果为：\n{ ch: a.ch * b.fa + b.ch * a.fa, fa: a.fa * b.fa, }\n比如 a = 1 / 3， b = 3 / 4，进行加法运算时，我们应该将他们的分母变为一样，即同时转为 3 * 4\n则 a = (1 * 4) / (3 * 4)， b = （3 * 3）/ (4 * 3)\n\n按照此逻辑，减法运算结果为：\n{ ch: a.ch * b.fa - b.ch * a.fa, fa: a.fa * b.fa, }\n\n而乘法运算结果：\n{ ch: a.ch * b.ch, fa: a.fa * b.fa, }\n\n除法运算结果为：\n{ ch: a.ch * b.fa, fa: a.fa * b.ch, }\n\n这样的话，我们就完成了分数的四则运算。\n\n最后就是关于，分数的最简格式转化了，其实也很简单，就是将分子、分母的最大公约数求解出来，然后分子、分母同时除以最大公约数，即可得到最简格式的分数。\n而两个数的最大公约数的求解，可以使用辗转相除法。如果不熟悉辗转相除法，可以去网上搜索相关资料。\n\n\n\n",
  "examples": [
    {
      "input": "1 + 2 * 3",
      "output": "7",
      "explanation": "先算2*3=6，再算1+6=7"
    },
    {
      "input": "1 / 2 + 3 / 4",
      "output": "5/4",
      "explanation": "1/2+3/4=2/4+3/4=5/4，保留最简分数"
    },
    {
      "input": "1 / 0",
      "output": "error",
      "explanation": "除数为0，输出error"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**中缀表达式求值**问题，需支持分数运算。\n\n**核心思路：**\n- 双栈法：操作数栈和操作符栈\n- 操作数用分数形式存储(分子/分母)\n- 最后约分输出最简形式\n\n**算法步骤：**\n1. 遍历表达式，数字入操作数栈(转为分数)\n2. 运算符比较优先级，高优先级先出栈计算\n3. 遇到括号特殊处理\n4. 计算完成后约分(辗转相除求GCD)\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  // 分数\n  static class Fractions {\n    int fa; // 分母\n    int ch; // 分子\n\n    public Fractions() {}\n\n    public Fractions(int fa, int ch) {\n      this.fa = fa;\n      this.ch = ch;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  // 操作数栈\n  static LinkedList<Fractions> oper_num = new LinkedList<>();\n  // 操作符栈\n  static LinkedList<Character> oper_sign = new LinkedList<>();\n\n  public static String getResult(String s) {\n    // +,-,*,/ 运算符优先级\n    HashMap<Character, Integer> priority = new HashMap<>();\n    priority.put('+', 1);\n    priority.put('-', 1);\n    priority.put('*', 2);\n    priority.put('/', 2);\n\n    // 操作数的字符缓存容器\n    StringBuilder numStr = new StringBuilder();\n\n    int i = 0;\n    while (i < s.length()) {\n      char c = s.charAt(i);\n\n      // 遇到数字字符\n      if (c >= '0' && c <= '9') {\n        // 则将该数字所在操作数的剩余数字字符一次性探索完\n        while (c >= '0' && c <= '9') {\n          numStr.append(c);\n          if (i + 1 >= s.length()) break;\n          i++;\n          c = s.charAt(i);\n        }\n        // 探索完后，将操作数缓存容器中记录的字符，变为分数后，压入操作数栈\n        oper_num.addLast(new Fractions(1, Integer.parseInt(numStr.toString())));\n        // 注意清空操作数缓存容器\n        numStr = new StringBuilder();\n      }\n\n      // 遇到运算符\n      if (c == '+' || c == '-' || c == '*' || c == '/') {\n        // 只要栈顶运算符的优先级 >= 当前运算符，就需要不停出栈运算\n        while (oper_sign.size() > 0\n            && oper_sign.getLast() != '('\n            && priority.get(c) <= priority.get(oper_sign.getLast())) {\n          calc();\n        }\n        oper_sign.addLast(c);\n      } else if (c == ')') {\n        // 遇到')', 需要将操作符栈中靠近栈顶的'('后面的运算都出栈做了\n        while (oper_sign.getLast() != '(') {\n          calc();\n        }\n        // 最后将')'对应的'('出栈\n        oper_sign.removeLast();\n      } else if (c == '(') {\n        // 遇到'('，则直接压倒操作符栈\n        oper_sign.add(c);\n      }\n\n      i++;\n    }\n\n    // oper_num栈中还有2个以上的数，则还需要进行运算\n    while (oper_num.size() > 1) {\n      calc();\n    }\n\n    // oper_num栈中只剩一个数时，该数就是表达式结果\n    Fractions result = oper_num.removeLast();\n\n    // 如果结果的分母为0（除数为0），则不合法\n    if (result.fa == 0) {\n      return \"ERROR\";\n    }\n\n    // 求分子、分母的最大公约数，并进行约份，求得最简格式的分子，分母\n    int k = getMaxCommonDivisor(result.fa, result.ch);\n    result.fa /= k;\n    result.ch /= k;\n\n    // 求计算结果的符号，这里用乘法是为了避免 分母小，分子大，除法结果为0的情况，这样会丢失符号信息\n    String sign = result.fa * result.ch < 0 ? \"-\" : \"\";\n\n    int fa = Math.abs(result.fa);\n    int ch = Math.abs(result.ch);\n\n    if (fa == 1) {\n      // 如果分母为1，则直接输出分子\n      return sign + ch;\n    } else {\n      // 如果分母不为1，则输出 分子 / 分母\n      return sign + ch + \"/\" + fa;\n    }\n  }\n\n  // 取出oper_num栈顶两个操作数进行运算\n  public static void calc() {\n    // 操作数顺序会对运算产生影响\n    Fractions b = oper_num.removeLast(); // 栈顶元素是运算符右边的操作数\n    Fractions a = oper_num.removeLast(); // 栈顶倒数第二个元素是运算符左边的操作数\n\n    // 运算符\n    char op = oper_sign.removeLast();\n\n    // 记录运算结果\n    Fractions result = new Fractions();\n\n    switch (op) {\n      case '+':\n        result.fa = a.fa * b.fa;\n        result.ch = a.ch * b.fa + b.ch * a.fa;\n        break;\n      case '-':\n        result.fa = a.fa * b.fa;\n        result.ch = a.ch * b.fa - b.ch * a.fa;\n        break;\n      case '*':\n        result.fa = a.fa * b.fa;\n        result.ch = a.ch * b.ch;\n        break;\n      case '/':\n        result.fa = a.fa * b.ch;\n        result.ch = a.ch * b.fa;\n        break;\n    }\n\n    oper_num.add(result);\n  }\n\n  // 辗转相除法，求两个数的最大公约数\n  public static int getMaxCommonDivisor(int x, int y) {\n    while (y != 0) {\n      int tmp = y;\n      y = x % y;\n      x = tmp;\n    }\n    return x;\n  }\n}",
    "python": "# 输入获取\ns = input()\n\n# 操作数栈\noper_num = []\n# 操作符栈\noper_sign = []\n\n\n# 分数类\nclass Fractions:\n    def __init__(self, fa, ch):\n        self.fa = fa  # 分母\n        self.ch = ch  # 分子\n\n\n# 辗转相除法，求两个数的最大公约数\ndef getMaxCommonDivisor(x, y):\n    while y != 0:\n        tmp = y\n        y = x % y\n        x = tmp\n\n    return x\n\n\n# 取出oper_num栈顶两个操作数进行运算\ndef calc():\n    # 操作数顺序会对运算产生影响\n    b = oper_num.pop()  # 栈顶元素是运算符右边的操作数\n    a = oper_num.pop()  # 栈顶倒数第二个元素是运算符左边的操作数\n\n    # 运算符\n    op = oper_sign.pop()\n\n    # 记录运算结果\n    result = Fractions(None, None)\n\n    if op == '+':\n        result.fa = a.fa * b.fa\n        result.ch = a.ch * b.fa + b.ch * a.fa\n    elif op == '-':\n        result.fa = a.fa * b.fa\n        result.ch = a.ch * b.fa - b.ch * a.fa\n    elif op == '*':\n        result.fa = a.fa * b.fa\n        result.ch = a.ch * b.ch\n    elif op == '/':\n        result.fa = a.fa * b.ch\n        result.ch = a.ch * b.fa\n\n    oper_num.append(result)\n\n\ndef getResult():\n    # +,-,*,/ 运算符优先级\n    priority = {\n        \"+\": 1,\n        \"-\": 1,\n        \"*\": 2,\n        \"/\": 2\n    }\n\n    # 操作数的字符缓存容器\n    numStr = []\n\n    i = 0\n    while i < len(s):\n        c = s[i]\n\n        # 遇到数字字符\n        if '9' >= c >= '0':\n            # 则将该数字所在操作数的剩余数字字符一次性探索完\n            while '9' >= c >= '0':\n                numStr.append(c)\n                if i + 1 >= len(s):\n                    break\n                i += 1\n                c = s[i]\n\n            # 探索完后，将操作数缓存容器中记录的字符，变为分数后，压入操作数栈\n            oper_num.append(Fractions(1, int(\"\".join(numStr))))\n            # 注意清空操作数缓存容器\n            numStr.clear()\n\n        # 遇到运算符\n        if c == '+' or c == '-' or c == '*' or c == '/':\n            # 只要栈顶运算符的优先级 >= 当前运算符，就需要不停出栈运算\n            while len(oper_sign) > 0 and oper_sign[-1] != '(' and priority[c] <= priority[oper_sign[-1]]:\n                calc()\n            oper_sign.append(c)\n        elif c == ')':\n            # 遇到')', 需要将操作符栈中靠近栈顶的'('后面的运算都出栈做了\n            while oper_sign[-1] != '(':\n                calc()\n            # 最后将')'对应的'('出栈\n            oper_sign.pop()\n        elif c == '(':\n            # 遇到'('，则直接压倒操作符栈\n            oper_sign.append(c)\n\n        i += 1\n\n    # oper_num栈中还有2个以上的数，则还需要进行运算\n    while len(oper_num) > 1:\n        calc()\n\n    # oper_num栈中只剩一个数时，该数就是表达式结果\n    result = oper_num.pop()\n\n    # 如果结果的分母为0（除数为0），则不合法\n    if result.fa == 0:\n        return \"ERROR\"\n\n    # 求分子、分母的最大公约数，并进行约份，求得最简格式的分子，分母\n    k = getMaxCommonDivisor(result.fa, result.ch)\n    result.fa //= k\n    result.ch //= k\n\n    # 求计算结果的符号，这里用乘法是为了避免 分母小，分子大，除法结果为0的情况，这样会丢失符号信息\n    sign = \"-\" if result.fa * result.ch < 0 else \"\"\n\n    fa = abs(result.fa)\n    ch = abs(result.ch)\n\n    if fa == 1:\n        #  如果分母为1，则直接输出分子\n        return f\"{sign}{ch}\"\n    else:\n        # 如果分母不为1，则输出 分子 / 分母\n        return f\"{sign}{ch}/{fa}\"\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}