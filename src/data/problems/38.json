{
  "id": "38",
  "title": "查找接口成功率最优时间段",
  "examType": "A",
  "score": 100,
  "description": "服务之间交换的接口成功率作为服务调用关键质量特性，某个时间段内的接口失败率使用一个数组表示，\n数组中每个元素都是单位时间内失败率数值，数组中的数值为0~100的整数，\n给定一个数值(minAverageLost)表示某个时间段内平均失败率容忍值，即平均失败率小于等于minAverageLost，\n找出数组中最长时间段，如果未找到则直接返回NULL。",
  "inputDesc": "输入有两行内容，第一行为{minAverageLost}，第二行为{数组}，数组元素通过空格(” “)分隔，\nminAverageLost及数组中元素取值范围为0~100的整数，数组元素的个数不会超过100个。",
  "outputDesc": "找出平均值小于等于minAverageLost的最长时间段，输出数组下标对，格式{beginIndex}-{endIndx}(下标从0开始)，\n如果同时存在多个最长时间段，则输出多个下标对且下标对之间使用空格(” “)拼接，多个下标对按下标从小到大排序。\n输入解释：minAverageLost=1，数组[0, 1, 2, 3, 4]\n前3个元素的平均值为1，因此数组第一个至第三个数组下标，即0-2\n输入解释：minAverageLost=2，数组[0, 0, 100, 2, 2, 99, 0, 2]\n通过计算小于等于2的最长时间段为：\n数组下标为0-1即[0, 0]，数组下标为3-4即[2, 2]，数组下标为6-7即[0, 2]，这三个部分都满足平均值小于等于2的要求，\n因此输出0-1 3-4 6-7\n解题思路如下：\n首先，我们需要读取输入的数据，包括容忍的平均失败率和失败率数组。\n然后，我们创建一个累积和数组，用于快速计算任意时间段的失败率总和。这个数组的每个元素都是从数组开始到当前位置的失败率的总和。\n接下来，我们遍历所有可能的时间段，包括所有可能的开始和结束索引。对于每个时间段，我们计算其失败率总和，然后计算其平均失败率。我们可以通过查找累积和数组来快速计算失败率总和。\n对于每个时间段，我们检查其平均失败率是否小于等于容忍的平均失败率。如果是，我们就找到了一个满足条件的时间段。\n我们需要找到最长的满足条件的时间段。因此，我们需要跟踪找到的最长时间段的长度。如果我们找到一个比当前最长时间段更长的时间段，我们就更新最长时间段的长度，并清空结果列表，然后将新的时间段添加到结果列表中。如果我们找到一个和当前最长时间段一样长的时间段，我们就将它添加到结果列表中。\n最后，我们检查结果列表。如果结果列表为空，说明我们没有找到任何满足条件的时间段，我们就输出\"NULL\"。否则，我们输出所有满足条件的时间段。如果有多个时间段，我们需要按照开始索引从小到大的顺序输出。\n这个解题思路的关键是使用累积和数组来快速计算任意时间段的失败率总和，以及使用一个结果列表来跟踪所有满足条件的时间段。这样，我们可以在一次遍历中找到所有满足条件的时间段，并且可以快速找到最长的时间段。",
  "examples": [
    {
      "input": "1\n0 1 2 3 4",
      "output": "0-2",
      "explanation": "minAverageLost=1，数组[0,1,2,3,4]。\n子数组[0,1,2]的平均值=(0+1+2)/3=1≤1，满足条件。\n这是最长的满足条件的时间段，输出0-2。"
    },
    {
      "input": "2\n0 0 100 2 2 99 0 2",
      "output": "0-1 3-4 6-7",
      "explanation": "minAverageLost=2，数组[0,0,100,2,2,99,0,2]。\n满足平均值≤2的最长时间段：\n- [0,0]长度2，平均值0\n- [2,2]长度2，平均值2\n- [0,2]长度2，平均值1\n三个长度相同，按下标排序输出。"
    },
    {
      "input": "0\n1 2 3 4 5",
      "output": "NULL",
      "explanation": "minAverageLost=0，但数组中没有任何元素≤0，无法找到满足条件的时间段。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**前缀和 + 枚举**问题。\n\n**算法步骤：**\n\n1. **前缀和预处理**：构建累积和数组，快速计算任意区间的和\n2. **枚举所有区间**：遍历所有(start, end)组合\n3. **判断条件**：sum ≤ length × minAverageLost（避免浮点运算）\n4. **维护最长区间**：\n   - 找到更长的区间：清空结果，记录新区间\n   - 找到等长的区间：添加到结果\n5. **输出结果**：无结果输出NULL，否则按下标排序输出\n\n**时间复杂度**：O(n²)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n\n    // 容忍的平均失败率\n    int toleratedAverageLoss = Integer.parseInt(scanner.nextLine());\n\n    // 读取失败率数组\n    Integer[] failureRates =\n        Arrays.stream(scanner.nextLine().split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    int arrayLength = failureRates.length;\n\n    // 创建一个累积和数组，用于快速计算任意时间段的失败率总和\n    int[] cumulativeSum = new int[arrayLength];\n    cumulativeSum[0] = failureRates[0];\n    for (int i = 1; i < arrayLength; i++) cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i];\n\n    // 存储满足条件的时间段的开始和结束索引\n    ArrayList<Integer[]> validPeriods = new ArrayList<>();\n    int maxLength = 0;\n    for (int start = 0; start < arrayLength; start++) {\n      for (int end = start; end < arrayLength; end++) {\n        int sum = start == 0 ? cumulativeSum[end] : cumulativeSum[end] - cumulativeSum[start - 1];\n        int length = end - start + 1;\n        int toleratedLoss = length * toleratedAverageLoss;\n\n        // 如果这个时间段的平均失败率小于等于容忍的平均失败率\n        if (sum <= toleratedLoss) {\n          // 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n          if (length > maxLength) {\n            validPeriods = new ArrayList<>();\n            validPeriods.add(new Integer[] {start, end});\n            maxLength = length;\n          } \n          // 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n          else if (length == maxLength) {\n            validPeriods.add(new Integer[] {start, end});\n          }\n        }\n      }\n    }\n\n    // 如果没有找到满足条件的时间段，输出\"NULL\"\n    if (validPeriods.size() == 0) {\n      System.out.println(\"NULL\");\n    } \n    // 否则，输出所有满足条件的时间段\n    else {\n      validPeriods.sort((a, b) -> a[0] - b[0]);\n\n      StringJoiner sj = new StringJoiner(\" \");\n      for (Integer[] period : validPeriods) sj.add(period[0] + \"-\" + period[1]);\n      System.out.println(sj.toString());\n    }\n  }\n}",
    "python": "# 容忍的平均失败率\ntoleratedAverageLoss = int(input())\n\n# 读取失败率数组\nfailureRates = list(map(int, input().split()))\n\narrayLength = len(failureRates)\n\n# 创建一个累积和数组，用于快速计算任意时间段的失败率总和\ncumulativeSum = [0] * arrayLength\ncumulativeSum[0] = failureRates[0] \nfor i in range(1, arrayLength):\n    cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i]\n\n# 存储满足条件的时间段的开始和结束索引\nvalidPeriods = []\nmaxLength = 0\nfor start in range(arrayLength):\n    for end in range(start, arrayLength):\n        sum = cumulativeSum[end] if start == 0 else cumulativeSum[end] - cumulativeSum[start - 1]\n        length = end - start + 1\n        toleratedLoss = length * toleratedAverageLoss\n\n        # 如果这个时间段的平均失败率小于等于容忍的平均失败率\n        if sum <= toleratedLoss:\n            # 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n            if length > maxLength:\n                validPeriods = []\n                validPeriods.append((start, end))\n                maxLength = length\n            # 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n            elif length == maxLength:\n                validPeriods.append((start, end))\n\n# 如果没有找到满足条件的时间段，输出\"NULL\"\nif len(validPeriods) == 0:\n    print(\"NULL\")\n# 否则，输出所有满足条件的时间段\nelse:\n    validPeriods.sort()\n\n    print(' '.join(f'{start}-{end}' for start, end in validPeriods))",
    "javascript": "const readline = require('readline').createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n \n\nreadline.on('line', tolerated => {\n const toleratedAverageLoss = parseInt(tolerated);\n  readline.on('line', rates => {a\n    const failureRates = rates.split(' ').map(Number);\n \n    const arrayLength = failureRates.length;\n\n    // 创建一个累积和数组，用于快速计算任意时间段的失败率总和\n    const cumulativeSum = new Array(arrayLength);\n    cumulativeSum[0] = failureRates[0];\n    for (let i = 1; i < arrayLength; i++) cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i];\n\n    // 存储满足条件的时间段的开始和结束索引\n    let validPeriods = [];\n    let maxLength = 0;\n    for (let start = 0; start < arrayLength; start++) {\n      for (let end = start; end < arrayLength; end++) {\n        const sum = start === 0 ? cumulativeSum[end] : cumulativeSum[end] - cumulativeSum[start - 1];\n        const length = end - start + 1;\n        const toleratedLoss = length * toleratedAverageLoss;\n\n        // 如果这个时间段的平均失败率小于等于容忍的平均失败率\n        if (sum <= toleratedLoss) {\n          // 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n          if (length > maxLength) {\n            validPeriods = [];\n            validPeriods.push([start, end]);\n            maxLength = length;\n          } \n          // 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n          else if (length === maxLength) {\n            validPeriods.push([start, end]);\n          }\n        }\n      }\n    }\n\n    // 如果没有找到满足条件的时间段，输出\"NULL\"\n    if (validPeriods.length === 0) {\n      console.log(\"NULL\");\n    } \n    // 否则，输出所有满足条件的时间段\n    else {\n      validPeriods.sort((a, b) => a[0] - b[0]);\n\n      console.log(validPeriods.map(period => period.join('-')).join(' '));\n    }\n  });\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    // 容忍的平均失败率\n    int toleratedAverageLoss;\n    cin >> toleratedAverageLoss;\n\n    // 读取失败率数组\n    vector<int> failureRates;\n    string line;\n    getline(cin >> ws, line);\n    istringstream iss(line);\n    int num;\n    while (iss >> num) {\n        failureRates.push_back(num);\n    }\n\n    int arrayLength = failureRates.size();\n\n    // 创建一个累积和数组，用于快速计算任意时间段的失败率总和\n    vector<int> cumulativeSum(arrayLength);\n    cumulativeSum[0] = failureRates[0];\n    for (int i = 1; i < arrayLength; i++) cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i];\n\n    // 存储满足条件的时间段的开始和结束索引\n    vector<pair<int, int>> validPeriods;\n    int maxLength = 0;\n    for (int start = 0; start < arrayLength; start++) {\n        for (int end = start; end < arrayLength; end++) {\n            int sum = start == 0 ? cumulativeSum[end] : cumulativeSum[end] - cumulativeSum[start - 1];\n            int length = end - start + 1;\n            int toleratedLoss = length * toleratedAverageLoss;\n\n            // 如果这个时间段的平均失败率小于等于容忍的平均失败率\n            if (sum <= toleratedLoss) {\n                // 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n                if (length > maxLength) {\n                    validPeriods.clear();\n                    validPeriods.push_back({start, end});\n                    maxLength = length;\n                } \n                // 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n                else if (length == maxLength) {\n                    validPeriods.push_back({start, end});\n                }\n            }\n        }\n    }\n\n    // 如果没有找到满足条件的时间段，输出\"NULL\"\n    if (validPeriods.empty()) {\n        cout << \"NULL\" << endl;\n    } \n    // 否则，输出所有满足条件的时间段\n    else {\n        sort(validPeriods.begin(), validPeriods.end());\n\n        for (auto& period : validPeriods) {\n            cout << period.first << \"-\" << period.second << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    // 容忍的平均失败率\n    int toleratedAverageLoss;\n    scanf(\"%d\", &toleratedAverageLoss);\n\n    // 读取失败率数组\n    int failureRates[100];\n    int arrayLength = 0;\n    while (scanf(\"%d\", &failureRates[arrayLength]) == 1) {\n        arrayLength++;\n    }\n\n    // 创建一个累积和数组，用于快速计算任意时间段的失败率总和\n    int cumulativeSum[100] = {0};\n    cumulativeSum[0] = failureRates[0];\n    for (int i = 1; i < arrayLength; i++) {\n        cumulativeSum[i] = cumulativeSum[i - 1] + failureRates[i];\n    }\n\n    // 存储满足条件的时间段的开始和结束索引\n    int validPeriods[100][2];\n    int validPeriodCount = 0;\n    int maxLength = 0;\n    for (int start = 0; start < arrayLength; start++) {\n        for (int end = start; end < arrayLength; end++) {\n            int sum = start == 0 ? cumulativeSum[end] : cumulativeSum[end] - cumulativeSum[start - 1];\n            int length = end - start + 1;\n            int toleratedLoss = length * toleratedAverageLoss;\n\n            // 如果这个时间段的平均失败率小于等于容忍的平均失败率\n            if (sum <= toleratedLoss) {\n                // 如果这个时间段比之前找到的时间段更长，清空结果列表并添加这个时间段\n                if (length > maxLength) {\n                    validPeriodCount = 0;\n                    validPeriods[validPeriodCount][0] = start;\n                    validPeriods[validPeriodCount][1] = end;\n                    validPeriodCount++;\n                    maxLength = length;\n                } \n                // 如果这个时间段和之前找到的最长时间段一样长，添加这个时间段\n                else if (length == maxLength) {\n                    validPeriods[validPeriodCount][0] = start;\n                    validPeriods[validPeriodCount][1] = end;\n                    validPeriodCount++;\n                }\n            }\n        }\n    }\n\n    // 如果没有找到满足条件的时间段，输出\"NULL\"\n    if (validPeriodCount == 0) {\n        printf(\"NULL\\n\");\n    } \n    // 否则，输出所有满足条件的时间段\n    else {\n        for (int i = 0; i < validPeriodCount; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%d-%d\", validPeriods[i][0], validPeriods[i][1]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}"
  }
}