{
  "id": "4",
  "title": "We Are A Team",
  "examType": "A",
  "score": 100,
  "description": "总共有 n 个人在机房，每个人有一个标号（1<=标号<=n），他们分成了多个团队，需要你根据收到的 m 条消息判定指定的两个人是否在一个团队中，具体的：\n\n1. 消息构成为 `a b c`，整数 a、b 分别代表两个人的标号，整数 c 代表指令\n2. `c == 0` 代表 a 和 b 在一个团队内\n3. `c == 1` 代表需要判定 a 和 b 的关系，如果 a 和 b 是一个团队，输出一行 `we are a team`，如果不是，输出一行 `we are not a team`\n4. c 为其他值，或当前行 a 或 b 超出 1~n 的范围，输出 `da pian zi`",
  "inputDesc": "第一行包含两个整数 n，m（1<=n,m<100000），分别表示有 n 个人和 m 条消息。\n随后的 m 行，每行一条消息，消息格式为：a b c（1<=a,b<=n，0<=c<=1）",
  "outputDesc": "1. c == 1 时，根据 a 和 b 是否在一个团队中输出一行字符串，在一个团队中输出 `we are a team`，不在一个团队中输出 `we are not a team`\n2. c 为其他值，或当前行 a 或 b 的标号小于 1 或者大于 n 时，输出字符串 `da pian zi`\n3. 如果第一行 n 和 m 的值超出约定的范围时，输出字符串 `Null`",
  "examples": [
    {
      "input": "5 7\n1 2 0\n4 5 0\n2 3 0\n1 2 1\n2 3 1\n4 5 1\n1 5 1",
      "output": "We are a team\nWe are a team\nWe are a team\nWe are not a team",
      "explanation": "前三条消息表示：1和2在同一团队、4和5在同一团队、2和3在同一团队。因此形成两个团队：团队1包含{1,2,3}，团队2包含{4,5}。后四条查询消息：1和2在团队1中、2和3在团队1中、4和5在团队2中，都输出'We are a team'；1和5分属不同团队，输出'We are not a team'。"
    },
    {
      "input": "5 6\n1 2 0\n1 2 1\n1 5 0\n2 3 1\n2 5 1\n1 3 2",
      "output": "we are a team\nwe are not a team\nwe are a team\nda pian zi",
      "explanation": "第1条消息将1和2合并为一个团队。第2条查询1和2，输出'we are a team'。第3条将1和5合并（此时团队包含{1,2,5}）。第4条查询2和3，3还未加入任何团队，输出'we are not a team'。第5条查询2和5，都在同一团队，输出'we are a team'。第6条指令c=2非法，输出'da pian zi'。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是典型的**并查集（Union-Find）**问题，用于处理动态连通性查询。\n\n**算法步骤：**\n\n1. **初始化**：创建一个 parent 数组，每个人初始时自己是自己的父节点（即每人独立成一个团队）\n\n2. **处理消息**：\n   - 若 c == 0：执行合并操作（Union），将 a 和 b 所在的团队合并\n   - 若 c == 1：执行查询操作（Find），判断 a 和 b 是否属于同一团队\n   - 其他情况：输出 `da pian zi`\n\n3. **路径压缩优化**：在查找根节点时，将沿途所有节点直接指向根节点，降低后续查询的时间复杂度\n\n**关键点：**\n- 并查集的 find 操作使用路径压缩\n- 注意边界检查：人员标号需在 [1, n] 范围内\n- 注意输出的大小写一致性",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n\n        // 检查输入范围\n        if (n < 1 || n >= 100000 || m < 1 || m >= 100000) {\n            System.out.println(\"Null\");\n            return;\n        }\n\n        // 初始化并查集\n        int[] parent = new int[n + 1];\n        for (int i = 0; i <= n; i++) parent[i] = i;\n\n        // 处理每条消息\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            int c = sc.nextInt();\n\n            // 检查标号范围\n            if (a < 1 || a > n || b < 1 || b > n) {\n                System.out.println(\"da pian zi\");\n                continue;\n            }\n\n            if (c == 0) {\n                // 合并团队\n                int rootA = find(a, parent);\n                int rootB = find(b, parent);\n                if (rootA != rootB) {\n                    parent[rootB] = rootA;\n                }\n            } else if (c == 1) {\n                // 查询是否同一团队\n                if (find(a, parent) == find(b, parent)) {\n                    System.out.println(\"We are a team\");\n                } else {\n                    System.out.println(\"We are not a team\");\n                }\n            } else {\n                System.out.println(\"da pian zi\");\n            }\n        }\n    }\n\n    // 带路径压缩的查找\n    public static int find(int x, int[] parent) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x], parent);\n        }\n        return parent[x];\n    }\n}",
    "python": "import sys\nsys.setrecursionlimit(100005)\n\ndef find(x, parent):\n    \"\"\"带路径压缩的查找\"\"\"\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\n# 读取输入\nn, m = map(int, input().split())\n\n# 检查输入范围\nif n < 1 or n >= 100000 or m < 1 or m >= 100000:\n    print(\"Null\")\nelse:\n    # 初始化并查集\n    parent = list(range(n + 1))\n\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n\n        # 检查标号范围\n        if a < 1 or a > n or b < 1 or b > n:\n            print(\"da pian zi\")\n            continue\n\n        if c == 0:\n            # 合并团队\n            root_a = find(a, parent)\n            root_b = find(b, parent)\n            if root_a != root_b:\n                parent[root_b] = root_a\n        elif c == 1:\n            # 查询是否同一团队\n            if find(a, parent) == find(b, parent):\n                print(\"We are a team\")\n            else:\n                print(\"We are not a team\")\n        else:\n            print(\"da pian zi\")",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nfunction find(x, parent) {\n  if (parent[x] !== x) {\n    parent[x] = find(parent[x], parent);\n  }\n  return parent[x];\n}\n\nlet lines = [];\nrl.on('line', (line) => {\n  lines.push(line);\n}).on('close', () => {\n  const [n, m] = lines[0].split(' ').map(Number);\n\n  if (n < 1 || n >= 100000 || m < 1 || m >= 100000) {\n    console.log('Null');\n    return;\n  }\n\n  const parent = Array.from({ length: n + 1 }, (_, i) => i);\n\n  for (let i = 1; i <= m; i++) {\n    const [a, b, c] = lines[i].split(' ').map(Number);\n\n    if (a < 1 || a > n || b < 1 || b > n) {\n      console.log('da pian zi');\n      continue;\n    }\n\n    if (c === 0) {\n      const rootA = find(a, parent);\n      const rootB = find(b, parent);\n      if (rootA !== rootB) {\n        parent[rootB] = rootA;\n      }\n    } else if (c === 1) {\n      if (find(a, parent) === find(b, parent)) {\n        console.log('We are a team');\n      } else {\n        console.log('We are not a team');\n      }\n    } else {\n      console.log('da pian zi');\n    }\n  }\n});",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> parent;\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    if (n < 1 || n >= 100000 || m < 1 || m >= 100000) {\n        cout << \"Null\" << endl;\n        return 0;\n    }\n\n    parent.resize(n + 1);\n    for (int i = 0; i <= n; i++) parent[i] = i;\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        cin >> a >> b >> c;\n\n        if (a < 1 || a > n || b < 1 || b > n) {\n            cout << \"da pian zi\" << endl;\n            continue;\n        }\n\n        if (c == 0) {\n            int rootA = find(a);\n            int rootB = find(b);\n            if (rootA != rootB) {\n                parent[rootB] = rootA;\n            }\n        } else if (c == 1) {\n            if (find(a) == find(b)) {\n                cout << \"We are a team\" << endl;\n            } else {\n                cout << \"We are not a team\" << endl;\n            }\n        } else {\n            cout << \"da pian zi\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n\nint parent[100005];\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    if (n < 1 || n >= 100000 || m < 1 || m >= 100000) {\n        printf(\"Null\\n\");\n        return 0;\n    }\n\n    for (int i = 0; i <= n; i++) parent[i] = i;\n\n    for (int i = 0; i < m; i++) {\n        int a, b, c;\n        scanf(\"%d %d %d\", &a, &b, &c);\n\n        if (a < 1 || a > n || b < 1 || b > n) {\n            printf(\"da pian zi\\n\");\n            continue;\n        }\n\n        if (c == 0) {\n            int rootA = find(a);\n            int rootB = find(b);\n            if (rootA != rootB) {\n                parent[rootB] = rootA;\n            }\n        } else if (c == 1) {\n            if (find(a) == find(b)) {\n                printf(\"We are a team\\n\");\n            } else {\n                printf(\"We are not a team\\n\");\n            }\n        } else {\n            printf(\"da pian zi\\n\");\n        }\n    }\n\n    return 0;\n}"
  }
}
