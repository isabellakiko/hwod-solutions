{
  "id": "51",
  "title": "英文输入法",
  "examType": "A",
  "score": 100,
  "description": "主管期望你来实现英文输入法单词联想功能。 需求如下：\n依据用户输入的单词前缀，从已输入的英文语句中联想出用户想输入的单词，按字典序输出联想到的单词序列，如果联想不到，请输出用户输入的单词前缀。\n注意：\n英文单词联想时，区分大小写缩略形式如”don’t”，判定为两个单词，”don”和”t”输出的单词序列，不能有重复单词，且只能是英文单词，不能有标点符号",
  "inputDesc": "输入为两行。\n首行输入一段由英文单词word和标点符号组成的语句str；\n接下来一行为一个英文单词前缀pre。\n0 < word.length() <= 200 < str.length <= 100000 < pre <= 20",
  "outputDesc": "输出符合要求的单词序列或单词前缀，存在多个时，单词之间以单个空格分割",
  "examples": [
    {
      "input": "I love you\nHe",
      "output": "He",
      "explanation": "从用户已输入英文语句”I love you”中提炼出“I”、“love”、“you”三个单词，接下来用户输入“He”，从已输入信息中无法联想到任何符合要求的单词，因此输出用户输入的单词前缀。"
    },
    {
      "input": "The furthest distance in the world, Is not between life and death, But when I stand in front of you, Yet you don’t know that I love you.\nf",
      "output": "front furthest",
      "explanation": "从用户已输入英文语句”The furthestdistance in the world, Is not between life and death, But when I stand in frontof you, Yet you dont know that I love you.”中提炼出的单词，符合“f”作为前缀的，有“furthest”和“front”，按字典序排序并在单词间添加空格后输出，结果为“front furthest”。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**字符串处理+排序**问题。\n\n**算法步骤：**\n\n1. 将输入语句中的非字母字符替换为空格\n2. 按空格分割得到单词列表\n3. 使用Set去重\n4. 筛选以prefix为前缀的单词\n5. 按字典序排序输出\n6. 若无匹配则输出前缀本身\n\n**注意事项：**\n- 缩略形式如\"don't\"被分为\"don\"和\"t\"\n- 区分大小写\n- 输出不能有重复单词\n\n**时间复杂度**：O(n log n)，n为单词数量",
  "codes": {
    "java": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String sentence = br.readLine(); // 输入一段由英文单词word和标点符号组成的语句\n        String prefix = br.readLine(); // 输入一个英文单词前缀\n        sentence = sentence.replaceAll(\"[^a-zA-Z]\", \" \"); // 将标点符号替换为空格\n        Set<String> wordSet = new TreeSet<>(); // 存储单词的集合，自动去重且按照字典序排序\n        String[] words = sentence.split(\"\\\\s+\");\n        for (String word : words) {\n            wordSet.add(word);\n        }\n        StringBuilder ans = new StringBuilder();\n        for (String s : wordSet) { // 遍历单词集合\n            if (s.startsWith(prefix)) { // 如果单词以前缀开头\n                ans.append(s).append(\" \"); // 将单词加入答案字符串\n            }\n        }\n        if (ans.length() > 0) { // 如果答案字符串不为空\n            System.out.println(ans.toString().trim()); // 输出单词序列\n        } else {\n            System.out.println(prefix); // 否则输出前缀\n        }\n    }\n}",
    "python": "import string\n\nsentence = input() # 输入一段由英文单词word和标点符号组成的语句\nprefix = input() # 输入一个英文单词前缀\nsentence = sentence.translate(str.maketrans(string.punctuation, ' ' * len(string.punctuation))) # 将标点符号替换为空格\nword_set = set(sentence.split()) # 存储单词的集合，自动去重且按照字典序排序\nans = ''\nfor s in sorted(word_set): # 遍历单词集合\n    if s.startswith(prefix): # 如果单词以前缀开头\n        ans += s + ' ' # 将单词加入答案字符串\nif ans: # 如果答案字符串不为空\n    print(ans) # 输出单词序列\nelse:\n    print(prefix) # 否则输出前缀",
    "javascript": "const readline = require('readline');\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (sentence) => {\n  rl.on('line', (prefix) => {\n  sentence = sentence.replace(/[^\\w\\s]/g, ' '); // 将标点符号替换为空格\n    const wordSet = new Set(sentence.split(' ')); // 存储单词的集合，自动去重且按照字典序排序\n    let ans = '';\n    for (const word of Array.from(wordSet).sort()) { // 遍历单词集合\n      if (word.startsWith(prefix)) { // 如果单词以前缀开头\n        ans += word + ' '; // 将单词加入答案字符串\n      }\n    }\n    if (ans) { // 如果答案字符串不为空\n      console.log(ans); // 输出单词序列\n    } else {\n      console.log(prefix); // 否则输出前缀\n    }\n    rl.close();\n  });\n});",
    "cpp": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    string sentence, prefix;\n    getline(cin, sentence); // 输入一段由英文单词word和标点符号组成的语句\n    getline(cin, prefix); // 输入一个英文单词前缀\n    replace_if(sentence.begin(), sentence.end(), [](char c){return !isalpha(c);}, ' '); // 将标点符号替换为空格\n    stringstream ss(sentence);\n    set<string> word_set; // 存储单词的集合，自动去重且按照字典序排序\n    string word;\n    while (ss >> word) {\n        word_set.insert(word);\n    }\n    string ans;\n    for (auto s : word_set) { // 遍历单词集合\n        if (s.substr(0, prefix.length()) == prefix) { // 如果单词以前缀开头\n            ans += s + \" \"; // 将单词加入答案字符串\n        }\n    }\n    if (ans.length() > 0) { // 如果答案字符串不为空\n        cout << ans << endl; // 输出单词序列\n    } else {\n        cout << prefix << endl; // 否则输出前缀\n    }\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#define MAX_WORDS 1000\n#define MAX_WORD_LENGTH 21\n#define MAX_SENTENCE_LENGTH 10001\n\nint compare(const void *a, const void *b) {\n    return strcmp(*(const char **)a, *(const char **)b);\n}\n\nint main() {\n    char sentence[MAX_SENTENCE_LENGTH], prefix[MAX_WORD_LENGTH];\n    fgets(sentence, MAX_SENTENCE_LENGTH, stdin); // 输入一段由英文单词和标点符号组成的语句\n    fgets(prefix, MAX_WORD_LENGTH, stdin);       // 输入一个英文单词前缀\n\n    // 去除前缀字符串末尾的换行符\n    size_t prefix_len = strlen(prefix);\n    if (prefix[prefix_len - 1] == '\\n') {\n        prefix[prefix_len - 1] = '\\0';\n        prefix_len--;\n    }\n\n    // 将标点符号替换为空格\n    for (int i = 0; sentence[i] != '\\0'; i++) {\n        if (!isalpha(sentence[i])) {\n            sentence[i] = ' ';\n        }\n    }\n\n    // 存储单词的数组\n    char *words[MAX_WORDS];\n    int word_count = 0;\n    char *word = strtok(sentence, \" \");\n\n    // 分割单词并存储\n    while (word != NULL) {\n        words[word_count] = (char *)malloc(strlen(word) + 1);\n        strcpy(words[word_count], word);\n        word_count++;\n        word = strtok(NULL, \" \");\n    }\n\n    // 对单词数组进行排序\n    qsort(words, word_count, sizeof(char *), compare);\n\n    // 输出结果\n    int found = 0;\n    for (int i = 0; i < word_count; i++) {\n        if (strncmp(words[i], prefix, prefix_len) == 0) {\n            printf(\"%s \", words[i]);\n            found = 1;\n        }\n        free(words[i]); // 释放分配的内存\n    }\n\n    // 如果没有找到任何匹配的单词，输出前缀\n    if (!found) {\n        printf(\"%s\", prefix);\n    }\n\n    return 0;\n}"
  }
}