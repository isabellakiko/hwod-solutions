{
  "id": "212",
  "title": "抢7游戏",
  "examType": "B",
  "score": 200,
  "description": "A、B两个人玩抢7游戏，游戏规则为：\nA先报一个起始数字 X（10 ≤ 起始数字 ≤ 10000），B报下一个数字 Y （X - Y < 3），A再报一个数字 Z（Y - Z < 3），以此类推，直到其中一个抢到7，抢到7即为胜者；\n在B赢得比赛的情况下，一共有多少种组合？\n",
  "inputDesc": "起始数字 M\n10 ≤ M ≤ 10000\n如：\n100\n",
  "outputDesc": "B能赢得比赛的组合次数\n\n\n下面模拟M为10~14时，B能够获胜的一些情况：\n\n看完上图，我们可以发现：\n抛开A首次叫的数字M，剩下的 M - 7 长度（上图中有颜色的），必须发生奇数次叫，才能保证B获胜。\n原因是：奇数次叫中，第一次必然是B，由于是奇数次，因此最后一次也必然是B，比如\nBAB\nBABAB\n都是奇数次。\n因此我们只需要将整数 M - 7 划分为奇数块即可，且每块取值只能是1或2。\n\n我们可以假设初始时，一共发生了M-7次叫（M-7可能不是奇数），即每块长度都是1，此时我们设\n然后检查 oneCount + twoCount 的和（一共叫几次）：\n之后，我们应该合并两个1为一个2，即：\n此时就会产生一种新的叫声情况，将新的oneCount和twoCount带入前面逻辑，进行循环处理，知道oneCount < 0 停止。\n\n本题的数量级很大，10 ≤ M ≤ 10000，因此满足要求的情况数量可能极端大，此时我们应该使用大数记录结果。\n\n",
  "examples": [
    {
      "input": "10",
      "output": "1",
      "explanation": "M=10，M-7=3，只有B叫9-8-7一种情况B赢"
    },
    {
      "input": "12",
      "output": "3",
      "explanation": "M=12，M-7=5，B赢的情况有3种组合"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**组合数学**问题。\n\n**核心思路：**\n- 将M-7划分为1和2的组合\n- 奇数块时B获胜\n\n**算法步骤：**\n1. 初始化oneCount=M-7，twoCount=0\n2. 若oneCount+twoCount为奇数，计算排列数\n3. 合并两个1为一个2，重复步骤2\n4. 累加所有满足条件的排列数\n5. 使用大数处理结果\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n  static BigInteger[] factor;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n\n    initFactor(m - 7);\n\n    int oneCount = m - 7;\n    int twoCount = 0;\n\n    // 记录B赢的情况数\n    BigInteger ans = new BigInteger(\"0\");\n\n    while (oneCount >= 0) {\n      // 叫的次数为奇数时，才能B赢\n      if ((oneCount + twoCount) % 2 != 0) {\n        ans = ans.add(getPermutationCount(oneCount, twoCount));\n      }\n\n      // 合并两个1为一个2\n      oneCount -= 2;\n      twoCount += 1;\n    }\n\n    System.out.println(ans);\n  }\n\n  // 求解不重复的全排列数\n  public static BigInteger getPermutationCount(int oneCount, int twoCount) {\n    if (oneCount == 0 || twoCount == 0) { // 即 1 1 1 1 1 或 2 2 2 这种情况，此时只有一种排列\n      return new BigInteger(\"1\");\n    } else {\n      // 排列数去重，比如 1 1 1 2 2 的不重复排列数为 5! / 3! / 2! = 10\n      return factor[oneCount + twoCount].divide(factor[oneCount].multiply(factor[twoCount]));\n    }\n  }\n\n  // 阶乘\n  public static void initFactor(int n) {\n    factor = new BigInteger[n + 1];\n    factor[0] = new BigInteger(\"1\");\n    for (int i = 1; i <= n; i++) {\n      factor[i] = factor[i - 1].multiply(new BigInteger(i + \"\"));\n    }\n  }\n}",
    "python": "import decimal  # 超大数运算内置库\nfrom decimal import Decimal\ndecimal.setcontext(decimal.Context(prec=2500))  # 设置超大数精度\n\nm = int(input())\nfactor = []\n\n\n# 阶乘\ndef initFactor(n):\n    factor.append(Decimal(1))\n\n    for i in range(1, n+1):\n        factor.append(Decimal(i) * factor[-1])\n\n\n# 求解不重复的全排列数\ndef getPermutationCount(oneCount, twoCount):\n    if oneCount == 0 or twoCount == 0:\n        # 即 1 1 1 1 1 或 2 2 2 这种情况，此时只有一种排列\n        return 1\n    else:\n        # 排列数去重，比如 1 1 1 2 2 的不重复排列数为 5! / 3! / 2! = 10\n        return factor[oneCount + twoCount] / factor[oneCount] / factor[twoCount]\n\n\ndef getResult():\n    initFactor(m - 7)\n\n    oneCount = m - 7\n    twoCount = 0\n\n    # 记录B赢的情况数\n    ans = Decimal(0)\n\n    while oneCount >= 0:\n        # 叫的次数为奇数时，才能B赢\n        if (oneCount + twoCount) % 2 != 0:\n            ans += getPermutationCount(oneCount, twoCount)\n\n        # 合并两个1为一个2\n        oneCount -= 2\n        twoCount += 1\n\n    return ans\n\n\nprint(\"{:.0f}\".format(getResult()))",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}