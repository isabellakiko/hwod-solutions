{
  "id": "13",
  "title": "幼儿园分班",
  "examType": "A",
  "score": 100,
  "description": "幼儿园两个班的小朋友在排队时混在了一起，每位小朋友都知道自己是否与前面一位小朋友同班，请你帮忙把同班的小朋友找出来。\n小朋友的编号是整数，与前一位小朋友同班用Y表示，不同班用N表示。",
  "inputDesc": "输入为空格分开的小朋友编号和是否同班标志。\n比如：6/N 2/Y 3/N 4/Y，表示4位小朋友，2和6同班，3和2不同班，4和3同班。\n其中，小朋友总数不超过999，每个小朋友编号大于0，小于等于999。\n不考虑输入格式错误问题。",
  "outputDesc": "输出为两行，每一行记录一个班小朋友的编号，编号用空格分开。\n- 编号按升序排列\n- 人数多的班级排在前面\n- 人数相同时，最小编号所在的班级排在前面",
  "examples": [
    {
      "input": "1/N 2/Y 3/N 4/Y",
      "output": "1 2\n3 4",
      "explanation": "1是第一个，标记N（无意义）。2的同班标记为Y，与1同班。3的同班标记为N，与2不同班。4的同班标记为Y，与3同班。\n\n分班结果：班A [1,2]，班B [3,4]。人数相同，按最小编号排序，输出：1 2\\n3 4"
    },
    {
      "input": "1/N 2/Y 3/N 4/Y 5/Y",
      "output": "3 4 5\n1 2",
      "explanation": "分班结果：班A [1,2]（2人），班B [3,4,5]（3人）。班B人数多，排在前面。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟分组**问题。\n\n**算法步骤：**\n\n1. **初始化**：创建两个班级列表 classA 和 classB，将第一个小朋友放入 classA\n2. **遍历处理**：维护一个\"当前班级\"指针\n   - 遇到 Y：当前小朋友与前一个同班，加入当前班级\n   - 遇到 N：当前小朋友与前一个不同班，切换到另一个班级，再加入\n3. **排序输出**：\n   - 每个班级内部按编号升序排列\n   - 人数多的班级先输出\n   - 人数相同时，最小编号所在的班级先输出\n\n**关键技巧**：用一个\"当前班级\"变量，遇到N就翻转，遇到Y保持不变。\n\n**时间复杂度**：O(n log n)，主要是排序",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] nums = scanner.nextLine().split(\" \");\n\n        String[] start = nums[0].split(\"/\");\n        List<String> class_A = new ArrayList<>();\n        class_A.add(start[0]);\n        List<String> class_B = new ArrayList<>();\n\n        List<List<String>> temp = new ArrayList<>();\n        temp.add(class_A);\n        temp.add(class_B);\n\n        for (int i = 1; i < nums.length; i++) {\n            String[] current = nums[i].split(\"/\");\n            String id_ = current[0];\n            String f = current[1];\n\n            if (f.equals(\"Y\")) {\n                temp = temp;\n            } else {\n                Collections.reverse(temp);\n            }\n\n            temp.get(0).add(id_);\n        }\n\n        if (!class_A.isEmpty()) {\n            Collections.sort(class_A, (a, b) -> Integer.parseInt(a) - Integer.parseInt(b));\n            System.out.println(String.join(\" \", class_A));\n        }\n\n        if (!class_B.isEmpty()) {\n            Collections.sort(class_B, (a, b) -> Integer.parseInt(a) - Integer.parseInt(b));\n            System.out.println(String.join(\" \", class_B));\n        }\n    }\n}",
    "python": "nums = input().split()\n\n# 将第一个元素以'/'分隔成两部分，第一部分表示小朋友的编号，第二部分表示是否与前一位小朋友同班\nstart = nums[0].split('/')\n# 创建一个列表class_A，用于存放同班的小朋友的编号\nclass_A = [start[0]]\n# 创建一个列表class_B，用于存放不同班的小朋友的编号\nclass_B = []\n\n# 创建一个临时列表temp，用于存放两个班级的小朋友编号列表\ntemp = [class_A, class_B]   \n\n# 遍历nums列表中的每一个元素\nfor n in nums[1:]:\n    # 将当前元素以'/'分隔成两部分，第一部分表示小朋友的编号，第二部分表示是否与前一位小朋友同班\n    id_, f = n.split(\"/\")\n\n    # 如果与前一位小朋友同班，则temp不变\n    if f == \"Y\":\n        temp = temp\n    else:\n        # 如果与前一位小朋友不同班，则将temp列表中的两个班级的小朋友编号列表颠倒顺序\n        temp = temp[::-1]\n\n    # 将当前小朋友的编号添加到temp列表的第一个班级的小朋友编号列表中\n    temp[0].append(id_)\n\n# 如果class_A列表不为空，则按照编号的大小升序排列，并用空格分隔成字符串输出\nif class_A:\n    print(\" \".join(sorted(class_A, key=lambda x: int(x))))\n# 如果class_B列表不为空，则按照编号的大小升序排列，并用空格分隔成字符串输出\nif class_B:\n    print(\" \".join(sorted(class_B, key=lambda x: int(x))))",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (nums) => {\n  nums = nums.split(' ');\n\n  let start = nums[0].split('/');\n  let class_A = [start[0]];\n  let class_B = [];\n  let temp = [class_A, class_B];\n\n  for (let i = 1; i < nums.length; i++) {\n    let [id_, f] = nums[i].split('/');\n\n    if (f === 'Y') {\n      temp = temp;\n    } else {\n      temp = temp.reverse();\n    }\n\n    temp[0].push(id_);\n  }\n\n  if (class_A.length > 0) {\n    console.log(class_A.sort((a, b) => parseInt(a) - parseInt(b)).join(' '));\n  }\n  if (class_B.length > 0) {\n    console.log(class_B.sort((a, b) => parseInt(a) - parseInt(b)).join(' '));\n  }\n\n  rl.close();\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\nvector<string> split(const string& s, char delimiter) {\n    vector<string> tokens;\n    string token;\n    istringstream tokenStream(s);\n    while (getline(tokenStream, token, delimiter)) {\n        tokens.push_back(token);\n    }\n    return tokens;\n}\n\nint main() {\n    string nums;\n    getline(cin, nums);\n\n    vector<string> nums_vec = split(nums, ' ');\n\n    vector<string> start = split(nums_vec[0], '/');\n    vector<string> class_A = {start[0]};\n    vector<string> class_B;\n    vector<vector<string>> temp = {class_A, class_B};\n\n    for (int i = 1; i < nums_vec.size(); i++) {\n        vector<string> temp_vec = split(nums_vec[i], '/');\n\n        string id_ = temp_vec[0];\n        string f = temp_vec[1];\n\n        if (f == \"Y\") {\n            temp = temp;\n        } else {\n            reverse(temp.begin(), temp.end());\n        }\n\n        temp[0].push_back(id_);\n    }\n\n    class_A = temp[0];\n    class_B = temp[1];\n  if (class_B.size() > 0) {\n        sort(class_B.begin(), class_B.end(), [](string a, string b) { return stoi(a) < stoi(b); });\n        for (string s : class_B) {\n            cout << s << \" \";\n        }\n        cout << endl;\n    }\n    if (class_A.size() > 0) {\n        sort(class_A.begin(), class_A.end(), [](string a, string b) { return stoi(a) < stoi(b); });\n        for (string s : class_A) {\n            cout << s << \" \";\n        }\n        cout << endl;\n    }\n  \n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义最大小朋友数量\n#define MAX_KIDS 1000\n\n// 辅助函数，用于比较两个字符串表示的数字\nint cmp(const void *a, const void *b) {\n    return atoi(*(const char **)a) - atoi(*(const char **)b);\n}\n\n// 主函数\nint main() {\n    char input[5000];  // 假设输入不超过5000字符\n    fgets(input, sizeof(input), stdin);  // 读取整行输入\n\n    char *nums[MAX_KIDS];  // 保存小朋友编号和同班标志\n    int count = 0;  // 输入的条目数量\n\n    // 分割输入的每个小朋友编号和同班标志\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        nums[count++] = token;\n        token = strtok(NULL, \" \");\n    }\n\n    // 定义两个班级的数组\n    char *class_A[MAX_KIDS];\n    int class_A_count = 0;\n    char *class_B[MAX_KIDS];\n    int class_B_count = 0;\n\n    // 初始化第一个小朋友\n    char *start = strtok(nums[0], \"/\");\n    class_A[class_A_count++] = start;\n\n    // 定义指向两个班级的数组\n    char ***temp[2] = { &class_A, &class_B };  // 指向class_A和class_B的指针\n    int temp_index = 0;  // 当前处理的班级\n\n    // 遍历输入的每个小朋友，从第二个开始\n    for (int i = 1; i < count; i++) {\n        char *id_ = strtok(nums[i], \"/\");  // 小朋友编号\n        char *f = strtok(NULL, \"/\");  // 同班标志\n\n        if (strcmp(f, \"N\") == 0) {\n            temp_index = 1 - temp_index;  // 切换到另一个班\n        }\n\n        // 将当前小朋友编号添加到当前班级\n        if (temp_index == 0) {\n            class_A[class_A_count++] = id_;\n        } else {\n            class_B[class_B_count++] = id_;\n        }\n    }\n\n    // 输出班级A的编号，升序排列\n    if (class_A_count > 0) {\n        qsort(class_A, class_A_count, sizeof(char *), cmp);\n        for (int i = 0; i < class_A_count; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%s\", class_A[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    // 输出班级B的编号，升序排列\n    if (class_B_count > 0) {\n        qsort(class_B, class_B_count, sizeof(char *), cmp);\n        for (int i = 0; i < class_B_count; i++) {\n            if (i > 0) printf(\" \");\n            printf(\"%s\", class_B[i]);\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}"
  }
}