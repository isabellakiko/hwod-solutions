{
  "id": "35",
  "title": "最少交换次数",
  "examType": "A",
  "score": 100,
  "description": "给出数字K,请输出所有结果小于K的整数组合到一起的最少交换次数。 组合一起是指满足条件的数字相邻，不要求相邻后在数组中的位置。\n数据范围：\n100 <= K <= 100 100 <= 数组中数值 <= 100\n100 <= K <= 100\n100 <= 数组中数值 <= 100",
  "inputDesc": "第一行输入数组：1 3 1 4 0\n第二行输入K数值：2",
  "outputDesc": "第一行输出最少交换次数：1",
  "examples": [
    {
      "input": "1 3 1 4 0\n2",
      "output": "1",
      "explanation": "数组[1,3,1,4,0]，K=2。\n小于2的元素：1,1,0（共3个）。\n使用长度为3的滑动窗口：\n- 窗口[1,3,1]：包含2个目标，需交换1次\n- 窗口[3,1,4]：包含1个目标，需交换2次\n- 窗口[1,4,0]：包含2个目标，需交换1次\n最少交换1次（如：交换3和0）。"
    },
    {
      "input": "1 2 3 1 2\n2",
      "output": "0",
      "explanation": "数组[1,2,3,1,2]，K=2。\n小于2的元素只有两个1，它们已经在窗口[1,2,3,1]的两端无法直接相邻。\n但窗口[3,1,2]中只有1个1...实际需要验证各窗口。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**滑动窗口**问题。\n\n**核心思想：**\n- 统计小于K的元素个数count\n- 用长度为count的滑动窗口遍历数组\n- 窗口内不满足条件的元素数量 = 需要交换进来的次数\n\n**算法步骤：**\n\n1. 统计小于K的元素个数count\n2. 初始化窗口[0, count-1]，计算窗口内>=K的元素数量\n3. 滑动窗口，更新最小交换次数\n4. 交换次数 = 窗口大小 - 窗口内目标元素数量\n\n**时间复杂度**：O(n)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // 使用Scanner读取一行输入\n        String numsStr = scanner.nextLine();\n        // 按空格分割字符串并转换为整数数组\n        String[] numParts = numsStr.split(\" \");\n        int[] nums = new int[numParts.length];\n        for (int i = 0; i < numParts.length; i++) {\n            nums[i] = Integer.parseInt(numParts[i]);\n        }\n        // 读取一个整数k\n        int k = scanner.nextInt();\n        // 计算数组中小于k的元素数量\n        int count = 0;\n        for (int num : nums) {\n            if (num < k) {\n                count++;\n            }\n        }\n        // 如果小于k的元素数量为1，直接输出0\n        if (count == 1) {\n            System.out.println(0);\n            return;\n        }\n        // 计算最少交换次数\n        int minSwapCount = 0;\n        for (int i = 0; i < count; i++) {\n            if (nums[i] >= k) {\n                minSwapCount++;\n            }\n        }\n        int tmpSwapCount = minSwapCount;\n        // 使用滑动窗口更新最小交换次数\n        for (int j = count; j < nums.length; j++) {\n            int preLeft = j - count;\n            int curRight = j;\n            if (nums[preLeft] >= k && nums[curRight] < k) {\n                tmpSwapCount--;\n            } else if (nums[preLeft] < k && nums[curRight] >= k) {\n                tmpSwapCount++;\n            }\n            minSwapCount = Math.min(minSwapCount, tmpSwapCount);\n        }\n        // 输出最终的最小交换次数\n        System.out.println(minSwapCount);\n    }\n}",
    "python": "nums = list(map(int, input().split()))\nk = int(input())\n\ncount = sum(1 for num in nums if num < k)\nif count == 1:\n    print(0)\n    exit()\n\nmin_swap_count = sum(1 for num in nums[:count] if num >= k)\ntmp_swap_count = min_swap_count\n\nfor j in range(count, len(nums)):\n    pre_left = j - count\n    cur_right = j\n    if nums[pre_left] >= k and nums[cur_right] < k:\n        tmp_swap_count -= 1\n    elif nums[pre_left] < k and nums[cur_right] >= k:\n        tmp_swap_count += 1\n    min_swap_count = min(min_swap_count, tmp_swap_count)\n\nprint(min_swap_count)",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', (numsStr) => {\n    const nums = numsStr.split(' ').map(Number);\n    rl.on('line', (k) => {\n        k = parseInt(k);\n        // 计算小于k的元素的数量\n        let count = nums.filter(num => num < k).length;\n        if (count === 1) {\n            console.log(0);\n            rl.close();\n            return;\n        }\n        // 计算需要交换的初始数量\n        let minSwapCount = nums.slice(0, count).filter(num => num >= k).length;\n        let tmpSwapCount = minSwapCount;\n        for (let j = count; j < nums.length; j++) {\n            let preLeft = j - count;\n            let curRight = j;\n            if (nums[preLeft] >= k && nums[curRight] < k) {\n                tmpSwapCount--;\n            } else if (nums[preLeft] < k && nums[curRight] >= k) {\n                tmpSwapCount++;\n            }\n            minSwapCount = Math.min(minSwapCount, tmpSwapCount);\n        }\n        console.log(minSwapCount);\n        rl.close();\n    });\n});",
    "cpp": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    char line[1024];\n    fgets(line, 1024, stdin);\n    int nums[100];\n    int length = 0;\n    char *token = strtok(line, \" \");\n    while (token) {\n        nums[length++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n\n    int count = 0;\n    for (int i = 0; i < length; i++) {\n        if (nums[i] < k) count++;\n    }\n\n    if (count == 1) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    int minSwapCount = 0;\n    for (int i = 0; i < count; i++) {\n        if (nums[i] >= k) minSwapCount++;\n    }\n\n    int tmpSwapCount = minSwapCount;\n    for (int j = count; j < length; j++) {\n        int preLeft = j - count;\n        int curRight = j;\n        if (nums[preLeft] >= k && nums[curRight] < k) {\n            tmpSwapCount--;\n        } else if (nums[preLeft] < k && nums[curRight] >= k) {\n            tmpSwapCount++;\n        }\n        if (tmpSwapCount < minSwapCount) {\n            minSwapCount = tmpSwapCount;\n        }\n    }\n\n    printf(\"%d\\n\", minSwapCount);\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    char line[1024];\n    fgets(line, 1024, stdin);\n    int nums[100];\n    int length = 0;\n    char *token = strtok(line, \" \");\n    while (token) {\n        nums[length++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    int k;\n    scanf(\"%d\", &k);\n\n    int count = 0;\n    for (int i = 0; i < length; i++) {\n        if (nums[i] < k) count++;\n    }\n\n    if (count == 1) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    int minSwapCount = 0;\n    for (int i = 0; i < count; i++) {\n        if (nums[i] >= k) minSwapCount++;\n    }\n\n    int tmpSwapCount = minSwapCount;\n    for (int j = count; j < length; j++) {\n        int preLeft = j - count;\n        int curRight = j;\n        if (nums[preLeft] >= k && nums[curRight] < k) {\n            tmpSwapCount--;\n        } else if (nums[preLeft] < k && nums[curRight] >= k) {\n            tmpSwapCount++;\n        }\n        if (tmpSwapCount < minSwapCount) {\n            minSwapCount = tmpSwapCount;\n        }\n    }\n\n    printf(\"%d\\n\", minSwapCount);\n\n    return 0;\n}"
  }
}