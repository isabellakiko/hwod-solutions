{
  "id": "40",
  "title": "游戏分组王者荣耀",
  "examType": "A",
  "score": 100,
  "description": "2020年题：\n英雄联盟是一款十分火热的对战类游戏。每一场对战有10位玩家参与，分为两组，每组5人。每位玩家都有一个战斗力，代表着这位玩家的厉害程度。为了对战尽可能精彩，我们需要把玩家们分为实力尽量相等的两组。一组的实力可以表示为这一组5位玩家的战斗力和。现在，给你10位玩家的战斗力，请你把他们分为实力尽量相等的两组。请你输出这两组的实力差。\n2023年题：\n部门准备举办一场王者荣耀表演赛，有10名游戏爱好者参与，分5为两队，每队5人。每位参与者都有一个评分，代表着他的游戏水平。为了表演赛尽可能精彩，我们需要把10名参赛者分为实力尽量相近的两队。一队的实力可以表示为这一队5名队员的评分总和。 现在给你10名参与者的游戏水平评分，请你根据上述要求分队最后输出这两组的实力差绝对值。 例: 10名参赛者的评分分别为5 1 8 3 4 6 710 9 2，分组为 (135 8 10) (24 679)，两组实力差最小，差值为1。有多种分法，但实力差的绝对值最小为1。",
  "inputDesc": "10个整数，表示10名参与者的游戏水平评分。范围在[1,10000]之间",
  "outputDesc": "1个整数，表示分组后两组实力差绝对值的最小值.\n输入：\n输出：\n说明：\n10名队员分成两组，两组实力差绝对值最小为1.",
  "examples": [
    {
      "input": "5 1 8 3 4 6 7 10 9 2",
      "output": "1",
      "explanation": "10名参赛者评分：5 1 8 3 4 6 7 10 9 2，总和55。\n最优分组：(1,3,5,8,10)=27 和 (2,4,6,7,9)=28。\n实力差：|27-28| = 1。"
    },
    {
      "input": "1 2 3 4 5 6 7 8 9 10",
      "output": "1",
      "explanation": "评分1-10，总和55。\n最优分组：(1,4,5,8,10)=28 和 (2,3,6,7,9)=27。\n实力差：|28-27| = 1。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**DFS+组合枚举**问题。\n\n**问题分析：**\n- 从10人中选5人组成一队，另外5人自动成为另一队\n- 组合数C(10,5) = 252，暴力枚举可行\n\n**算法步骤：**\n\n1. 计算所有玩家评分总和totalSum\n2. DFS枚举所有选5人的组合\n3. 每次递归有两种选择：选当前玩家入队1，或不选\n4. 当队1满5人时，计算两队差值并更新最小值\n5. 剪枝：idx到10时停止\n\n**时间复杂度**：O(C(10,5)) = O(252)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    static int res = Integer.MAX_VALUE;\n    static int totalSum = 0;\n    static int targetSum = 0;\n\n    public static void main(String[] args) {\n        Scanner cin = new Scanner(System.in);\n        int[] nums = Arrays.stream(cin.nextLine().split(\" \"))\n                .mapToInt(Integer::parseInt).toArray();\n        for (int num : nums) {\n            totalSum += num;\n        }\n        targetSum = totalSum / 2;\n        dfs(nums, 0, 0, 0);\n        System.out.println(res);\n        cin.close();\n    }\n\n    static void dfs(int[] nums, int idx, int count, int currentSum) {\n        // 剪枝条件：如果当前总和超过目标，则停止.考友反馈，去掉可得100%\n        // if (currentSum > targetSum) return;\n\n        // 当我们为一个队伍选择了5名玩家时\n        if (count == 5) {\n            // 计算另一个队伍的总和\n            int otherTeamSum = totalSum - currentSum;\n            // 用较小的差值更新结果\n            res = Math.min(res, Math.abs(currentSum - otherTeamSum));\n            return;\n        }\n\n        // 如果我们已经考虑了所有玩家，停止递归\n        if (idx == 10) return;\n\n        // 为第一个队伍选择当前玩家\n        dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);\n        \n        // 不为第一个队伍选择当前玩家\n        dfs(nums, idx + 1, count, currentSum);\n    }\n}",
    "python": "import sys\n\nres = sys.maxsize\ntotalSum = 0\ntargetSum = 0\n\n# 深度优先搜索函数\ndef dfs(nums, idx, count, currentSum):\n    global res, totalSum, targetSum\n    # 剪枝条件：如果当前总和超过目标，则停止.考友反馈，去掉可得100%\n    # if currentSum > targetSum:\n    #    return\n\n    # 当我们为一个队伍选择了5名玩家时\n    if count == 5:\n        # 计算另一个队伍的总和\n        otherTeamSum = totalSum - currentSum\n        # 用较小的差值更新结果\n        res = min(res, abs(currentSum - otherTeamSum))\n        return\n\n    # 如果我们已经考虑了所有玩家，停止递归\n    if idx == 10:\n        return\n\n    # 为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count + 1, currentSum + nums[idx])\n    \n    # 不为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count, currentSum)\n\nnums = list(map(int, input().split()))\nfor num in nums:\n    totalSum += num\ntargetSum = totalSum // 2\ndfs(nums, 0, 0, 0)\nprint(res)",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet res = Infinity;\nlet totalSum = 0;\n\nfunction dfs(nums, idx, count, currentSum) {\n    if (count === 5) {\n        const otherTeamSum = totalSum - currentSum;\n        res = Math.min(res, Math.abs(currentSum - otherTeamSum));\n        return;\n    }\n    if (idx === 10) return;\n    dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);\n    dfs(nums, idx + 1, count, currentSum);\n}\n\nrl.on('line', (line) => {\n    const nums = line.split(' ').map(Number);\n    totalSum = nums.reduce((a, b) => a + b, 0);\n    dfs(nums, 0, 0, 0);\n    console.log(res);\n    rl.close();\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\nint res = INT_MAX;\nint totalSum = 0;\nint targetSum = 0;\n\n// 深度优先搜索函数\nvoid dfs(vector<int>& nums, int idx, int count, int currentSum) {\n    // 剪枝条件：如果当前总和超过目标，则停止 ,考友反馈，去掉可得100%\n    // if (currentSum > targetSum) return;\n\n    // 当我们为一个队伍选择了5名玩家时\n    if (count == 5) {\n        // 计算另一个队伍的总和\n        int otherTeamSum = totalSum - currentSum;\n        // 用较小的差值更新结果\n        res = min(res, abs(currentSum - otherTeamSum));\n        return;\n    }\n\n    // 如果我们已经考虑了所有玩家，停止递归\n    if (idx == 10) return;\n\n    // 为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);\n    \n    // 不为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count, currentSum);\n}\n\nint main() {\n    vector<int> nums(10);\n    for (int i = 0; i < 10; ++i) {\n        cin >> nums[i];\n        totalSum += nums[i];\n    }\n    targetSum = totalSum / 2;\n    dfs(nums, 0, 0, 0);\n    cout << res << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint res = INT_MAX;\nint totalSum = 0;\nint targetSum = 0;\n\n// 深度优先搜索函数\nvoid dfs(int nums[10], int idx, int count, int currentSum) {\n    // 剪枝条件：如果当前总和超过目标，则停止.考友反馈，去掉可得100%\n    // if (currentSum > targetSum) return;\n\n    // 当我们为一个队伍选择了5名玩家时\n    if (count == 5) {\n        // 计算另一个队伍的总和\n        int otherTeamSum = totalSum - currentSum;\n        // 用较小的差值更新结果\n        res = abs(currentSum - otherTeamSum) < res ? abs(currentSum - otherTeamSum) : res;\n        return;\n    }\n\n    // 如果我们已经考虑了所有玩家，停止递归\n    if (idx == 10) return;\n\n    // 为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count + 1, currentSum + nums[idx]);\n    \n    // 不为第一个队伍选择当前玩家\n    dfs(nums, idx + 1, count, currentSum);\n}\n\nint main() {\n    int nums[10];\n    for (int i = 0; i < 10; ++i) {\n        scanf(\"%d\", &nums[i]);\n        totalSum += nums[i];\n    }\n    targetSum = totalSum / 2;\n    dfs(nums, 0, 0, 0);\n    printf(\"%d\\n\", res);\n    return 0;\n}"
  }
}