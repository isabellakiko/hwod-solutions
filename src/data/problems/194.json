{
  "id": "194",
  "title": "查找单入口空闲区域",
  "examType": "B",
  "score": 100,
  "description": "给定一个 m x n 的矩阵，由若干字符 ‘X’ 和 ‘O’构成，’X’表示该处已被占据，’O’表示该处空闲，请找到最大的单入口空闲区域。\n解释：\n空闲区域是由连通的’O’组成的区域，位于边界的’O’可以构成入口，\n单入口空闲区域即有且只有一个位于边界的’O’作为入口的由连通的’O’组成的区域。 如果两个元素在水平或垂直方向相邻，则称它们是“连通”的。\n",
  "inputDesc": "第一行输入为两个数字，第一个数字为行数m，第二个数字为列数n，两个数字以空格分隔，1<=m,n<=200。\n剩余各行为矩阵各行元素，元素为‘X’或‘O’，各元素间以空格分隔。\n",
  "outputDesc": "若有唯一符合要求的最大单入口空闲区域，输出三个数字\n三个数字以空格分隔；\n若有多个符合要求，则输出区域大小最大的，若多个符合要求的单入口区域的区域大小相同，则此时只需要输出区域大小，不需要输出入口坐标。\n若没有，输出NULL。\n\n本题可以使用深度优先搜索来解题。\n首先，我们可以遍历矩阵元素，当遍历到“O”时，已该“O”的坐标位置开始向其上、下、左、右方向开始深度优先搜索，每搜索到一个“O”，则该空闲区域数量+1，如果搜索到的“O”的坐标位置处于矩阵第一列，或最后一列，或者第一行，或者最后一行，那么该“O”位置就是空闲区域的入口位置，我们将其缓存到out数组中。\n当所有深度优先搜索的分支都搜索完了，则判断out统计的入口数量，\n另外，我们还需要定义一个check集合来缓存，已经被递归过的\"O\"位置，避免重复的深度优先搜索。\n",
  "examples": [
    {
      "input": "4 4\nX X X X\nX O O X\nX O O X\nX O X X",
      "output": "1 3 5",
      "explanation": "单入口空闲区域入口在(1,3)，包含5个O"
    },
    {
      "input": "3 3\nX X X\nO O O\nX X X",
      "output": "NULL",
      "explanation": "中间一行有3个入口，不是单入口区域"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**DFS连通块**问题。\n\n**核心思路：**\n- 找所有由O组成的连通区域\n- 统计每个区域的边界入口数\n- 找单入口且最大的区域\n\n**算法步骤：**\n1. DFS遍历每个O的连通区域\n2. 记录区域大小和边界入口坐标\n3. 筛选单入口区域\n4. 返回最大的单入口区域信息\n\n**时间复杂度**：O(M*N)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    static int n;\n    static int m;\n    static String[][] matrix;\n    static int[][] offset = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};\n    static HashSet<String> checked = new HashSet<>();\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();\n        m = sc.nextInt();\n\n        matrix = new String[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                matrix[i][j] = sc.next();\n            }\n        }\n\n        System.out.println(getResult(matrix, n, m));\n    }\n\n    public static String getResult(String[][] matrix, int n, int m) {\n        ArrayList<Integer[]> ans = new ArrayList<>();\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (\"O\".equals(matrix[i][j]) && !checked.contains(i + \"-\" + j)) {\n                    ArrayList<Integer[]> enter = new ArrayList<>();\n                    int count = dfs(i, j, 0, enter);\n                    if (enter.size() == 1) {\n                        Integer[] pos = enter.get(0);\n                        Integer[] an = {pos[0], pos[1], count};\n                        ans.add(an);\n                    }\n                }\n            }\n        }\n\n        if (ans.size() == 0) return \"NULL\";\n        ans.sort((a, b) -> b[2] - a[2]);\n\n        if (ans.size() == 1 || ans.get(0)[2] > ans.get(1)[2]) {\n            StringJoiner sj = new StringJoiner(\" \", \"\", \"\");\n            for (Integer ele : ans.get(0)) {\n                sj.add(ele + \"\");\n            }\n            return sj.toString();\n        } else {\n            return ans.get(0)[2] + \"\";\n        }\n\n    }\n\n    public static int dfs(int i, int j, int count, ArrayList<Integer[]> enter) {\n        String pos = i + \"-\" + j;\n\n        if (i < 0 || i >= n || j < 0 || j >= m || \"X\".equals(matrix[i][j]) || checked.contains(pos)) {\n            return count;\n        }\n\n        checked.add(pos);\n\n        if (i == 0 || i == n - 1 || j == 0 || j == m - 1) enter.add(new Integer[]{i, j});\n\n        count++;\n\n        for (int k = 0; k < offset.length; k++) {\n            int offsetX = offset[k][0];\n            int offsetY = offset[k][1];\n\n            int newI = i + offsetX;\n            int newJ = j + offsetY;\n            count = dfs(newI, newJ, count, enter);\n        }\n\n        return count;\n    }\n}",
    "python": "# 输入获取\nm, n = map(int, input().split())\nmatrix = [input().split() for i in range(m)]\n\n\n# 算法入口\ndef getResult(matrix, m, n):\n    checked = set()\n\n    offsets = ((0, -1), (0, 1), (-1, 0), (1, 0))\n\n    def dfs(i, j, count, out):\n        pos = f\"{i}-{j}\"\n\n        if i < 0 or i >= m or j < 0 or j >= n or matrix[i][j] == \"X\" or pos in checked:\n            return count\n\n        checked.add(pos)\n\n        if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n            out.append([i, j])\n\n        count += 1\n\n        for offsetX, offsetY in offsets:\n            newI = i + offsetX\n            newJ = j + offsetY\n            count = dfs(newI, newJ, count, out)\n\n        return count\n\n    ans = []\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == \"O\" and f\"{i}-{j}\" not in checked:\n                out = []\n                count = dfs(i, j, 0, out)\n                if len(out) == 1:\n                    tmp = out[0][:]\n                    tmp.append(count)\n                    ans.append(tmp)\n\n    if len(ans) == 0:\n        return \"NULL\"\n\n    ans.sort(key=lambda x: -x[2])\n\n    if len(ans) == 1 or ans[0][2] > ans[1][2]:\n        return \" \".join(map(str, ans[0]))\n    else:\n        return ans[0][2]\n\n\n# 算法调用\nprint(getResult(matrix, m, n))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n, m;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [n, m] = lines[0].split(\" \").map(Number);\n  }\n\n  if (n && lines.length === n + 1) {\n    lines.shift();\n    const matrix = lines.map((line) => line.split(\" \"));\n    console.log(getResult(matrix, n, m));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(matrix, n, m) {\n  const checked = new Set();\n\n  const offset = [\n    [0, -1],\n    [0, 1],\n    [-1, 0],\n    [1, 0],\n  ];\n\n  function dfs(i, j, count, out) {\n    const pos = `${i}-${j}`;\n\n    if (\n      i < 0 ||\n      i >= n ||\n      j < 0 ||\n      j >= m ||\n      matrix[i][j] === \"X\" ||\n      checked.has(pos)\n    )\n      return count;\n\n    checked.add(pos);\n\n    if (i === 0 || i === n - 1 || j === 0 || j === m - 1) out.push([i, j]);\n\n    count++;\n\n    for (let k = 0; k < offset.length; k++) {\n      const [offsetX, offsetY] = offset[k];\n      const newI = i + offsetX;\n      const newJ = j + offsetY;\n      count = dfs(newI, newJ, count, out);\n    }\n\n    return count;\n  }\n\n  const ans = [];\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (matrix[i][j] === \"O\" && !checked.has(`${i}-${j}`)) {\n        const out = [];\n        const count = dfs(i, j, 0, out);\n        if (out.length === 1) {\n          ans.push([...out[0], count]);\n        }\n      }\n    }\n  }\n\n  if (!ans.length) return \"NULL\";\n\n  ans.sort((a, b) => b[2] - a[2]);\n\n  if (ans.length === 1 || ans[0][2] > ans[1][2]) {\n    return ans[0].join(\" \");\n  } else {\n    return ans[0][2];\n  }\n}",
    "cpp": "",
    "c": ""
  }
}