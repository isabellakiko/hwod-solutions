{
  "id": "113",
  "title": "原A卷老题)- 处理器问题",
  "examType": "A",
  "score": 100,
  "description": "某公司研发了一款高性能AI处理器。每台物理设备具备8颗AI处理器，编号分别为0、1、2、3、4、5、6、7。\n编号0-3的处理器处于同一个链路中，编号4-7的处理器处于另外一个链路中，不通链路中的处理器不能通信。\n如下图所示。现给定服务器可用的处理器编号数组array，以及任务申请的处理器数量num，找出符合下列亲和性调度原则的芯片组合。\n如果不存在符合要求的组合，则返回空列表。\n\n亲和性调度原则：\n-如果申请处理器个数为1，则选择同一链路，剩余可用的处理器数量为1个的最佳，其次是剩余3个的为次佳，然后是剩余2个，最后是剩余4个。\n-如果申请处理器个数为2，则选择同一链路剩余可用的处理器数量2个的为最佳，其次是剩余4个，最后是剩余3个。\n-如果申请处理器个数为4，则必须选择同一链路剩余可用的处理器数量为4个。\n-如果申请处理器个数为8，则申请节点所有8个处理器。\n\n提示：\n任务申请的处理器数量只能是1、2、4、8。编号0-3的处理器处于一个链路，编号4-7的处理器处于另外一个链路。处理器编号唯一，且不存在相同编号处理器。\n",
  "inputDesc": "输入包含可用的处理器编号数组array，以及任务申请的处理器数量num两个部分。\n第一行为array，第二行为num。例如：\n[0, 1, 4, 5, 6, 7] 1\n表示当前编号为0、1、4、5、6、7的处理器可用。任务申请1个处理器。\n0 <= array.length <= 80 <= array[i] <= 7num in [1, 2, 4, 8]\n",
  "outputDesc": "输出为组合列表，当array=[0，1，4，5，6，7]，num=1 时，输出为[[0], [1]]。\n\n根据第一条亲和性调度原则，在剩余两个处理器的链路（0, 1, 2, 3）中选择处理器。\n由于只有0和1可用，则返回任意一颗处理器即可。\n\n用例中，链路link1=[0,1]，链路link2=[4,5,6,7]\n现在要选1个处理器，则需要按照亲和性调度原则\n如果申请处理器个数为1，则选择同一链路，剩余可用的处理器数量为1个的最佳，其次是剩余3个的为次佳，然后是剩余2个，最后是剩余4个。\n最佳的是，找剩余可用1个处理器的链路，发现没有，link1剩余可用2，link2剩余可用4\n其次的是，找剩余可用3个处理器的链路，发现没有\n再次的是，找剩余可用2个处理器的链路，link1符合要求，即从0和1处理器中任选一个，有两种选择，可以使用dfs找对应组合。\n\n关于回溯算法求解组合，可以看下：\nLeetCode - 77 组合_算法的组合_伏城之外的博客-CSDN博客\n",
  "examples": [
    {
      "input": "[0, 1, 4, 5, 6, 7]\n1",
      "output": "[[0], [1]]",
      "explanation": "link1=[0,1]剩余2个，link2=[4,5,6,7]剩余4个。按亲和性原则选剩余2个的链路"
    },
    {
      "input": "[0, 1, 2, 3, 4, 5, 6, 7]\n4",
      "output": "[[0, 1, 2, 3], [4, 5, 6, 7]]",
      "explanation": "两个链路都剩余4个，申请4个时返回两种组合"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟+DFS组合**问题。\n\n**核心思路：**\n- 将处理器分为两个链路：0-3和4-7\n- 根据申请数量和亲和性原则选择链路\n- 用DFS生成所有可能的组合\n\n**亲和性原则：**\n- 申请1个：优先剩余1>3>2>4的链路\n- 申请2个：优先剩余2>4>3的链路\n- 申请4个：必须剩余4个的链路\n- 申请8个：两个链路都满\n\n**时间复杂度**：O(C(n,k))",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    Integer[] arr =\n        Arrays.stream(sc.nextLine().split(\"[\\\\[\\\\]\\\\,\\\\s]\"))\n            .filter(str -> !\"\".equals(str))\n            .map(Integer::parseInt)\n            .toArray(Integer[]::new);\n\n    String num = sc.next();\n\n    System.out.println(getResult(arr, num));\n  }\n\n  public static String getResult(Integer[] arr, String num) {\n    ArrayList<Integer> link1 = new ArrayList<>();\n    ArrayList<Integer> link2 = new ArrayList<>();\n\n    Arrays.sort(arr, (a, b) -> a - b);\n    for (Integer e : arr) {\n      if (e < 4) {\n        link1.add(e);\n      } else {\n        link2.add(e);\n      }\n    }\n\n    ArrayList<ArrayList<Integer>> ans = new ArrayList<>();\n    int len1 = link1.size();\n    int len2 = link2.size();\n\n    switch (num) {\n      case \"1\":\n        if (len1 == 1 || len2 == 1) {\n          if (len1 == 1) dfs(link1, 0, 1, new ArrayList<>(), ans);\n          if (len2 == 1) dfs(link2, 0, 1, new ArrayList<>(), ans);\n        } else if (len1 == 3 || len2 == 3) {\n          if (len1 == 3) dfs(link1, 0, 1, new ArrayList<>(), ans);\n          if (len2 == 3) dfs(link2, 0, 1, new ArrayList<>(), ans);\n        } else if (len1 == 2 || len2 == 2) {\n          if (len1 == 2) dfs(link1, 0, 1, new ArrayList<>(), ans);\n          if (len2 == 2) dfs(link2, 0, 1, new ArrayList<>(), ans);\n        } else if (len1 == 4 || len2 == 4) {\n          if (len1 == 4) dfs(link1, 0, 1, new ArrayList<>(), ans);\n          if (len2 == 4) dfs(link2, 0, 1, new ArrayList<>(), ans);\n        }\n        break;\n      case \"2\":\n        if (len1 == 2 || len2 == 2) {\n          if (len1 == 2) dfs(link1, 0, 2, new ArrayList<>(), ans);\n          if (len2 == 2) dfs(link2, 0, 2, new ArrayList<>(), ans);\n        } else if (len1 == 4 || len2 == 4) {\n          if (len1 == 4) dfs(link1, 0, 2, new ArrayList<>(), ans);\n          if (len2 == 4) dfs(link2, 0, 2, new ArrayList<>(), ans);\n        } else if (len1 == 3 || len2 == 3) {\n          if (len1 == 3) dfs(link1, 0, 2, new ArrayList<>(), ans);\n          if (len2 == 3) dfs(link2, 0, 2, new ArrayList<>(), ans);\n        }\n        break;\n      case \"4\":\n        if (len1 == 4 || len2 == 4) {\n          if (len1 == 4) ans.add(link1);\n          if (len2 == 4) ans.add(link2);\n        }\n        break;\n      case \"8\":\n        if (len1 == 4 && len2 == 4) {\n          ans.add(\n              Stream.concat(link1.stream(), link2.stream())\n                  .collect(Collectors.toCollection(ArrayList<Integer>::new)));\n        }\n        break;\n    }\n\n    return ans.toString();\n  }\n\n  public static void dfs(\n      ArrayList<Integer> arr,\n      int index,\n      int level,\n      ArrayList<Integer> path,\n      ArrayList<ArrayList<Integer>> res) {\n    if (path.size() == level) {\n      res.add(new ArrayList<>(path));\n      return;\n    }\n\n    for (int i = index; i < arr.size(); i++) {\n      path.add(arr.get(i));\n      dfs(arr, i + 1, level, path, res);\n      path.remove(path.size() - 1);\n    }\n  }\n}",
    "python": "# 输入获取\narr = eval(input())\nnum = int(input())\n\n\n# 算法入口\ndef getResult(arr, num):\n    link1 = []\n    link2 = []\n\n    arr.sort()\n\n    for e in arr:\n        if e < 4:\n            link1.append(e)\n        else:\n            link2.append(e)\n\n    ans = []\n    len1 = len(link1)\n    len2 = len(link2)\n\n    if num == 1:\n        if len1 == 1 or len2 == 1:\n            if len1 == 1:\n                dfs(link1, 0, 1, [], ans)\n            if len2 == 1:\n                dfs(link2, 0, 1, [], ans)\n        elif len1 == 3 or len2 == 3:\n            if len1 == 3:\n                dfs(link1, 0, 1, [], ans)\n            if len2 == 3:\n                dfs(link2, 0, 1, [], ans)\n        elif len1 == 2 or len2 == 2:\n            if len1 == 2:\n                dfs(link1, 0, 1, [], ans)\n            if len2 == 2:\n                dfs(link2, 0, 1, [], ans)\n        elif len1 == 4 or len2 == 4:\n            if len1 == 4:\n                dfs(link1, 0, 1, [], ans)\n            if len2 == 4:\n                dfs(link2, 0, 1, [], ans)\n    elif num == 2:\n        if len1 == 2 or len2 == 2:\n            if len1 == 2:\n                dfs(link1, 0, 2, [], ans)\n            if len2 == 2:\n                dfs(link2, 0, 2, [], ans)\n        elif len1 == 4 or len2 == 4:\n            if len1 == 4:\n                dfs(link1, 0, 2, [], ans)\n            if len2 == 4:\n                dfs(link2, 0, 2, [], ans)\n        elif len1 == 3 or len2 == 3:\n            if len1 == 3:\n                dfs(link1, 0, 2, [], ans)\n            if len2 == 3:\n                dfs(link2, 0, 2, [], ans)\n    elif num == 4:\n        if len1 == 4 or len2 == 4:\n            if len1 == 4:\n                ans.append(link1)\n            if len2 == 4:\n                ans.append(link2)\n    elif num == 8:\n        if len1 == 4 and len2 == 4:\n            tmp = []\n            tmp.extend(link1)\n            tmp.extend(link2)\n            ans.append(tmp)\n\n    return ans\n\n\ndef dfs(arr, index, level, path, res):\n    if len(path) == level:\n        res.append(path[:])\n        return\n\n    for i in range(index, len(arr)):\n        path.append(arr[i])\n        dfs(arr, i + 1, level, path, res)\n        path.pop()\n\n\n# 算法调用\nprint(getResult(arr, num))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const arr = JSON.parse(lines[0]);\n    const num = lines[1];\n\n    console.log(getResult(arr, num));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(arr, num) {\n  const link1 = [];\n  const link2 = [];\n\n  arr\n    .sort((a, b) => a - b)\n    .forEach((e) => {\n      e < 4 ? link1.push(e) : link2.push(e);\n    });\n\n  const ans = [];\n  const len1 = link1.length;\n  const len2 = link2.length;\n\n  switch (num) {\n    case \"1\":\n      if (len1 === 1 || len2 === 1) {\n        if (len1 === 1) dfs(link1, 0, 1, [], ans);\n        if (len2 === 1) dfs(link2, 0, 1, [], ans);\n      } else if (len1 === 3 || len2 === 3) {\n        if (len1 === 3) dfs(link1, 0, 1, [], ans);\n        if (len2 === 3) dfs(link2, 0, 1, [], ans);\n      } else if (len1 === 2 || len2 === 2) {\n        if (len1 === 2) dfs(link1, 0, 1, [], ans);\n        if (len2 === 2) dfs(link2, 0, 1, [], ans);\n      } else if (len1 === 4 || len2 === 4) {\n        if (len1 === 4) dfs(link1, 0, 1, [], ans);\n        if (len2 === 4) dfs(link2, 0, 1, [], ans);\n      }\n      break;\n    case \"2\":\n      if (len1 === 2 || len2 === 2) {\n        if (len1 === 2) dfs(link1, 0, 2, [], ans);\n        if (len2 === 2) dfs(link2, 0, 2, [], ans);\n      } else if (len1 === 4 || len2 === 4) {\n        if (len1 === 4) dfs(link1, 0, 2, [], ans);\n        if (len2 === 4) dfs(link2, 0, 2, [], ans);\n      } else if (len1 === 3 || len2 === 3) {\n        if (len1 === 3) dfs(link1, 0, 2, [], ans);\n        if (len2 === 3) dfs(link2, 0, 2, [], ans);\n      }\n      break;\n    case \"4\":\n      if (len1 === 4 || len2 === 4) {\n        if (len1 === 4) ans.push(link1);\n        if (len2 === 4) ans.push(link2);\n      }\n      break;\n    case \"8\":\n      if (len1 === 4 && len2 === 4) {\n        ans.push([...link1, ...link2]);\n      }\n      break;\n  }\n\n  return JSON.stringify(ans).split(\",\").join(\", \");\n}\n\nfunction dfs(arr, index, level, path, res) {\n  if (path.length === level) {\n    return res.push([...path]);\n  }\n\n  for (let i = index; i < arr.length; i++) {\n    path.push(arr[i]);\n    dfs(arr, i + 1, level, path, res);\n    path.pop();\n  }\n}",
    "cpp": "",
    "c": ""
  }
}