{
  "id": "59",
  "title": "高矮个子排队",
  "examType": "A",
  "score": 100,
  "description": "现在有一队小朋友，他们高矮不同，我们以正整数数组表示这一队小朋友的身高，如数组{5,3,1,2,3}。\n我们现在希望小朋友排队，以“高”“矮”“高”“矮”顺序排列，每一个“高”位置的小朋友要比相邻的位置高或者相等；每一个“矮”位置的小朋友要比相邻的位置矮或者相等；\n要求小朋友们移动的距离和最小，第一个从“高”位开始排，输出最小移动距离即可。\n例如，在示范小队{5,3,1,2,3}中，{5, 1, 3, 2, 3}是排序结果。\n{5, 2, 3, 1, 3} 虽然也满足“高”“矮”“高”“矮”顺序排列，但小朋友们的移动距离大，所以不是最优结果。\n移动距离的定义如下所示：\n第二位小朋友移到第三位小朋友后面，移动距离为1，若移动到第四位小朋友后面，移动距离为2；",
  "inputDesc": "排序前的小朋友，以英文空格的正整数：\n4 3 5 7 8\n注：小朋友<100个",
  "outputDesc": "排序后的小朋友，以英文空格分割的正整数：4 3 7 5 8\n备注：4（高）3（矮）7（高）5（矮）8（高）， 输出结果为最小移动距离，只有5和7交换了位置，移动距离都是1。",
  "examples": [
    {
      "input": "5 3 1 2 3",
      "output": "5 1 3 2 3",
      "explanation": "原序列：5(高) 3(矮) 1(高) 2(矮) 3(高)\n位置0高、位置1矮：5>3符合\n位置1矮、位置2高：3>1不符合，交换→5 1 3 2 3\n后续位置都符合要求。"
    },
    {
      "input": "4 3 5 7 8",
      "output": "4 3 7 5 8",
      "explanation": "位置2高、位置3矮：5<7不符合，交换5和7。\n结果：4(高)3(矮)7(高)5(矮)8(高)"
    },
    {
      "input": "1 1 1 1",
      "output": "1 1 1 1",
      "explanation": "所有相等，无需交换。相邻位置可以相等。"
    },
    {
      "input": "xxx",
      "output": "[]",
      "explanation": "非法参数，返回空数组。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心+相邻交换**问题。\n\n**关键点：**\n题目要求从\"高\"位开始，发现不符合就交换相邻元素。\n\n**算法步骤：**\n\n1. 遍历相邻元素对\n2. 偶数位置应为\"高\"：期望heights[i] >= heights[i+1]\n3. 奇数位置应为\"矮\"：期望heights[i] <= heights[i+1]\n4. 不符合要求时交换相邻两个元素\n\n**判断条件：**\n`(heights[i] > heights[j]) != (i % 2 == 0)` 时需要交换\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.*;   \n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);   \n        String s = sc.nextLine();   \n\n        // 使用正则表达式检查输入字符串是否只包含数字和空格\n        // 如果字符串中包含非法字符（非数字或空格），则输出\"[]\"并退出程序\n        if (!s.matches(\"[0-9\\\\s]+\")) {\n            System.out.println(\"[]\");\n            return;\n        }\n\n        // 将输入字符串按空格分割，并将每个部分转换为整数，存储在数组heights中\n        int[] heights = Arrays.stream(s.split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n        // 初始化两个指针i和j，分别指向相邻的两个小朋友\n        int i = 0, j = 1;\n\n        // 遍历数组，调整相邻小朋友的身高顺序以满足\"高矮交替\"的要求\n        while (j < heights.length) {\n            // 判断当前两个相邻小朋友的身高是否满足要求\n            // 条件解释：如果heights[i] > heights[j]且i是偶数，或者heights[i] < heights[j]且i是奇数\n            // 则需要交换heights[i]和heights[j]的值，以符合\"高矮交替\"的规则\n            if (heights[i] != heights[j] && (heights[i] > heights[j]) != (i % 2 == 0)) {\n                // 交换heights[i]和heights[j]的值\n                int tmp = heights[i];\n                heights[i] = heights[j];\n                heights[j] = tmp;\n            }\n\n            // 移动指针，检查下一个相邻的小朋友\n            i++;\n            j++;\n        }\n\n        // 使用StringJoiner将排序后的身高数组转换为字符串，并以空格分隔\n        StringJoiner sj = new StringJoiner(\" \");\n        for (int h : heights) {  // 遍历heights数组中的每一个元素\n            sj.add(String.valueOf(h));  // 将元素转换为字符串并添加到StringJoiner中\n        }\n        // 输出最终排序结果\n        System.out.println(sj.toString());\n    }\n}",
    "python": "import re\n\ns = input()\nif not re.match(r\"[0-9\\s]+\", s):\n    print(\"[]\")\n    exit()\n\nheights = list(map(int, s.split()))\n\ni = 0\nj = 1\n\nwhile j < len(heights):\n    if heights[i] != heights[j] and (heights[i] > heights[j]) != (i % 2 == 0):\n        heights[i], heights[j] = heights[j], heights[i]\n        \n    i += 1\n    j += 1\n\nresult = \" \".join(map(str, heights))\nprint(result)",
    "javascript": "const readline = require('readline');\n\n \nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n \nrl.on('line', (s) => {\n    // 使用正则表达式检查输入字符串是否只包含数字和空格\n    // 如果字符串中包含非法字符（非数字或空格），则输出\"[]\"并退出程序\n    if (!/^[0-9\\s]+$/.test(s)) {\n        console.log(\"[]\");\n        rl.close();  // 关闭接口\n        return;\n    }\n\n    // 将输入字符串按空格分割，并将每个部分转换为整数，存储在数组heights中\n    let heights = s.split(' ').map(Number);\n\n    // 初始化两个指针i和j，分别指向相邻的两个小朋友\n    let i = 0, j = 1;\n\n    // 遍历数组，调整相邻小朋友的身高顺序以满足\"高矮交替\"的要求\n    while (j < heights.length) {\n        // 判断当前两个相邻小朋友的身高是否满足要求\n        // 条件解释：如果heights[i] > heights[j]且i是偶数，或者heights[i] < heights[j]且i是奇数\n        // 则需要交换heights[i]和heights[j]的值，以符合\"高矮交替\"的规则\n        if (heights[i] !== heights[j] && (heights[i] > heights[j]) !== (i % 2 === 0)) {\n            // 交换heights[i]和heights[j]的值\n            [heights[i], heights[j]] = [heights[j], heights[i]];\n        }\n\n        // 移动指针，检查下一个相邻的小朋友\n        i++;\n        j++;\n    }\n\n    // 将排序后的身高数组转换为字符串，并以空格分隔\n    console.log(heights.join(' '));\n\n    \n});",
    "cpp": "#include <iostream>    // 包含输入输出流库\n#include <sstream>     // 包含字符串流库，用于处理字符串\n#include <string>      // 包含字符串库\n#include <vector>      // 包含向量库，用于动态数组\nusing namespace std;\n\nint main() {\n    string s;\n    // 从标准输入读取一行字符串，存储在变量s中\n    getline(cin, s);\n\n    // 检查输入字符串中是否包含非数字或空格的字符\n    // 如果发现非法字符（非数字或空格），则输出\"[]\"并退出程序\n    if (s.find_first_not_of(\"0123456789 \") != string::npos) {\n        cout << \"[]\" << endl;\n        return 0;\n    }\n\n    // 使用字符串流将字符串s按空格分割，并依次转化为整数存入向量heights中\n    istringstream iss(s);\n    vector<int> heights;  // 定义一个整型向量用于存储小朋友的身高\n    int height;\n    while (iss >> height) {  // 从字符串流中读取一个整数，并存入heights向量\n        heights.push_back(height);\n    }\n\n    // 初始化两个索引i和j，分别指向相邻的两个小朋友\n    int i = 0, j = 1;\n    while (j < heights.size()) {  // 遍历向量，直到处理完所有元素\n        // 检查当前两个相邻位置是否满足\"高矮高矮\"的排列要求\n        // 如果heights[i] > heights[j] 且 i 是偶数，或者 heights[i] < heights[j] 且 i 是奇数\n        // 则说明当前排列不符合要求，需要交换两个元素的位置\n        if (heights[i] != heights[j] && (heights[i] > heights[j]) != (i % 2 == 0)) {\n            // 交换 heights[i] 和 heights[j] 的值\n            int tmp = heights[i];\n            heights[i] = heights[j];\n            heights[j] = tmp;\n        }\n        // 移动索引i和j，继续检查下一个相邻的元素对\n        i++;\n        j++;\n    }\n\n    // 将调整后的向量heights中的元素转换为字符串，准备输出\n    string result;\n    for (int h : heights) {  // 遍历向量中的每一个元素\n        result += to_string(h) + \" \";  // 将元素转换为字符串并拼接到result中，以空格分隔\n    }\n    result.pop_back();  // 移除最后一个多余的空格\n    cout << result << endl;  // 输出最终的排列结果\n\n    return 0;  // 程序结束\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n// 函数声明\nint is_valid_input(const char* s);\nint* split_and_convert(const char* s, int* size);\nvoid swap(int* a, int* b);\n\nint main() {\n    char s[1024];\n    fgets(s, sizeof(s), stdin);  // 读取用户输入\n\n    // 检查输入字符串是否只包含数字和空格\n    if (!is_valid_input(s)) {\n        printf(\"[]\\n\");\n        return 0;\n    }\n\n    int size;\n    int* heights = split_and_convert(s, &size);  // 将输入字符串分割并转换为整数数组\n\n    // 初始化两个指针i和j，分别指向相邻的两个小朋友\n    int i = 0, j = 1;\n\n    // 遍历数组，调整相邻小朋友的身高顺序以满足\"高矮交替\"的要求\n    while (j < size) {\n        // 判断当前两个相邻小朋友的身高是否满足要求\n        // 条件解释：如果heights[i] > heights[j]且i是偶数，或者heights[i] < heights[j]且i是奇数\n        // 则需要交换heights[i]和heights[j]的值，以符合\"高矮交替\"的规则\n        if (heights[i] != heights[j] && (heights[i] > heights[j]) != (i % 2 == 0)) {\n            // 交换heights[i]和heights[j]的值\n            swap(&heights[i], &heights[j]);\n        }\n\n        // 移动指针，检查下一个相邻的小朋友\n        i++;\n        j++;\n    }\n\n    // 输出最终排序结果\n    for (int k = 0; k < size; k++) {\n        if (k > 0) {\n            printf(\" \");\n        }\n        printf(\"%d\", heights[k]);\n    }\n    printf(\"\\n\");\n\n    free(heights);  // 释放动态分配的内存\n    return 0;\n}\n\n// 检查输入字符串是否只包含数字和空格\nint is_valid_input(const char* s) {\n    while (*s) {\n        if (!isdigit(*s) && !isspace(*s)) {\n            return 0;  // 非法字符\n        }\n        s++;\n    }\n    return 1;\n}\n\n// 将输入字符串按空格分割并转换为整数数组\nint* split_and_convert(const char* s, int* size) {\n    int* heights = malloc(1024 * sizeof(int));  // 假设数组最大长度为1024\n    *size = 0;\n\n    char* token = strtok(strdup(s), \" \");\n    while (token != NULL) {\n        heights[(*size)++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n    return heights;\n}\n\n// 交换两个整数的值\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}"
  }
}