{
  "id": "93",
  "title": "分苹果",
  "examType": "A",
  "score": 100,
  "description": "A、B两个人把苹果分为两堆，A希望按照他的计算规则等分苹果，他的计算规则是按照二进制加法计算，并且不计算进位 12+5=9（1100 + 0101 = 9），B的计算规则是十进制加法，包括正常进位，B希望在满足A的情况下获取苹果重量最多。\n输入苹果的数量和每个苹果重量，输出满足A的情况下B获取的苹果总重量。\n如果无法满足A的要求，输出-1。\n数据范围\n1 <= 总苹果数量 <= 200001 <= 每个苹果重量 <= 10000",
  "inputDesc": "输入第一行是苹果数量：3\n输入第二行是每个苹果重量：3 5 6",
  "outputDesc": "输出第一行是B获取的苹果总重量：11",
  "examples": [
    {
      "input": "3\n3 5 6",
      "output": "11",
      "explanation": "3^5^6=0，可以等分。B拿最多=总和14-最小3=11。"
    },
    {
      "input": "2\n5 6",
      "output": "-1",
      "explanation": "5^6=3≠0，无法按A的规则等分。"
    },
    {
      "input": "4\n1 2 3 4",
      "output": "9",
      "explanation": "1^2^3^4=4≠0，无法等分，输出-1。（需验证）"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**异或运算**问题。\n\n**核心思路：**\n- 二进制加法不进位 = 异或运算(XOR)\n- A要求等分：两堆异或结果相等 → 全部异或为0\n- B要最多：把最小的苹果给A，其余给B\n\n**算法步骤：**\n1. 计算所有苹果重量的异或和\n2. 若异或和≠0，无法等分，返回-1\n3. 若异或和=0，B获取 = 总和 - 最小值\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个扫描器对象，用于读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取苹果的数量 n\n        int n = scanner.nextInt();\n        // 创建一个大小为 n 的数组，用于存储每个苹果的重量\n        int[] a = new int[n];\n        // 循环读取每个苹果的重量，并存储到数组中\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        // 初始化异或总和变量\n        int sums = 0;\n        // 初始化最小值变量为整型的最大值\n        int min = Integer.MAX_VALUE;\n        // 遍历所有苹果的重量\n        for (int x : a) {\n            // 按位异或操作，更新异或总和\n            sums = sums ^ x;\n            // 找到当前最小的苹果重量\n            if (x < min) {\n                min = x;\n            }\n        }\n        // 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\n        if (sums != 0) {\n            System.out.println(-1);\n        } else {\n            // 计算所有苹果重量的总和\n            int sum = 0;\n            for (int x : a) {\n                sum += x;\n            }\n            // 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n            System.out.println(sum - min);\n        }\n    }\n}",
    "python": "import sys\n\n# 读取苹果的数量 n\nn = int(input())\n# 读取每个苹果的重量并存储到列表 a 中\na = list(map(int, input().split()))\n\n# 初始化异或总和\nsums = 0\n# 初始化最小值为系统的最大整数\nmin_val = sys.maxsize\n# 遍历所有苹果的重量\nfor x in a:\n    # 按位异或操作，更新异或总和\n    sums = sums ^ x\n    # 找到当前最小的苹果重量\n    if x < min_val:\n        min_val = x\n\n# 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\nif sums != 0:\n    print(-1)\nelse:\n    # 计算所有苹果重量的总和\n    total_sum = sum(a)\n    # 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n    print(total_sum - min_val)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet n;  // 苹果数量\nlet a;  // 每个苹果的重量数组\n\n// 读取输入的第一行，苹果数量 n\nrl.on('line', (inputN) => {\n  n = parseInt(inputN);\n  \n  // 读取输入的第二行，苹果的重量列表\n  rl.on('line', (inputA) => {\n    a = inputA.split(' ').map(Number);\n    \n    // 初始化异或总和\n    let sums = 0;\n    // 初始化最小值为 JavaScript 中安全的最大整数\n    let min_val = Number.MAX_SAFE_INTEGER;\n    \n    // 遍历所有苹果的重量\n    a.forEach((x) => {\n      // 按位异或操作，更新异或总和\n      sums = sums ^ x;\n      // 找到当前最小的苹果重量\n      if (x < min_val) {\n        min_val = x;\n      }\n    });\n    \n    // 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\n    if (sums !== 0) {\n      console.log(-1);\n    } else {\n      // 计算所有苹果重量的总和\n      const total_sum = a.reduce((sum, x) => sum + x, 0);\n      // 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n      console.log(total_sum - min_val);\n    }\n    \n    rl.close();  // 关闭读取接口\n  });\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <limits>\n\nint main() {\n    int n;\n    // 读取苹果的数量 n\n    std::cin >> n;\n    // 创建一个大小为 n 的向量，用于存储每个苹果的重量\n    std::vector<int> a(n);\n    // 循环读取每个苹果的重量，并存储到向量中\n    for (int i = 0; i < n; i++) {\n        std::cin >> a[i];\n    }\n    // 初始化异或总和变量\n    int sums = 0;\n    // 初始化最小值变量为整型的最大值\n    int min = std::numeric_limits<int>::max();\n    // 遍历所有苹果的重量\n    for (int x : a) {\n        // 按位异或操作，更新异或总和\n        sums = sums ^ x;\n        // 找到当前最小的苹果重量\n        if (x < min) {\n            min = x;\n        }\n    }\n    // 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\n    if (sums != 0) {\n        std::cout << -1 << std::endl;\n    } else {\n        // 计算所有苹果重量的总和\n        int sum = 0;\n        for (int x : a) {\n            sum += x;\n        }\n        // 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n        std::cout << sum - min << std::endl;\n    }\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <limits.h>  // 用于定义整型的最大值 INT_MAX\n\nint main() {\n    int n;\n    // 读取苹果的数量 n\n    scanf(\"%d\", &n);\n    \n    // 创建一个大小为 n 的数组，用于存储每个苹果的重量\n    int a[n];\n    \n    // 循环读取每个苹果的重量，并存储到数组中\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    \n    // 初始化异或总和变量\n    int sums = 0;\n    // 初始化最小值变量为整型的最大值\n    int min = INT_MAX;\n    \n    // 遍历所有苹果的重量\n    for (int i = 0; i < n; i++) {\n        // 按位异或操作，更新异或总和\n        sums = sums ^ a[i];\n        // 找到当前最小的苹果重量\n        if (a[i] < min) {\n            min = a[i];\n        }\n    }\n    \n    // 如果异或总和不为 0，则无法按 A 的规则分堆，输出 -1\n    if (sums != 0) {\n        printf(\"-1\\n\");\n    } else {\n        // 计算所有苹果重量的总和\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += a[i];\n        }\n        // 输出 B 可以获取的最大苹果重量（总和减去最小的苹果重量）\n        printf(\"%d\\n\", sum - min);\n    }\n    \n    return 0;\n}"
  }
}