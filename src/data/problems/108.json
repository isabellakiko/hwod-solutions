{
  "id": "108",
  "title": "爱吃蟠桃的孙悟空",
  "examType": "A",
  "score": 100,
  "description": "孙悟空爱吃蟠桃，有一天趁着蟠桃园守卫不在来偷吃。已知蟠桃园有 N 棵桃树，每颗树上都有桃子，守卫将在 H 小时后回来。\n孙悟空可以决定他吃蟠桃的速度K（个/小时），每个小时选一颗桃树，并从树上吃掉 K 个，如果树上的桃子少于 K 个，则全部吃掉，并且这一小时剩余的时间里不再吃桃。\n孙悟空喜欢慢慢吃，但又想在守卫回来前吃完桃子。\n请返回孙悟空可以在 H 小时内吃掉所有桃子的最小速度 K（K为整数）。如果以任何速度都吃不完所有桃子，则返回0。",
  "inputDesc": "一行输入为 N 个数字，N 表示桃树的数量，这 N 个数字表示每颗桃树上蟠桃的数量。\n第二行输入为一个数字，表示守卫离开的时间 H。\n其中数字通过空格分割，N、H为正整数，每颗树上都有蟠桃，且 0 < N < 10000，0 < H < 10000。",
  "outputDesc": "吃掉所有蟠桃的最小速度 K，无解或输入异常时输出 0。",
  "examples": [
    {
      "input": "2 3 4 5\n4",
      "output": "5",
      "explanation": "4棵桃树有2,3,4,5个桃子，4小时内吃完。速度5时：1+1+1+1=4小时刚好吃完"
    },
    {
      "input": "2 3 4 5\n3",
      "output": "0",
      "explanation": "4棵树只有3小时，每小时只能吃一棵树，无法吃完，返回0"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二分查找**问题（LeetCode 875）。\n\n**核心思路：**\n- 二分查找最小吃桃速度K\n- 对于速度K，计算吃完所有桃子需要的时间\n- 时间<=H则速度可行，尝试更小速度\n\n**算法步骤：**\n1. 二分范围：[1, max(桃子数)]\n2. 计算当前速度吃完所有树需要的时间\n3. 时间<=H：right=mid，否则left=mid+1\n4. 特判：树的数量>H时无解返回0\n\n**时间复杂度**：O(N×log(max))",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个Scanner对象用于读取输入\n        Scanner cin = new Scanner(System.in);\n        // 读取一行输入并转换为整数数组，代表每棵桃树上的桃子数量\n        int[] peachCounts = Arrays.stream(cin.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 读取下一行输入，转换为整数，代表可用的小时数\n        int h = Integer.parseInt(cin.nextLine());\n        // 获取桃树的数量\n        int n = peachCounts.length;\n \n        // 输入验证：如果桃树数量为0，或小时数不合法，或桃树数量大于小时数，则输出0并返回\n        if (n == 0 || h <= 0 || n >= 10000 || h >= 10000 || n > h) {\n            System.out.println(0);\n            return;\n        }\n\n        // 初始化二分查找的左右边界\n        int left = 1, right = (int)1e9; // 假设最大的吃桃速度不会超过1e9\n        // 当左边界小于右边界时，执行二分查找\n        while (left < right) {\n            // 计算中间值\n            int mid = left + (right - left) / 2;\n            // 如果以mid的速度可以在h小时内吃完桃子，则尝试更小的速度\n            if (canFinish(peachCounts, h, mid)) {\n                right = mid;\n            } else {\n                // 否则尝试更大的速度\n                left = mid + 1;\n            }\n        }\n\n        // 输出最小吃桃速度，此时left是满足条件的最小速度\n        System.out.println(left);\n    }\n\n    // 定义一个方法，判断以速度k是否能在h小时内吃完所有桃子\n    static boolean canFinish(int[] p, int h, int k) {\n        // 初始化所需的总小时数\n        int ans = 0;\n        // 遍历每棵桃树\n        for (int x : p) {\n            // 计算吃完这棵桃树上桃子所需的小时数，向上取整\n            ans += Math.ceil(x * 1.0 / k);\n        }\n        // 如果所需总小时数小于等于h，则返回true，表示可以完成\n        return ans <= h;\n    }\n}",
    "python": "import math\n\n# 判断以速度k是否能在h小时内吃完所有桃子\ndef can_finish(p, h, k):\n    ans = 0\n    for x in p:\n        ans += math.ceil(x / k)\n    return ans <= h\n\n# 读取输入\npeach_counts = list(map(int, input().split()))\nh = int(input())\n\n# 输入验证\nn = len(peach_counts)\nif n == 0 or h <= 0 or n >= 10000 or h >= 10000 or n > h:\n    print(0)\n    exit(0)\n\n# 二分查找最小吃桃速度\nleft, right = 1, int(1e9)\nwhile left < right:\n    mid = (left + right) // 2\n    if can_finish(peach_counts, h, mid):\n        right = mid\n    else:\n        left = mid + 1\n\n# 输出最小吃桃速度\nprint(left)",
    "javascript": "// 读取标准输入\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 判断以速度k是否能在h小时内吃完所有桃子\nfunction canFinish(p, h, k) {\n    let ans = 0;\n    for (let x of p) {\n        ans += Math.ceil(x / k);\n    }\n    return ans <= h;\n}\n\n// 处理输入\nrl.on('line', (input) => {\n    if (!this.peachCounts) {\n        // 第一行输入，转换为桃子数量数组\n        this.peachCounts = input.split(' ').map(Number);\n        return;\n    }\n    // 第二行输入，转换为小时数\n    const h = Number(input);\n    rl.close(); // 不再读取输入\n\n    // 输入验证\n    const n = this.peachCounts.length;\n    if (n === 0 || h <= 0 || n >= 10000 || h >= 10000 || n > h) {\n        console.log(0);\n        return;\n    }\n\n    // 二分查找最小吃桃速度\n    let left = 1, right = 1e9;\n    while (left < right) {\n        const mid = Math.floor((left + right) / 2);\n        if (canFinish(this.peachCounts, h, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    // 输出最小吃桃速度\n    console.log(left);\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <sstream>\nusing namespace std;\n\n// 判断以速度k是否能在h小时内吃完所有桃子\nbool canFinish(vector<int>& p, int h, int k) {\n    long long ans = 0; // 使用 long long 防止溢出\n    for (int x : p) {\n        ans += ceil(x * 1.0 / k); // 向上取整\n    }\n    return ans <= h;\n}\n\nint main() {\n    // 读取输入\n    string line;\n    getline(cin, line);\n    istringstream iss(line);\n    vector<int> peachCounts;\n    int x;\n    while (iss >> x) {\n        peachCounts.push_back(x);\n    }\n    int h;\n    cin >> h;\n\n    // 输入验证\n    int n = peachCounts.size();\n    if (n == 0 || h <= 0 || n >= 10000 || h >= 10000 || n > h) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    // 二分查找最小吃桃速度\n    int left = 1, right = 1e9; // 假设最大的吃桃速度不会超过1e9\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (canFinish(peachCounts, h, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    // 输出最小吃桃速度\n    cout << left << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n// 判断以速度k是否能在h小时内吃完所有桃子\nint can_finish(int* p, int n, int h, int k) {\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans += (int)ceil((double)p[i] / k);\n    }\n    return ans <= h;\n}\n\nint main() {\n \n    char input[10000];\n    fgets(input, sizeof(input), stdin);\n\n    // 将输入分割并存入数组\n    int peach_counts[10000];  \n    int n = 0;\n\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        peach_counts[n++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n\n    int h;\n    scanf(\"%d\", &h);\n\n    // 输入验证\n    if (n == 0 || h <= 0 || n >= 10000 || h >= 10000 || n > h) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    // 二分查找最小吃桃速度\n    int left = 1, right = (int)1e9;\n    while (left < right) {\n        int mid = (left + right) / 2;\n        if (can_finish(peach_counts, n, h, mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    // 输出最小吃桃速度\n    printf(\"%d\\n\", left);\n\n    return 0;\n}"
  }
}