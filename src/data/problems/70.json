{
  "id": "70",
  "title": "完美走位",
  "examType": "A",
  "score": 100,
  "description": "在第一人称射击游戏中，玩家通过键盘的A、S、D、W四个按键控制游戏人物分别向左、向后、向右、向前进行移动，从而完成走位。\n假设玩家每按动一次键盘，游戏任务会向某个方向移动一步，如果玩家在操作一定次数的键盘并且各个方向的步数相同时，此时游戏任务必定会回到原点，则称此次走位为完美走位。\n现给定玩家的走位（例如：ASDA），请通过更换其中一段连续走位的方式使得原走位能够变成一个完美走位。其中待更换的连续走位可以是相同长度的任何走位。\n请返回待更换的连续走位的最小可能长度。\n如果原走位本身是一个完美走位，则返回0。\n",
  "inputDesc": "输入为由键盘字母表示的走位s，例如：ASDA\n",
  "outputDesc": "输出为待更换的连续走位的最小可能长度。",
  "examples": [
    {
      "input": "WASD",
      "output": "0",
      "explanation": "W、A、S、D各1个，已经平衡，无需替换。"
    },
    {
      "input": "WWWWAAAASSSS",
      "output": "6",
      "explanation": "需要各3个，W、A、S各超1个。最短替换子串是WAAAAS（6个字符）替换为DDD。"
    },
    {
      "input": "WWAA",
      "output": "2",
      "explanation": "需要各1个，W和A各超1个。替换WA为SD即可，最短长度2。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**滑动窗口**问题，类似最小覆盖子串。\n\n**算法步骤：**\n1. 统计W、A、S、D各字母数量\n2. 计算平衡状态每个字母应有的数量avg=len/4\n3. 统计超出avg的字母及超出数量\n4. 用滑动窗口找包含所有超出字母的最短子串\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.next()));\n  }\n\n  public static int getResult(String str) {\n    // count用于记录W,A,S,D字母的数量\n    HashMap<Character, Integer> count = new HashMap<>();\n\n    for (int i = 0; i < str.length(); i++) {\n      Character c = str.charAt(i);\n      count.put(c, count.getOrDefault(c, 0) + 1);\n    }\n\n    // 平衡状态时，W,A,S,D应该都是avg数量\n    int avg = str.length() / 4;\n\n    // total用于记录多余字母个数\n    int total = 0;\n\n    // flag表示当前是否为平衡状态，默认是\n    boolean flag = true;\n\n    for (Character c : count.keySet()) {\n      if (count.get(c) > avg) {\n        // 如果有一个字母数量超标，则平衡打破\n        flag = false;\n        // 此时count记录每个字母超过avg的数量\n        count.put(c, count.get(c) - avg);\n        total += count.get(c);\n      } else {\n        count.put(c, 0); // 此时count统计的其实是多余字母，如果没有超过avg,则表示没有多余字母\n      }\n    }\n\n    // 如果平衡，则输出0\n    if (flag) return 0;\n\n    int i = 0;\n    int j = 0;\n    int minLen = str.length() + 1;\n\n    while (j < str.length()) {\n      Character jc = str.charAt(j);\n\n      if (count.get(jc) > 0) {\n        total--;\n      }\n      count.put(jc, count.get(jc) - 1);\n\n      while (total == 0) {\n        minLen = Math.min(minLen, j - i + 1);\n\n        Character ic = str.charAt(i);\n        if (count.get(ic) >= 0) {\n          total++;\n        }\n        count.put(ic, count.get(ic) + 1);\n\n        i++;\n      }\n      j++;\n    }\n    return minLen;\n  }\n}",
    "python": "# 输入获取\ns = input()\n\n\n# 算法入口\ndef getResult(s):\n    # 此时count记录统计W,A,S,D字母的数量\n    count = {\n        \"W\": 0,\n        \"A\": 0,\n        \"S\": 0,\n        \"D\": 0\n    }\n\n    for c in s:\n        count[c] += 1\n\n    avg = len(s) / 4  # 平衡状态时，W,A,S,D应该都是avg数量\n    total = 0  # total用于记录多余字母个数\n    flag = True  # flag表示当前是否为平衡状态，默认是\n\n    for c in count.keys():\n        if count[c] > avg:\n            flag = False  # 如果有一个字母数量超标，则平衡打破\n            count[c] -= avg  # 此时count记录每个字母超过avg的数量\n            total += count[c]\n        else:\n            count[c] = 0\n\n    if flag:\n        return 0  # 如果平衡，则输出0\n\n    i = 0\n    j = 0\n    minLen = len(s) - 1\n\n    while j < len(s):\n        jc = s[j]\n\n        if count[jc] > 0:\n            total -= 1\n        count[jc] -= 1\n\n        while total == 0:\n            minLen = min(minLen, j - i + 1)\n\n            ic = s[i]\n            if count[ic] >= 0:\n                total += 1\n            count[ic] += 1\n\n            i += 1\n\n        j += 1\n\n    return minLen\n\n\nprint(getResult(s))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  console.log(getResult(line));\n});\n\nfunction getResult(str) {\n  // 此时count记录统计W,A,S,D字母的数量\n  const count = {\n    W: 0,\n    A: 0,\n    S: 0,\n    D: 0,\n  };\n\n  for (let c of str) count[c]++;\n\n  // 平衡状态时，W,A,S,D应该都是avg数量\n  const avg = str.length / 4;\n\n  let total = 0; // total用于记录多余字母个数\n\n  let flag = true; // flag表示当前是否为平衡状态，默认是\n  for (let c in count) {\n    if (count[c] > avg) {\n      flag = false; // 如果有一个字母数量超标，则平衡打破\n      count[c] -= avg; // 此时count记录每个字母超过avg的数量\n      total += count[c];\n    } else {\n      delete count[c];\n    }\n  }\n\n  if (flag) return 0; // 如果平衡，则输出0\n\n  let i = 0;\n  let j = 0;\n  let minLen = str.length + 1;\n\n  while (j < str.length) {\n    const jc = str[j];\n\n    if (count[jc]-- > 0) {\n      total--;\n    }\n\n    while (total === 0) {\n      minLen = Math.min(minLen, j - i + 1);\n\n      const ic = str[i];\n      if (count[ic]++ >= 0) {\n        total++;\n      }\n\n      i++;\n    }\n\n    j++;\n  }\n\n  return minLen;\n}",
    "cpp": "#include <iostream>\n#include <string>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string s;\n    cin >> s;\n    \n    map<char, int> count;\n    count['W'] = count['A'] = count['S'] = count['D'] = 0;\n    \n    for (char c : s) count[c]++;\n    \n    int avg = s.length() / 4;\n    int total = 0;\n    bool flag = true;\n    \n    for (auto& p : count) {\n        if (p.second > avg) {\n            flag = false;\n            p.second -= avg;\n            total += p.second;\n        } else {\n            p.second = 0;\n        }\n    }\n    \n    if (flag) {\n        cout << 0 << endl;\n        return 0;\n    }\n    \n    int i = 0, j = 0;\n    int minLen = s.length() + 1;\n    \n    while (j < s.length()) {\n        if (count[s[j]]-- > 0) total--;\n        \n        while (total == 0) {\n            minLen = min(minLen, j - i + 1);\n            if (count[s[i]]++ >= 0) total++;\n            i++;\n        }\n        j++;\n    }\n    \n    cout << minLen << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char s[100001];\n    scanf(\"%s\", s);\n    int len = strlen(s);\n    \n    int count[128] = {0};\n    for (int i = 0; i < len; i++) count[(int)s[i]]++;\n    \n    int avg = len / 4;\n    int total = 0;\n    int flag = 1;\n    \n    char keys[] = \"WASD\";\n    for (int i = 0; i < 4; i++) {\n        char c = keys[i];\n        if (count[(int)c] > avg) {\n            flag = 0;\n            count[(int)c] -= avg;\n            total += count[(int)c];\n        } else {\n            count[(int)c] = 0;\n        }\n    }\n    \n    if (flag) {\n        printf(\"0\\n\");\n        return 0;\n    }\n    \n    int i = 0, j = 0;\n    int minLen = len + 1;\n    \n    while (j < len) {\n        if (count[(int)s[j]]-- > 0) total--;\n        \n        while (total == 0) {\n            if (j - i + 1 < minLen) minLen = j - i + 1;\n            if (count[(int)s[i]]++ >= 0) total++;\n            i++;\n        }\n        j++;\n    }\n    \n    printf(\"%d\\n\", minLen);\n    return 0;\n}"
  }
}