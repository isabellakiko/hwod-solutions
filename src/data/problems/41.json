{
  "id": "41",
  "title": "热点网站统计",
  "examType": "A",
  "score": 100,
  "description": "企业路由器的统计页面，有一个功能需要动态统计公司访问最多的网页URL top N。请设计一个算法，可以高效动态统计Top N的页面。",
  "inputDesc": "每一行都是一个URL或一个数字，如果是URL，代表一段时间内的网页访问； 如果是一个数字N，代表本次需要输出的Top N个URL。\n输入约束：\n1、总访问网页数量小于5000个，单网页访问次数小于65535次； 2、网页URL仅由字母，数字和点分隔符组成，且长度小于等于127字节； 3、数字是正整数，小于等于10且小于当前总访问网页数；",
  "outputDesc": "行输入要对应一行输出，输出按访问次数排序的前N个URL，用逗号分隔。\n输出要求：\n1、每次输出要统计之前所有输入，不仅是本次输入； 2、如果有访问次数相等的URL，按URL的字符串字典序升序排列，输出排序靠前的URL；",
  "examples": [
    {
      "input": "news.qq.com\nnews.sina.com.cn\nnews.qq.com\nnews.qq.com\ngame.163.com\ngame.163.com\n3\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com\nwww.cctv.com\nwww.huawei.com\n3",
      "output": "news.qq.com,game.163.com,news.sina.com.cn\nwww.huawei.com,www.cctv.com,news.qq.com",
      "explanation": "第一次查询Top3时：news.qq.com(3次)、game.163.com(2次)、news.sina.com.cn(1次)。\n第二次查询Top3时：www.huawei.com(7次)、www.cctv.com(5次)、news.qq.com(3次)。"
    },
    {
      "input": "news.qq.com\n1\nwww.cctv.com\nwww.huawei.com\nwww.huawei.com\n2\n3",
      "output": "news.qq.com\nwww.huawei.com,news.qq.com\nwww.huawei.com,news.qq.com,www.cctv.com",
      "explanation": "第一次查询Top1：news.qq.com(1次)。\n第二次查询Top2：www.huawei.com(2次)、news.qq.com(1次)。\n第三次查询Top3：www.huawei.com(2次)、news.qq.com(1次)、www.cctv.com(1次)，后两者次数相同按字典序。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**哈希表+排序**问题。\n\n**核心思想：**\n- 用哈希表统计每个URL的访问次数\n- 遇到数字N时，对所有URL排序后输出Top N\n\n**算法步骤：**\n\n1. 逐行读取输入\n2. 如果是URL，更新哈希表中该URL的计数\n3. 如果是数字N：\n   - 将哈希表转为列表\n   - 按访问次数降序排序，次数相同按字典序升序\n   - 输出前N个URL\n4. 注意：统计是累积的，包含之前所有输入\n\n**时间复杂度**：每次查询O(m log m)，m为不同URL数量",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<String> lines = new ArrayList<>(); // 创建一个字符串列表，用于存储输入的每一行数据\n        Map<String, Integer> cache = new HashMap<>(); // 创建一个哈希表，用于存储每个 URL 出现的次数\n        while (scanner.hasNext()) { // 不断读取输入，直到没有下一行\n            String line = scanner.nextLine(); // 读取一行数据\n            lines.add(line); // 将该行数据添加到字符串列表中\n            if (line.matches(\"^\\\\d+$\")) { // 如果该行数据只包含数字，说明已经读取完了一个测试用例\n                System.out.println(sortURL(lines, cache)); // 调用 sortURL 方法进行处理，并输出结果\n                lines.clear(); // 清空字符串列表，为下一个测试用例做准备\n            }\n        }\n    }\n\n    public static String sortURL(List<String> lines, Map<String, Integer> cache) {\n        int n = Integer.parseInt(lines.remove(lines.size() - 1)); // 从字符串列表中取出最后一个元素，即需要输出的 URL 数量\n        for (String url : lines) { // 遍历字符串列表中的每一个 URL\n            cache.put(url, cache.getOrDefault(url, 0) + 1); // 将该 URL 在哈希表中的计数加一\n        }\n        List<Map.Entry<String, Integer>> list = new ArrayList<>(cache.entrySet()); // 将哈希表中的每一项转换成一个键值对，并存入一个列表中\n        list.sort((a, b) -> { // 对列表进行排序，按照计数从大到小排序，如果计数相同则按照字典序从小到大排序\n            int res = b.getValue() - a.getValue();\n            return res == 0 ? a.getKey().compareTo(b.getKey()) : res;\n        });\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n && i < list.size(); i++) { // 取出前 n 个 URL，并将它们拼接成一个字符串\n            sb.append(list.get(i).getKey()).append(\",\");\n        }\n        if (sb.length() > 0) { // 如果字符串不为空，则删除最后一个逗号\n            sb.deleteCharAt(sb.length() - 1);\n        }\n        return sb.toString(); // 返回拼接好的字符串\n    }\n}",
    "python": "import sys\ndef sortURL(lines, cache):\n    n = int(lines.pop())\n \n    for url in lines:\n        cache[url] = cache.get(url, 0) + 1\n \n    arr = []\n    for key in cache:\n        arr.append({\n            \"count\": cache[key],\n            \"url\": key\n        })\n \n    return \",\".join([ele[\"url\"] for ele in sorted(arr, key=lambda x: (-x[\"count\"], x[\"url\"]))[:n]]) \nlines = []\ncache = {}\nfor line in sys.stdin:\n    lines.append(line.strip())\n \n    if line.strip().isdigit():\n        print(sortURL(lines, cache))\n        lines = []",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst lines = [];\nconst cache = {};\n\nrl.on('line', (line) => {\n  lines.push(line);\n\n  if (/^\\d+$/.test(line)) {\n    console.log(sortURL(lines, cache));\n    lines.length = 0;\n  }\n});\n\nfunction sortURL(lines, cache) {\n  const n = parseInt(lines.pop());\n  for (const url of lines) {\n    cache[url] = (cache[url] || 0) + 1;\n  }\n  const list = Object.entries(cache);\n  list.sort((a, b) => {\n    const res = b[1] - a[1];\n    return res === 0 ? a[0].localeCompare(b[0]) : res;\n  });\n  let sb = '';\n  for (let i = 0; i < n && i < list.length; i++) {\n    sb += list[i][0] + ',';\n  }\n  if (sb.length > 0) {\n    sb = sb.slice(0, -1);\n  }\n  return sb;\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <regex>\n\nusing namespace std;\n\nstring sortURL(vector<string>& lines, map<string, int>& cache);\n\nint main() {\n    vector<string> lines; // 创建一个字符串列表，用于存储输入的每一行数据\n    map<string, int> cache; // 创建一个哈希表，用于存储每个 URL 出现的次数\n    string line;\n    while (getline(cin, line)) { // 不断读取输入，直到没有下一行\n        lines.push_back(line); // 将该行数据添加到字符串列表中\n        if (regex_match(line, regex(\"^\\\\d+$\"))) { // 如果该行数据只包含数字，说明已经读取完了一个测试用例\n            cout << sortURL(lines, cache) << endl; // 调用 sortURL 方法进行处理，并输出结果\n            lines.clear(); // 清空字符串列表，为下一个测试用例做准备\n        }\n    }\n    return 0;\n}\n\nstring sortURL(vector<string>& lines, map<string, int>& cache) {\n    int n = stoi(lines.back()); // 从字符串列表中取出最后一个元素，即需要输出的 URL 数量\n    lines.pop_back(); // 删除最后一个元素\n    for (string url : lines) { // 遍历字符串列表中的每一个 URL\n        cache[url]++; // 将该 URL 在哈希表中的计数加一\n    }\n    vector<pair<string, int>> list(cache.begin(), cache.end()); // 将哈希表中的每一项转换成一个键值对，并存入一个列表中\n    sort(list.begin(), list.end(), [](const pair<string, int>& a, const pair<string, int>& b) { // 对列表进行排序，按照计数从大到小排序，如果计数相同则按照字典序从小到大排序\n        if (a.second != b.second) {\n            return a.second > b.second;\n        } else {\n            return a.first < b.first;\n        }\n    });\n    string res;\n    for (int i = 0; i < n && i < list.size(); i++) { // 取出前 n 个 URL，并将它们拼接成一个字符串\n        res += list[i].first + \",\";\n    }\n    if (!res.empty()) { // 如果字符串不为空，则删除最后一个逗号\n        res.pop_back();\n    }\n    return res; // 返回拼接好的字符串\n}",
    "c": "#include <stdio.h>   // 包含标准输入输出库，用于使用 printf 和 fgets\n#include <stdlib.h>  // 包含标准库，用于使用 atoi 和 qsort\n#include <string.h>  // 包含字符串处理库，用于使用 strcmp 和 strcpy\n#include <ctype.h>   // 包含字符处理库，用于使用 isdigit\n\n// 定义常量，最大 URL 长度为 128，最大 URL 记录数量为 5000\n#define MAX_URL_LENGTH 128\n#define MAX_URL_COUNT 5000\n\n// 定义结构体，用于存储 URL 和该 URL 的访问计数\ntypedef struct {\n    char url[MAX_URL_LENGTH]; // URL 字符串，最大长度为 128\n    int count; // 该 URL 被访问的次数\n} UrlCount;\n\n// 自定义比较函数，用于 qsort 函数排序\n// 按照 URL 访问次数从大到小排序，如果访问次数相同则按照字典序从小到大排序\nint urlCompare(const void *a, const void *b) {\n    UrlCount *url1 = (UrlCount *)a; // 将 void 指针转换为 UrlCount 指针\n    UrlCount *url2 = (UrlCount *)b;\n    \n    // 如果两个 URL 的访问次数不相等，按照访问次数从大到小排序\n    if (url1->count != url2->count) {\n        return url2->count - url1->count; // 返回负值表示 url2 应该排在 url1 前面\n    }\n    \n    // 如果访问次数相等，按照字典序排序\n    return strcmp(url1->url, url2->url); // strcmp 返回值：负值表示 url1 小于 url2\n}\n\n// 排序并输出访问次数最多的 n 个 URL\nvoid sortURLs(UrlCount urls[], int size, int n) {\n    // 使用 qsort 对 URL 数组进行排序\n    qsort(urls, size, sizeof(UrlCount), urlCompare);\n    \n    // 输出前 n 个 URL，按照排序后的顺序\n    for (int i = 0; i < n && i < size; i++) {\n        printf(\"%s\", urls[i].url); // 输出当前 URL\n        // 如果还未输出到第 n 个 URL 或最后一个 URL，继续打印逗号分隔\n        if (i < n - 1 && i < size - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"\\n\"); // 输出完毕后换行\n}\n\nint main() {\n    UrlCount cache[MAX_URL_COUNT] = {0}; // 创建一个 URL 数组用于缓存，初始值为 0\n    int urlCount = 0; // 当前缓存的 URL 数量，初始为 0\n    char line[128]; // 用于存储每一行输入的字符串\n\n \n    while (fgets(line, sizeof(line), stdin)) {\n        line[strcspn(line, \"\\n\")] = 0; // 去掉字符串末尾的换行符\n        \n        // 判断输入行是否为数字（用于请求输出前 n 个 URL）\n        if (isdigit(line[0])) { // 如果首字符是数字，则认为该行是请求输出的数字\n            int n = atoi(line); // 将字符串转换为整数，表示请求输出的 URL 数量\n            sortURLs(cache, urlCount, n); // 调用排序并输出函数，输出前 n 个 URL\n        } else { // 否则认为该行是 URL\n            int found = 0; // 标志变量，记录当前 URL 是否已经存在\n            // 遍历当前已记录的 URL，检查是否已存在\n            for (int i = 0; i < urlCount; i++) {\n                if (strcmp(cache[i].url, line) == 0) { // 如果找到相同的 URL\n                    cache[i].count++; // 计数器加 1\n                    found = 1; // 标记为已找到\n                    break; // 跳出循环\n                }\n            }\n            // 如果未找到该 URL，说明是新 URL\n            if (!found) {\n                strcpy(cache[urlCount].url, line); // 将新的 URL 到缓存中\n                cache[urlCount].count = 1; // 初始化该 URL 的访问计数为 1\n                urlCount++; // 增加 URL 数量\n            }\n        }\n    }\n    return 0; // 程序结束\n}"
  }
}