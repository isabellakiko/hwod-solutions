{
  "id": "85",
  "title": "租车骑绿岛",
  "examType": "A",
  "score": 100,
  "description": "部门组织绿岛骑行团建活动。租用公共双人自行车，每辆自行车最多坐两人，最大载重M。 给出部门每个人的体重，请问最多需要租用多少双人自行车。\n",
  "inputDesc": "第一行两个数字m、n，分别代表自行车限重，部门总人数。\n第二行，n个数字，代表每个人的体重，体重都小于等于自行车限重m。\n0<m<=2000<n<=1000000\n",
  "outputDesc": "最小需要的双人自行车数量。",
  "examples": [
    {
      "input": "100 4\n30 40 50 60",
      "output": "2",
      "explanation": "排序后[30,40,50,60]，30+60=90≤100可配对，40+50=90≤100可配对，需2辆车。"
    },
    {
      "input": "100 3\n80 50 60",
      "output": "2",
      "explanation": "排序后[50,60,80]，50+80=130>100不能配对，80单独1辆；50+60=110>100也不能配对，各1辆。共2辆。"
    },
    {
      "input": "200 5\n100 100 100 100 100",
      "output": "3",
      "explanation": "每两人100+100=200刚好，2对用2辆，剩1人1辆，共3辆。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心+双指针**问题。\n\n**算法步骤：**\n1. 将所有人体重升序排序\n2. 双指针i指向最轻，j指向最重\n3. 若arr[i]+arr[j]≤m，两人共享一辆车，i++,j--\n4. 若超重，重的人单独一辆车，j--\n5. 若i==j，剩一人单独一辆车\n\n**时间复杂度**：O(N log N)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n\n    int[] arr = new int[n];\n    for (int i = 0; i < n; i++) {\n      arr[i] = sc.nextInt();\n    }\n\n    System.out.println(getResult(arr, m));\n  }\n\n  public static int getResult(int[] arr, int m) {\n    Arrays.sort(arr);\n\n    int count = 0;\n\n    int i = 0;\n    int j = arr.length - 1;\n\n    while (i < j) {\n      if (arr[i] + arr[j] <= m) i++;\n      j--;\n      count++;\n    }\n\n    if (i == j) count++;\n\n    return count;\n  }\n}",
    "python": "# 输入获取\nm, n = map(int, input().split())\narr = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult(arr, m, n):\n    arr.sort()\n\n    count = 0\n\n    i = 0\n    j = n - 1\n\n    while i < j:\n        if arr[i] + arr[j] <= m:\n            i += 1\n        j -= 1\n        count += 1\n\n    if i == j:\n        count += 1\n\n    return count\n\n\n# 算法调用\nprint(getResult(arr, m, n))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const [m, n] = lines[0].split(\" \").map(Number);\n    const arr = lines[1].split(\" \").map(Number);\n\n    console.log(getResult(arr, m, n));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(arr, m, n) {\n  arr.sort((a, b) => a - b);\n\n  let count = 0;\n\n  // while (arr.at(-1) >= m) {\n  //   count++;\n  //   arr.pop();\n  // }\n\n  let i = 0;\n  let j = arr.length - 1;\n\n  while (i < j) {\n    if (arr[i] + arr[j] <= m) i++;\n    j--;\n    count++;\n  }\n\n  if (i === j) count++;\n\n  return count;\n}",
    "cpp": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    \n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n    }\n    \n    sort(arr, arr + n);\n    \n    int count = 0;\n    int i = 0, j = n - 1;\n    \n    while (i < j) {\n        if (arr[i] + arr[j] <= m) i++;\n        j--;\n        count++;\n    }\n    \n    if (i == j) count++;\n    \n    cout << count << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint cmp(const void* a, const void* b) {\n    return *(int*)a - *(int*)b;\n}\n\nint main() {\n    int m, n;\n    scanf(\"%d %d\", &m, &n);\n    \n    int arr[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n    \n    qsort(arr, n, sizeof(int), cmp);\n    \n    int count = 0;\n    int i = 0, j = n - 1;\n    \n    while (i < j) {\n        if (arr[i] + arr[j] <= m) i++;\n        j--;\n        count++;\n    }\n    \n    if (i == j) count++;\n    \n    printf(\"%d\\n\", count);\n    return 0;\n}"
  }
}