{
  "id": "116",
  "title": "九宫格按键输入",
  "examType": "A",
  "score": 200,
  "description": "九宫格按键输入，输出显示内容，有英文和数字两个模式，默认是数字模式，数字模式直接输出数字，英文模式连续按同一个按键会依次出现这个按键上的字母，如果输入”/”或者其他字符，则循环中断。\n字符对应关系如图：\n\n要求输入一串按键，输出屏幕显示。\n#用于切换模式，默认是数字模式，执行#后切换为英文模式；/表示延迟，例如在英文模式下，输入 22/222，显示为 bc；英文模式下，多次按同一键，例如输入 22222，显示为 b；",
  "inputDesc": "输入范围为数字 0~9 和字符’#’、’/’，输出屏幕显示，例如，\n在数字模式下，输入 1234，显示 1234 在英文模式下，输入 1234，显示,adg\n在数字模式下，输入 1234，显示 1234\n在英文模式下，输入 1234，显示,adg",
  "outputDesc": "#用于切换模式，默认是数字模式，执行#后切换为英文模式；\n/表示延迟，例如在英文模式下，输入 22/222，显示为 bc；\n英文模式下，多次按同一键，例如输入 22222，显示为 b；",
  "examples": [
    {
      "input": "123",
      "output": "123",
      "explanation": "默认数字模式，直接输出数字"
    },
    {
      "input": "#2222/22",
      "output": "ab",
      "explanation": "#进入英文模式，2222循环取余得a，/分隔后22得b"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟+状态机**问题。\n\n**核心思路：**\n- 维护当前模式（数字/英文）\n- 数字模式直接输出数字\n- 英文模式统计连续相同数字，取余映射字母\n\n**按键映射：**\n- 2→abc, 3→def, 4→ghi, 5→jkl\n- 6→mno, 7→pqrs, 8→tuv, 9→wxyz\n\n**特殊字符：**\n- #：切换模式\n- /：分隔连续输入\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String input_str = reader.readLine();\n\n        // 九宫格枚举信息\n        Map<Character, String> char_map = new HashMap<>();\n        char_map.put('0', \" \");\n        char_map.put('1', \",.\");\n        char_map.put('2', \"abc\");\n        char_map.put('3', \"def\");\n        char_map.put('4', \"ghi\");\n        char_map.put('5', \"jkl\");\n        char_map.put('6', \"mno\");\n        char_map.put('7', \"pqrs\");\n        char_map.put('8', \"tuv\");\n        char_map.put('9', \"wxyz\");\n\n        StringBuilder res = new StringBuilder();\n        // 默认是数字模式\n        int mode = 0;\n\n        for (int i = 0; i < input_str.length(); i++) {\n            char c = input_str.charAt(i);\n            if (Character.isDigit(c)) { // 如果是数字\n                if (mode == 0) { // 如果是数字模式，直接加入结果\n                    res.append(c);\n                } else if (mode == 1) { // 如果是字母模式\n                    int j = i;\n                    String tempstr = char_map.get(c);\n                    while (j < input_str.length() && input_str.charAt(j) == c) { // 统计连续出现的数字个数\n                        j++;\n                    }\n                    int index = (j - i - 1) % tempstr.length(); // 计算对应的字母下标\n                    res.append(tempstr.charAt(index)); // 加入结果\n                    i = j - 1; // 跳过已经处理的数字\n                }\n            } else if (c == '#') { // 如果是切换模式符号\n                mode = (mode + 1) % 2; // 切换模式\n            } else if (c == '/') { // 如果是延迟符号，不做处理\n                // 延迟，不做处理\n            } else { // 如果是其他字符，直接退出循环\n                break;\n            }\n        }\n        System.out.println(res.toString()); // 输出结果\n    }\n}",
    "python": "input_str = input().strip()\n\n# 九宫格枚举信息\nchar_map = {\n    '0': ' ',\n    '1': ',.',\n    '2': 'abc',\n    '3': 'def',\n    '4': 'ghi',\n    '5': 'jkl',\n    '6': 'mno',\n    '7': 'pqrs',\n    '8': 'tuv',\n    '9': 'wxyz'\n}\n\nres = \"\"\n# 默认是数字模式\nmode = 0\n\ni = 0\nwhile i < len(input_str):\n    c = input_str[i]\n    if c.isdigit():  # 如果是数字\n        if mode == 0:  # 如果是数字模式，直接加入结果\n            res += c\n        elif mode == 1:  # 如果是字母模式\n            j = i\n            tempstr = char_map[c]\n            while j < len(input_str) and input_str[j] == c:  # 统计连续出现的数字个数\n                j += 1\n            index = (j - i - 1) % len(tempstr)  # 计算对应的字母下标\n            res += tempstr[index]  # 加入结果\n            i = j - 1  # 跳过已经处理的数字\n    elif c == '#':  # 如果是切换模式符号\n        mode = (mode + 1) % 2  # 切换模式\n    elif c == '/':  # 如果是延迟符号，不做处理\n        pass\n    else:  # 如果是其他字符，直接退出循环\n        break\n    i += 1\n\nprint(res)  # 输出结果",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (input_str) => {\n  // 九宫格枚举信息\n  const char_map = new Map();\n  char_map.set('0', ' ');\n  char_map.set('1', ',.');\n  char_map.set('2', 'abc');\n  char_map.set('3', 'def');\n  char_map.set('4', 'ghi');\n  char_map.set('5', 'jkl');\n  char_map.set('6', 'mno');\n  char_map.set('7', 'pqrs');\n  char_map.set('8', 'tuv');\n  char_map.set('9', 'wxyz');\n\n  let res = '';\n  // 默认是数字模式\n  let mode = 0;\n\n  for (let i = 0; i < input_str.length; i++) {\n    const c = input_str.charAt(i);\n    if (/\\d/.test(c)) { // 如果是数字\n      if (mode === 0) { // 如果是数字模式，直接加入结果\n        res += c;\n      } else if (mode === 1) { // 如果是字母模式\n        let j = i;\n        const tempstr = char_map.get(c);\n        while (j < input_str.length && input_str.charAt(j) === c) { // 统计连续出现的数字个数\n          j++;\n        }\n        const index = (j - i - 1) % tempstr.length; // 计算对应的字母下标\n        res += tempstr.charAt(index); // 加入结果\n        i = j - 1; // 跳过已经处理的数字\n      }\n    } else if (c === '#') { // 如果是切换模式符号\n      mode = (mode + 1) % 2; // 切换模式\n    } else if (c === '/') { // 如果是延迟符号，不做处理\n      // 延迟，不做处理\n    } else { // 如果是其他字符，直接退出循环\n      break;\n    }\n  }\n  console.log(res); // 输出结果\n});",
    "cpp": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string.h>\n#include<map>\nusing namespace std;\n \nint main() {\n    string input_str;\n    cin >> input_str;\n    \n    // 九宫格枚举信息\n    map<char, string> char_map;\n    char_map['0'] = \" \";\n    char_map['1'] = \",.\";\n    char_map['2'] = \"abc\";\n    char_map['3'] = \"def\";\n    char_map['4'] = \"ghi\";\n    char_map['5'] = \"jkl\";\n    char_map['6'] = \"mno\";\n    char_map['7'] = \"pqrs\";\n    char_map['8'] = \"tuv\";\n    char_map['9'] = \"wxyz\";\n    \n    string res;\n    // 默认是数字模式\n    int mode = 0;\n    \n    for (int i = 0; i < input_str.size(); i++) {\n        char c = input_str[i];\n        if (isdigit(c)) { // 如果是数字\n            if (mode == 0) { // 如果是数字模式，直接加入结果\n                res.push_back(c);\n            } else if (mode == 1) { // 如果是字母模式\n                int j = i;\n                string tempstr = char_map[c];\n                while (j < input_str.size() && input_str[j] == c) { // 统计连续出现的数字个数\n                    j++;\n                }\n                int index = (j - i - 1) % tempstr.size(); // 计算对应的字母下标\n                res.push_back(tempstr[index]); // 加入结果\n                i = j - 1; // 跳过已经处理的数字\n            }\n        } else if (c == '#') { // 如果是切换模式符号\n            mode = (mode + 1) % 2; // 切换模式\n        } else if (c == '/') { // 如果是延迟符号，不做处理\n            // 延迟，不做处理\n        } else { // 如果是其他字符，直接退出循环\n            break;\n        }\n    }\n    cout << res << endl; // 输出结果\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n// 定义映射的结构体，用于存储数字与对应字符的映射\ntypedef struct {\n    char digit;\n    char *letters;\n} CharMap;\n\n// 主函数\nint main() {\n    char input_str[100];  // 定义输入字符串\n    scanf(\"%s\", input_str);  // 读取用户输入\n    \n    // 九宫格枚举信息，字符映射表\n    CharMap char_map[] = {\n        {'0', \" \"},\n        {'1', \",.\"},\n        {'2', \"abc\"},\n        {'3', \"def\"},\n        {'4', \"ghi\"},\n        {'5', \"jkl\"},\n        {'6', \"mno\"},\n        {'7', \"pqrs\"},\n        {'8', \"tuv\"},\n        {'9', \"wxyz\"}\n    };\n\n    char res[100];  // 存储结果字符串\n    int res_index = 0;  // 结果字符串的当前索引\n    int mode = 0;  // 模式，0表示数字模式，1表示字母模式\n    int input_len = strlen(input_str);  // 获取输入字符串的长度\n    \n    // 遍历输入的每个字符\n    for (int i = 0; i < input_len; i++) {\n        char c = input_str[i];  // 当前字符\n\n        // 判断当前字符是否为数字\n        if (isdigit(c)) {\n            if (mode == 0) {  // 数字模式，直接将字符加入结果\n                res[res_index++] = c;\n            } else if (mode == 1) {  // 字母模式\n                int j = i;\n                char *tempstr = NULL;  // 当前数字对应的字符集\n                for (int k = 0; k < 10; k++) {\n                    if (char_map[k].digit == c) {\n                        tempstr = char_map[k].letters;  // 获取该数字对应的字符集\n                        break;\n                    }\n                }\n                // 统计连续相同数字的个数\n                while (j < input_len && input_str[j] == c) {\n                    j++;\n                }\n                int index = (j - i - 1) % strlen(tempstr);  // 计算字母的索引\n                res[res_index++] = tempstr[index];  // 将对应的字母加入结果\n                i = j - 1;  // 跳过已经处理的字符\n            }\n        } else if (c == '#') {  // 切换模式符号\n            mode = (mode + 1) % 2;  // 切换模式\n        } else if (c == '/') {  // 延迟符号，不做处理\n            // 什么都不做，跳过该字符\n        } else {  // 非法字符，直接退出循环\n            break;\n        }\n    }\n    \n    res[res_index] = '\\0';  // 在结果字符串末尾加上结束符\n    printf(\"%s\\n\", res);  // 输出结果\n    \n    return 0;\n}"
  }
}