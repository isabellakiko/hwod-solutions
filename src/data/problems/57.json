{
  "id": "57",
  "title": "选修课",
  "examType": "A",
  "score": 100,
  "description": "现有两门选修课，每门选修课都有一部分学生选修，每个学生都有选修课的成绩，需要你找出同时选修了两门选修课的学生，先按照班级进行划分，班级编号小的先输出，每个班级按照两门选修课成绩和的降序排序，成绩相同时按照学生的学号升序排序。",
  "inputDesc": "第一行为第一门选修课学生的成绩，\n第二行为第二门选修课学生的成绩，每行数据中学生之间以英文分号分隔，每个学生的学号和成绩以英文逗号分隔，\n学生学号的格式为8位数字(2位院系编号+入学年份后2位+院系内部1位专业编号+所在班级3位学号)，\n学生成绩的取值范围为[0,100]之间的整数，\n两门选修课选修学生数的取值范围为[1-2000]之间的整数。",
  "outputDesc": "同时选修了两门选修课的学生的学号，如果没有同时选修两门选修课的学生输出NULL，\n否则，先按照班级划分，班级编号小的先输出，每个班级先输出班级编号(学号前五位)，然后另起一行输出这个班级同时选修两门选修课的学生学号，学号按照要求排序(按照两门选修课成绩和的降序，成绩和相同时按照学号升序)，学生之间以英文分号分隔。",
  "examples": [
    {
      "input": "01202008,75;01201033,95;01202021,80;01203006,90;01203088,100\n01202008,70;01203088,85;01202111,80;01202021,75;01201100,88",
      "output": "01202\n01202008;01202021\n01203\n01203088",
      "explanation": "同时选修两门课的学生：\n01202008: 75+70=145分\n01202021: 80+75=155分\n01203088: 100+85=185分\n\n按班级分组后：\n01202班：01202021(155)和01202008(145)，按成绩降序\n01203班：01203088(185)"
    },
    {
      "input": "01202033,75;01202018,95;01203006,80;01202066,100\n01203102,70;01202111,85;01201021,80;01201100,88",
      "output": "NULL",
      "explanation": "两门课没有共同的学生，输出NULL。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**字符串解析+分组排序**问题。\n\n**算法步骤：**\n\n1. 解析两行输入，提取学号和成绩\n2. 用HashMap存储学生信息，找出同时选两门课的学生\n3. 按班级(学号前5位)分组\n4. 每组内按成绩和降序、学号升序排列\n5. 按班级编号升序输出各组\n\n**学号格式**：8位数字\n- 前2位：院系编号\n- 第3-4位：入学年份\n- 第5位：专业编号\n- 第6-8位：班级学号\n\n**时间复杂度**：O(N log N)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n    static class Student {\n        String studentId; // 学生学号\n        String classId; // 班级编号\n        int score1 = -1; // 第一门选修课成绩\n        int score2 = -1; // 第二门选修课成绩\n\n        public int getSumScore() { // 计算两门选修课成绩和\n            return this.score1 + this.score2;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String scores1 = sc.nextLine(); // 第一门选修课学生的成绩\n        String scores2 = sc.nextLine(); // 第二门选修课学生的成绩\n        HashMap<String, Student> students = new HashMap<>(); // 存储学生信息的HashMap\n        divide(scores1, 1, students); // 将第一门选修课学生成绩划分到HashMap中\n        divide(scores2, 2, students); // 将第二门选修课学生成绩划分到HashMap中\n        Student[] selectedStudents = students.values().stream().filter(stu -> stu.score1 != -1 && stu.score2 != -1)\n                .toArray(Student[]::new); // 选取同时选修了两门选修课的学生\n        if (selectedStudents.length == 0) {\n            System.out.println(\"NULL\"); // 如果没有同时选修两门选修课的学生，则输出NULL\n            return;\n        }\n        HashMap<String, ArrayList<Student>> ans = new HashMap<>(); // 存储按班级划分的学生信息的HashMap\n        for (Student stu : selectedStudents) {\n            ans.putIfAbsent(stu.classId, new ArrayList<>()); // 如果班级还没有被加入HashMap中，则加入\n            ans.get(stu.classId).add(stu); // 将学生加入对应班级的ArrayList中\n        }\n        ans.keySet().stream().sorted(String::compareTo).forEach(classId -> {\n            System.out.println(classId); // 先输出班级编号\n            ArrayList<Student> studentsInClass = ans.get(classId);\n            studentsInClass.sort((a, b) -> a.getSumScore() != b.getSumScore() ? b.getSumScore() - a.getSumScore()\n                    : a.studentId.compareTo(b.studentId)); // 按照成绩和的降序和学号的升序排序\n            StringJoiner sj = new StringJoiner(\";\"); // 用于拼接学生学号的StringJoiner\n            for (Student student : studentsInClass)\n                sj.add(student.studentId); // 将学生学号加入StringJoiner中\n            System.out.println(sj); // 输出学生学号\n        });\n    }\n\n    public static void divide(String str, int courseId, HashMap<String, Student> students) {\n        for (String sub : str.split(\";\")) {\n            String[] tmp = sub.split(\",\");\n            String studentId = tmp[0]; // 学生学号\n            String classId = studentId.substring(0, 5); // 班级编号\n            int score = Integer.parseInt(tmp[1]); // 选修课成绩\n            students.putIfAbsent(studentId, new Student()); // 如果学生还没有被加入HashMap中，则加入\n            Student stu = students.get(studentId);\n            stu.studentId = studentId;\n            stu.classId = classId;\n            if (courseId == 1)\n                stu.score1 = score; // 将第一门选修课成绩加入学生对象中\n            else\n                stu.score2 = score; // 将第二门选修课成绩加入学生对象中\n        }\n    }\n}",
    "python": "class Student:\n    def __init__(self):\n        self.studentId = \"\"  # 学生学号\n        self.classId = \"\"  # 班级编号\n        self.score1 = -1  # 第一门选修课成绩\n        self.score2 = -1  # 第二门选修课成绩\n\n    def getSumScore(self):  # 计算两门选修课成绩和\n        return self.score1 + self.score2\n\n\ndef divide(str, courseId, students):\n    for sub in str.split(\";\"):\n        tmp = sub.split(\",\")\n        studentId = tmp[0]  # 学生学号\n        classId = studentId[:5]  # 班级编号\n        score = int(tmp[1])  # 选修课成绩\n        if studentId not in students:\n            students[studentId] = Student()  # 如果学生还没有被加入HashMap中，则加入\n        stu = students[studentId]\n        stu.studentId = studentId\n        stu.classId = classId\n        if courseId == 1:\n            stu.score1 = score  # 将第一门选修课成绩加入学生对象中\n        else:\n            stu.score2 = score  # 将第二门选修课成绩加入学生对象中\n\n\nscores1 = input()  # 第一门选修课学生的成绩\nscores2 = input()  # 第二门选修课学生的成绩\nstudents = {}  # 存储学生信息的字典\ndivide(scores1, 1, students)  # 将第一门选修课学生成绩划分到字典中\ndivide(scores2, 2, students)  # 将第二门选修课学生成绩划分到字典中\nselectedStudents = [stu for stu in students.values() if stu.score1 != -1 and stu.score2 != -1]  # 选取同时选修了两门选修课的学生\nif len(selectedStudents) == 0:\n    print(\"NULL\")  # 如果没有同时选修两门选修课的学生，则输出NULL\nelse:\n    ans = {}  # 存储按班级划分的学生信息的字典\n    for stu in selectedStudents:\n        if stu.classId not in ans:\n            ans[stu.classId] = []  # 如果班级还没有被加入字典中，则加入\n        ans[stu.classId].append(stu)  # 将学生加入对应班级的列表中\n    for classId in sorted(ans.keys()):\n        print(classId)  # 先输出班级编号\n        studentsInClass = ans[classId]\n        studentsInClass.sort(key=lambda stu: (-stu.getSumScore(), stu.studentId))  # 按照成绩和的降序和学号的升序排序\n        studentIds = [stu.studentId for stu in studentsInClass]  # 学生学号列表\n        print(\";\".join(studentIds))  # 输出学生学号",
    "javascript": "const readline = require('readline');\n\nclass Student {\n  constructor() {\n    this.studentId = \"\"; // 学生学号\n    this.classId = \"\"; // 班级编号\n    this.score1 = -1; // 第一门选修课成绩\n    this.score2 = -1; // 第二门选修课成绩\n  }\n\n  getSumScore() { // 计算两门选修课成绩和\n    return this.score1 + this.score2;\n  }\n}\n\nfunction divide(str, courseId, students) {\n  for (let sub of str.split(\";\")) {\n    let tmp = sub.split(\",\");\n    let studentId = tmp[0]; // 学生学号\n    let classId = studentId.slice(0, 5); // 班级编号\n    let score = parseInt(tmp[1]); // 选修课成绩\n    if (!(studentId in students)) {\n      students[studentId] = new Student(); // 如果学生还没有被加入HashMap中，则加入\n    }\n    let stu = students[studentId];\n    stu.studentId = studentId;\n    stu.classId = classId;\n    if (courseId === 1) {\n      stu.score1 = score; // 将第一门选修课成绩加入学生对象中\n    } else {\n      stu.score2 = score; // 将第二门选修课成绩加入学生对象中\n    }\n  }\n}\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (scores1) => {\n  rl.on('line', (scores2) => {\n    let students = {}; // 存储学生信息的字典\n    divide(scores1, 1, students); // 将第一门选修课学生成绩划分到字典中\n    divide(scores2, 2, students); // 将第二门选修课学生成绩划分到字典中\n    let selectedStudents = Object.values(students).filter(stu => stu.score1 !== -1 && stu.score2 !== -1); // 选取同时选修了两门选修课的学生\n    if (selectedStudents.length === 0) {\n      console.log(\"NULL\"); // 如果没有同时选修两门选修课的学生，则输出NULL\n    } else {\n      let ans = {}; // 存储按班级划分的学生信息的字典\n      for (let stu of selectedStudents) {\n        if (!(stu.classId in ans)) {\n          ans[stu.classId] = []; // 如果班级还没有被加入字典中，则加入\n        }\n        ans[stu.classId].push(stu); // 将学生加入对应班级的列表中\n      }\n      for (let classId of Object.keys(ans).sort()) {\n        console.log(classId); // 先输出班级编号\n        let studentsInClass = ans[classId];\n        studentsInClass.sort((a, b) => (b.getSumScore() - a.getSumScore()) || (a.studentId.localeCompare(b.studentId))); // 按照成绩和的降序和学号的升序排序\n        let studentIds = studentsInClass.map(stu => stu.studentId); // 学生学号列表\n        console.log(studentIds.join(\";\")); // 输出学生学号\n      }\n    }\n    rl.close();\n  });\n});",
    "cpp": "#include <iostream>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct Student {\n    string id;\n    int score;\n    Student(const string& id, int score) : id(id), score(score) {}\n    bool operator<(const Student& other) const {\n        return score != other.score ? score > other.score : id < other.id;\n    }\n};\n\nint main() {\n    string line_one, line_two;\n    getline(cin, line_one);\n    getline(cin, line_two);\n\n    map<string, int> tIds;\n    stringstream ss(line_two);\n    string token;\n    while (getline(ss, token, ';')) {\n        vector<string> tStu;\n        stringstream ss2(token);\n        while (getline(ss2, token, ',')) {\n            tStu.push_back(token);\n        }\n        tIds[tStu[0]] = stoi(tStu[1]);\n    }\n\n    map<string, set<Student>> map;\n    stringstream ss3(line_one);\n    while (getline(ss3, token, ';')) {\n        vector<string> sStu;\n        stringstream ss4(token);\n        while (getline(ss4, token, ',')) {\n            sStu.push_back(token);\n        }\n        const string& sId = sStu[0];\n        if (tIds.count(sId)) {\n            const int totalScore = stoi(sStu[1]) + tIds[sId];\n            const string cls = sId.substr(0, 5);\n            map[cls].emplace(sId, totalScore);\n        }\n    }\n\n    if (map.empty()) {\n        cout << \"NULL\\n\";\n    } else {\n        for (const auto& [key, value] : map) {\n            cout << key << \"\\n\";\n            string res;\n            for (const auto& student : value) {\n                res += student.id + \";\";\n            }\n            res.pop_back(); \n            cout << res << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_STUDENTS 2000\n#define ID_LEN 10\n#define CLASS_ID_LEN 6\n\n// 学生结构体，包含学生学号、班级编号、两门选修课的成绩\ntypedef struct {\n    char studentId[ID_LEN]; // 学生学号\n    char classId[CLASS_ID_LEN]; // 班级编号\n    int score1; // 第一门选修课成绩\n    int score2; // 第二门选修课成绩\n} Student;\n\n// 用于存储学生信息的全局数组\nStudent students[MAX_STUDENTS];\nint student_count = 0; // 学生数量\n\n// 按照总成绩降序，学号升序比较函数\nint compare_students(const void* a, const void* b) {\n    Student* s1 = (Student*)a;\n    Student* s2 = (Student*)b;\n    int sum1 = s1->score1 + s1->score2;\n    int sum2 = s2->score1 + s2->score2;\n    if (sum1 != sum2) {\n        return sum2 - sum1; // 按照总成绩降序排列\n    } else {\n        return strcmp(s1->studentId, s2->studentId); // 如果成绩相同则按照学号升序排列\n    }\n}\n\n// 通过分割字符串，将学生成绩导入到结构体中\nvoid divide(const char* str, int courseId) {\n    char buffer[10000];\n    strcpy(buffer, str); // 输入字符串以便修改\n    char* token = strtok(buffer, \";\"); // 按分号分割字符串\n\n    while (token != NULL) {\n        char studentId[ID_LEN];\n        int score;\n        sscanf(token, \"%[^,],%d\", studentId, &score); // 解析学号和成绩\n\n        // 查找是否已存在该学生\n        int found = 0;\n        for (int i = 0; i < student_count; i++) {\n            if (strcmp(students[i].studentId, studentId) == 0) {\n                found = 1;\n                if (courseId == 1) {\n                    students[i].score1 = score; // 记录第一门课程成绩\n                } else {\n                    students[i].score2 = score; // 记录第二门课程成绩\n                }\n                break;\n            }\n        }\n\n        // 如果没有找到该学生，则新建学生\n        if (!found) {\n            strcpy(students[student_count].studentId, studentId);\n            strncpy(students[student_count].classId, studentId, 5); // 班级编号为学号前五位\n            students[student_count].classId[5] = '\\0'; // 确保字符串正确结束\n            if (courseId == 1) {\n                students[student_count].score1 = score; // 设置第一门课成绩\n                students[student_count].score2 = -1;    // 第二门课成绩未设定\n            } else {\n                students[student_count].score1 = -1;    // 第一门课成绩未设定\n                students[student_count].score2 = score; // 设置第二门课成绩\n            }\n            student_count++;\n        }\n\n        token = strtok(NULL, \";\"); // 继续分割下一个学生记录\n    }\n}\n\nint main() {\n    char line_one[10000], line_two[10000];\n\n    // 读取两行输入，第一行是第一门选修课成绩，第二行是第二门选修课成绩\n    fgets(line_one, sizeof(line_one), stdin);\n    fgets(line_two, sizeof(line_two), stdin);\n\n    // 处理第一门和第二门课程的学生成绩\n    divide(line_one, 1);\n    divide(line_two, 2);\n\n    // 创建按班级分类的数组\n    Student selectedStudents[MAX_STUDENTS];\n    int selected_count = 0;\n\n    // 筛选出同时选修了两门课程的学生\n    for (int i = 0; i < student_count; i++) {\n        if (students[i].score1 != -1 && students[i].score2 != -1) {\n            selectedStudents[selected_count++] = students[i];\n        }\n    }\n\n    // 如果没有找到符合条件的学生，则输出 \"NULL\"\n    if (selected_count == 0) {\n        printf(\"NULL\\n\");\n        return 0;\n    }\n\n    // 对筛选出的学生按照班级编号和成绩进行分类和排序\n    qsort(selectedStudents, selected_count, sizeof(Student), compare_students);\n\n    // 输出学生信息，按班级分组\n    char current_class[CLASS_ID_LEN] = \"\";\n    for (int i = 0; i < selected_count; i++) {\n        // 如果当前学生的班级不同于上一个，则输出班级编号\n        if (strcmp(current_class, selectedStudents[i].classId) != 0) {\n            if (i > 0) printf(\"\\n\"); // 换行符\n            strcpy(current_class, selectedStudents[i].classId);\n            printf(\"%s\\n\", current_class); // 输出班级编号\n        }\n\n        // 输出学生学号\n        if (i > 0 && strcmp(current_class, selectedStudents[i - 1].classId) == 0) {\n            printf(\";\"); // 同一班级中的学号之间使用分号隔开\n        }\n        printf(\"%s\", selectedStudents[i].studentId);\n    }\n\n    printf(\"\\n\");\n    return 0;\n}"
  }
}