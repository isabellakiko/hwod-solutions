{
  "id": "110",
  "title": "猜数字",
  "examType": "A",
  "score": 100,
  "description": "一个人设定一组四码的数字作为谜底，另一方猜。\n每猜一个数，出数者就要根据这个数字给出提示，提示以XAYB形式呈现，直到猜中位置。\n其中X表示位置正确的数的个数（数字正确且位置正确），而Y表示数字正确而位置不对的数的个数。\n例如，当谜底为8123，而猜谜者猜1052时，出题者必须提示0A2B。\n例如，当谜底为5637，而猜谜者才4931时，出题者必须提示1A0B。\n当前已知N组猜谜者猜的数字与提示，如果答案确定，请输出答案，不确定则输出NA。",
  "inputDesc": "第一行输入一个正整数，0＜N ＜ 100。\n接下来N行，每一行包含一个猜测的数字与提示结果。",
  "outputDesc": "输出最后的答案，答案不确定则输出NA。",
  "examples": [
    {
      "input": "6\n4815 1A1B\n5765 0A1B\n2732 0A1B\n1346 0A0B\n2265 3A0B\n6265 2A1B",
      "output": "2675",
      "explanation": "枚举0000-9999，验证每个数字与所有猜测是否匹配，只有2675满足所有条件"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**暴力枚举**问题。\n\n**核心思路：**\n- 枚举0000~9999所有可能的谜底\n- 对每个候选答案验证是否符合所有猜测提示\n- 唯一符合的即为答案，否则输出NA\n\n**算法步骤：**\n1. 枚举0000-9999\n2. 对每个候选计算与猜测的XAYB\n3. 验证计算结果与提示是否一致\n4. 统计符合条件的答案个数\n\n**时间复杂度**：O(10000×N)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // 输入猜测的次数\n\n        // 存储所有猜测的数字和提示结果\n        List<String[]> guessInfos = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            String guessNum = scanner.next(); // 输入猜测的数字\n            String guessResult = scanner.next(); // 输入猜测的结果\n            guessInfos.add(new String[]{guessNum, guessResult}); // 将猜测的数字和结果存入列表中\n        }\n\n        int validCount = 0; // 记录符合条件的答案数量\n        String validAnswer = \"\"; // 存储符合条件的答案\n\n        // 遍历所有可能的四位数\n        for (int num = 0; num <= 9999; num++) {\n            String answer = String.format(\"%04d\", num); // 将数字格式化为四位数字符串\n            boolean isValid = true; // 标记当前答案是否有效\n\n            // 遍历每个猜测的数字和结果\n            for (String[] guessInfo : guessInfos) {\n                String guess = guessInfo[0]; // 获取猜测的数字\n                String expectResult = guessInfo[1]; // 获取猜测的结果\n\n                int countA = 0; // 记录数字和位置都正确的个数\n                int countB = 0; // 记录数字正确但位置不正确的个数\n\n                int[] answerArr = new int[10]; // 存储答案中每个数字出现的次数\n                int[] guessArr = new int[10]; // 存储猜测中每个数字出现的次数\n\n                // 遍历每个位置\n                for (int i = 0; i < guess.length(); i++) {\n                    int c1Int = guess.charAt(i) - '0'; // 获取猜测中该位置上的数字\n                    int c2Int = answer.charAt(i) - '0'; // 获取答案中该位置上的数字\n\n                    if (c1Int == c2Int) {\n                        countA++; // 如果数字和位置都正确，countA+1\n                    } else {\n                        guessArr[c1Int]++; // 在 guessArr 中记录该数字出现的次数\n                        answerArr[c2Int]++; // 在 answerArr 中记录该数字出现的次数\n                    }\n                }\n\n                for (int i = 0; i < 10; i++) {\n                    countB += Math.min(answerArr[i], guessArr[i]); // 计算数字正确但位置不正确的个数\n                }\n\n                String realResult = countA + \"A\" + countB + \"B\"; // 根据猜测和答案计算真实结果\n\n                if (!realResult.equals(expectResult)) {\n                    isValid = false; // 如果真实结果和猜测结果不一致，标记当前答案为无效\n                    break;\n                }\n            }\n\n            if (isValid) {\n                validCount++; // 如果当前答案有效，更新符合条件的答案数量\n                validAnswer = answer; // 更新符合条件的答案\n\n                if (validCount > 1) {\n                    break; // 如果符合条件的答案数量大于1，跳出循环\n                }\n            }\n        }\n\n        if (validCount != 1) {\n            System.out.println(\"NA\"); // 如果符合条件的答案不唯一，输出 NA\n        } else {\n            System.out.println(validAnswer); // 如果符合条件的答案唯一，输出答案\n        }\n    }\n}",
    "python": "from typing import List, Tuple\n\ndef main():\n    n = int(input())  # 输入猜测的次数\n\n    # 存储所有猜测的数字和提示结果\n    guess_infos = [tuple(input().split()) for _ in range(n)]\n\n    valid_count = 0  # 记录符合条件的答案数量\n    valid_answer = \"\"  # 存储符合条件的答案\n\n    # 遍历所有可能的四位数\n    for num in range(10000):\n        answer = f\"{num:04d}\"  # 将数字格式化为四位数字符串\n        is_valid = True  # 标记当前答案是否有效\n\n        # 遍历每个猜测的数字和结果\n        for guess, expect_result in guess_infos:\n            count_a = 0  # 记录数字和位置都正确的个数\n            count_b = 0  # 记录数字正确但位置不正确的个数\n\n            answer_arr = [0] * 10  # 存储答案中每个数字出现的次数\n            guess_arr = [0] * 10  # 存储猜测中每个数字出现的次数\n\n            # 遍历每个位置\n            for i in range(len(guess)):\n                c1_int = int(guess[i])  # 获取猜测中该位置上的数字\n                c2_int = int(answer[i])  # 获取答案中该位置上的数字\n\n                if c1_int == c2_int:\n                    count_a += 1  # 如果数字和位置都正确，countA+1\n                else:\n                    guess_arr[c1_int] += 1  # 在 guessArr 中记录该数字出现的次数\n                    answer_arr[c2_int] += 1  # 在 answerArr 中记录该数字出现的次数\n\n            count_b = sum(min(answer_arr[i], guess_arr[i]) for i in range(10))  # 计算数字正确但位置不正确的个数\n\n            real_result = f\"{count_a}A{count_b}B\"  # 根据猜测和答案计算真实结果\n\n            if real_result != expect_result:\n                is_valid = False  # 如果真实结果和猜测结果不一致，标记当前答案为无效\n                break\n\n        if is_valid:\n            valid_count += 1  # 如果当前答案有效，更新符合条件的答案数量\n            valid_answer = answer  # 更新符合条件的答案\n\n            if valid_count > 1:\n                break  # 如果符合条件的答案数量大于1，跳出循环\n\n    if valid_count != 1:\n        print(\"NA\")  # 如果符合条件的答案不唯一，输出 NA\n    else:\n        print(valid_answer)  # 如果符合条件的答案唯一，输出答案\n\nif __name__ == \"__main__\":\n    main()",
    "javascript": "// 引入readline库，用于从标准输入读取数据\nconst readline = require('readline');\n// 创建readline接口实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 定义变量n来存储猜测的总数\nlet n;\n// 定义数组来存储每次的猜测数字和结果\nlet guessInfos = [];\n\n// 监听行输入事件\nrl.on('line', (line) => {\n  if (!n) {\n    // 如果n未定义，读取第一行作为猜测总数\n    n = parseInt(line.trim());\n  } else {\n    // 否则读取猜测数字和相应的结果，并存入guessInfos数组\n    const [guessNum, guessResult] = line.split(' ');\n    guessInfos.push([guessNum, guessResult]);\n    if (guessInfos.length === n) {\n      // 当读取完所有数据后关闭接口\n      rl.close();\n    }\n  }\n});\n\n// 监听关闭事件，开始处理数据\nrl.on('close', () => {\n  // 用于记录符合条件的答案数量\n  let validCount = 0;\n  // 用于存储有效的答案\n  let validAnswer = '';\n\n  // 遍历0000到9999所有可能的答案\n  for (let num = 0; num <= 9999; num++) {\n    const answer = num.toString().padStart(4, '0');\n    let isValid = true;\n\n    // 遍历所有的猜测信息\n    for (const [guess, expectResult] of guessInfos) {\n      let countA = 0; // 位置和数字都正确的数量\n      let countB = 0; // 数字正确但位置错误的数量\n      // 初始化数字出现频次的数组\n      const answerArr = new Array(10).fill(0);\n      const guessArr = new Array(10).fill(0);\n\n      // 对每个位置的数字进行比较\n      for (let i = 0; i < guess.length; i++) {\n        const c1Int = parseInt(guess[i]);\n        const c2Int = parseInt(answer[i]);\n\n        if (c1Int === c2Int) {\n          countA++;\n        } else {\n          guessArr[c1Int]++;\n          answerArr[c2Int]++;\n        }\n      }\n\n      // 计算位置不正确但数字正确的数量\n      for (let i = 0; i < 10; i++) {\n        countB += Math.min(answerArr[i], guessArr[i]);\n      }\n\n      // 构造实际结果字符串\n      const realResult = `${countA}A${countB}B`;\n\n      // 如果实际结果与预期结果不匹配，该答案无效\n      if (realResult !== expectResult) {\n        isValid = false;\n        break;\n      }\n    }\n\n    // 如果该答案有效，记录下来\n    if (isValid) {\n      validCount++;\n      validAnswer = answer;\n\n      // 如果找到多于一个有效答案，则停止搜索\n      if (validCount > 1) {\n        break;\n      }\n    }\n  }\n\n  // 根据有效答案数量输出结果\n  if (validCount !== 1) {\n    console.log('NA');\n  } else {\n    console.log(validAnswer);\n  }\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <sstream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n; // 输入猜测的次数\n\n    // 存储所有猜测的数字和提示结果\n    vector<pair<string, string>> guessInfos;\n    for (int i = 0; i < n; i++) {\n        string guessNum, guessResult;\n        cin >> guessNum >> guessResult; // 输入猜测的数字和结果\n        guessInfos.push_back(make_pair(guessNum, guessResult)); // 将猜测的数字和结果存入列表中\n    }\n\n    int validCount = 0; // 记录符合条件的答案数量\n    string validAnswer = \"\"; // 存储符合条件的答案\n\n    // 遍历所有可能的四位数\n    for (int num = 0; num <= 9999; num++) {\n        stringstream ss;\n        ss << setw(4) << setfill('0') << num;\n        string answer = ss.str(); // 将数字格式化为四位数字符串\n        bool isValid = true; // 标记当前答案是否有效\n\n        // 遍历每个猜测的数字和结果\n        for (const auto& guessInfo : guessInfos) {\n            string guess = guessInfo.first; // 获取猜测的数字\n            string expectResult = guessInfo.second; // 获取猜测的结果\n\n            int countA = 0; // 记录数字和位置都正确的个数\n            int countB = 0; // 记录数字正确但位置不正确的个数\n\n            vector<int> answerArr(10, 0); // 存储答案中每个数字出现的次数\n            vector<int> guessArr(10, 0); // 存储猜测中每个数字出现的次数\n\n            // 遍历每个位置\n            for (int i = 0; i < guess.length(); i++) {\n                int c1Int = guess[i] - '0'; // 获取猜测中该位置上的数字\n                int c2Int = answer[i] - '0'; // 获取答案中该位置上的数字\n\n                if (c1Int == c2Int) {\n                    countA++; // 如果数字和位置都正确，countA+1\n                } else {\n                    guessArr[c1Int]++; // 在 guessArr 中记录该数字出现的次数\n                    answerArr[c2Int]++; // 在 answerArr 中记录该数字出现的次数\n                }\n            }\n\n            for (int i = 0; i < 10; i++) {\n                countB += min(answerArr[i], guessArr[i]); // 计算数字正确但位置不正确的个数\n            }\n\n            string realResult = to_string(countA) + \"A\" + to_string(countB) + \"B\"; // 根据猜测和答案计算真实结果\n\n            if (realResult != expectResult) {\n                isValid = false; // 如果真实结果和猜测结果不一致，标记当前答案为无效\n                break;\n            }\n        }\n\n        if (isValid) {\n            validCount++; // 如果当前答案有效，更新符合条件的答案数量\n            validAnswer = answer; // 更新符合条件的答案\n\n            if (validCount > 1) {\n                break; // 如果符合条件的答案数量大于1，跳出循环\n            }\n        }\n    }\n\n    if (validCount != 1) {\n        cout << \"NA\" << endl; // 如果符合条件的答案不唯一，输出 NA\n    } else {\n        cout << validAnswer << endl; // 如果符合条件的答案唯一，输出答案\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main() {\n    int n;\n    scanf(\"%d\", &n); // 读取输入的猜测次数\n\n    char guessNum[5], guessResult[5];\n    char guessInfos[n][10][2][5]; // 创建数组存储每次的猜测和结果\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s %s\", guessNum, guessResult); // 读取每次的猜测数字和结果\n        strcpy(guessInfos[i][0], guessNum);\n        strcpy(guessInfos[i][1], guessResult);\n    }\n\n    int validCount = 0; // 用于记录符合条件的答案数量\n    char validAnswer[5]; // 用于存储有效答案\n\n    // 遍历所有可能的四位数\n    for (int num = 0; num <= 9999; num++) {\n        char answer[5];\n        sprintf(answer, \"%04d\", num); // 将数字格式化为四位数字符串\n\n        int isValid = 1; // 假设当前答案有效\n\n        // 对每组猜测信息进行验证\n        for (int j = 0; j < n; j++) {\n            char *guess = guessInfos[j][0];\n            char *expectResult = guessInfos[j][1];\n\n            int countA = 0; // 位置和数字都正确的数量\n            int countB = 0; // 数字正确位置错误的数量\n            int answerArr[10] = {0};\n            int guessArr[10] = {0};\n\n            // 比较猜测数字和答案数字\n            for (int i = 0; i < 4; i++) {\n                int c1Int = guess[i] - '0';\n                int c2Int = answer[i] - '0';\n\n                if (c1Int == c2Int) {\n                    countA++;\n                } else {\n                    guessArr[c1Int]++;\n                    answerArr[c2Int]++;\n                }\n            }\n\n            // 计算位置不对但数字正确的情况\n            for (int i = 0; i < 10; i++) {\n                countB += (answerArr[i] < guessArr[i]) ? answerArr[i] : guessArr[i];\n            }\n\n            char realResult[5];\n            sprintf(realResult, \"%dA%dB\", countA, countB); // 构造实际的结果字符串\n\n            if (strcmp(realResult, expectResult) != 0) {\n                isValid = 0; // 如果实际结果和预期结果不符，标记为无效\n                break;\n            }\n        }\n\n        // 如果当前答案有效，记录下来\n        if (isValid) {\n            validCount++;\n            strcpy(validAnswer, answer);\n\n            if (validCount > 1) {\n                break; // 如果找到多于一个有效答案，停止搜索\n            }\n        }\n    }\n\n    // 根据有效答案的数量输出结果\n    if (validCount != 1) {\n        printf(\"NA\\n\");\n    } else {\n        printf(\"%s\\n\", validAnswer);\n    }\n\n    return 0;\n}"
  }
}