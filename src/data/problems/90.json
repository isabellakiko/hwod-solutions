{
  "id": "90",
  "title": "boss的收入",
  "examType": "A",
  "score": 100,
  "description": "一个XX产品行销总公司，只有一个boss，其有若干一级分销，一级分销又有若干二级分销，每个分销只有唯一的上级分销。\n规定，每个月，下级分销需要将自己的总收入（自己的+下级上交的）每满100元上交15元给自己的上级。\n现给出一组分销的关系，和每个分销的收入，请找出boss并计算出这个boss的收入。\n比如：\n收入100元，上交15元；收入199元（99元不够100），上交15元；收入200元，上交30元。\n输入：\n分销关系和收入：[[分销id 上级分销id 收入], [分销id 上级分销id 收入], [分销id 上级分销id 收入]]\n分销ID范围： 0…65535收入范围：0…65535，单位元\n提示： 输入的数据只存在1个boss，不存在环路\n输出：\n[boss的ID, 总收入]",
  "inputDesc": "第一行输入关系的总数量 N 第二行开始，输入关系信息，格式：\n分销ID 上级分销ID 收入\n比如：\n123456",
  "outputDesc": "输出：\nboss的ID 总收入\n比如：\n0 120\n给定的输入数据都是合法的，不存在环路，重复的",
  "examples": [
    {
      "input": "5\n1 0 100\n2 0 199\n3 0 200\n4 0 200\n5 0 200",
      "output": "0 120",
      "explanation": "0是boss。1上交15，2上交15，3/4/5各上交30。共15+15+30+30+30=120。"
    },
    {
      "input": "2\n2 1 100\n1 0 100",
      "output": "0 30",
      "explanation": "0是boss。1收入100上交15，2收入100上交15给1，1总收入115上交15给0。共30。"
    },
    {
      "input": "1\n1 0 50",
      "output": "0 0",
      "explanation": "分销1收入50元，不够100元，不上交。boss收入0。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**树形结构DFS**问题。\n\n**算法步骤：**\n1. 构建分销树：记录子→父的映射和父→子列表\n2. 找到boss：没有父节点的分销商\n3. DFS递归计算：从叶子节点向上累加收入\n4. 上交规则：每满100元上交15元给上级\n5. boss的收入=所有直接下级上交的总和\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 读取分销关系的数量\n        int n = Integer.parseInt(sc.nextLine().trim());\n\n        // 记录每个分销商的收入\n        HashMap<Integer, Long> income = new HashMap<>();\n        // 记录所有的分销商 ID\n        HashSet<Integer> ids = new HashSet<>();\n        // 记录子分销商到父分销商的映射关系\n        HashMap<Integer, Integer> childToParent = new HashMap<>();\n        // 记录父分销商到其所有子分销商的映射关系\n        HashMap<Integer, LinkedList<Integer>> parentToChildren = new HashMap<>();\n\n        // 读取输入数据并构建映射关系\n        for (int i = 0; i < n; i++) {\n            // 读取当前行\n            String[] parts = sc.nextLine().split(\" \");\n            // 解析当前子分销商的 ID\n            int childId = Integer.parseInt(parts[0]);\n            // 解析当前子分销商的父分销商 ID\n            int parentId = Integer.parseInt(parts[1]);\n            // 解析当前子分销商的收入\n            long childIncome = Long.parseLong(parts[2]);\n\n            // 将子分销商的收入记录在 income 映射中\n            income.put(childId, childIncome);\n            // 将子分销商和父分销商的 ID 添加到分销商 ID 集合中\n            ids.add(childId);\n            ids.add(parentId);\n\n            // 记录子分销商到父分销商的映射关系\n            childToParent.put(childId, parentId);\n\n            // 如果父分销商还没有子分销商列表，则初始化一个新的列表\n            parentToChildren.putIfAbsent(parentId, new LinkedList<>());\n            // 将当前子分销商 ID 添加到父分销商的子分销商列表中\n            parentToChildren.get(parentId).add(childId);\n        }\n\n        // 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\n        for (int id : ids) {\n            // 如果当前分销商 ID 不在 childToParent 映射中，说明它是顶级分销商\n            if (!childToParent.containsKey(id)) {\n                // 初始化顶级分销商的收入为0，因为它自身没有任何直接收入\n                income.put(id, 0L);\n                // 调用深度优先搜索算法计算该顶级分销商的总收入（包括来自下级分销商的提成）\n                calcTotalIncome(id, parentToChildren, income);\n                // 输出顶级分销商的 ID 和其计算出的总收入\n                System.out.println(id + \" \" + income.get(id));\n                // 一旦找到顶级分销商，结束循环\n                break;\n            }\n        }\n    }\n\n    // 使用递归的深度优先搜索算法计算分销商的总收入，包括从下级分销商获取的部分\n    private static void calcTotalIncome(int parentId, \n                                        HashMap<Integer, LinkedList<Integer>> parentToChildren, \n                                        HashMap<Integer, Long> income) {\n        // 获取当前父分销商的子分销商列表\n        LinkedList<Integer> children = parentToChildren.get(parentId);\n\n        // 如果该父分销商有子分销商\n        if (children != null && !children.isEmpty()) {\n            // 遍历所有子分销商\n            for (int childId : children) {\n                // 递归计算子分销商的总收入\n                calcTotalIncome(childId, parentToChildren, income);\n                // 计算父分销商从该子分销商处获取的提成收入\n                long additionalIncome = income.get(childId) / 100 * 15;\n                // 将提成收入累加到父分销商的总收入中\n                income.put(parentId, income.get(parentId) + additionalIncome);\n            }\n        }\n    }\n}",
    "python": "# 导入必要的库\nfrom collections import defaultdict, deque\n \n    \n\ndef calc_total_income(parent_id, parent_to_children, income):\n    \"\"\"\n    使用递归的深度优先搜索算法计算分销商的总收入，包括从下级分销商获取的部分\n    \"\"\"\n    # 获取当前父分销商的子分销商列表\n    children = parent_to_children[parent_id]\n\n    # 如果该父分销商有子分销商\n    if children:\n        # 遍历所有子分销商\n        for child_id in children:\n            # 递归计算子分销商的总收入\n            calc_total_income(child_id, parent_to_children, income)\n            # 计算父分销商从该子分销商处获取的提成收入\n            additional_income = income[child_id] // 100 * 15\n            # 将提成收入累加到父分销商的总收入中\n            income[parent_id] += additional_income\n\n# 读取输入的分销关系数量\nn = int(input().strip())\n\n# 记录每个分销商的收入\nincome = {}\n# 记录所有的分销商 ID\nids = set()\n# 记录子分销商到父分销商的映射关系\nchild_to_parent = {}\n# 记录父分销商到其所有子分销商的映射关系\nparent_to_children = defaultdict(list)\n\n# 读取输入数据并构建映射关系\nfor _ in range(n):\n    # 读取当前行并按空格分割\n    parts = input().strip().split()\n    # 解析当前子分销商的 ID\n    child_id = int(parts[0])\n    # 解析当前子分销商的父分销商 ID\n    parent_id = int(parts[1])\n    # 解析当前子分销商的收入\n    child_income = int(parts[2])\n\n    # 将子分销商的收入记录在 income 映射中\n    income[child_id] = child_income\n    # 将子分销商和父分销商的 ID 添加到分销商 ID 集合中\n    ids.add(child_id)\n    ids.add(parent_id)\n\n    # 记录子分销商到父分销商的映射关系\n    child_to_parent[child_id] = parent_id\n\n    # 如果父分销商还没有子分销商列表，则初始化一个新的列表（由 defaultdict 自动处理）\n    # 将当前子分销商 ID 添加到父分销商的子分销商列表中\n    parent_to_children[parent_id].append(child_id)\n\n# 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\nfor id in ids:\n    # 如果当前分销商 ID 不在 child_to_parent 映射中，说明它是顶级分销商\n    if id not in child_to_parent:\n        # 初始化顶级分销商的收入为 0，因为它自身没有任何直接收入\n        income[id] = 0\n        # 调用深度优先搜索算法计算该顶级分销商的总收入（包括来自下级分销商的提成）\n        calc_total_income(id, parent_to_children, income)\n        # 输出顶级分销商的 ID 和其计算出的总收入\n        print(f\"{id} {income[id]}\")\n        # 一旦找到顶级分销商，结束循环\n        break",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 用于存储所有分销商信息的全局变量\nlet n; // 分销关系的数量\nconst income = {}; // 记录每个分销商的收入\nconst ids = new Set(); // 记录所有的分销商 ID\nconst childToParent = {}; // 记录子分销商到父分销商的映射关系\nconst parentToChildren = {}; // 记录父分销商到其所有子分销商的映射关系\n\n// 读取输入并处理\nrl.on('line', (input) => {\n    // 首次输入是分销关系的数量\n    if (n === undefined) {\n        n = parseInt(input.trim());\n    } else {\n        // 处理每一行输入\n        const parts = input.trim().split(' ');\n        const childId = parseInt(parts[0]);\n        const parentId = parseInt(parts[1]);\n        const childIncome = parseInt(parts[2]);\n\n        // 将子分销商的收入记录在 income 映射中\n        income[childId] = childIncome;\n        // 将子分销商和父分销商的 ID 添加到分销商 ID 集合中\n        ids.add(childId);\n        ids.add(parentId);\n\n        // 记录子分销商到父分销商的映射关系\n        childToParent[childId] = parentId;\n\n        // 如果父分销商还没有子分销商列表，则初始化一个新的列表\n        if (!parentToChildren[parentId]) {\n            parentToChildren[parentId] = [];\n        }\n        // 将当前子分销商 ID 添加到父分销商的子分销商列表中\n        parentToChildren[parentId].push(childId);\n\n        // 当所有数据读取完毕后，处理顶级分销商的收入计算\n        if (--n === 0) {\n            // 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\n            for (let id of ids) {\n                if (!childToParent.hasOwnProperty(id)) {\n                    // 初始化顶级分销商的收入为 0，因为它自身没有任何直接收入\n                    income[id] = 0;\n                    // 调用深度优先搜索算法计算该顶级分销商的总收入（包括来自下级分销商的提成）\n                    calcTotalIncome(id, parentToChildren, income);\n                    // 输出顶级分销商的 ID 和其计算出的总收入\n                    console.log(`${id} ${income[id]}`);\n                    // 一旦找到顶级分销商，结束循环\n                    break;\n                }\n            }\n        \n            rl.close();\n        }\n    }\n});\n\n/**\n * 使用递归的深度优先搜索算法计算分销商的总收入，包括从下级分销商获取的部分\n * @param {number} parentId - 父分销商的 ID\n * @param {object} parentToChildren - 父分销商到其子分销商列表的映射\n * @param {object} income - 分销商的收入映射\n */\nfunction calcTotalIncome(parentId, parentToChildren, income) {\n    // 获取当前父分销商的子分销商列表\n    const children = parentToChildren[parentId] || [];\n\n    // 如果该父分销商有子分销商\n    for (let childId of children) {\n        // 递归计算子分销商的总收入\n        calcTotalIncome(childId, parentToChildren, income);\n        // 计算父分销商从该子分销商处获取的提成收入\n        const additionalIncome = Math.floor(income[childId] / 100)  * 15;\n        // 将提成收入累加到父分销商的总收入中\n        income[parentId] += additionalIncome;\n    }\n}",
    "cpp": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// 使用递归的深度优先搜索算法计算分销商的总收入，包括从下级分销商获取的部分\nvoid calcTotalIncome(int parentId, \n                     unordered_map<int, list<int>>& parentToChildren, \n                     unordered_map<int, long long>& income) {\n    // 获取当前父分销商的子分销商列表\n    if (parentToChildren.find(parentId) != parentToChildren.end()) {\n        list<int>& children = parentToChildren[parentId];\n\n        // 遍历所有子分销商\n        for (int childId : children) {\n            // 递归计算子分销商的总收入\n            calcTotalIncome(childId, parentToChildren, income);\n            // 计算父分销商从该子分销商处获取的提成收入\n            long long additionalIncome = (income[childId] / 100) * 15;\n            // 将提成收入累加到父分销商的总收入中\n            income[parentId] += additionalIncome;\n        }\n    }\n}\n\nint main() {\n    int n;\n    // 读取分销关系的数量\n    cin >> n;\n    cin.ignore();\n\n    // 记录每个分销商的收入\n    unordered_map<int, long long> income;\n    // 记录所有的分销商 ID\n    unordered_set<int> ids;\n    // 记录子分销商到父分销商的映射关系\n    unordered_map<int, int> childToParent;\n    // 记录父分销商到其所有子分销商的映射关系\n    unordered_map<int, list<int>> parentToChildren;\n\n    // 读取输入数据并构建映射关系\n    for (int i = 0; i < n; i++) {\n        string line;\n        getline(cin, line);\n        stringstream ss(line);\n        int childId, parentId;\n        long long childIncome;\n\n        // 解析当前子分销商的 ID\n        ss >> childId;\n        // 解析当前子分销商的父分销商 ID\n        ss >> parentId;\n        // 解析当前子分销商的收入\n        ss >> childIncome;\n\n        // 将子分销商的收入记录在 income 映射中\n        income[childId] = childIncome;\n        // 将子分销商和父分销商的 ID 添加到分销商 ID 集合中\n        ids.insert(childId);\n        ids.insert(parentId);\n\n        // 记录子分销商到父分销商的映射关系\n        childToParent[childId] = parentId;\n\n        // 如果父分销商还没有子分销商列表，则初始化一个新的列表\n        if (parentToChildren.find(parentId) == parentToChildren.end()) {\n            parentToChildren[parentId] = list<int>();\n        }\n        // 将当前子分销商 ID 添加到父分销商的子分销商列表中\n        parentToChildren[parentId].push_back(childId);\n    }\n\n    // 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\n    for (int id : ids) {\n        // 如果当前分销商 ID 不在 childToParent 映射中，说明它是顶级分销商\n        if (childToParent.find(id) == childToParent.end()) {\n            // 初始化顶级分销商的收入为0，因为它自身没有任何直接收入\n            income[id] = 0;\n            // 调用深度优先搜索算法计算该顶级分销商的总收入（包括来自下级分销商的提成）\n            calcTotalIncome(id, parentToChildren, income);\n            // 输出顶级分销商的 ID 和其计算出的总收入\n            cout << id << \" \" << income[id] << endl;\n            // 一旦找到顶级分销商，结束循环\n            break;\n        }\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义结构体用于表示链表节点，链表用于存储子分销商ID\ntypedef struct Node {\n    int id;            // 子分销商的ID\n    struct Node* next; // 指向下一个子分销商的指针\n} Node;\n\n// 定义结构体用于表示分销商的收入信息以及子分销商链表\ntypedef struct {\n    long long income; // 分销商的收入\n    Node* children;   // 指向子分销商链表的头节点\n} Distributor;\n\n// 动态数组用于存储所有分销商的ID\nint ids[1000];\nint idsCount = 0;\n\n// 哈希表，用于记录分销商ID到其收入信息及子分销商链表的映射\nDistributor* distributors[1000];\n\n// 哈希表，用于记录子分销商到父分销商的映射关系\nint childToParent[1000];\nint childToParentCount = 0;\n\n// 初始化所有分销商的收入信息及子分销商链表\nvoid initializeDistributors() {\n    for (int i = 0; i < 1000; i++) {\n        distributors[i] = NULL;\n        childToParent[i] = -1;\n    }\n}\n\n// 创建新的链表节点\nNode* createNode(int id) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->id = id;\n    node->next = NULL;\n    return node;\n}\n\n// 添加子分销商到父分销商的链表中\nvoid addChild(int parentId, int childId) {\n    Node* childNode = createNode(childId);\n    childNode->next = distributors[parentId]->children;\n    distributors[parentId]->children = childNode;\n}\n\n// 递归计算分销商的总收入，包括从下级分销商获取的部分\nvoid calcTotalIncome(int parentId) {\n    Node* childNode = distributors[parentId]->children;\n    while (childNode != NULL) {\n        calcTotalIncome(childNode->id); // 递归计算子分销商的总收入\n        long long additionalIncome = (distributors[childNode->id]->income / 100) * 15;\n        distributors[parentId]->income += additionalIncome; // 累加提成收入\n        childNode = childNode->next;\n    }\n}\n\nint main() {\n    initializeDistributors();\n\n    int n;\n    scanf(\"%d\", &n); // 读取分销关系的数量\n\n    for (int i = 0; i < n; i++) {\n        int childId, parentId;\n        long long childIncome;\n        scanf(\"%d %d %lld\", &childId, &parentId, &childIncome); // 读取每个分销关系\n\n        // 如果分销商尚未创建，创建新的分销商结构体\n        if (distributors[childId] == NULL) {\n            distributors[childId] = (Distributor*)malloc(sizeof(Distributor));\n            distributors[childId]->income = 0;\n            distributors[childId]->children = NULL;\n        }\n\n        // 记录子分销商的收入\n        distributors[childId]->income = childIncome;\n\n        // 记录父分销商ID到子分销商ID的映射关系\n        childToParent[childId] = parentId;\n\n        // 将父分销商ID和子分销商ID添加到ID列表中\n        ids[idsCount++] = childId;\n        ids[idsCount++] = parentId;\n\n        // 如果父分销商尚未创建，创建新的分销商结构体\n        if (distributors[parentId] == NULL) {\n            distributors[parentId] = (Distributor*)malloc(sizeof(Distributor));\n            distributors[parentId]->income = 0;\n            distributors[parentId]->children = NULL;\n        }\n\n        // 将子分销商添加到父分销商的子分销商链表中\n        addChild(parentId, childId);\n    }\n\n    // 寻找顶级分销商 (即没有父分销商的分销商，即 boss)\n    for (int i = 0; i < idsCount; i++) {\n        int id = ids[i];\n        if (childToParent[id] == -1) {\n            // 计算顶级分销商的总收入\n            calcTotalIncome(id);\n            // 输出顶级分销商的ID和总收入\n            printf(\"%d %lld\\n\", id, distributors[id]->income);\n            break;\n        }\n    }\n\n    return 0;\n}"
  }
}