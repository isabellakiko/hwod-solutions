{
  "id": "213",
  "title": "无向图染色",
  "examType": "B",
  "score": 200,
  "description": "给一个无向图染色，可以填红黑两种颜色，必须保证相邻两个节点不能同时为红色，输出有多少种不同的染色方案？\n",
  "inputDesc": "第一行输入M(图中节点数) N(边数)\n后续N行格式为：V1 V2表示一个V1到V2的边。\n数据范围：1 <= M <= 15,0 <= N <= M * 3，不能保证所有节点都是连通的。\n",
  "outputDesc": "输出一个数字表示染色方案的个数。\n\n4个节点，4条边，1号节点和2号节点相连，\n2号节点和4号节点相连，3号节点和4号节点相连，\n1号节点和3号节点相连，\n若想必须保证相邻两个节点不能同时为红色，总共7种方案。\n\n2022.12.25 更正解析说明，感谢Andy___Zhong指出错误。\n本题其实就是求解连通图的染色方案，\n目前我想到的最好方式是暴力法，即通过回溯算法，求解出染红节点的全组合，\nn个数的全组合数量一共有 (2^n) - 1。\n比如：1,2,3的全组合情况有：1、2、3、12、13、23、123，即 (2^3) - 1 = 7个。\n本题中节点一共有m个，而1 <= m <= 15，即最多有 (2^15) - 1 = 32767 个组合情况，这个数量级不算多。 因此暴力法可行。\n\n我们需要尝试对组合中的节点进行染红色，但是相邻节点不能同时染成红色。因此，在求解全组合时，还可以进行剪枝优化，即判断新加入的节点 是否和 已存在的节点相邻，如果相邻，则剪枝，如果不相邻则继续递归。\n\n本题，到此还未结束，因为题目中有一句话：\n不能保证所有节点都是连通的\n这说明什么呢？即对应用例4的情况，用例4对应的无向图如下：\n\n此时一共有8种染色方案如下：\n\n\n\n其实就是先求解无向图的各个连通分量，比如用例4的无向图就有两个连通分量，分别是：\n然后求解各连通分量各自的染色方案，比如\n那么总染色方案数目就是2*4=8种\n\n因此，本题还考察了连通分量的求解。\n连通分量的求解可以使用并查集，关于并查集知识请看：华为机试 - 发广播_伏城之外的博客-CSDN博客\n\n但是本题实现上可以取巧，即不需要使用并查集去求解连通分量，而是完全依赖于暴力，因为不管节点是否在一个连通分量中，还是不在一个连通分量中，他们的染色都要满足：\n相邻节点不能同时为红色\n因此，处于两个连通分量中的节点必然不相连，则必然可以同时染红，因此直接用前面求染红节点组合就可以，不需要用并查集。\n\n补充一个边界用例情况：\n4 3 2 3 2 4 3 4\n输出应该是8\n\n但是节点1和任何其他节点不相连，也没有在边，因此下面代码，统计connect时，即统计每个节点的相邻节点，必然统计不到节点1，即connect[1] 的值为null，因此后续获取节点1的相邻节点时会得到null，此时我们应该要特殊处理null。\n\n",
  "examples": [],
  "solution": "",
  "codes": {
    "java": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n\n    int[][] edges = new int[n][2];\n    for (int i = 0; i < n; i++) {\n      edges[i][0] = sc.nextInt();\n      edges[i][1] = sc.nextInt();\n    }\n\n    System.out.println(getResult(edges, m));\n  }\n\n  /**\n   * @param edges 边，即[v1, v2]\n   * @param m 点数量\n   * @return\n   */\n  public static int getResult(int[][] edges, int m) {\n    // connect用于存放每个节点的相邻节点\n    HashMap<Integer, HashSet<Integer>> connect = new HashMap<>();\n\n    for (int[] edge : edges) {\n      connect.putIfAbsent(edge[0], new HashSet<>());\n      connect.get(edge[0]).add(edge[1]);\n\n      connect.putIfAbsent(edge[1], new HashSet<>());\n      connect.get(edge[1]).add(edge[0]);\n    }\n\n    // 节点从index=1开始，必有count=1个的全黑染色方案\n    return dfs(connect, m, 1, 1, new LinkedList<>());\n  }\n\n  // 该方法用于求解给定多个节点染红的全组合数\n  public static int dfs(\n      HashMap<Integer, HashSet<Integer>> connect,\n      int m,\n      int index,\n      int count,\n      LinkedList<HashSet<Integer>> path) {\n    if (path.size() == m) return count;\n\n    outer:\n    for (int i = index; i <= m; i++) {\n      // 如果新加入节点i和已有节点j相邻，则说明新加入节点不能染成红色，需要进行剪枝\n      for (HashSet<Integer> p : path) {\n        if (p.contains(i)) continue outer;\n      }\n\n      count++;\n\n      if (connect.containsKey(i)) {\n        path.addLast(connect.get(i));\n        count = dfs(connect, m, i + 1, count, path);\n        path.removeLast();\n      } else {\n        count = dfs(connect, m, i + 1, count, path);\n      }\n    }\n\n    return count;\n  }\n}",
    "python": "# 输入获取\nm, n = map(int, input().split())\narr = [list(map(int, input().split())) for i in range(n)]\n\n\n# 算法入口\ndef getResult(arr, m):\n    \"\"\"\n    :param arr: 边，即[v1, v2]\n    :param m: 点数量\n    :return: 染色方案数\n    \"\"\"\n\n    # connect用于存放每个节点的相邻节点\n    connect = {}\n\n    for v1, v2 in arr:\n        if connect.get(v1) is None:\n            connect[v1] = set()\n        connect[v1].add(v2)\n\n        if connect.get(v2) is None:\n            connect[v2] = set()\n        connect[v2].add(v1)\n\n    # 节点从1开始\n    return dfs(m, 1, [], 1, connect)\n\n\n# 求解染红节点的全组合情况\ndef dfs(m, index, path, count, connect):\n    \"\"\"\n    :param m: 点数量，点从1计数\n    :param index: 当前第几个点\n    :param path: 保存点的容器\n    :param count: 染色方案数量\n    :param connect: 每个节点的相邻节点\n    :return: 染色方案数量\n    \"\"\"\n    if len(path) == m:\n        return count\n\n    flag = False\n\n    for i in range(index, m + 1):\n        #  如果新加入节点和已有节点相邻，则说明新加入节点不能染成红色，需要进行剪枝\n        for p in path:\n            if i in p:\n                flag = True\n                break\n\n        if flag:\n            flag = False\n            continue\n\n        count += 1\n\n        if connect.get(i) is not None:\n            path.append(connect.get(i))\n            count = dfs(m, i + 1, path, count, connect)\n            path.pop()\n        else:\n            count = dfs(m, i + 1, path, count, connect)\n\n    return count\n\n\n# 算法调用\nprint(getResult(arr, m))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet m, n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [m, n] = lines[0].split(\" \").map(Number);\n  }\n\n  if (n !== undefined && lines.length === n + 1) {\n    const arr = lines.slice(1).map((line) => line.split(\" \").map(Number));\n\n    console.log(getResult(arr, m));\n\n    lines.length = 0;\n  }\n});\n\n/**\n *\n * @param {*} arr 边，即[v1, v2]\n * @param {*} m 点数量\n */\nfunction getResult(arr, m) {\n  // connect用于存放每个节点的相邻节点\n  const connect = {};\n\n  for (let [v1, v2] of arr) {\n    connect[v1] ? connect[v1].add(v2) : (connect[v1] = new Set([v2]));\n    connect[v2] ? connect[v2].add(v1) : (connect[v2] = new Set([v1]));\n  }\n\n  // 必有一种全黑的染色方案\n  let count = 1;\n\n  // 求解染红节点的全组合情况\n  function dfs(m, index, path) {\n    if (path.length === m) return;\n\n    outer: for (let i = index; i <= m; i++) {\n      // 如果新加入节点和已有节点相邻，则说明新加入节点不能染成红色，需要进行剪枝\n      for (let j = 0; j < path.length; j++) {\n        if (path[j].has(i)) continue outer;\n      }\n\n      count++;\n\n      if (connect[i] != undefined) {\n        path.push(connect[i]);\n        dfs(m, i + 1, path);\n        path.pop();\n      } else {\n        dfs(m, i + 1, path);\n      }\n    }\n  }\n\n  // 节点从1开始\n  dfs(m, 1, []);\n\n  return count;\n}",
    "cpp": "",
    "c": ""
  }
}