{
  "id": "170",
  "title": "最长方连续方波信号",
  "examType": "A",
  "score": 200,
  "description": "输入一串方波信号，求取最长的完全连续交替方波信号，并将其输出，如果有相同长度的交替方波信号，输出任一即可。方波信号高位用1标识，低位用0标识 。\n说明：\n一个完整的信号一定以0开始然后以0结尾，即010是一个完整信号，但101，1010，0101不是输入的一串方波信号是由一个或多个完整信号组成两个相邻信号之间可能有0个或多个低位，如0110010，011000010同一个信号中可以有连续的高位，如01110101011110001010，前14位是一个具有连续高位的信号完全连续交替方波是指10交替，如01010是完全连续交替方波，0110不是\n输入信号字符串（长度 >= 3 且 <= 1024）：\n例如：0010101010110000101000010\n注：输入总是合法的，不用考虑异常情况\n输出最长的完全连续交替方波信号串\n例如：01010\n若不存在完全连续交替方波信号串，输出 -1。",
  "inputDesc": "",
  "outputDesc": "",
  "examples": [
    {
      "input": "0010101010110000101000010",
      "output": "01010101010",
      "explanation": "最长完全连续交替方波为01010101010，长度11"
    },
    {
      "input": "00110010",
      "output": "010",
      "explanation": "只有010是完全连续交替方波"
    }
  ],
  "solution": "题目要求处理一串由0和1组成的方波信号字符串，从中找出最长的“完全连续交替方波”信号，并输出该信号。如果有多个相同长度的完全连续交替方波信号，则输出任意一个。如果不存在符合要求的信号串，则输出-1。\n完全连续交替方波的定义：\n必须以0开头，以0结尾。中间部分必须是1和0严格交替的形式（例如010，01010等）。例如：01010是一个完全连续交替方波，而0110和101则不是。",
  "codes": {
    "java": "import java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String signal = scanner.nextLine(); // 输入信号字符串\n\n        Pattern pattern = Pattern.compile(\"^(01)+0$\"); // 定义正则表达式匹配完全连续交替方波信号\n\n        int maxLength = 0; // 最长完全连续交替方波信号的长度\n        String result = \"-1\"; // 最长完全连续交替方波信号的字符串\n\n        StringBuilder sb = new StringBuilder(); // 用于存储当前处理的信号\n        for (char c : signal.toCharArray()) {\n            if (c == '0' && sb.length() > 0 && sb.charAt(sb.length() - 1) == '0') { // 当前字符是0，且前一个字符也是0，说明一个完整信号结束\n                Matcher matcher = pattern.matcher(sb.toString()); // 对当前信号进行匹配\n                if (matcher.find() && sb.length() > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n                    maxLength = sb.length(); // 更新最大长度\n                    result = sb.toString(); // 更新最大长度对应的字符串\n                }\n                sb.setLength(0); // 清空当前信号\n            }\n            sb.append(c); // 将当前字符加入当前信号\n        }\n\n        Matcher matcher = pattern.matcher(sb.toString()); // 对最后一个信号进行匹配\n        if (matcher.find() && sb.length() > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n            result = sb.toString(); // 更新最大长度对应的字符串\n        }\n\n        System.out.println(result); // 输出最长的完全连续交替方波信号串\n    }\n}",
    "python": "import re\n\nsignal = input() # 输入信号字符串\n\npattern = re.compile(\"^(01)+0$\") # 定义正则表达式匹配完全连续交替方波信号\n\nmaxLength = 0 # 最长完全连续交替方波信号的长度\nresult = \"-1\" # 最长完全连续交替方波信号的字符串\n\nsb = \"\" # 用于存储当前处理的信号\nfor c in signal:\n    if c == '0' and len(sb) > 0 and sb[-1] == '0': # 当前字符是0，且前一个字符也是0，说明一个完整信号结束\n        matcher = pattern.match(sb) # 对当前信号进行匹配\n        if matcher and len(sb) > maxLength: # 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n            maxLength = len(sb) # 更新最大长度\n            result = sb # 更新最大长度对应的字符串\n        sb = \"\" # 清空当前信号\n\n    sb += c # 将当前字符加入当前信号\n\nmatcher = pattern.match(sb) # 对最后一个信号进行匹配\nif matcher and len(sb) > maxLength: # 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n    result = sb # 更新最大长度对应的字符串\n\nprint(result) # 输出最长的完全连续交替方波信号串",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (signal) => {\n  const pattern = /^(01)+0$/; // 定义正则表达式匹配完全连续交替方波信号\n\n  let maxLength = 0; // 最长完全连续交替方波信号的长度\n  let result = '-1'; // 最长完全连续交替方波信号的字符串\n\n  let sb = ''; // 用于存储当前处理的信号\n  for (let i = 0; i < signal.length; i++) {\n    const c = signal.charAt(i);\n\n    if (c === '0' && sb.length > 0 && sb.charAt(sb.length - 1) === '0') { // 当前字符是0，且前一个字符也是0，说明一个完整信号结束\n      const matcher = sb.match(pattern); // 对当前信号进行匹配\n      if (matcher && sb.length > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n        maxLength = sb.length; // 更新最大长度\n        result = sb; // 更新最大长度对应的字符串\n      }\n      sb = ''; // 清空当前信号\n    }\n\n    sb += c; // 将当前字符加入当前信号\n  }\n\n  const matcher = sb.match(pattern); // 对最后一个信号进行匹配\n  if (matcher && sb.length > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n    result = sb; // 更新最大长度对应的字符串\n  }\n\n  console.log(result); // 输出最长的完全连续交替方波信号串\n\n  rl.close();\n});",
    "cpp": "#include <iostream>\n#include <string>\n#include <regex>\nusing namespace std;\n\nint main() {\n    string signal;\n    getline(cin, signal); // 输入信号字符串\n\n    regex pattern(\"^(01)+0$\"); // 定义正则表达式匹配完全连续交替方波信号\n\n    int maxLength = 0; // 最长完全连续交替方波信号的长度\n    string result = \"-1\"; // 最长完全连续交替方波信号的字符串\n\n    string sb; // 用于存储当前处理的信号\n    for (int i = 0; i < signal.length(); i++) {\n        char c = signal[i];\n\n        if (c == '0' && sb.length() > 0 && sb[sb.length() - 1] == '0') { // 当前字符是0，且前一个字符也是0，说明一个完整信号结束\n            smatch matcher; // 定义匹配结果\n            if (regex_match(sb, matcher, pattern) && sb.length() > maxLength) { // 对当前信号进行匹配，如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n                maxLength = sb.length(); // 更新最大长度\n                result = sb; // 更新最大长度对应的字符串\n            }\n            sb = \"\"; // 清空当前信号\n        }\n\n        sb += c; // 将当前字符加入当前信号\n    }\n\n    smatch matcher; // 对最后一个信号进行匹配\n    if (regex_match(sb, matcher, pattern) && sb.length() > maxLength) { // 如果匹配到完全连续交替方波信号，并且长度大于之前的最大长度\n        result = sb; // 更新最大长度对应的字符串\n    }\n\n    cout << result << endl; // 输出最长的完全连续交替方波信号串\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n// 检查字符串是否匹配\"^(01)+0$\"的模式\nbool is_alternating_wave(const char *str) {\n    int len = strlen(str);\n    \n    // 如果字符串长度小于3，直接返回false\n    if (len < 3) {\n        return false;\n    }\n    \n    // 检查字符串是否以\"01\"开头，并以\"0\"结尾，中间部分要严格交替\n    if (str[0] != '0' || str[len-1] != '0') {\n        return false;\n    }\n    \n    // 遍历字符串中间部分，检查是否严格交替 \"01\"\n    for (int i = 1; i < len - 1; i++) {\n        if (str[i] == str[i-1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    char signal[1025]; // 输入信号字符串，长度最大为1024\n    fgets(signal, sizeof(signal), stdin); // 从标准输入读取信号字符串\n    \n    int maxLength = 0; // 最长的完全连续交替方波信号的长度\n    char result[1025] = \"-1\"; // 最长的完全连续交替方波信号的字符串，默认值为 \"-1\"\n    \n    char sb[1025] = \"\"; // 用于存储当前处理的信号\n    int sb_len = 0; // 当前信号的长度\n    \n    int signal_len = strlen(signal);\n    \n    // 遍历输入的信号字符串\n    for (int i = 0; i < signal_len; i++) {\n        char c = signal[i];\n\n        // 如果遇到两个连续的\"0\"，说明一个完整信号段结束\n        if (c == '0' && sb_len > 0 && sb[sb_len - 1] == '0') {\n            if (is_alternating_wave(sb) && sb_len > maxLength) { // 如果当前信号是完全连续交替方波，并且长度大于之前的最大长度\n                maxLength = sb_len; // 更新最大长度\n                strcpy(result, sb); // 更新最大长度对应的信号串\n            }\n            sb[0] = '\\0'; // 清空当前信号串\n            sb_len = 0; // 重置当前信号长度\n        }\n        \n        // 将当前字符加入当前信号串\n        sb[sb_len++] = c;\n        sb[sb_len] = '\\0';\n    }\n    \n    // 处理最后一个信号段\n    if (is_alternating_wave(sb) && sb_len > maxLength) {\n        strcpy(result, sb); // 更新最大长度对应的信号串\n    }\n    \n    printf(\"%s\\n\", result); // 输出最长的完全连续交替方波信号串\n\n    return 0; // 程序结束\n}"
  }
}