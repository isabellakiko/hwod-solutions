{
  "id": "218",
  "title": "猜密码",
  "examType": "B",
  "score": 200,
  "description": "小杨申请了一个保密柜，但是他忘记了密码。只记得密码都是数字，而且所有数字都是不重复的。\n请你根据他记住的数字范围和密码的最小数字数量，帮他算下有哪些可能的组合，规则如下：\n输出的组合都是从可选的数字范围中选取的，且不能重复；输出的密码数字要按照从小到大的顺序排列，密码组合需要按照字母顺序，从小到大的顺序排序。输出的每一个组合的数字的数量要大于等于密码最小数字数量；如果可能的组合为空，则返回“None”\n",
  "inputDesc": "输入的第一行是可能的密码数字列表，数字间以半角逗号分隔 输入的第二行是密码最小数字数量\n",
  "outputDesc": "可能的密码组合，每种组合显示成一行，每个组合内部的数字以半角逗号分隔，从小到大的顺序排列。\n输出的组合间需要按照字典序排序。 比如：2,3,4放到2,4的前面\n\n字典序是指按照单词出现在字典的顺序进行排序的方法，比如：\n\n最小密码数量是两个，可能有三种组合： 2,3 2,4 3,4\n三个密码有一种： 2,3,4\n\n本题是一道求组合问题。可以利用回溯算法求解。\n\n本题求组合时有如下要求：\n\n输出时：\n\n另外本题没有说明输入的数字是否为单位数，因此需要考虑多位数情况。\n\n本题中树层去重的逻辑可以参考：\n华为OD机试 - 篮球比赛（Java & JS & Python & C）-CSDN博客\n",
  "examples": [],
  "solution": "",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  static int[] nums;\n  static int level;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    nums = Arrays.stream(sc.nextLine().split(\",\")).mapToInt(Integer::parseInt).toArray();\n    level = Integer.parseInt(sc.nextLine());\n\n    System.out.println(getResult());\n  }\n\n  public static String getResult() {\n    // 按照数值大小升序，这样后续形成的组合的内部就是按照数值大小升序的\n    Arrays.sort(nums);\n\n    // 求不重复组合\n    ArrayList<String> res = new ArrayList<>();\n    dfs(0, new LinkedList<>(), res);\n\n    if (res.size() > 0) {\n      // 组合间按照字典序排序\n      res.sort(String::compareTo);\n      return String.join(\"\\n\", res);\n    } else {\n      return \"None\";\n    }\n  }\n\n  public static void dfs(int index, LinkedList<String> path, ArrayList<String> res) {\n    if (path.size() >= level) {\n      // 如果path层数到达level层，则记录该组合\n      res.add(String.join(\",\", path));\n    }\n\n    for (int i = index; i < nums.length; i++) {\n      // 树层去重\n      if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n      path.add(nums[i] + \"\");\n      dfs(i + 1, path, res);\n      path.removeLast();\n    }\n  }\n}",
    "python": "# 输入获取\nnums = list(map(int, input().split(\",\")))\nlevel = int(input())\n\n\ndef dfs(index, path, res):\n    if len(path) >= level:\n        # 如果path层数到达level层，则记录该组合\n        res.append(\",\".join(map(str, path)))\n\n    for i in range(index, len(nums)):\n        # 树层去重\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n\n        path.append(nums[i])\n        dfs(i + 1, path, res)\n        path.pop()\n\n\n# 算法入口\ndef getResult():\n    # 按照数值大小升序，这样后续形成的组合的内部就是按照数值大小升序的\n    nums.sort()\n\n    # 求不重复组合\n    res = []\n    dfs(0, [], res)\n\n    if len(res) > 0:\n        # 组合间按照字典序排序\n        res.sort()\n        return \"\\n\".join(res)\n    else:\n        return \"None\"\n\n\n# 调用算法\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}