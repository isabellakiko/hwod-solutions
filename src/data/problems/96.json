{
  "id": "96",
  "title": "报文响应时间",
  "examType": "A",
  "score": 100,
  "description": "IGMP 协议中，有一个字段称作最大响应时间 (Max Response Time) ，HOST收到查询报文，解折出 MaxResponsetime 字段后，需要在 (0，MaxResponseTime] 时间 (s) 内选取随机时间回应一个响应报文，如果在随机时间内收到一个新的查询报文，则会根据两者时间的大小，选取小的一方刷新回应时间。\n最大响应时间有如下计算方式：\n当 Max Resp Code < 128, Max Resp Time = Max Resp Code；当 Max Resp Code ≥ 128, Max Resp Time = (mant | 0x10) << (exp + 3)；\n\n注: exp最大响应时间的高5~7位: mant 为最大响应时间的低4位。\n其中接收到的MaxRespCode 最大值为 255，以上出现所有字段均为无符号数。\n现在我们认为 HOST收到查询报文时，选取的随机时间必定为最大值，现给出 HOST 收到查询报文个数 C，HOST 收到该报文的时间T，以及查询报文的最大响应时间字段值 M，请计算出HOST 发送响应报文的时间。",
  "inputDesc": "第一行为查询报文个数 C，后续每行分别为 HOST 收到报文时间 T，及最大响应时间M，以空格分割。",
  "outputDesc": "HOST 发送响应报文的时间。\n用例确定只会发送一个响应报文， 不存在计时结束后依然收到查询报文的情况。",
  "examples": [
    {
      "input": "3\n0 20\n1 10\n8 20",
      "output": "11",
      "explanation": "3个报文：0+20=20秒，1+10=11秒，8+20=28秒。最小响应时间为11秒。"
    },
    {
      "input": "2\n0 255\n200 60",
      "output": "260",
      "explanation": "255>=128，计算得31744秒。200+60=260秒。最小为260秒。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟+位运算**问题。\n\n**核心思路：**\n- 计算每个报文的响应时间 = 到达时间 + MaxRespTime\n- 取所有响应时间的最小值\n\n**MaxRespTime计算：**\n- 若 code < 128：直接使用code\n- 若 code >= 128：\n  - exp = (code & 0x70) >> 4（高5-7位）\n  - mant = code & 0x0F（低4位）\n  - MaxRespTime = (mant | 0x10) << (exp + 3)\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main{\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int numQueries = in.nextInt(); // 查询报文个数\n        int[] arrivalTime = new int[numQueries]; // HOST收到报文时间\n        int[] maxRespCode = new int[numQueries]; // 最大响应时间字段值\n\n        for (int i = 0; i < numQueries; i++) {\n            arrivalTime[i] = in.nextInt();\n            maxRespCode[i] = in.nextInt();\n        }\n\n        int minResponseTime = Integer.MAX_VALUE; // HOST发送响应报文的时间\n        for (int i = 0; i < numQueries; i++) {\n            int maxRespTime = 0;\n            if (maxRespCode[i] < 128) { // 当MaxRespCode < 128 ,MaxRespTime = MaxRespCode\n                maxRespTime = maxRespCode[i];\n            } else { // 当MaxRespCode >= 128 ,MaxRespTime = (mant | 0x10) << (exp + 3)\n                int exp = (maxRespCode[i] & 0x70) >> 4; // exp 最大响应时间的 高5~7位\n                int mant = maxRespCode[i] & 0x0F; // mant 为最大响应时间的 低4位\n                maxRespTime = (mant | 0x10) << (exp + 3);\n            }\n            int responseTime = arrivalTime[i] + maxRespTime; // HOST发送响应报文的时间\n            minResponseTime = Math.min(minResponseTime, responseTime); // 更新最小的 HOST发送响应报文的时间\n        }\n        System.out.println(minResponseTime);    \n    }\n}",
    "python": "import sys\n\nnumQueries = int(input()) # 查询报文个数\narrivalTime = [0] * numQueries # HOST收到报文时间\nmaxRespCode = [0] * numQueries # 最大响应时间字段值\n\nfor i in range(numQueries):\n    arrivalTime[i], maxRespCode[i] = map(int, input().split())\n\nminResponseTime = sys.maxsize # HOST发送响应报文的时间\nfor i in range(numQueries):\n    maxRespTime = 0\n    if maxRespCode[i] < 128: # 当MaxRespCode < 128 ,MaxRespTime = MaxRespCode\n        maxRespTime = maxRespCode[i]\n    else: # 当MaxRespCode >= 128 ,MaxRespTime = (mant | 0x10) << (exp + 3)\n        exp = (maxRespCode[i] & 0x70) >> 4 # exp 最大响应时间的 高5~7位\n        mant = maxRespCode[i] & 0x0F # mant 为最大响应时间的 低4位\n        maxRespTime = (mant | 0x10) << (exp + 3)\n    responseTime = arrivalTime[i] + maxRespTime # HOST发送响应报文的时间\n    minResponseTime = min(minResponseTime, responseTime) # 更新最小的 HOST发送响应报文的时间\n\nprint(minResponseTime)",
    "javascript": "const readline = require('readline');  \n\n \nconst rl = readline.createInterface({\n  input: process.stdin,  \n  output: process.stdout  \n});\n\nlet numQueries; // 存储查询的数量\nlet arrivalTime = []; // 存储每次查询的到达时间\nlet maxRespCode = []; // 存储每次查询的最大响应码\n\n \nrl.on('line', (input) => {\n  // 首次输入，用于获取查询的数量\n  if (!numQueries) {\n    numQueries = parseInt(input); // 解析输入为整数，并存储到 numQueries\n  } else {\n    // 分割输入的两个数值，并将其转换为数字类型\n    const [a, b] = input.split(' ').map(Number);\n    arrivalTime.push(a); // 将到达时间存入 arrivalTime 数组\n    maxRespCode.push(b); // 将最大响应码存入 maxRespCode 数组\n\n    // 当输入的查询数达到指定的数量时，开始处理计算\n    if (arrivalTime.length === numQueries) {\n      let minResponseTime = Number.MAX_SAFE_INTEGER; // 初始化最小响应时间为一个很大的值\n      for (let i = 0; i < numQueries; i++) { // 遍历每个查询\n        let maxRespTime = 0; // 用于存储当前查询的最大响应时间\n\n        // 根据 maxRespCode 的值决定计算方式\n        if (maxRespCode[i] < 128) {\n          maxRespTime = maxRespCode[i]; // 如果 maxRespCode 小于 128，直接使用其值作为 maxRespTime\n        } else {\n          // 如果 maxRespCode 大于等于 128，进行复杂计算\n          const exp = (maxRespCode[i] & 0x70) >> 4; // 提取 maxRespCode 的第 4 至 6 位作为 exp\n          const mant = maxRespCode[i] & 0x0F; // 提取 maxRespCode 的第 1 至 3 位作为 mant\n          maxRespTime = (mant | 0x10) << (exp + 3); // 计算 maxRespTime 的实际值\n        }\n\n        // 计算当前查询的响应时间\n        const responseTime = arrivalTime[i] + maxRespTime;\n        // 更新最小响应时间\n        minResponseTime = Math.min(minResponseTime, responseTime);\n      }\n      console.log(minResponseTime); // 输出最小响应时间\n      rl.close(); // 关闭 readline 接口\n    }\n  }\n});",
    "cpp": "#include <iostream>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int numQueries;\n    cin >> numQueries; // 查询报文个数\n    int arrivalTime[numQueries]; // HOST收到报文时间\n    int maxRespCode[numQueries]; // 最大响应时间字段值\n\n    for (int i = 0; i < numQueries; i++) {\n        cin >> arrivalTime[i];\n        cin >> maxRespCode[i];\n    }\n\n    int minResponseTime = INT_MAX; // HOST发送响应报文的时间\n    for (int i = 0; i < numQueries; i++) {\n        int maxRespTime = 0;\n        if (maxRespCode[i] < 128) { // 当MaxRespCode < 128 ,MaxRespTime = MaxRespCode\n            maxRespTime = maxRespCode[i];\n        } else { // 当MaxRespCode >= 128 ,MaxRespTime = (mant | 0x10) << (exp + 3)\n            int exp = (maxRespCode[i] & 0x70) >> 4; // exp 最大响应时间的 高5~7位\n            int mant = maxRespCode[i] & 0x0F; // mant 为最大响应时间的 低4位\n            maxRespTime = (mant | 0x10) << (exp + 3);\n        }\n        int responseTime = arrivalTime[i] + maxRespTime; // HOST发送响应报文的时间\n        minResponseTime = min(minResponseTime, responseTime); // 更新最小的 HOST发送响应报文的时间\n    }\n    cout << minResponseTime << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <limits.h> \n\nint main() {\n    int numQueries;\n    scanf(\"%d\", &numQueries);  \n\n    int arrivalTime[numQueries]; // 定义数组存储 HOST 收到报文的时间\n    int maxRespCode[numQueries]; // 定义数组存储最大响应时间字段值\n\n    // 读取每个查询的到达时间和最大响应码\n    for (int i = 0; i < numQueries; i++) {\n        scanf(\"%d\", &arrivalTime[i]); // 读取到达时间\n        scanf(\"%d\", &maxRespCode[i]); // 读取最大响应码\n    }\n\n    int minResponseTime = INT_MAX; // 初始化最小响应时间为最大整数值\n\n    // 遍历所有查询，计算最小的响应时间\n    for (int i = 0; i < numQueries; i++) {\n        int maxRespTime = 0; // 初始化最大响应时间为0\n\n        // 判断 maxRespCode 的值以决定如何计算最大响应时间\n        if (maxRespCode[i] < 128) {\n            // 如果 maxRespCode 小于 128，直接将其作为 maxRespTime\n            maxRespTime = maxRespCode[i];\n        } else {\n            // 如果 maxRespCode 大于等于 128，根据给定的公式计算 maxRespTime\n            int exp = (maxRespCode[i] & 0x70) >> 4; // 提取 maxRespCode 的第 4 至 6 位作为 exp\n            int mant = maxRespCode[i] & 0x0F; // 提取 maxRespCode 的第 1 至 3 位作为 mant\n            maxRespTime = (mant | 0x10) << (exp + 3); // 计算 maxRespTime 的实际值\n        }\n\n        // 计算当前查询的响应时间\n        int responseTime = arrivalTime[i] + maxRespTime;\n\n        // 更新最小的响应时间\n        if (responseTime < minResponseTime) {\n            minResponseTime = responseTime;\n        }\n    }\n\n    // 输出最小的响应时间\n    printf(\"%d\\n\", minResponseTime);\n\n    return 0; // 程序正常结束\n}"
  }
}