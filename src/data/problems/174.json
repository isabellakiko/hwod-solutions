{
  "id": "174",
  "title": "计算疫情扩散时间",
  "examType": "A",
  "score": 200,
  "description": "在一个地图中(地图由n*n个区域组成），有部分区域被感染病菌。 感染区域每天都会把周围（上下左右）的4个区域感染。 请根据给定的地图计算，多少天以后，全部区域都会被感染。 如果初始地图上所有区域全部都被感染，或者没有被感染区域，返回-1",
  "inputDesc": "一行N*N个数字（只包含0,1，不会有其他数字）表示一个地图，数字间用,分割，0表示未感染区域，1表示已经感染区域\n每N个数字表示地图中一行，输入数据共表示N行N列的区域地图。\n例如输入1,0,1,0,0,0,1,0,1，表示地图\n123",
  "outputDesc": "一个整数，表示经过多少天以后，全部区域都被感染 1<=N<200",
  "examples": [
    {
      "input": "1,0,1,0,0,0,1,0,1",
      "output": "2",
      "explanation": "1天以后，地图中仅剩余中心点未被感染；2天以后，全部被感染。"
    },
    {
      "input": "1,1,1,1,1,1,1,1,1",
      "output": "-1",
      "explanation": "全部都感染"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**BFS广度优先搜索**问题。\n\n**核心思路：**\n- 多源BFS，从所有感染点同时扩散\n- 每天向四周扩散一格\n- 统计全部感染所需天数\n\n**算法步骤：**\n1. 将所有初始感染点入队\n2. BFS逐层扩散，每层代表一天\n3. 感染未感染的相邻区域\n4. 返回扩散完成的天数\n\n**时间复杂度**：O(N²)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine();\n        List<Integer> map = new ArrayList<>();\n        int pos = 0;\n        String token;\n        while ((pos = input.indexOf(\",\")) != -1) { // 将输入字符串转换为一维数组\n            token = input.substring(0, pos);\n            map.add(Integer.parseInt(token));\n            input = input.substring(pos + 1);\n        }\n        map.add(Integer.parseInt(input));\n        System.out.println(getInfectionDays(map)); // 输出感染天数\n    }\n\n    public static int getInfectionDays(List<Integer> map) {\n        int n = (int) Math.sqrt(map.size());\n\n        int[][] matrix = new int[n][n]; // 将一维数组转换为二维矩阵\n\n        Queue<int[]> q = new LinkedList<>(); // 用队列存储感染区域\n\n        int healthy = 0; // 记录未感染区域数量\n\n        int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 记录四个方向的偏移量\n\n        for (int i = 0; i < n * n; i++) {\n            int x = i / n;\n            int y = i % n;\n            matrix[x][y] = map.get(i); // 将一维数组转换为二维矩阵\n            if (matrix[x][y] == 1) {\n                q.offer(new int[]{x, y}); // 将感染区域加入队列\n            } else {\n                healthy++; // 计算未感染区域数量\n            }\n        }\n\n        if (healthy == 0 || healthy == n * n) { // 判断特殊情况\n            return -1;\n        }\n\n        int day = 0; // 记录感染天数\n        while (!q.isEmpty() && healthy > 0) { // 当队列不为空且还有未感染区域时，进行循环\n            int[] tmp = q.poll(); // 取出队首元素\n            int x = tmp[0], y = tmp[1]; // 获取队首元素的坐标\n            day = matrix[x][y] + 1; // 记录感染天数\n\n            for (int[] offset : offsets) { // 遍历四个方向\n                int newX = x + offset[0]; // 新的横坐标\n                int newY = y + offset[1]; // 新的纵坐标\n\n                if (newX >= 0 && newX < n && newY >= 0 && newY < n && matrix[newX][newY] == 0) { // 判断边界和未感染区域\n                    healthy--; // 未感染区域数量减一\n                    matrix[newX][newY] = day; // 标记该区域已感染\n                    q.offer(new int[]{newX, newY}); // 将该区域加入队列\n                }\n            }\n        }\n\n        return day - 1; // 返回感染天数\n    }\n}",
    "python": "import math\nfrom queue import Queue\n\ndef getInfectionDays(map):\n    # 计算地图边长，即每一行（或列）的元素个数\n    n = int(math.sqrt(len(map)))\n    \n    # 构建二维矩阵表示地图，初始值为0\n    matrix = [[0 for j in range(n)] for i in range(n)]\n    \n    # 初始化一个队列，用于存放已感染区域的位置\n    q = Queue()\n    \n    # 遍历地图，将已感染区域的坐标入队，并初始化二维矩阵\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = map[i * n + j]\n            if matrix[i][j] == 1:\n                q.put((i, j))\n    \n    # 如果队列为空（没有感染区域）或所有区域都已被感染，返回-1\n    if q.empty() or q.qsize() == len(map):\n        return -1\n    \n    # 计算未感染区域的数量\n    healthy = len(map) - q.qsize()\n    \n    # 定义四个方向的偏移量（上下左右）\n    offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]]\n    \n    # 初始化天数计数器\n    day = 0\n    \n    # 广度优先搜索，通过队列逐层扩散感染\n    while not q.empty() and healthy > 0:\n        tmp = q.get()\n        x, y = tmp[0], tmp[1]\n        day = matrix[x][y] + 1  # 更新天数\n        \n        # 对当前节点的四个方向进行探索\n        for offset in offsets:\n            new_x = x + offset[0]\n            new_y = y + offset[1]\n            \n            # 检查新坐标是否越界\n            if new_x < 0 or new_x >= n or new_y < 0 or new_y >= n:\n                continue\n            \n            # 如果新坐标的区域未被感染，则将其感染，并将其加入队列\n            if matrix[new_x][new_y] == 0:\n                healthy -= 1\n                matrix[new_x][new_y] = day\n                q.put((new_x, new_y))\n    \n    # 返回全部区域被感染所需的天数，由于最后一天的增加已在循环中完成，故减1\n    return day - 1\n\n# 读取输入，并转换成整数列表\ninput_str = input()\ninput_list = list(map(int, input_str.split(\",\")))\n\n# 输出计算结果\nprint(getInfectionDays(input_list))",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nfunction getInfectionDays(map) {\n  const n = Math.sqrt(map.length);\n\n  const matrix = new Array(n).fill().map(() => new Array(n)); // 将一维数组转换为二维矩阵\n\n  const q = []; // 用队列存储感染区域\n\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      matrix[i][j] = map[i * n + j]; // 将一维数组转换为二维矩阵\n      if (matrix[i][j] === 1) q.push([i, j]); // 将感染区域加入队列\n    }\n  }\n\n  if (q.length === 0 || q.length === map.length) { // 判断特殊情况\n    return -1;\n  }\n\n  let healthy = map.length - q.length; // 记录未感染区域数量\n\n  const offsets = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 记录四个方向的偏移量\n\n  let day = 0; // 记录感染天数\n  while (q.length > 0 && healthy > 0) { // 当队列不为空且还有未感染区域时，进行循环\n    const [x, y] = q.shift(); // 取出队首元素\n    day = matrix[x][y] + 1; // 记录感染天数\n\n    for (const offset of offsets) { // 遍历四个方向\n      const [dx, dy] = offset;\n      const newX = x + dx; // 新的横坐标\n      const newY = y + dy; // 新的纵坐标\n\n      if (newX < 0 || newX >= n || newY < 0 || newY >= n) continue; // 判断边界\n\n      if (matrix[newX][newY] === 0) { // 如果该区域未感染\n        healthy--; // 未感染区域数量减一\n        matrix[newX][newY] = day; // 标记该区域已感染\n        q.push([newX, newY]); // 将该区域加入队列\n      }\n    }\n  }\n\n  return day - 1; // 返回感染天数\n}\n\nrl.on('line', (input) => {\n  const map = input.split(',').map(Number);\n  console.log(getInfectionDays(map));\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\nusing namespace std;\n\nint getInfectionDays(vector<int>& map) {\n    int n = sqrt(map.size());\n\n    vector<vector<int>> matrix(n, vector<int>(n)); // 将一维数组转换为二维矩阵\n\n    queue<pair<int, int>> q; // 用队列存储感染区域\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            matrix[i][j] = map[i * n + j]; // 将一维数组转换为二维矩阵\n            if (matrix[i][j] == 1) q.push({i, j}); // 将感染区域加入队列\n        }\n    }\n\n    if (q.empty() || q.size() == map.size()) { // 判断特殊情况\n        return -1;\n    }\n\n    int healthy = map.size() - q.size(); // 记录未感染区域数量\n\n    vector<vector<int>> offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 记录四个方向的偏移量\n\n    int day = 0; // 记录感染天数\n    while (!q.empty() && healthy > 0) { // 当队列不为空且还有未感染区域时，进行循环\n        pair<int, int> tmp = q.front(); // 取出队首元素\n        q.pop(); // 弹出队首元素\n        int x = tmp.first, y = tmp.second; // 获取队首元素的坐标\n        day = matrix[x][y] + 1; // 记录感染天数\n\n        for (vector<int>& offset : offsets) { // 遍历四个方向\n            int newX = x + offset[0]; // 新的横坐标\n            int newY = y + offset[1]; // 新的纵坐标\n\n            if (newX < 0 || newX >= n || newY < 0 || newY >= n) continue; // 判断边界\n\n            if (matrix[newX][newY] == 0) { // 如果该区域未感染\n                healthy--; // 未感染区域数量减一\n                matrix[newX][newY] = day; // 标记该区域已感染\n                q.push({newX, newY}); // 将该区域加入队列\n            }\n        }\n    }\n\n    return day - 1; // 返回感染天数\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n    vector<int> map;\n    size_t pos = 0;\n    string token;\n    while ((pos = input.find(\",\")) != string::npos) { // 将输入字符串转换为一维数组\n        token = input.substr(0, pos);\n        map.push_back(stoi(token));\n        input.erase(0, pos + 1);\n    }\n    map.push_back(stoi(input));\n    cout << getInfectionDays(map) << endl; // 输出感染天数\n    return 0;\n}",
    "c": ""
  }
}