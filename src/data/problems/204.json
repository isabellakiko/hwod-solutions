{
  "id": "204",
  "title": "Excel单元格数值统计",
  "examType": "B",
  "score": 200,
  "description": "Excel工作表中对选定区域的数值进行统计的功能非常实用。\n仿照Excel的这个功能，请对给定表格中选中区域中的单元格进行求和统计，并输出统计结果。\n为简化计算，假设当前输入中每个单元格内容仅为数字或公式两种。\n如果为数字，则是一个非负整数，形如3、77\n如果为公式，则固定以=开头，且仅包含下面三种情况：\n等于某单元格的值，例如=B12两个单元格的双目运算（仅为+或-），形如=C1-C2、C3+B2单元格和数字的双目运算（仅为+或-），形如=B1+1、100-B2\n注意：\n公式内容都是合法的，例如不存在，=C+1、=C1-C2+B3,=5、=3+5不存在循环引用，例如A1=B1+C1、C1=A1+B2内容中不存在空格、括号\n",
  "inputDesc": "第一行两个整数rows cols，表示给定表格区域的行数和列数，1<=rows<=20，1<=cols<=26。 接下来rows行，每行cols个以空格分隔的字符串，表示给定表格values的单元格内容。 最后一行输入的字符串，表示给定的选中区域，形如A1:C2。\n",
  "outputDesc": "一个整数，表示给定选中区域各单元格中数字的累加总和，范围-2,147,483,648 ~ 2,147,483,647\n\n\n\n\n本题逻辑不难，但是实现起来比较麻烦。\n我的解题思路如下：\n首先，要搞清楚Excel表格坐标和matrix输入矩阵的索引的对应关系，比如上面用例中，输入的matrix矩阵为：[ [\"1\", \"=A1+C1\", \"3\"] ]\n其中“1”值，对应矩阵 martix[0][0]，而对应的Excel表格坐标是A1，其中A代表列号，1代表行号。\n因此，我们容易得到Excel表格坐标和matrix输入矩阵的索引的对应关系：\n\n解下来，我们需要弄清楚，如何将Excel坐标，如A1，B2，C3中的列号和行号解析出来，因为只有解析出来，才能方便处理，之后才能对应到matrix的索引。\n这里我们使用了正则表达式的捕获组，正则为：/^(A-Z)(\\d+)$/\n\n\n接下来，我们就可以实现根据Excel坐标，获取到matrix矩阵元素的逻辑了，我们定义一个方法getCell，入参Excel坐标，然后通过上面的正则解析出来对应列号、行号，然后再根据Excel列号、行号转化求得matrix矩阵的行索引、列索引，进而求得matrix矩阵对应索引的值。\n\n此时，取得的值有两类：\n1、非公式的值，比如1\n2、公式，以=开头\n\n对于非公式的值，直接将其转为数值后返回；\n对于公式，又分为三种情况：\n我们可以通过getCell方法获取到Excel坐标对应的值，然后再来运算\n",
  "examples": [
    {
      "input": "1 3\n1 =A1+C1 3\nA1:C1",
      "output": "8",
      "explanation": "A1=1，B1=A1+C1=1+3=4，C1=3，总和1+4+3=8"
    },
    {
      "input": "2 2\n1 2\n=A1 =B1-A1\nA1:B2",
      "output": "4",
      "explanation": "A1=1,B1=2,A2=1,B2=1，总和1+2+1+1=5，错误应该是4"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**递归求值模拟**问题。\n\n**核心思路：**\n- 解析单元格坐标与矩阵索引映射\n- 递归计算公式单元格的值\n\n**算法步骤：**\n1. 解析选中区域坐标范围\n2. 遍历区域内每个单元格\n3. 若是数字直接取值，若是公式递归求值\n4. 累加所有单元格值\n\n**时间复杂度**：O(M*N)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n  static String[][] table; // 给定表格区域\n  static int rows; // 给定表格区域的行数\n  static int cols; // 给定表格区域的列数\n  static String start; // 选中区域的左上角位置\n  static String end; // 选中区域的右下角位置\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    rows = sc.nextInt();\n    cols = sc.nextInt();\n\n    table = new String[rows][cols];\n    for (int i = 0; i < rows; i++) {\n      for (int j = 0; j < cols; j++) {\n        table[i][j] = sc.next();\n      }\n    }\n\n    String[] range = sc.next().split(\":\");\n    start = range[0];\n    end = range[1];\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    int[] s = getPos(start);\n    int[] e = getPos(end);\n\n    int r1 = s[0], c1 = s[1];\n    int r2 = e[0], c2 = e[1];\n\n    int ans = 0;\n    for (int i = r1; i <= r2; i++) {\n      for (int j = c1; j <= c2; j++) {\n        ans += getCellVal(table[i][j]);\n      }\n    }\n\n    return ans;\n  }\n\n  // 获取单元格的值\n  public static int getCellVal(String cell) {\n    /*\n     * 单元格内容cell如果以'='开头，则必然是公式\n     * */\n    if (cell.charAt(0) == '=') {\n      // fn是公式内容\n      String fn = cell.substring(1);\n\n      // 如果公式内容fn包含“+”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n      if (fn.contains(\"+\")) {\n        return operate(fn.split(\"\\\\+\"), true);\n      }\n      // 如果公式内容fn包含“-”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n      else if (fn.contains(\"-\")) {\n        return operate(fn.split(\"-\"), false);\n      }\n      // 如果公式内容fn不包含“+”和“-”，则必然等于某单元格的值，例如=B12\n      else {\n        return getPosVal(getPos(fn));\n      }\n    }\n    /*\n     * 单元格内容cell如果不以'='开头，则必然是数字，且是非负正数\n     * */\n    else {\n      return Integer.parseInt(cell);\n    }\n  }\n\n  // 双目运算\n  public static int operate(String[] ops, boolean isAdd) {\n    int op1, op2;\n\n    if (isPos(ops[0])) {\n      // 如果操作数1是单元格\n      op1 = getPosVal(getPos(ops[0]));\n    } else {\n      // 如果操作数1是数字\n      op1 = Integer.parseInt(ops[0]);\n    }\n\n    if (isPos(ops[1])) {\n      // 如果操作数2是单元格\n      op2 = getPosVal(getPos(ops[1]));\n    } else {\n      // 如果操作数2是数字\n      op2 = Integer.parseInt(ops[1]);\n    }\n\n    if (isAdd) {\n      // 加法运算\n      return op1 + op2;\n    } else {\n      // 减法运算\n      return op1 - op2;\n    }\n  }\n\n  // 解析单元格坐标  为  矩阵坐标\n  public static int[] getPos(String pos) {\n    int c = pos.charAt(0) - 65;\n    int r = Integer.parseInt(pos.substring(1)) - 1;\n    return new int[] {r, c};\n  }\n\n  // 获取矩阵对应坐标的值，并且更新矩阵对应单元格的内容\n  public static int getPosVal(int[] pos) {\n    int r = pos[0], c = pos[1];\n    int val = getCellVal(table[r][c]);\n    table[r][c] = val + \"\";\n    return val;\n  }\n\n  // 判断一个内容是否为单元格坐标\n  public static boolean isPos(String str) {\n    char c = str.charAt(0);\n    return c <= 'Z' && c >= 'A';\n  }\n}",
    "python": "# 输入获取\nrows, cols = list(map(int, input().split()))\ntable = [input().split() for _ in range(rows)]\nstart, end = input().split(\":\")\n\n\n# 判断一个内容是否为单元格坐标\ndef isPos(pos):\n    return \"Z\" >= pos[0] >= 'A'\n\n\n# 解析单元格坐标  为  矩阵坐标\ndef getPos(pos):\n    c = ord(pos[0]) - 65\n    r = int(pos[1:]) - 1\n    return r, c\n\n\n# 获取矩阵对应坐标的值，并且更新矩阵对应单元格的内容\ndef getPosVal(pos):\n    r, c = pos\n    table[r][c] = getCellVal(table[r][c])\n    return table[r][c]\n\n\n# 双目运算\ndef operate(ops, isAdd):\n    op1 = 0\n    op2 = 0\n\n    if isPos(ops[0]):\n        # 如果操作数1是单元格\n        op1 = getPosVal(getPos(ops[0]))\n    else:\n        # 如果操作数1是数字\n        op1 = int(ops[0])\n\n    if isPos(ops[1]):\n        op2 = getPosVal(getPos(ops[1]))\n    else:\n        op2 = int(ops[1])\n\n    if isAdd:\n        return op1 + op2\n    else:\n        return op1 - op2\n\n\n# 获取单元格的值\ndef getCellVal(cell):\n    cell = str(cell)\n    # 单元格内容cell如果以'='开头，则必然是公式\n    if cell[0] == \"=\":\n        # fn是公式内容\n        fn = cell[1:]\n\n        # 如果公式内容fn包含“+”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n        if fn.find(\"+\") != -1:\n            return operate(fn.split(\"+\"), True)\n        # 如果公式内容fn包含“-”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n        elif fn.find(\"-\") != -1:\n            return operate(fn.split(\"-\"), False)\n        # 如果公式内容fn不包含“+”和“-”，则必然等于某单元格的值，例如=B12\n        else:\n            return getPosVal(getPos(fn))\n    # 单元格内容cell如果不以'='开头，则必然是数字，且是非负正数\n    else:\n        return int(cell)\n\n\n# 算法入口\ndef getResult():\n    r1, c1 = getPos(start)\n    r2, c2 = getPos(end)\n\n    ans = 0\n    for i in range(r1, r2 + 1):\n        for j in range(c1, c2 + 1):\n            ans += getCellVal(table[i][j])\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst { get } = require(\"http\");\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\n\nlet table, rows, cols, start, end;\n\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [rows, cols] = lines[0].split(\" \").map(Number);\n  }\n\n  if (rows && lines.length === rows + 2) {\n    lines.shift();\n    [start, end] = lines.pop().split(\":\");\n    table = lines.map((line) => line.split(\" \"));\n    console.log(getResult());\n    lines.length = 0;\n  }\n});\n\nfunction getResult() {\n  const [r1, c1] = getPos(start);\n  const [r2, c2] = getPos(end);\n\n  let ans = 0;\n  for (let i = r1; i <= r2; i++) {\n    for (let j = c1; j <= c2; j++) {\n      ans += getCellVal(table[i][j]);\n    }\n  }\n\n  return ans;\n}\n\n// 判断一个内容是否为单元格坐标\nfunction isPos(s) {\n  return s[0] <= \"Z\" && s[0] >= \"A\";\n}\n\n// 解析单元格坐标  为  矩阵坐标\nfunction getPos(pos) {\n  const c = pos[0].charCodeAt() - 65;\n  const r = pos.slice(1) - 1;\n  return [r, c];\n}\n\n// 获取矩阵对应坐标的值，并且更新矩阵对应单元格的内容\nfunction getPosVal(pos) {\n  const [r, c] = pos;\n  table[r][c] = getCellVal(table[r][c]);\n  return table[r][c];\n}\n\n// 双目运算\nfunction operate(ops, isAdd) {\n  let op1, op2;\n\n  if (isPos(ops[0])) {\n    // 如果操作数1是单元格\n    op1 = getPosVal(getPos(ops[0]));\n  } else {\n    // 如果操作数1是数字\n    op1 = parseInt(ops[0]);\n  }\n\n  if (isPos(ops[1])) {\n    // 如果操作数2是单元格\n    op2 = getPosVal(getPos(ops[1]));\n  } else {\n    // 如果操作数2是数字\n    op2 = parseInt(ops[1]);\n  }\n\n  if (isAdd) {\n    // 加法运算\n    return op1 + op2;\n  } else {\n    // 减法运算\n    return op1 - op2;\n  }\n}\n\n// 获取单元格的值\nfunction getCellVal(cell) {\n  /*\n   * 单元格内容cell如果以'='开头，则必然是公式\n   * */\n  if (cell[0] == \"=\") {\n    // fn是公式内容\n    const fn = cell.slice(1);\n\n    // 如果公式内容fn包含“+”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n    if (fn.indexOf(\"+\") != -1) {\n      return operate(fn.split(\"+\"), true);\n    } else if (fn.indexOf(\"-\") != -1) {\n      // 如果公式内容fn包含“-”，则可能是两个单元格的双目运算，也可能是单元格和数字的双目运算\n      return operate(fn.split(\"-\"), false);\n    } else {\n      // 如果公式内容fn不包含“+”和“-”，则必然等于某单元格的值，例如=B12\n      return getPosVal(getPos(fn));\n    }\n  } else {\n    /*\n     * 单元格内容cell如果不以'='开头，则必然是数字，且是非负正数\n     * */\n    return parseInt(cell);\n  }\n}",
    "cpp": "",
    "c": ""
  }
}