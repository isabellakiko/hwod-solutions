{
  "id": "155",
  "title": "最优资源分配",
  "examType": "A",
  "score": 200,
  "description": "某块业务芯片最小容量单位为1.25G，总容量为M*1.25G，对该芯片资源编号为1，2，...，M。该芯片支持3种不同的配置，分别为A、B、C。\n配置A：占用容量为 1.25 * 1 = 1.25G配置B：占用容量为 1.25 * 2 = 2.5G配置C：占用容量为 1.25 * 8 = 10G\n某块板卡上集成了N块上述芯片，对芯片编号为1，2，...，N，各个芯片之间彼此独立，不能跨芯片占用资源。\n给定板卡上芯片数量N、每块芯片容量M、用户按次序配置后，请输出芯片资源占用情况，保证消耗的芯片数量最少。\n\n资源分配规则：按照芯片编号从小到大分配所需资源，芯片上资源如果被占用标记为1，没有被占用标记为0.\n用户配置序列：用户配置是按次序依次配置到芯片中，如果用户配置序列种某个配置超过了芯片总容量，丢弃该配置，继续遍历用户后续配置。\n",
  "inputDesc": "M：每块芯片容量为 M * 1.25G，取值范围为：1~256\nN：每块板卡包含芯片数量，取值范围为1~32\n用户配置序列：例如ACABA，长度不超过1000\n",
  "outputDesc": "板卡上每块芯片的占用情况\n\n用户配置是按次序依次配置到芯片中，如果用户配置序列种某个配置超过了芯片总容量，丢弃该配置，继续遍历用户后续配置。\n\n用户第1个配置A：占用第1块芯片第1个资源，芯片占用情况为：\n10000000\n00000000\n用户第2个配置C：第1块芯片剩余8.75G，配置C容量不够，只能占用第2块芯片，芯片占用情况为：\n10000000\n11111111\n用户第3个配置A：第1块芯片剩余8.75G，还能继续配置，占用第1块芯片第2个资源，芯片占用情况为：\n11000000\n11111111\n用户第4个配置B：第1块芯片剩余7.5G，还能继续配置，占用第1块芯片第3、4个资源，芯片占用情况为：\n11110000\n11111111\n用户第5个配置A：第1块芯片剩余5G，还能继续配置，占用第1块芯片第5个资源，芯片占用情况为：\n11111000\n11111111\n用户第1个配置A：占用第1块芯片第1个资源，芯片占用情况为：\n10000000\n00000000\n用户第2个配置C：第1块芯片剩余8.75G，配置C容量不够，只能占用第2块芯片，芯片占用情况为：\n10000000\n11111111\n用户第3个配置B：第1块芯片剩余8.75G，还能继续配置，占用第1块芯片第2、3个资源，芯片占用情况为：\n11100000\n11111111\n用户第4个配置C：芯片资源不够，丢弃配置，继续下一个配置，本次配置后芯片占用情况保持不变：\n11100000\n11111111\n用户第5个配置B：第1块芯片剩余6.25G,还能继续配置，占用第1块芯片第4、5个资源，芯片占用情况为：\n11111000\n11111111\n本题输出比较难以理解，我这里以用例1解释一下：\n用例1的前两行输入表示：\n板卡上有N=2个芯片，而每个芯片有8个单位容量，因此对应如下：\n00000000\n00000000\n其中每个0代表一个单位容量，而一个芯片有8单位容量，因此第一排8个0代表一个芯片的总容量，第二排8个0代表另一个芯片的总容量。\n理解了这个，本题就不难了。\n",
  "examples": [
    {
      "input": "8\n2\nACABA",
      "output": "11111000\n11111111",
      "explanation": "芯片容量8单位。A占1,C占8(芯片1不够用芯片2),A占1,B占2,A占1。芯片1用5,芯片2用8"
    },
    {
      "input": "8\n2\nABCCB",
      "output": "11100000\n11111111",
      "explanation": "A占1,B占2,C占8(用芯片2),第二个C无法放置丢弃,B占2。芯片1用3,芯片2用8"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟**问题。\n\n**核心思路：**\n- 按顺序处理配置序列\n- 贪心地从编号小的芯片开始分配\n- 容量不足则丢弃该配置\n\n**算法步骤：**\n1. 初始化N个芯片，每个容量M×1.25G\n2. 遍历配置序列，A占1单位，B占2单位，C占8单位\n3. 从芯片1开始找能容纳的芯片\n4. 找到则扣减容量，找不到则丢弃\n5. 输出每个芯片的占用情况(1已用,0未用)\n\n**时间复杂度**：O(L×N)，L为配置序列长度",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n    String sequence = sc.next();\n\n    getResult(m, n, sequence);\n  }\n\n  public static void getResult(int m, int n, String sequence) {\n    double[] boardCard = new double[n];\n    Arrays.fill(boardCard, m * 1.25);\n\n    HashMap<Character, Integer> dict = new HashMap<>();\n    dict.put('A', 1);\n    dict.put('B', 2);\n    dict.put('C', 8);\n\n    for (int i = 0; i < sequence.length(); i++) {\n      double need = 1.25 * dict.get(sequence.charAt(i));\n      for (int j = 0; j < n; j++) {\n        if (boardCard[j] >= need) {\n          boardCard[j] -= need;\n          break;\n        }\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      int unUsed = (int) (boardCard[i] / 1.25);\n      int used = m - unUsed;\n\n      StringBuilder sb = new StringBuilder();\n      for (int j = 0; j < used; j++) {\n        sb.append(1);\n      }\n      for (int k = 0; k < unUsed; k++) {\n        sb.append(0);\n      }\n      System.out.println(sb);\n    }\n  }\n}",
    "python": "# 输入获取\nm = int(input())\nn = int(input())\nsequence = input()\n\n\n# 算法入口\ndef getResult(m, n, sequence):\n    boardCard = [m * 1.25] * n\n    mapping = {\"A\": 1, \"B\": 2, \"C\": 8}\n\n    for i in range(len(sequence)):\n        need = 1.25 * mapping[sequence[i]]\n        for j in range(n):\n            if boardCard[j] >= need:\n                boardCard[j] -= need\n                break\n\n    for remain in boardCard:\n        unUsed = int(remain / 1.25)\n        used = m - unUsed\n        print('1' * used + '0' * unUsed)\n\n\n# 算法调用\ngetResult(m, n, sequence)",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 3) {\n    let m = lines[0] - 0;\n    let n = lines[1] - 0;\n    let sequence = lines[2];\n\n    getResult(m, n, sequence);\n    lines.length = 0;\n  }\n});\n\nfunction getResult(m, n, sequence) {\n  boardCard = new Array(n).fill(0).map(() => m * 1.25);\n\n  dict = { A: 1, B: 2, C: 8 };\n\n  for (let i = 0; i < sequence.length; i++) {\n    const need = 1.25 * dict[sequence[i]];\n    for (let j = 0; j < n; j++) {\n      if (boardCard[j] >= need) {\n        boardCard[j] -= need;\n        break;\n      }\n    }\n  }\n\n  boardCard.forEach((remain) => {\n    unUsed = remain / 1.25;\n    used = m - unUsed;\n    console.log(\n      new Array(used).fill(1).join(\"\") + new Array(unUsed).fill(0).join(\"\")\n    );\n  });\n}",
    "cpp": "",
    "c": ""
  }
}