{
  "id": "26",
  "title": "报数游戏",
  "examType": "A",
  "score": 100,
  "description": "100个人围成一圈，每个人有一个编码，编号从1开始到100。\n他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。\n请问最后剩余的人在原先的编号为多少？",
  "inputDesc": "输入一个整数参数 M",
  "outputDesc": "如果输入参数M小于等于1或者大于等于100，输出“ERROR!”；\n否则按照原先的编号从小到大的顺序，以英文逗号分割输出编号字符串",
  "examples": [
    {
      "input": "3",
      "output": "58,91",
      "explanation": "M=3，100人围成一圈，每报到3的人退出。\n不断重复直到剩余人数小于3。\n最后剩下的人编号为58和91。"
    },
    {
      "input": "4",
      "output": "34,45,97",
      "explanation": "M=4，100人围成一圈，每报到4的人退出。\n最后剩下3人，编号为34、45、97。"
    },
    {
      "input": "1",
      "output": "ERROR!",
      "explanation": "M=1不满足 1<M<100 的条件，输出ERROR!"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**约瑟夫环**问题的变种。\n\n**算法步骤：**\n\n1. **参数校验**：如果 M≤1 或 M≥100，输出 \"ERROR!\"\n2. **模拟过程**：\n   - 用列表存储1-100的编号\n   - 每次移除第M个人（索引M-1）\n   - 从被移除位置开始重新排列队列\n3. **终止条件**：剩余人数 < M\n4. **输出结果**：按编号升序输出，逗号分隔\n\n**时间复杂度**：O(100/M * 100) ≈ O(n²)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n   \n    public static List<Integer> find_last_person(List<Integer> numbers, int M) {\n        // 遍历numbers数组\n        for (int i = 1; i <= numbers.size(); i++) {\n            // 当索引i等于M时，执行以下操作\n            if (i == M) {\n                // 将第M个元素之后的元素放入新的临时列表temp\n                List<Integer> temp = new ArrayList<>(numbers.subList(M, numbers.size()));\n                // 将原数组从0到M-1的元素加到临时列表的末尾\n                temp.addAll(numbers.subList(0, M - 1));\n                // 递归调用find_last_person函数，以新的temp列表继续进行处理\n                return find_last_person(temp, M);\n            }\n        }\n        // 当数组遍历完成，返回最终的numbers列表\n        return numbers;\n    }\n\n    public static void main(String[] args) {\n       \n        Scanner scanner = new Scanner(System.in);\n    \n        int M = scanner.nextInt();\n\n        // 如果M的值不在1到100之间，输出错误信息\n        if (M <= 1 || M >= 100) {\n            System.out.println(\"ERROR!\");\n        } else {\n            // 创建一个存储1到100的列表\n            List<Integer> numbers = new ArrayList<>();\n            for (int i = 0; i < 100; i++) {\n                numbers.add(i + 1);  // 将1到100依次加入numbers列表\n            }\n\n            // 调用find_last_person函数，处理numbers列表\n            List<Integer> result = find_last_person(numbers, M);\n            // 对结果进行排序\n            Collections.sort(result);\n\n            // 遍历result列表，按格式输出结果\n            for (int i = 0; i < result.size(); i++) {\n                System.out.print(result.get(i));\n                // 在元素之间添加逗号，最后一个元素后不加逗号\n                if (i != result.size() - 1) {\n                    System.out.print(\",\");\n                }\n            }\n            // 输出换行符\n            System.out.println();\n        }\n    }\n}",
    "python": "def find_last_person(numbers, M):\n    while len(numbers) >= M:  # 如果当前人数不小于M，则继续执行\n        temp = numbers[M:] + numbers[:M-1]  # 将第M个元素以后的部分和前M-1个元素合并\n        numbers = temp  # 更新numbers\n    return numbers\n\n \nM = int(input())  # 读入整数M\n\nif M <= 1 or M >= 100:\n    print(\"ERROR!\")  # 如果M不在规定范围内，输出错误信息\nelse:\n    numbers = list(range(1, 101))  # 生成1到100的列表\n    result = find_last_person(numbers, M)  # 获取最后剩下的人\n    result.sort()  # 对结果进行排序\n\n    # 打印结果，用逗号分隔\n    print(\",\".join(map(str, result)))",
    "javascript": "const readline = require('readline');\n\n\nconst rl = readline.createInterface({\n  input: process.stdin,   \n  output: process.stdout  \n});\n\n \nfunction find_last_person(numbers, M) {\n  // 遍历数字数组\n  for (let i = 1; i <= numbers.length; i++) {\n    // 当索引等于M时，执行操作\n    if (i === M) {\n        // 构造新数组：从第M个元素开始到数组结束，再拼接从数组开始到第M-1个元素\n        const temp = [...numbers.slice(M), ...numbers.slice(0, M - 1)];\n        // 递归调用，以新的数组和M为参数\n        return find_last_person(temp, M);\n    }\n  }\n  // 当数组遍历完成，返回最终数组\n   return numbers;\n}\n\n \nrl.on('line', (M) => {\n  M = parseInt(M); // 将输入转换为整数\n\n  // 如果输入的M小于等于1或大于等于100，输出错误信息\n  if (M <= 1 || M >= 100) {\n    console.log(\"ERROR!\");\n  } else {\n    // 否则，创建一个从1到100的数组\n    const numbers = Array.from({length: 100}, (_, i) => i + 1);\n\n    // 调用find_last_person函数处理numbers数组\n    const result = find_last_person(numbers, M);\n    // 对结果进行排序\n    result.sort((a, b) => a - b);\n\n    // 使用逗号将数组元素连接成一个字符串，并打印输出\n    console.log(result.join(','));\n  }\n\n  // 完成输入后关闭readline接口\n  rl.close();\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>  \n\nusing namespace std;\n\n \nvector<int> find_last_person(vector<int>& numbers, int M) {\n    while (numbers.size() >= M) { // 只要人数不小于M，就继续进行\n        vector<int> temp; // 创建一个临时向量存储剩余的人\n        // 将M位置以后的人加到temp的末尾，并将前M-1个人也加到末尾\n        for (size_t i = M; i < numbers.size(); i++) {\n            temp.push_back(numbers[i]);\n        }\n        for (size_t i = 0; i < M - 1; i++) {\n            temp.push_back(numbers[i]);\n        }\n        numbers = temp; // 更新numbers为temp\n    }\n    return numbers;\n}\n\nint main() {\n    int M;\n    cin >> M; // 读入M值\n\n    if (M <= 1 || M >= 100) {\n        cout << \"ERROR!\" << endl; // 检查M值是否合法\n    } else {\n        vector<int> numbers(100); // 创建一个向量存放1到100的编号\n        for (int i = 0; i < 100; i++) {\n            numbers[i] = i + 1;\n        }\n\n        vector<int> result = find_last_person(numbers, M);\n        sort(result.begin(), result.end()); // 对结果进行排序\n\n        // 输出结果，用逗号分隔\n        for (size_t i = 0; i < result.size(); i++) {\n            cout << result[i];\n            if (i != result.size() - 1) {\n                cout << \",\";\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}",
    "c": "#include <stdio.h>   \n#include <stdlib.h> \n\n \nint* find_last_person(int* numbers, int size, int M, int* result_size) {\n    while (size >= M) { // 只要人数不小于M，就继续进行\n        int* temp = (int*)malloc(sizeof(int) * size); // 动态分配临时数组\n        int temp_size = 0;\n        for (int i = M; i < size; i++) {\n            temp[temp_size++] = numbers[i]; // 添加M之后的元素到临时数组\n        }\n        for (int i = 0; i < M - 1; i++) {\n            temp[temp_size++] = numbers[i]; // 添加前M-1的元素到临时数组\n        }\n        free(numbers); // 释放原始数组\n        numbers = temp; // 更新指向新数组\n        size = temp_size; // 更新大小\n    }\n    *result_size = size; // 设置返回大小\n    return numbers;\n}\n\nint cmpfunc(const void* a, const void* b) { // 用于qsort的比较函数\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int M;\n    scanf(\"%d\", &M); // 输入M\n\n    if (M <= 1 || M >= 100) {\n        printf(\"ERROR!\\n\"); // 检查M的合法性\n    } else {\n        int* numbers = (int*)malloc(sizeof(int) * 100); // 动态分配数组\n        for (int i = 0; i < 100; i++) {\n            numbers[i] = i + 1; // 初始化1到100\n        }\n\n        int result_size;\n        int* result = find_last_person(numbers, 100, M, &result_size);\n        qsort(result, result_size, sizeof(int), cmpfunc); // 对结果排序\n\n        // 输出结果\n        for (int i = 0; i < result_size; i++) {\n            printf(\"%d\", result[i]);\n            if (i != result_size - 1) {\n                printf(\",\");\n            }\n        }\n        printf(\"\\n\");\n\n        free(result); // 释放结果数组\n    }\n    return 0;\n}"
  }
}