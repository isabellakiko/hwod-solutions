{
  "id": "64",
  "title": "MVP争夺战",
  "examType": "A",
  "score": 100,
  "description": "在星球争霸篮球赛对抗赛中，最大的宇宙战队希望每个人都能拿到MVP，MVP的条件是单场最高分得分获得者。 可以并列所以宇宙战队决定在比赛中尽可能让更多队员上场，并且让所有得分的选手得分都相同， 然而比赛过程中的每1分钟的得分都只能由某一个人包揽。",
  "inputDesc": "输入第一行为一个数字 t ，表示为有得分的分钟数 1 ≤ t ≤ 50\n第二行为 t 个数字，代表每一分钟的得分 p， 1 ≤ p ≤ 50",
  "outputDesc": "输出有得分的队员都是MVP时，最少得MVP得分。",
  "examples": [
    {
      "input": "3\n3 3 3",
      "output": "3",
      "explanation": "总分9分，可分给3人每人3分，最少MVP得分为3。"
    },
    {
      "input": "5\n1 2 3 4 5",
      "output": "5",
      "explanation": "总分15分，可分给3人每人5分(1+4=5, 2+3=5, 5=5)，最少MVP得分为5。"
    },
    {
      "input": "4\n2 3 5 7",
      "output": "17",
      "explanation": "总分17，无法均分，只能1人包揽，MVP得分为17。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**回溯+剪枝**问题，类似于将数组分成k个相等和的子集。\n\n**算法步骤：**\n1. 计算总分sum\n2. 从最大得分开始，尝试将总分分成m份\n3. 使用回溯法判断能否分成m个和相等的子集\n4. 找到能分成的最小子集和即为答案\n\n**剪枝优化：**\n- 总分必须能被m整除\n- 子集和必须>=最大元素\n- 跳过相同的空桶\n\n**时间复杂度**：O(k^N)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] arr = new int[n];\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            arr[i] = sc.nextInt();\n            sum += arr[i];\n        }\n        Arrays.sort(arr);\n        // 反转为降序\n        for (int i = 0; i < n / 2; i++) {\n            int tmp = arr[i];\n            arr[i] = arr[n - 1 - i];\n            arr[n - 1 - i] = tmp;\n        }\n        \n        // 从最大元素开始尝试每个可能的子集和\n        for (int target = arr[0]; target <= sum; target++) {\n            if (sum % target == 0) {\n                int k = sum / target;\n                int[] buckets = new int[k];\n                if (canPartition(arr, 0, buckets, target)) {\n                    System.out.println(target);\n                    return;\n                }\n            }\n        }\n        System.out.println(sum);\n    }\n    \n    static boolean canPartition(int[] arr, int idx, int[] buckets, int target) {\n        if (idx == arr.length) return true;\n        for (int i = 0; i < buckets.length; i++) {\n            if (i > 0 && buckets[i] == buckets[i-1]) continue;\n            if (buckets[i] + arr[idx] <= target) {\n                buckets[i] += arr[idx];\n                if (canPartition(arr, idx + 1, buckets, target)) return true;\n                buckets[i] -= arr[idx];\n            }\n            if (buckets[i] == 0) break;\n        }\n        return false;\n    }\n}",
    "python": "def dfs(arr, buckets, idx, target):\n    if idx == len(arr):\n        return True\n    for i in range(len(buckets)):\n        if i > 0 and buckets[i] == buckets[i-1]:\n            continue\n        if buckets[i] + arr[idx] <= target:\n            buckets[i] += arr[idx]\n            if dfs(arr, buckets, idx + 1, target):\n                return True\n            buckets[i] -= arr[idx]\n        if buckets[i] == 0:\n            break\n    return False\n\nn = int(input())\narr = list(map(int, input().split()))\ntotal = sum(arr)\narr.sort(reverse=True)\n\nfor target in range(arr[0], total + 1):\n    if total % target == 0:\n        k = total // target\n        buckets = [0] * k\n        if dfs(arr, buckets, 0, target):\n            print(target)\n            break",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst lines = [];\nrl.on('line', (line) => {\n    lines.push(line);\n    if (lines.length === 2) {\n        const n = parseInt(lines[0]);\n        const arr = lines[1].split(' ').map(Number);\n        console.log(solve(arr));\n        rl.close();\n    }\n});\n\nfunction solve(arr) {\n    const sum = arr.reduce((a, b) => a + b, 0);\n    arr.sort((a, b) => b - a);\n    \n    for (let target = arr[0]; target <= sum; target++) {\n        if (sum % target === 0) {\n            const k = sum / target;\n            const buckets = new Array(k).fill(0);\n            if (canPartition(arr, 0, buckets, target)) {\n                return target;\n            }\n        }\n    }\n    return sum;\n}\n\nfunction canPartition(arr, idx, buckets, target) {\n    if (idx === arr.length) return true;\n    for (let i = 0; i < buckets.length; i++) {\n        if (i > 0 && buckets[i] === buckets[i-1]) continue;\n        if (buckets[i] + arr[idx] <= target) {\n            buckets[i] += arr[idx];\n            if (canPartition(arr, idx + 1, buckets, target)) return true;\n            buckets[i] -= arr[idx];\n        }\n        if (buckets[i] === 0) break;\n    }\n    return false;\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool canPartition(vector<int>& arr, int idx, vector<int>& buckets, int target) {\n    if (idx == arr.size()) return true;\n    for (int i = 0; i < buckets.size(); i++) {\n        if (i > 0 && buckets[i] == buckets[i-1]) continue;\n        if (buckets[i] + arr[idx] <= target) {\n            buckets[i] += arr[idx];\n            if (canPartition(arr, idx + 1, buckets, target)) return true;\n            buckets[i] -= arr[idx];\n        }\n        if (buckets[i] == 0) break;\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<int> arr(n);\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        cin >> arr[i];\n        sum += arr[i];\n    }\n    sort(arr.begin(), arr.end(), greater<int>());\n    \n    for (int target = arr[0]; target <= sum; target++) {\n        if (sum % target == 0) {\n            int k = sum / target;\n            vector<int> buckets(k, 0);\n            if (canPartition(arr, 0, buckets, target)) {\n                cout << target << endl;\n                return 0;\n            }\n        }\n    }\n    cout << sum << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint arr[55];\nint buckets[55];\nint n, k;\n\nint cmp(const void* a, const void* b) {\n    return *(int*)b - *(int*)a;\n}\n\nint canPartition(int idx, int target) {\n    if (idx == n) return 1;\n    for (int i = 0; i < k; i++) {\n        if (i > 0 && buckets[i] == buckets[i-1]) continue;\n        if (buckets[i] + arr[idx] <= target) {\n            buckets[i] += arr[idx];\n            if (canPartition(idx + 1, target)) return 1;\n            buckets[i] -= arr[idx];\n        }\n        if (buckets[i] == 0) break;\n    }\n    return 0;\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n        sum += arr[i];\n    }\n    qsort(arr, n, sizeof(int), cmp);\n    \n    for (int target = arr[0]; target <= sum; target++) {\n        if (sum % target == 0) {\n            k = sum / target;\n            for (int i = 0; i < k; i++) buckets[i] = 0;\n            if (canPartition(0, target)) {\n                printf(\"%d\\n\", target);\n                return 0;\n            }\n        }\n    }\n    printf(\"%d\\n\", sum);\n    return 0;\n}"
  }
}
