{
  "id": "191",
  "title": "整理扑克牌",
  "examType": "B",
  "score": 100,
  "description": "给定一组数字，表示扑克牌的牌面数字，忽略扑克牌的花色，请按如下规则对这一组扑克牌进行整理：\n步骤1. 对扑克牌进行分组，形成组合牌，规则如下：\n当牌面数字相同张数大于等于4时，组合牌为“炸弹”；3张相同牌面数字 + 2张相同牌面数字，且3张牌与2张牌不相同时，组合牌为“葫芦”；3张相同牌面数字，组合牌为“三张”；2张相同牌面数字，组合牌为“对子”；剩余没有相同的牌，则为“单张”；\n步骤2. 对上述组合牌进行由大到小排列，规则如下：\n不同类型组合牌之间由大到小排列规则：“炸弹” > “葫芦” > “三张” > “对子” > “单张”；相同类型组合牌之间，除“葫芦”外，按组合牌全部牌面数字加总由大到小排列；“葫芦”则先按3张相同牌面数字加总由大到小排列，3张相同牌面数字加总相同时，再按另外2张牌面数字加总由大到小排列；由于“葫芦”>“三张”，因此如果能形成更大的组合牌，也可以将“三张”拆分为2张和1张，其中的2张可以和其它“三张”重新组合成“葫芦”，剩下的1张为“单张”\n步骤3. 当存在多个可能组合方案时，按如下规则排序取最大的一个组合方案：\n依次对组合方案中的组合牌进行大小比较，规则同上；当组合方案A中的第n个组合牌大于组合方案B中的第n个组合牌时，组合方案A大于组合方案B；\n",
  "inputDesc": "第一行为空格分隔的N个正整数，每个整数取值范围[1,13]，N的取值范围[1,1000]\n",
  "outputDesc": "经重新排列后的扑克牌数字列表，每个数字以空格分隔\n\n我的解题思路如下：\n首先，将给定牌中，炸弹，三张，对子，单子先统计出来，即先不处理葫芦。\n统计逻辑很简单，就是看某个牌面的数量：\n统计完后，我们就可以先对炸弹进行排序，排序规则是：全部牌面数字加总由大到小排列\n接着可以组合葫芦了，组合逻辑如下：\n首先，需要先对三张、对子按照加总降序\n然后，选取一个最大的三张，并比较第二大的三张的牌面和第一大的对子的牌面\n按照上面规则组合葫芦，直到三张用完。\n注意上面逻辑是三张用完结束，而不是对子用完，因为还有一种情况就是对子先用完了，但是三张还有多个，此时我们要继续拆分小的三张来组合大三张为葫芦。\n组合完葫芦后。\n我们就可以对单张进行加总降序排序了，因为组合葫芦过程中，很可能产生新的单张。\n最后，依次将统计并排序后的炸弹、葫芦、三张、对子、单张，打印出来\n2023.03.24 补充说明\n在看了满分答案后，我发现当前我的代码实现和满分答案的区别仅仅在于炸弹排序有所不同，比如下面用例：\n5 5 5 5 4 4 4 4 4\n满分答案的输出是：4 4 4 4 4 5 5 5 5\n我的答案输出是：5 5 5 5 4 4 4 4 4\n\n对满分答案经过分析后，我发现造成这个差异的原因是，我对题目中“加总”的理解有偏差。\n比如，斗地主时，炸弹的张数越多，炸弹越大，因此五个4 在现实中就是要比 四个5 的炸弹大。\n但是本题中“加总”这个词比较有迷惑性，我理解是 = 牌面值 * 牌数量，即炸弹的所有牌之和，因此我的逻辑中 五个4 和 四个5 的炸弹是一样大的。\n而满分答案的对“加总”的理解和现实生活中一致，就是炸弹的牌数越多，就越大。\n\n因此，本题代码修正非常容易，就是将炸弹的排序规则修改一下，先按照炸弹牌的牌数量降序，如果牌数量一致，则再按照牌面大小降序。\n比如下面代码中：\nJS的第49行\nJava的第58行\nPython的第37行\n\n那么其他类型牌，比如葫芦，三张，对子，单张，的排序逻辑是否需要变动呢？\n答案是不需要，因为这些类型牌中的牌数量都是固定的，比如葫芦就是3+2，三张就是3，对子就是2，单张就是1。因此这些同类型牌之间的对比就是牌面值得对比。可以沿用之前得逻辑。\n",
  "examples": [
    {
      "input": "1 2 3 3 3 4 4",
      "output": "4 4 3 3 3 2 1",
      "explanation": "对子4>三张3>单张2>单张1"
    },
    {
      "input": "5 5 5 4 4 4 3 3",
      "output": "5 5 5 4 4 4 3 3",
      "explanation": "三张5和三张4可组合成两个葫芦：5 5 5 4 4和4 4 4 3 3不如直接两个三张大"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟+贪心**问题。\n\n**核心思路：**\n- 按规则分组：炸弹>葫芦>三张>对子>单张\n- 同类型按牌面值排序\n- 三张可拆分为对子组合葫芦\n\n**算法步骤：**\n1. 统计各牌面数量，分为炸弹、三张、对子、单张\n2. 尝试用三张+对子组合葫芦\n3. 各类型按规则排序\n4. 依次输出炸弹、葫芦、三张、对子、单张\n\n**时间复杂度**：O(N*logN)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String str = sc.nextLine();\n    Integer[] arr = Arrays.stream(str.split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    System.out.println(getResult(arr));\n  }\n\n  public static String getResult(Integer[] arr) {\n    HashMap<Integer, Integer> card = new HashMap<>();\n\n    // 统计各种牌面的数量\n    for (Integer num : arr) {\n      if (card.containsKey(num)) {\n        int val = card.get(num);\n        card.put(num, ++val);\n      } else {\n        card.put(num, 1);\n      }\n    }\n\n    // 统计组合，4代表炸弹，3+2代表葫芦，3代表三张，2代表对子，1代表单张\n    HashMap<String, LinkedList<Integer[]>> combine = new HashMap<>();\n    combine.put(\"4\", new LinkedList<Integer[]>());\n    combine.put(\"3+2\", new LinkedList<Integer[]>());\n    combine.put(\"3\", new LinkedList<Integer[]>());\n    combine.put(\"2\", new LinkedList<Integer[]>());\n    combine.put(\"1\", new LinkedList<Integer[]>());\n\n    // 首先将初始组合统计出来\n    Set<Integer> cardKeys = card.keySet();\n    for (Integer num : cardKeys) {\n      switch (card.get(num)) {\n        case 3:\n          combine.get(\"3\").add(new Integer[] {num});\n          break;\n        case 2:\n          combine.get(\"2\").add(new Integer[] {num});\n          break;\n        case 1:\n          combine.get(\"1\").add(new Integer[] {num});\n          break;\n        default:\n          combine\n              .get(\"4\")\n              .add(\n                  new Integer[] {\n                    num, card.get(num)\n                  }); // 由于炸弹可能有4张以上相同牌面组成，因此既需要统计牌面num，也需要统计牌数card[num]\n      }\n    }\n\n    // 炸弹排序\n    combine.get(\"4\").sort((a, b) -> !Objects.equals(a[1], b[1]) ? b[1] - a[1] : b[0] - a[0]);\n\n    // 三张排序，牌面值越大，三张越大\n    combine.get(\"3\").sort((a, b) -> b[0] - a[0]);\n\n    // 对子排序，牌面值越大，对子越大\n    combine.get(\"2\").sort((a, b) -> b[0] - a[0]);\n\n    // 尝试组合出葫芦\n    while (combine.get(\"3\").size() > 0) {\n      // 如果对子用完，三张还有一个，那么可以直接结束循环\n      if (combine.get(\"2\").size() == 0 && combine.get(\"3\").size() == 1) break;\n\n      // 否则，选取一个最大的三张\n      Integer san_top = combine.get(\"3\").removeFirst()[0];\n\n      Integer tmp;\n      // 如果此时没有对子了，胡总和第二大的三张的牌面，比最大的对子牌面大，则可以拆分三张，组合出葫芦\n      if (combine.get(\"2\").size() == 0\n          || (combine.get(\"3\").size() > 0\n              && combine.get(\"3\").get(0)[0] > combine.get(\"2\").get(0)[0])) {\n        tmp = combine.get(\"3\").removeFirst()[0];\n        // 拆分三张为对子的话，会多出一个单张\n        combine.get(\"1\").add(new Integer[] {tmp});\n      } else {\n        // 如果对子牌面比三张大，则不需要拆分三张，直接使用对子组合出葫芦\n        tmp = combine.get(\"2\").removeFirst()[0];\n      }\n      combine.get(\"3+2\").add(new Integer[] {san_top, tmp}); // 葫芦元素含义：[三张牌面，对子牌面]\n    }\n\n    // 处理完葫芦后，就可以对单张进行降序了（因为组合葫芦的过程中，可能产生新的单张，因此单张排序要在葫芦组合得到后进行）\n    combine.get(\"1\").sort((a, b) -> b[0] - a[0]);\n\n    // ans存放题解\n    ArrayList<Integer> ans = new ArrayList<>();\n\n    // 首先将炸弹放到ans中\n    for (Integer[] vals : combine.get(\"4\")) {\n      int score = vals[0];\n      int count = vals[1];\n      for (int i = 0; i < count; i++) {\n        ans.add(score);\n      }\n    }\n\n    // 然后将葫芦放大ans中\n    for (Integer[] vals : combine.get(\"3+2\")) {\n      int san = vals[0];\n      int er = vals[1];\n      for (int i = 0; i < 3; i++) ans.add(san);\n      for (int i = 0; i < 2; i++) ans.add(er);\n    }\n\n    // 之后将三张放到ans中\n    for (Integer[] vals : combine.get(\"3\")) {\n      for (int i = 0; i < 3; i++) ans.add(vals[0]);\n    }\n\n    // 接着是对子放到ans中\n    for (Integer[] vals : combine.get(\"2\")) {\n      for (int i = 0; i < 2; i++) ans.add(vals[0]);\n    }\n\n    // 最后是单张放到ans中\n    for (Integer[] vals : combine.get(\"1\")) {\n      ans.add(vals[0]);\n    }\n\n    StringJoiner sj = new StringJoiner(\" \");\n    for (Integer an : ans) {\n      sj.add(an + \"\");\n    }\n\n    return sj.toString();\n  }\n}",
    "python": "# 输入获取\narr = input().split()\n\n\n# 算法入口\ndef getResult(arr):\n    # card统计各种牌面的数量\n    card = {}\n    for num in arr:\n        if card.get(num) is None:\n            card[num] = 1\n        else:\n            card[num] += 1\n\n    # combine统计组合，4代表炸弹，3+2代表葫芦，3代表三张，2代表对子，1代表单张\n    combine = {\n        \"4\": [],\n        \"3+2\": [],\n        \"3\": [],\n        \"2\": [],\n        \"1\": []\n    }\n\n    # 首先将初始组合统计出来\n    for num in card.keys():\n        if card[num] == 3:\n            combine[\"3\"].append(int(num))\n        elif card[num] == 2:\n            combine[\"2\"].append(int(num))\n        elif card[num] == 1:\n            combine[\"1\"].append(int(num))\n        else:\n            # 由于炸弹可能有4张以上相同牌面组成，因此既需要统计牌面num，也需要统计牌数card[num]\n            combine[\"4\"].append([int(num), card[num]])\n\n    # 炸弹排序\n    combine[\"4\"].sort(key=lambda x: (-x[1], -x[0]))\n\n    # 三张排序，牌面值越大，三张越大\n    combine[\"3\"].sort(reverse=True)\n\n    # 对子降序，牌面值越大，对子越大\n    combine[\"2\"].sort(reverse=True)\n\n    # 尝试组合出葫芦\n    while len(combine[\"3\"]) > 0:\n        # 如果对子用完，三张还有一个，那么可以直接结束循环\n        if len(combine[\"2\"]) == 0 and len(combine[\"3\"]) == 1:\n            break\n\n        # 选取一个最大的三张\n        san_top = combine[\"3\"].pop(0)\n\n        tmp = None\n\n        #  如果第二大的三张的牌面，比最大的对子牌面大，或者没有对子了，则可以拆分三张，组合出葫芦\n        if len(combine[\"2\"]) == 0 or (len(combine[\"3\"]) >= 1 and combine[\"3\"][0] > combine[\"2\"][0]):\n            tmp = combine[\"3\"].pop(0)\n            # 拆分三张为对子的话，会多出一个单张\n            combine[\"1\"].append(tmp)\n        else:\n            # 如果对子牌面比三张大，则不需要拆分三张，直接使用对子组合出葫芦\n            tmp = combine[\"2\"].pop(0)\n\n        combine[\"3+2\"].append([san_top, tmp])  # 葫芦元素含义：[三张牌面，对子牌面]\n\n    # 处理完葫芦后，就可以对单张进行降序了（因为组合葫芦的过程中，可能产生新的单张，因此单张排序要在葫芦组合得到后进行）\n    combine[\"1\"].sort(reverse=True)\n\n    # ans存放题解\n    ans = []\n\n    # 首先将炸弹放到ans中\n    for score, count in combine[\"4\"]:\n        ans += [score] * count\n\n    # 然后将葫芦放大ans中\n    for san, er in combine[\"3+2\"]:\n        ans += [san] * 3 + [er] * 2\n\n    # 之后将三张放到ans中\n    for san in combine[\"3\"]:\n        ans += [san] * 3\n\n    # 接着是对子放到ans中\n    for er in combine[\"2\"]:\n        ans += [er] * 2\n\n    # 最后是单张放到ans中\n    for dan in combine[\"1\"]:\n        ans += [dan]\n\n    return \" \".join(map(str, ans))\n\n\n# 算法调用\nprint(getResult(arr))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const arr = line.split(\" \").map(Number);\n  console.log(getResult(arr));\n});\n\nfunction getResult(arr) {\n  const card = {};\n\n  // 统计各种牌面的数量\n  for (let num of arr) {\n    card[num] ? card[num]++ : (card[num] = 1);\n  }\n\n  // 统计组合，4代表炸弹，3+2代表葫芦，3代表三张，2代表对子，1代表单张\n  const combine = {\n    4: [],\n    \"3+2\": [],\n    3: [],\n    2: [],\n    1: [],\n  };\n\n  // 首先将初始组合统计出来\n  for (let num in card) {\n    switch (card[num]) {\n      case 3:\n        combine[3].push(num - 0);\n        break;\n      case 2:\n        combine[2].push(num - 0);\n        break;\n      case 1:\n        combine[1].push(num - 0);\n        break;\n      default:\n        combine[4].push([num - 0, card[num]]); // 由于炸弹可能有4张以上相同牌面组成，因此既需要统计牌面num，也需要统计牌数card[num]\n    }\n  }\n\n  // 炸弹排序\n  combine[4].sort((a, b) => (a[1] != b[1] ? b[1] - a[1] : b[0] - a[0]));\n\n  // 三张排序，牌面值越大，三张越大\n  combine[3].sort((a, b) => b - a);\n\n  // 对子降序，牌面值越大，对子越大\n  combine[2].sort((a, b) => b - a);\n\n  // 尝试组合出葫芦\n  while (combine[3].length) {\n    // 如果对子用完，三张还有一个，那么可以直接结束循环\n    if (combine[2].length === 0 && combine[3].length === 1) break;\n\n    // 选取一个最大的三张\n    const san_top = combine[3].shift();\n\n    let tmp;\n    // 如果第二大的三张的牌面，比最大的对子牌面大，或者没有对子了，则可以拆分三张，组合出葫芦\n    if (\n      combine[2].length === 0 ||\n      (combine[3].length >= 1 && combine[3][0] > combine[2][0])\n    ) {\n      tmp = combine[3].shift();\n      // 拆分三张为对子的话，会多出一个单张\n      combine[1].push(tmp);\n    } else {\n      // 如果对子牌面比三张大，则不需要拆分三张，直接使用对子组合出葫芦\n      tmp = combine[2].shift();\n    }\n    combine[\"3+2\"].push([san_top, tmp]); // 葫芦元素含义：[三张牌面，对子牌面]\n  }\n\n  // 处理完葫芦后，就可以对单张进行降序了（因为组合葫芦的过程中，可能产生新的单张，因此单张排序要在葫芦组合得到后进行）\n  combine[1].sort((a, b) => b - a);\n\n  // ans存放题解\n  const ans = [];\n\n  // 首先将炸弹放到ans中\n  for (let card of combine[4]) {\n    const [score, count] = card;\n    ans.push(...new Array(count).fill(score));\n  }\n\n  // 然后将葫芦放大ans中\n  for (let card of combine[\"3+2\"]) {\n    const [san, er] = card;\n    ans.push(...new Array(3).fill(san), ...new Array(2).fill(er));\n  }\n\n  // 之后将三张放到ans中\n  for (let san of combine[3]) {\n    ans.push(...new Array(3).fill(san));\n  }\n\n  // 接着是对子放到ans中\n  for (let er of combine[2]) {\n    ans.push(...new Array(2).fill(er));\n  }\n\n  // 最后是单张放到ans中\n  ans.push(...combine[1]);\n\n  return ans.join(\" \");\n}",
    "cpp": "",
    "c": ""
  }
}