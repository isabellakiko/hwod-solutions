{
  "id": "105",
  "title": "机器人活动区域",
  "examType": "A",
  "score": 100,
  "description": "现有一个机器人，可放置于 M × N 的网格中任意位置，每个网格包含一个非负整数编号，当相邻网格的数字编号差值的绝对值小于等于 1 时，机器人可以在网格间移动。\n问题： 求机器人可活动的最大范围对应的网格点数目。\n说明：网格左上角坐标为 (0,0) ,右下角坐标为(m−1,n−1)，机器人只能在相邻网格间上下左右移动",
  "inputDesc": "第 1 行输入为 M 和 N\nM 表示网格的行数N 表示网格的列数\n之后 M 行表示网格数值，每行 N 个数值（数值大小用 k 表示），数值间用单个空格分隔，行首行尾无多余空格。\nM、 N、 k 均为整数1 ≤ M，N ≤ 150,0 ≤ k ≤ 50",
  "outputDesc": "输出 1 行，包含 1 个数字，表示最大活动区域的网格点数目， 行首行尾无多余空格。",
  "examples": [
    {
      "input": "4 3\n2 5 2\n4 4 5\n5 7 1\n6 2 4",
      "output": "6",
      "explanation": "4×3网格，相邻差值<=1的最大连通区域包含6个网格点"
    },
    {
      "input": "2 2\n3 5\n1 3",
      "output": "1",
      "explanation": "任意相邻网格差值都>1，机器人只能在单个网格内，数目为1"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**DFS/BFS连通分量**问题。\n\n**核心思路：**\n- 相邻网格差值绝对值<=1时可移动\n- 求最大连通区域的网格数\n\n**算法步骤：**\n1. 遍历每个网格作为起点\n2. DFS/BFS探索所有可达的相邻网格\n3. 统计连通区域大小\n4. 返回最大区域的网格数\n\n**时间复杂度**：O(M×N×M×N)",
  "codes": {
    "java": "import java.util.Scanner;\n\nclass Main {\n    // 定义四个方向，上下左右\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    public static void main(String[] args) {\n        // 输入处理\n        Scanner in = new Scanner(System.in);\n        int m = in.nextInt(); // 行数\n        int n = in.nextInt(); // 列数\n        int[][] matrix = new int[m][n]; // 定义矩阵\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = in.nextInt(); // 读入矩阵中的值\n            }\n        }\n\n        // 遍历每个点作为起点，求最大活动范围\n        int maxRange = 0; // 定义最大活动范围\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                boolean[][] visited = new boolean[m][n]; // 定义是否访问过\n                int range = dfs(matrix, visited, i, j); // 深度优先搜索\n                maxRange = Math.max(maxRange, range); // 更新最大活动范围\n            }\n        }\n\n        System.out.println(maxRange); // 输出最大活动范围\n    }\n\n    public static int dfs(int[][] matrix, boolean[][] visited, int x, int y) {\n        visited[x][y] = true; // 标记当前点已经访问过\n        int range = 1; // 定义活动范围\n        for (int[] direction : directions) { // 遍历四个方向\n            int newX = x + direction[0]; // 新的横坐标\n            int newY = y + direction[1]; // 新的纵坐标\n            if (newX >= 0 && newX < matrix.length && newY >= 0 && newY < matrix[0].length\n                    && !visited[newX][newY] && Math.abs(matrix[newX][newY] - matrix[x][y]) <= 1) { // 判断是否越界、是否访问过、是否符合条件\n                range += dfs(matrix, visited, newX, newY); // 更新活动范围\n            }\n        }\n        return range; // 返回活动范围\n    }\n}",
    "python": "import sys\n\n# 定义四个可能的移动方向：右，左，下，上\ndirections = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n# 使用深度优先搜索（DFS）来探索网格\ndef dfs(matrix, visited, x, y):\n    # 标记当前网格点为已访问\n    visited[x][y] = True\n    # 初始化当前网格点的范围计数为1\n    range = 1\n    # 遍历所有可能的移动方向\n    for direction in directions:\n        newX = x + direction[0]  # 计算新的行坐标\n        newY = y + direction[1]  # 计算新的列坐标\n        # 检查新坐标是否在网格内部，且未访问过，并且满足编号差值绝对值小于等于1的条件\n        if newX >= 0 and newX < len(matrix) and newY >= 0 and newY < len(matrix[0]) \\\n            and not visited[newX][newY] and abs(matrix[newX][newY] - matrix[x][y]) <= 1:\n            # 递归地继续探索并累加可活动的网格点数目\n            range += dfs(matrix, visited, newX, newY)\n    # 返回从当前网格点出发可活动的最大网格点数目\n    return range\n\n# 读取输入数据\nm, n = 0, 0  # 初始化网格的行数和列数\nmatrix = []  # 初始化网格矩阵\n\n# 逐行读取输入\nfor line in sys.stdin:\n    if not m and not n:\n        m, n = map(int, line.split())  # 读取网格的行数和列数\n    else:\n        matrix.append(list(map(int, line.split())))  # 读取网格中的数值\n        if len(matrix) == m:  # 如果已经读取完所有行，结束读取\n            break\n\n# 寻找机器人可以活动的最大范围\nmaxRange = 0\nfor i in range(m):\n    for j in range(n):\n        visited = [[False] * n for _ in range(m)]  # 初始化访问标记数组\n        ranges = dfs(matrix, visited, i, j)  # 对每个网格点执行DFS\n        maxRange = max(maxRange, ranges)  # 更新最大活动范围\n\n# 输出机器人可以活动的最大范围对应的网格点数目\nprint(maxRange)",
    "javascript": "// 导入readline模块以读取和处理输入数据\nconst readline = require('readline');\n\n// 创建readline接口，配置输入来自标准输入，输出到标准输出\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 定义四个可能的移动方向：右，左，下，上\nconst directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];\n\n// 使用深度优先搜索（DFS）来探索网格\nfunction dfs(matrix, visited, x, y) {\n  visited[x][y] = true;  // 标记当前网格点为已访问\n  let range = 1;  // 初始化当前网格点的范围计数为1\n  // 遍历所有可能的移动方向\n  for (let direction of directions) {\n    let newX = x + direction[0];  // 计算新的行坐标\n    let newY = y + direction[1];  // 计算新的列坐标\n    // 检查新坐标是否在网格内部，且未访问过，并且满足编号差值绝对值小于等于1的条件\n    if (newX >= 0 && newX < matrix.length && newY >= 0 && newY < matrix[0].length\n        && !visited[newX][newY] && Math.abs(matrix[newX][newY] - matrix[x][y]) <= 1) {\n      range += dfs(matrix, visited, newX, newY);  // 递归地继续探索并累加可活动的网格点数目\n    }\n  }\n  return range;  // 返回从当前网格点出发可活动的最大网格点数目\n}\n\nlet m, n;  // 声明变量m和n来存储网格的行数和列数\nlet matrix = [];  // 初始化网格矩阵\n\n// 处理每行输入\nrl.on('line', (line) => {\n  if (!m && !n) {\n    [m, n] = line.split(' ').map(Number);  // 解析输入的行数和列数\n    return;\n  }\n  matrix.push(line.split(' ').map(Number));  // 读取网格中的数值\n  if (matrix.length === m) {  // 如果已经读取完所有行，关闭输入流\n    rl.close();\n  }\n});\n\n// 输入流关闭后开始处理数据\nrl.on('close', () => {\n  let maxRange = 0;  // 初始化最大活动范围\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let visited = Array.from({length: m}, () => Array(n).fill(false));  // 初始化访问标记数组\n      let range = dfs(matrix, visited, i, j);  // 对每个网格点执行DFS\n      maxRange = Math.max(maxRange, range);  // 更新最大活动范围\n    }\n  }\n  console.log(maxRange);  // 输出机器人可以活动的最大范围对应的网格点数目\n});",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n// 定义四个方向，上下左右\nconst vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nint dfs(vector<vector<int>>& matrix, vector<vector<bool>>& visited, int x, int y) {\n    visited[x][y] = true; // 标记当前点已经访问过\n    int range = 1; // 定义活动范围\n    for (vector<int> direction : directions) { // 遍历四个方向\n        int newX = x + direction[0]; // 新的横坐标\n        int newY = y + direction[1]; // 新的纵坐标\n        if (newX >= 0 && newX < matrix.size() && newY >= 0 && newY < matrix[0].size()\n                && !visited[newX][newY] && abs(matrix[newX][newY] - matrix[x][y]) <= 1) { // 判断是否越界、是否访问过、是否符合条件\n            range += dfs(matrix, visited, newX, newY); // 更新活动范围\n        }\n    }\n    return range; // 返回活动范围\n}\n\nint main() {\n    // 输入处理\n    int m, n;\n    cin >> m >> n;\n    vector<vector<int>> matrix(m, vector<int>(n)); // 定义矩阵\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> matrix[i][j]; // 读入矩阵中的值\n        }\n    }\n\n    // 遍历每个点作为起点，求最大活动范围\n    int maxRange = 0; // 定义最大活动范围\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            vector<vector<bool>> visited(m, vector<bool>(n, false)); // 定义是否访问过\n            int range = dfs(matrix, visited, i, j); // 深度优先搜索\n            maxRange = max(maxRange, range); // 更新最大活动范围\n        }\n    }\n\n    cout << maxRange << endl; // 输出最大活动范围\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n// 定义四个方向，上下左右\nint directions[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n// 深度优先搜索函数\nint dfs(int **matrix, bool **visited, int x, int y, int m, int n) {\n    visited[x][y] = true; // 标记当前点已经访问过\n    int range = 1; // 定义活动范围\n    for (int i = 0; i < 4; i++) { // 遍历四个方向\n        int newX = x + directions[i][0]; // 新的横坐标\n        int newY = y + directions[i][1]; // 新的纵坐标\n        // 判断是否越界、是否访问过、是否符合条件\n        if (newX >= 0 && newX < m && newY >= 0 && newY < n &&\n            !visited[newX][newY] && abs(matrix[newX][newY] - matrix[x][y]) <= 1) {\n            range += dfs(matrix, visited, newX, newY, m, n); // 更新活动范围\n        }\n    }\n    return range; // 返回活动范围\n}\n\nint main() {\n    int m, n;\n    scanf(\"%d %d\", &m, &n); // 输入行数和列数\n\n    // 动态分配矩阵空间\n    int **matrix = (int **)malloc(m * sizeof(int *));\n    for (int i = 0; i < m; i++) {\n        matrix[i] = (int *)malloc(n * sizeof(int));\n    }\n\n    // 动态分配访问标记数组空间\n    bool **visited = (bool **)malloc(m * sizeof(bool *));\n    for (int i = 0; i < m; i++) {\n        visited[i] = (bool *)malloc(n * sizeof(bool));\n    }\n\n    // 读入矩阵中的值\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n\n    int maxRange = 0; // 定义最大活动范围\n    // 遍历每个点作为起点，求最大活动范围\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            // 初始化访问标记数组为未访问\n            for (int a = 0; a < m; a++) {\n                for (int b = 0; b < n; b++) {\n                    visited[a][b] = false;\n                }\n            }\n            int range = dfs(matrix, visited, i, j, m, n); // 深度优先搜索\n            if (range > maxRange) {\n                maxRange = range; // 更新最大活动范围\n            }\n        }\n    }\n\n    printf(\"%d\\n\", maxRange); // 输出最大活动范围\n\n    // 释放分配的内存\n    for (int i = 0; i < m; i++) {\n        free(matrix[i]);\n        free(visited[i]);\n    }\n    free(matrix);\n    free(visited);\n\n    return 0;\n}"
  }
}