{
  "id": "25",
  "title": "找终点",
  "examType": "A",
  "score": 100,
  "description": "给定一个正整数数组，设为nums，最大为100个成员，求从第一个成员开始，正好走到数组最后一个成员，所使用的最少步骤数。\n要求：\n第一步必须从第一元素开始，且1<=第一步的步长<len/2;（len为数组的长度，需要自行解析）。从第二步开始，只能以所在成员的数字走相应的步数，不能多也不能少, 如果目标不可达返回**-1**，只输出最少的步骤数量。只能向数组的尾部走，不能往回走。",
  "inputDesc": "由正整数组成的数组，以空格分隔，数组长度小于100，请自行解析数据数量。",
  "outputDesc": "正整数，表示最少的步数，如果不存在输出**-1**",
  "examples": [
    {
      "input": "7 5 9 4 2 6 8 3 5 4 3 9",
      "output": "2",
      "explanation": "数组长度12，第一步步长范围 [1, 5]。\n选择步长2：从索引0跳到索引2（值为9）。\n第二步：从索引2走9步到索引11（最后一个元素）。\n共2步到达终点。"
    },
    {
      "input": "1 2 3 7 1 5 9 3 2 1",
      "output": "-1",
      "explanation": "数组长度10，第一步步长范围 [1, 4]。\n尝试所有可能的第一步步长，都无法恰好到达最后一个元素，返回-1。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟 + 枚举**问题。\n\n**算法步骤：**\n\n1. **枚举第一步**：步长范围为 [1, len/2)（整除）\n2. **模拟后续步骤**：从第一步到达的位置开始，每次按当前位置的值前进\n3. **判断终点**：如果恰好到达最后一个元素（index == len-1），记录步数\n4. **返回最小值**：所有成功路径中的最小步数，无成功路径返回-1\n\n**注意**：步长条件是 `1 <= 步长 < len/2`（整除），不是四舍五入\n\n**时间复杂度**：O(n²)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String input = scanner.nextLine(); // 读取用户输入的整数字符串，以空格分隔\n        String[] numberStrings = input.split(\" \"); // 将输入的字符串分割成字符串数组\n        int[] numbers = new int[numberStrings.length]; // 创建一个与字符串数组长度相同的整型数组\n        for (int i = 0; i < numberStrings.length; i++) {\n            numbers[i] = Integer.parseInt(numberStrings[i]); // 将字符串数组的每个元素转换为整数，并存入整型数组\n        }\n        int length = numbers.length; // 获取数组的长度\n        List<Integer> result = new ArrayList<>(); // 用于存储所有可能的步数结果\n        for (int i = 1; i < length / 2; i++) { // 遍历所有从第一个元素开始的有效步长\n            int step = 1; // 初始化步数为1，因为第一步已经走出\n            int index = i; // 将索引设为当前步长\n            while (index < length - 1) { // 只要没有走到数组的最后一个元素\n                index += numbers[index]; // 按照当前索引位置的数字值前进\n                step++; // 每走一步，步数加1\n            }\n            if (index == length - 1) { // 如果恰好到达数组的最后一个元素\n                result.add(step); // 将步数结果存入结果列表\n            }\n        }\n        if (result.size() > 0) {\n            Integer[] resultArray = result.toArray(new Integer[0]); // 将结果列表转换为数组\n            Arrays.sort(resultArray); // 对步数结果进行排序\n            System.out.println(resultArray[0]); // 输出最小的步数\n        } else {\n            System.out.println(-1); // 如果没有结果，输出-1\n        }\n    }\n}",
    "python": "numbers = list(map(int, input().split())) # 将输入的字符串分割并映射为整数列表\nlength = len(numbers) # 获取数组的长度\nresult = [] # 用于存储所有可能的步数结果\nfor i in range(1, length // 2): # 遍历所有从第一个元素开始的有效步长\n    step = 1 # 初始化步数为1，因为第一步已经走出\n    index = i # 将索引设为当前步长\n    while index < length - 1: # 只要没有走到数组的最后一个元素\n        index += numbers[index] # 按照当前索引位置的数字值前进\n        step += 1 # 每走一步，步数加1\n    if index == length - 1: # 如果恰好到达数组的最后一个元素\n        result.append(step) # 将步数结果存入结果列表\nif len(result) > 0:\n    result.sort() # 对步数结果进行排序\n    print(result[0]) # 输出最小的步数\nelse:\n    print(-1) # 如果没有结果，输出-1",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (numbersInput) => {\n  const numbers = numbersInput.split(' ').map(Number); // 将输入的字符串分割并映射为整数数组\n  const length = numbers.length; // 获取数组的长度\n  const result = []; // 用于存储所有可能的步数结果\n\n  for (let i = 1; i < Math.floor(length / 2); i++) { // 遍历所有从第一个元素开始的有效步长\n    let step = 1; // 初始化步数为1，因为第一步已经走出\n    let index = i; // 将索引设为当前步长\n\n    while (index < length - 1) { // 只要没有走到数组的最后一个元素\n      index += numbers[index]; // 按照当前索引位置的数字值前进\n      step++; // 每走一步，步数加1\n    }\n\n    if (index === length - 1) { // 如果恰好到达数组的最后一个元素\n      result.push(step); // 将步数结果存入结果列表\n    }\n  }\n\n  if (result.length > 0) {\n    result.sort(); // 对步数结果进行排序\n    console.log(result[0]); // 输出最小的步数\n  } else {\n    console.log(-1); // 如果没有结果，输出-1\n  }\n\n  rl.close();\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> numbers; // 用于存储输入的整数\n    int num;\n    while(std::cin >> num) {\n        numbers.push_back(num); // 将输入的整数存入向量\n    }\n    int length = numbers.size(); // 获取数组的长度\n    std::vector<int> result; // 用于存储所有可能的步数结果\n    for(int i = 1; i < length / 2; i++) { // 遍历所有从第一个元素开始的有效步长\n        int step = 1; // 初始化步数为1，因为第一步已经走出\n        int index = i; // 将索引设为当前步长\n        while(index < length - 1) { // 只要没有走到数组的最后一个元素\n            index += numbers[index]; // 按照当前索引位置的数字值前进\n            step += 1; // 每走一步，步数加1\n        }\n        if(index == length - 1) { // 如果恰好到达数组的最后一个元素\n            result.push_back(step); // 将步数结果存入结果列表\n        }\n    }\n    if(result.size() > 0) {\n        std::sort(result.begin(), result.end()); // 对步数结果进行排序\n        std::cout << result[0] << std::endl; // 输出最小的步数\n    } else {\n        std::cout << -1 << std::endl; // 如果没有结果，输出-1\n    }\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int numbers[100];  \n    int length = 0; // 实际输入的元素个数\n    int num;\n\n    // 从标准输入读取一系列整数，直到遇到非数字或文件结束\n    while (scanf(\"%d\", &num) == 1) {\n        numbers[length++] = num;\n    }\n\n    int result[100]; // 存储所有可能的步数结果\n    int result_count = 0; // 记录结果数量\n\n    // 遍历所有从第一个元素开始的有效步长\n    for (int i = 1; i < length / 2; i++) {\n        int step = 1; // 初始化步数为1，因为第一步已经走出\n        int index = i; // 将索引设为当前步长\n\n        // 只要没有走到数组的最后一个元素\n        while (index < length - 1) {\n            index += numbers[index]; // 按照当前索引位置的数字值前进\n            step++; // 每走一步，步数加1\n        }\n\n        // 如果恰好到达数组的最后一个元素\n        if (index == length - 1) {\n            result[result_count++] = step; // 将步数结果存入结果数组\n        }\n    }\n\n    // 如果有有效的步数结果\n    if (result_count > 0) {\n        int min_step = result[0];\n        // 找出最小的步数\n        for (int i = 1; i < result_count; i++) {\n            if (result[i] < min_step) {\n                min_step = result[i];\n            }\n        }\n        printf(\"%d\\n\", min_step); // 输出最小的步数\n    } else {\n        printf(\"-1\\n\"); // 如果没有结果，输出-1\n    }\n\n    return 0;\n}"
  }
}