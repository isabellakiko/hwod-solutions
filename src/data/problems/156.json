{
  "id": "156",
  "title": "最佳植树距离",
  "examType": "A",
  "score": 200,
  "description": "按照环保公司要求，小明需要在沙化严重的地区进行植树防沙工作，初步目标是种植一条直线的树带。由于有些区域目前不适合种植树木，所以只能在一些可以种植的点来种植树木。\n在树苗有限的情况下，要达到最佳效果，就要尽量散开种植，不同树苗之间的最小间距要尽量大。给你一个适合种情树木的点坐标和一个树苗的数量，请帮小明选择一个最佳的最小种植间距。\n例如，适合种植树木的位置分别为1,3,5,6,7,10,13 树苗数量是3，种植位置在1,7,13，树苗之间的间距都是6，均匀分开，就达到了散开种植的目的，最佳的最小种植间距是6\n",
  "inputDesc": "第1行表示适合种树的坐标数量 第2行是适合种树的坐标位置 第3行是树苗的数量\n例如：\n7 1 5 3 6 10 7 13 3\n",
  "outputDesc": "最佳的最小种植间距\n\n\n\n本题是LeetCode - 1552 两球之间的磁力_伏城之外的博客-CSDN博客\n的换皮题。题解请参考链接博客。\n",
  "examples": [
    {
      "input": "7\n1 5 3 6 10 7 13\n3",
      "output": "6",
      "explanation": "3棵树种在1,7,13位置，最小间距为6"
    },
    {
      "input": "5\n1 2 3 4 5\n3",
      "output": "2",
      "explanation": "3棵树种在1,3,5位置，最小间距为2"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二分答案**问题（LeetCode 1552变体）。\n\n**核心思路：**\n- 二分查找最大的最小间距\n- 贪心验证该间距能否种下m棵树\n\n**算法步骤：**\n1. 对坐标排序\n2. 二分范围[1, 最大坐标-最小坐标]\n3. 对于mid间距，贪心验证能否种m棵树\n4. 能种则尝试更大间距，否则缩小间距\n\n**时间复杂度**：O(NlogN + NlogD)，D为坐标范围",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    int[] positions = new int[n];\n    for (int i = 0; i < n; i++) {\n      positions[i] = sc.nextInt();\n    }\n\n    int m = sc.nextInt();\n\n    System.out.println(getResult(n, positions, m));\n  }\n\n  public static int getResult(int n, int[] positions, int m) {\n    Arrays.sort(positions);\n\n    int min = 1, max = positions[n - 1] - positions[0];\n    int ans = 0;\n\n    while (min <= max) {\n      int mid = (min + max) >> 1;\n\n      if (check(positions, m, mid)) {\n        ans = mid;\n        min = mid + 1;\n      } else {\n        max = mid - 1;\n      }\n    }\n\n    return ans;\n  }\n\n  public static boolean check(int[] positions, int m, int minDis) {\n    int count = 1;\n\n    int curPos = positions[0];\n    for (int i = 1; i < positions.length; i++) {\n      if (positions[i] - curPos >= minDis) {\n        count++;\n        curPos = positions[i];\n      }\n    }\n\n    return count >= m;\n  }\n}",
    "python": "# 输入获取\nn = int(input())\npositions = list(map(int, input().split()))\nm = int(input())\n\n\ndef check(minDis):\n    count = 1\n    curPos = positions[0]\n\n    for i in range(1, n):\n        if positions[i] - curPos >= minDis:\n            count += 1\n            curPos = positions[i]\n\n    return count >= m\n\n\n# 算法入口\ndef getResult():\n    positions.sort()\n\n    low = 1\n    high = positions[-1] - positions[0]\n    ans = 0\n\n    while low <= high:\n        mid = (low + high) >> 1\n\n        if check(mid):\n            ans = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst rl = require(\"readline\").createInterface({\n  input: process.stdin,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 3) {\n    const n = lines[0] - 0;\n    const positions = lines[1].split(\" \").map(Number);\n    const m = lines[2] - 0;\n\n    console.log(getResult(n, positions, m));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(n, positions, m) {\n  positions.sort((a, b) => a - b);\n\n  let min = 1;\n  let max = positions[n - 1] - positions[0];\n  let ans = 0;\n\n  while (min <= max) {\n    const mid = (min + max) >> 1;\n    if (check(positions, m, mid)) {\n      ans = mid;\n      min = mid + 1;\n    } else {\n      max = mid - 1;\n    }\n  }\n\n  return ans;\n}\n\nfunction check(positions, m, minDis) {\n  let count = 1;\n  let curPos = positions[0];\n\n  for (let i = 1; i < positions.length; i++) {\n    if (positions[i] - curPos >= minDis) {\n      count++;\n      curPos = positions[i];\n    }\n  }\n\n  return count >= m;\n}",
    "cpp": "",
    "c": ""
  }
}