{
  "id": "34",
  "title": "最小的调整次数特异性双端队列",
  "examType": "A",
  "score": 100,
  "description": "有一个特异性的双端队列，该队列可以从头部或尾部添加数据，但是只能从头部移出数据。\n小A依次执行2n个指令往队列中添加数据和移出数据。其中n个指令是添加数据（可能从头部添加、也可能从尾部添加），依次添加1到n；n个指令是移出数据。\n现在要求移除数据的顺序为1到n。\n为了满足最后输出的要求，小A可以在任何时候调整队列中数据的顺序。\n请问 小A 最少需要调整几次才能够满足移除数据的顺序正好是1到n。",
  "inputDesc": "第一行一个数据n，表示数据的范围。\n接下来的2n行，其中有n行为添加数据，指令为：\nhead add x表示从头部添加数据 x，tail add x 表示从尾部添加数据x，\n另外 n 行为移出数据指令，指令为：remove 的形式，表示移出1个数据；\n1 ≤ n ≤ 3 * 10^5。\n所有的数据均合法。",
  "outputDesc": "一个整数，表示 小A 要调整的最小次数。",
  "examples": [
    {
      "input": "5\nhead add 1\ntail add 2\nremove\nhead add 3\ntail add 4\nhead add 5\nremove\nremove\nremove\nremove",
      "output": "1",
      "explanation": "n=5，依次添加1-5并移除。\n1. head add 1 → [1]\n2. tail add 2 → [1,2]\n3. remove → 移除1 ✓\n4. head add 3 → [3,2] ← 从头部加，顺序乱了\n5. tail add 4 → [3,2,4]\n6. head add 5 → [5,3,2,4]\n7. remove → 需要移除2，但队头是5，需调整1次\n之后按序移除3,4,5。\n总共调整1次。"
    },
    {
      "input": "3\ntail add 1\ntail add 2\ntail add 3\nremove\nremove\nremove",
      "output": "0",
      "explanation": "全部从尾部添加，顺序为[1,2,3]，依次移除1,2,3，无需调整。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟**问题。\n\n**核心观察：**\n- 如果所有元素都从尾部添加，队列天然有序\n- 如果在队列非空时从头部添加，会破坏顺序\n- 每次remove前如果顺序被破坏，就需要调整一次\n\n**算法步骤：**\n\n1. 维护一个标志 in_order 表示当前队列是否有序\n2. head add：如果队列非空且当前有序，则标记为无序\n3. remove：如果当前无序，调整次数+1，并重置为有序\n4. 返回调整次数\n\n**时间复杂度**：O(n)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int number = scanner.nextInt();//数据的范围\n        scanner.nextLine();\n\n        Queue<Integer> queue = new LinkedList<>();//模拟双端队列\n        boolean in_order = true;//是否按顺序删除\n        int result = 0;//最小的调整顺序次数\n\n        for (int i = 0; i < 2 * number; i++) {\n            String input_str = scanner.nextLine();\n            String[] operation = input_str.split(\" \");\n            if (operation[0].equals(\"head\")) {//从头部添加元素\n                if (!queue.isEmpty() && in_order) {//不按顺序删除\n                    in_order = false;\n                }\n                queue.add(Integer.parseInt(operation[2]));\n            } else if (operation[0].equals(\"tail\")) {//从尾部添加元素\n                queue.add(Integer.parseInt(operation[2]));\n            } else {//删除元素\n                if (queue.isEmpty()) {\n                    continue;\n                }\n                if (!in_order) {//不按顺序删除\n                    result++;\n                    in_order = true;\n                }\n                queue.poll();\n            }\n        }\n\n        System.out.println(result);//输出最小的调整顺序次数\n    }\n}",
    "python": "from collections import deque\n\nnumber = int(input()) # 数据的范围\n\nqueue = deque() # 模拟双端队列\nin_order = True # 是否按顺序删除\nresult = 0 # 最小的调整顺序次数\n\nfor i in range(2 * number):\n    input_str = input()\n    operation = input_str.split(\" \")\n    if operation[0] == \"head\": # 从头部添加元素\n        if len(queue) != 0 and in_order: # 不按顺序删除\n            in_order = False\n        queue.appendleft(int(operation[2]))\n    elif operation[0] == \"tail\": # 从尾部添加元素\n        queue.append(int(operation[2]))\n    else: # 删除元素\n        if len(queue) == 0:\n            continue\n        if not in_order: # 不按顺序删除\n            result += 1\n            in_order = True\n        queue.pop()\n\nprint(result) # 输出最小的调整顺序次数",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet number = 0;\nlet operations = [];\n\nrl.on('line', (input) => {\n  if (number === 0) {\n    number = parseInt(input);\n  } else {\n    operations.push(input.split(\" \"));\n    if (operations.length === 2 * number) {\n      rl.close();\n    }\n  }\n});\n\nconst queue = []; // 模拟双端队列\nlet in_order = true; // 是否按顺序删除\nlet result = 0; // 最小的调整顺序次数\n\nrl.on('close', () => {\n  for (let i = 0; i < 2 * number; i++) {\n    const operation = operations[i];\n     if (operation[0] === \"head\") { // 从头部添加元素\n      if (queue.length !== 0 && in_order) { // 不按顺序删除\n        in_order = false;\n      }\n      queue.unshift(parseInt(operation[2]));\n    } else if (operation[0] === \"tail\") { // 从尾部添加元素\n      queue.push(parseInt(operation[2]));\n    } else { // 删除元素\n      if (queue.length === 0) {\n        continue;\n      }\n      if (!in_order) { // 不按顺序删除\n        result += 1;\n        in_order = true;\n      }\n      queue.pop();\n    }\n  }\n  console.log(result); // 输出最小的调整顺序次数\n});",
    "cpp": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint main() {\n    int number;\n    cin >> number;\n    cin.ignore();\n\n    queue<int> queue;\n    bool in_order = true;\n    int result = 0;\n\n    for (int i = 0; i < 2 * number; i++) {\n        string input_str;\n        getline(cin, input_str);\n        string operation[3];\n        int j = 0;\n        for (char c : input_str) {\n            if (c == ' ') {\n                j++;\n            } else {\n                operation[j] += c;\n            }\n        }\n        if (operation[0] == \"head\") {\n            if (!queue.empty() && in_order) {\n                in_order = false;\n            }\n            queue.push(stoi(operation[2]));\n        } else if (operation[0] == \"tail\") {\n            queue.push(stoi(operation[2]));\n        } else {\n            if (queue.empty()) {\n                continue;\n            }\n            if (!in_order) {\n                result++;\n                in_order = true;\n            }\n            queue.pop();\n        }\n    }\n\n    cout << result << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 600000 // 定义队列的最大容量（2n）\n\nint queue[MAX_SIZE]; // 模拟双端队列的数组\nint front = 0; // 队列头部索引\nint rear = -1; // 队列尾部索引\nint size = 0; // 当前队列中的元素数量\n\nint main() {\n    int n;\n    scanf(\"%d\", &n); // 读取数据范围n\n\n    int result = 0; // 记录最小的调整顺序次数\n    int expected = 1; // 期望移除的下一个元素\n    int in_order = 1; // 标记是否按顺序删除\n\n    for (int i = 0; i < 2 * n; i++) {\n        char operation[10];\n        int x;\n\n        scanf(\"%s\", operation); // 读取操作类型\n\n        if (operation[0] == 'r') { // 如果是 \"remove\" 操作\n            if (queue[front] != expected) { // 如果移除的元素不是期望的\n                in_order = 0; // 标记为不按顺序\n            } else {\n                expected++; // 移除的元素符合预期，更新下一个期望值\n            }\n            front = (front + 1) % MAX_SIZE; // 更新头部索引\n            size--; // 减少队列中的元素数量\n        } else { // 如果是 \"head add\" 或 \"tail add\" 操作\n            scanf(\"%*s %d\", &x); // 读取要添加的元素x\n\n            if (operation[0] == 'h') { // 如果是 \"head add\"\n                front = (front - 1 + MAX_SIZE) % MAX_SIZE; // 更新头部索引\n                queue[front] = x; // 从头部添加元素\n            } else { // 如果是 \"tail add\"\n                rear = (rear + 1) % MAX_SIZE; // 更新尾部索引\n                queue[rear] = x; // 从尾部添加元素\n            }\n            size++; // 增加队列中的元素数量\n        }\n        \n        if (!in_order && size == 0) { // 如果当前不按顺序且队列为空\n            result++; // 增加调整次数\n            in_order = 1; // 重置为按顺序状态\n        }\n    }\n\n    printf(\"%d\\n\", result); // 输出最小的调整顺序次数\n\n    return 0;\n}"
  }
}