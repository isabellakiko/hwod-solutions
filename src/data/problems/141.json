{
  "id": "141",
  "title": "跳格子3",
  "examType": "A",
  "score": 200,
  "description": "小明和朋友们一起玩跳格子游戏，每个格子上有特定的分数 score = [1, -1, -6, 7, -17, 7]，\n从起点score[0]开始，每次最大的步长为k，请你返回小明跳到终点 score[n-1] 时，能得到的最大得分。",
  "inputDesc": "第一行输入总的格子数量 n\n第二行输入每个格子的分数 score[i]\n第三行输入最大跳的步长 k\n格子的总长度 n 和步长 k 的区间在 [1, 100000] 每个格子的分数 score[i] 在 [-10000, 10000] 区间中\n格子的总长度 n 和步长 k 的区间在 [1, 100000]\n每个格子的分数 score[i] 在 [-10000, 10000] 区间中",
  "outputDesc": "输出最大得分",
  "examples": [
    {
      "input": "6\n1 -1 -6 7 -17 7\n2",
      "output": "14",
      "explanation": "从score[0]=1开始，最大步长2，最优路径1->7->7，得分1+7+7=15，但必须到终点，最优解为14"
    },
    {
      "input": "3\n1 2 3\n1",
      "output": "6",
      "explanation": "步长为1，必须依次跳过每个格子，得分1+2+3=6"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**动态规划+单调队列优化**问题。\n\n**核心思路：**\n- dp[i]表示到达第i格的最大得分\n- dp[i] = max(dp[i-k]...dp[i-1]) + score[i]\n- 用单调队列维护滑动窗口最大值\n\n**算法步骤：**\n1. 初始化dp[0]=score[0]，队列加入索引0\n2. 遍历每格，移除超出k范围的队首元素\n3. dp[i]=score[i]+dp[队首]，队首为窗口最大值\n4. 维护队列单调递减，将当前索引入队\n5. 返回dp[n-1]\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args)  {\n        Scanner sc = new Scanner(System.in);\n \n        int n = Integer.parseInt(sc.nextLine());\n        int[] scores = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        int k = Integer.parseInt(sc.nextLine());\n    \n\n        // 特殊情况处理：如果格子数量为1，直接输出该格子的分数\n        if (n == 1) {\n            System.out.println(scores[0]);\n            return;\n        }\n\n        // 动态规划数组，dp[i]存储到达第i个格子时能得到的最大分数\n        int[] dp = new int[n];\n        dp[0] = scores[0]; // 初始化，起点的最大分数就是起点的分数\n\n        // 使用双端队列来维护窗口内的最大dp值的索引\n        Deque<Integer> deque = new LinkedList<>();\n        deque.add(0);\n\n        for (int i = 1; i < n; i++) {\n            // 如果队列不为空且队列头部的索引已经超出了跳跃范围，从队列中移除头部\n            if (!deque.isEmpty() && deque.peekFirst() < i - k) {\n                deque.pollFirst();\n            }\n\n            // 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n            dp[i] = scores[i] + (deque.isEmpty() ? 0 : dp[deque.peekFirst()]);\n\n            // 维护队列，保持队列为递减，新的最大值需要添加到队尾\n            while (!deque.isEmpty() && dp[deque.peekLast()] <= dp[i]) {\n                deque.pollLast();\n            }\n\n            // 将当前索引加到队列尾部\n            deque.addLast(i);\n        }\n\n        // 输出到达最后一个格子时能得到的最大分数\n        System.out.println(dp[n - 1]);\n    }\n}",
    "python": "from collections import deque\n\nn = int(input().strip())\nscores = list(map(int, input().strip().split()))\nk = int(input().strip())\n\n# 特殊情况处理：如果格子数量为1，直接输出该格子的分数\nif n == 1:\n    print(scores[0])\n    exit()\n\n# 动态规划数组，dp[i]存储到达第i个格子时能得到的最大分数\ndp = [0] * n\ndp[0] = scores[0]  # 初始化，起点的最大分数就是起点的分数\n\n# 使用双端队列来维护窗口内的最大dp值的索引\ndeque = deque([0])\n\nfor i in range(1, n):\n    # 如果队列不为空且队列头部的索引已经超出了跳跃范围，从队列中移除头部\n    if deque and deque[0] < i - k:\n        deque.popleft()\n\n    # 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n    dp[i] = scores[i] + (dp[deque[0]] if deque else 0)\n\n    # 维护队列，保持队列为递减，新的最大值需要添加到队尾\n    while deque and dp[deque[-1]] <= dp[i]:\n        deque.pop()\n\n    # 将当前索引加到队列尾部\n    deque.append(i)\n\n# 输出到达最后一个格子时能得到的最大分数\nprint(dp[-1])",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst inputs = [];\nrl.on('line', function(line) {\n    inputs.push(line);\n}).on('close', function() {\n    const n = parseInt(inputs[0]); // 读取第一行输入，格子的数量\n    const scores = inputs[1].split(' ').map(Number); // 读取第二行输入，并转化为整数数组\n    const k = parseInt(inputs[2]); // 读取第三行输入，跳跃的最大范围\n\n    // 特殊情况处理：如果格子数量为1，直接输出该格子的分数\n    if (n === 1) {\n        console.log(scores[0]);\n        return;\n    }\n\n    // 动态规划数组，dp[i]存储到达第i个格子时能得到的最大分数\n    const dp = Array(n).fill(0);\n    dp[0] = scores[0]; // 初始化，起点的最大分数就是起点的分数\n\n    // 使用双端队列来维护窗口内的最大dp值的索引\n    const deque = [];\n    deque.push(0);\n\n    for (let i = 1; i < n; i++) {\n        // 如果队列不为空且队列头部的索引已经超出了跳跃范围，从队列中移除头部\n        while (deque.length > 0 && deque[0] < i - k) {\n            deque.shift();\n        }\n\n        // 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n        dp[i] = scores[i] + (deque.length === 0 ? 0 : dp[deque[0]]);\n\n        // 维护队列，保持队列为递减，新的最大值需要添加到队尾\n        while (deque.length > 0 && dp[deque[deque.length - 1]] <= dp[i]) {\n            deque.pop();\n        }\n\n        // 将当前索引加到队列尾部\n        deque.push(i);\n    }\n\n    // 输出到达最后一个格子时能得到的最大分数\n    console.log(dp[n - 1]);\n    \n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <sstream>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n;\n    cin.ignore(); // 忽略换行符，以便读取下一行分数\n\n    string line;\n    getline(cin, line);\n    stringstream ss(line);\n    vector<int> scores(n);\n    for (int &score : scores) {\n        ss >> score;\n    }\n    cin >> k;\n\n    // 特殊情况处理：如果格子数量为1，直接输出该格子的分数\n    if (n == 1) {\n        cout << scores[0] << endl;\n        return 0;\n    }\n\n    // 动态规划数组，dp[i]存储到达第i个格子时能得到的最大分数\n    vector<int> dp(n);\n    dp[0] = scores[0]; // 初始化，起点的最大分数就是起点的分数\n\n    // 使用双端队列来维护窗口内的最大dp值的索引\n    deque<int> deque;\n    deque.push_back(0);\n\n    for (int i = 1; i < n; i++) {\n        // 如果队列不为空且队列头部的索引已经超出了跳跃范围，从队列中移除头部\n        if (!deque.empty() && deque.front() < i - k) {\n            deque.pop_front();\n        }\n\n        // 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n        dp[i] = scores[i] + (deque.empty() ? 0 : dp[deque.front()]);\n\n        // 维护队列，保持队列为递减，新的最大值需要添加到队尾\n        while (!deque.empty() && dp[deque.back()] <= dp[i]) {\n            deque.pop_back();\n        }\n\n        // 将当前索引加到队列尾部\n        deque.push_back(i);\n    }\n\n    // 输出到达最后一个格子时能得到的最大分数\n    cout << dp[n - 1] << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    int n, k;\n    scanf(\"%d\", &n); // 读取格子的数量\n\n    int scores[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &scores[i]); // 读取每个格子的分数\n    }\n    scanf(\"%d\", &k); // 读取跳跃的最大范围\n\n    // 特殊情况处理：如果格子数量为1，直接输出该格子的分数\n    if (n == 1) {\n        printf(\"%d\\n\", scores[0]);\n        return 0;\n    }\n\n    int dp[n];\n    dp[0] = scores[0]; // 初始化，起点的最大分数就是起点的分数\n\n    // 使用数组模拟窗口内最大dp值的索引\n    int window[n];\n    int start = 0, end = 0; // 窗口的起始和终止位置\n    window[end++] = 0;\n\n    for (int i = 1; i < n; i++) {\n        // 如果窗口的第一个元素已经超出了跳跃范围，从窗口中移除该元素\n        if (window[start] < i - k) {\n            start++;\n        }\n\n        // 计算当前格子的最大分数：当前格子的分数加上可以跳到该格子的最大分数\n        dp[i] = scores[i] + dp[window[start]];\n\n        // 维护窗口，保持窗口内为递减，新的最大值需要添加到窗口尾部\n        while (start < end && dp[window[end - 1]] <= dp[i]) {\n            end--;\n        }\n\n        // 将当前索引加到窗口尾部\n        window[end++] = i;\n    }\n\n    // 输出到达最后一个格子时能得到的最大分数\n    printf(\"%d\\n\", dp[n - 1]);\n    return 0;\n}"
  }
}