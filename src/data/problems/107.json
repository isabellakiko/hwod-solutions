{
  "id": "107",
  "title": "流浪地球",
  "examType": "A",
  "score": 100,
  "description": "流浪地球计划在赤道上均匀部署了N个转向发动机，按位置顺序编号为0~N-1。\n初始状态下所有的发动机都是未启动状态;发动机启动的方式分为”手动启动\"和”关联启动\"两种方式;如果在时刻1一个发动机被启动，下一个时刻2与之相邻的两个发动机就会被”关联启动”;如果准备启动某个发动机时，它已经被启动了，则什么都不用做;发动机0与发动机N-1是相邻的;\n地球联合政府准备挑选某些发动机在某些时刻进行“手动启动”。当然最终所有的发动机都会被启动。\n哪些发动机最晚被启动呢?",
  "inputDesc": "第一行两个数字N和E，中间有空格 N代表部署发动机的总个数，E代表计划手动启动的发动机总个数 1<N<=1000,1<=E<=1000,E<=N接下来共E行，每行都是两个数字T和P，中间有空格 T代表发动机的手动启动时刻，P代表此发动机的位置编号。 0<=T<=N.0<=P<N",
  "outputDesc": "第一行输出最晚被启动的发动机个数，第二行输出这些发动机的编号（空格分隔）",
  "examples": [
    {
      "input": "8 2\n0 2\n0 6",
      "output": "2\n0 4",
      "explanation": "8个发动机，时刻0启动2和6号。时刻1启动1,3,5,7。时刻2启动0和4，共2个最晚启动"
    },
    {
      "input": "8 2\n0 0\n1 7",
      "output": "1\n4",
      "explanation": "时刻0启动0号，时刻1启动7和1号，最终4号最晚被启动"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**BFS模拟**问题。\n\n**核心思路：**\n- 发动机排列成环（0和N-1相邻）\n- 手动启动后，相邻发动机会在下一时刻关联启动\n- 找出最晚被启动的发动机\n\n**算法步骤：**\n1. 初始化所有发动机状态为-1（未启动）\n2. 设置手动启动的发动机时刻\n3. 模拟关联启动过程，更新相邻发动机\n4. 找出启动时刻最大的发动机\n\n**时间复杂度**：O(N×T)",
  "codes": {
    "java": "import java.util.*;\n\npublic class EngineManager {\n    // 检查数组中是否有引擎处于未激活状态（即状态为 -1）\n    public static boolean hasInactiveEngines(int[] engineStatuses) {\n        return Arrays.stream(engineStatuses).anyMatch(status -> status == -1);\n    }\n \n    // 激活指定引擎的相邻引擎\n    public static void activateAdjacentEngines(int[] engineStatuses, int currentEngine, int activationTime, int totalEngines) {\n        int leftEngine = currentEngine == 0 ? totalEngines - 1 : (currentEngine - 1);  // 计算左边相邻引擎的索引\n        int rightEngine = currentEngine == totalEngines - 1 ? 0 : currentEngine + 1;  // 计算右边相邻引擎的索引\n        engineStatuses[leftEngine] = engineStatuses[leftEngine] == -1 ? activationTime : engineStatuses[leftEngine];  // 若左引擎未激活，则激活\n        engineStatuses[rightEngine] = engineStatuses[rightEngine] == -1 ? activationTime : engineStatuses[rightEngine];  // 若右引擎未激活，则激活\n    }\n \n    // 更新所有引擎的激活状态，直到所有引擎都被激活\n    public static void updateEngineStatuses(int[] engineStatuses, int startTime) {\n        boolean continueUpdate = true;\n        while (continueUpdate) {\n            for (int i = 0; i < engineStatuses.length; i++) {\n                if (engineStatuses[i] == startTime) {              \n                    activateAdjacentEngines(engineStatuses, i, startTime + 1, engineStatuses.length);  // 激活当前引擎的相邻引擎\n                }\n            }\n            startTime++;  // 增加时间步长，检查下一个时间点\n            continueUpdate = hasInactiveEngines(engineStatuses);  // 检查是否还有未激活的引擎\n        }\n        int lastActivationTime = Arrays.stream(engineStatuses).max().getAsInt();  // 获取最后一个被激活的时间\n        int countActiveEngines = 0;\n        StringBuilder enginesReport = new StringBuilder();\n        for (int i = 0; i < engineStatuses.length; i++) {\n            if(lastActivationTime == engineStatuses[i]) {\n                enginesReport.append(i + \" \");\n                countActiveEngines++;\n            }\n        }\n        System.out.println(countActiveEngines);  // 输出最后激活时间的引擎数量\n        System.out.println(enginesReport.toString().trim());  // 输出这些引擎的编号\n    }\n \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNextLine()) {\n            String[] inputs = scanner.nextLine().split(\" \");\n            int numberOfEngines = Integer.parseInt(inputs[0]);  // 引擎总数\n            int numberOfEntries = Integer.parseInt(inputs[1]);  // 输入的数据条数\n\n            int[] engineStatuses = new int[numberOfEngines];\n            Arrays.fill(engineStatuses, -1);  // 初始状态设置所有引擎为未激活\n            int earliestActivation = Integer.MAX_VALUE;\n\n            for (int i = 0; i < numberOfEntries; i++) {\n                String[] timeIndex = scanner.nextLine().split(\" \");\n                int activationTime = Integer.parseInt(timeIndex[0]);  // 激活时间\n                int engineIndex = Integer.parseInt(timeIndex[1]);  // 引擎索引\n                engineStatuses[engineIndex] = activationTime;  // 设置激活时间\n                earliestActivation = Math.min(earliestActivation, activationTime);  // 记录最早的激活时间\n            }\n            updateEngineStatuses(engineStatuses, earliestActivation);  // 根据最早的激活时间开始更新状态\n        }\n    }\n}",
    "python": "def has_inactive_engines(engine_statuses):\n    \"\"\"检查列表中是否有引擎处于未激活状态（即状态为 -1）。\n    返回值为布尔类型，True表示存在未激活的引擎，False则表示所有引擎均已激活。\"\"\"\n    return -1 in engine_statuses\n\ndef activate_adjacent_engines(engine_statuses, current_engine, activation_time, total_engines):\n    \"\"\"激活指定引擎的相邻引擎。计算并更新左右两边的引擎状态。\n    - current_engine: 当前引擎的索引。\n    - activation_time: 当前引擎的激活时间。\n    - total_engines: 引擎总数，用于计算边界条件。\"\"\"\n    left_engine = total_engines - 1 if current_engine == 0 else current_engine - 1\n    right_engine = 0 if current_engine == total_engines - 1 else current_engine + 1\n    if engine_statuses[left_engine] == -1:\n        engine_statuses[left_engine] = activation_time\n    if engine_statuses[right_engine] == -1:\n        engine_statuses[right_engine] = activation_time\n\ndef update_engine_statuses(engine_statuses, start_time):\n    \"\"\"更新所有引擎的激活状态，直到所有引擎都被激活。\n    进行循环检查，若当前时间点有引擎被激活，则激活其相邻引擎，并递增时间步长。\"\"\"\n    continue_update = True\n    while continue_update:\n        for i, status in enumerate(engine_statuses):\n            if status == start_time:        \n                activate_adjacent_engines(engine_statuses, i, start_time + 1, len(engine_statuses))\n        start_time += 1\n        continue_update = has_inactive_engines(engine_statuses)\n    last_activation_time = max(engine_statuses)\n    count_active_engines = sum(status == last_activation_time for status in engine_statuses)\n    engines_report = ' '.join(str(i) for i, status in enumerate(engine_statuses) if status == last_activation_time)\n    print(count_active_engines)  # 打印在最后一个激活时间被激活的引擎数量\n    print(engines_report.strip())  # 打印这些引擎的索引\n\n# 主循环，持续接受输入直到遇到文件结束符（EOF）\nwhile True:\n    try:\n        inputs = input().split()\n        number_of_engines = int(inputs[0])  # 读取引擎总数\n        number_of_entries = int(inputs[1])  # 读取条目数量\n\n        engine_statuses = [-1] * number_of_engines  # 初始化引擎状态数组，初始值为-1表示未激活\n        earliest_activation = float('inf')  # 设置最早激活时间为无穷大\n\n        for _ in range(number_of_entries):\n            time_index = input().split()\n            activation_time = int(time_index[0])\n            engine_index = int(time_index[1])\n            engine_statuses[engine_index] = activation_time  # 更新指定引擎的激活时间\n            earliest_activation = min(earliest_activation, activation_time)  # 更新最早激活时间\n\n        update_engine_statuses(engine_statuses, earliest_activation)  # 根据最早激活时间更新引擎状态\n    except EOFError:\n        break  # 结束循环，等待输入结束",
    "javascript": "// 引入 readline 模块并创建接口用于读取来自标准输入（stdin）的数据\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\n\n// 创建异步迭代器，用于按行读取输入\nvar iter = rl[Symbol.asyncIterator]();\n\n// 定义一个异步函数用于读取一行输入\nconst readline = async () => (await iter.next()).value;\n\n// 立即执行的异步函数\nvoid (async function () {\n    // 读取一行输入并按空格分割，获取输入的参数\n    const inputs = (await readline()).split(\" \");\n    const numberOfEngines = parseInt(inputs[0], 10);  // 引擎总数\n    const numberOfEntries = parseInt(inputs[1], 10);  // 输入的数据条数\n\n    // 创建一个数组，初始值为 -1，表示所有引擎初始时都未激活\n    const engineStatuses = new Array(numberOfEngines).fill(-1);\n    let earliestActivation = Infinity;  // 设置一个变量用于记录最早的激活时间\n\n    // 遍历每一个输入条目\n    for (let i = 0; i < numberOfEntries; i++) {\n        const timeIndex = (await readline()).split(\" \");\n        const activationTime = parseInt(timeIndex[0], 10);  // 读取激活时间\n        const engineIndex = parseInt(timeIndex[1], 10);  // 读取引擎索引\n        engineStatuses[engineIndex] = activationTime;  // 设置引擎的激活时间\n        earliestActivation = Math.min(earliestActivation, activationTime);  // 更新最早的激活时间\n    }\n\n    // 根据最早的激活时间开始更新所有引擎的状态\n    await updateEngineStatuses(engineStatuses, earliestActivation);\n    process.exit(0);  // 执行完成后退出程序\n})();\n\n// 检查是否有未激活的引擎\nfunction hasInactiveEngines(engineStatuses) {\n    return engineStatuses.some(status => status === -1);  // 使用 some 方法检查数组中是否存在未激活的引擎\n}\n\n// 激活指定引擎的相邻引擎\nfunction activateAdjacentEngines(engineStatuses, currentEngine, activationTime, totalEngines) {\n    const leftEngine = currentEngine === 0 ? totalEngines - 1 : currentEngine - 1;  // 计算左侧相邻引擎的索引\n    const rightEngine = currentEngine === totalEngines - 1 ? 0 : currentEngine + 1;  // 计算右侧相邻引擎的索引\n    // 如果相邻引擎未激活，则设置其激活时间\n    if (engineStatuses[leftEngine] === -1) {\n        engineStatuses[leftEngine] = activationTime;\n    }\n    if (engineStatuses[rightEngine] === -1) {\n        engineStatuses[rightEngine] = activationTime;\n    }\n}\n\n// 循环更新所有引擎的状态，直到没有未激活的引擎\nasync function updateEngineStatuses(engineStatuses, startTime) {\n    let continueUpdate = true;\n    while (continueUpdate) {\n        for (let i = 0; i < engineStatuses.length; i++) {\n            if (engineStatuses[i] === startTime) {\n                activateAdjacentEngines(engineStatuses, i, startTime + 1, engineStatuses.length);\n            }\n        }\n        startTime++;  // 增加时间步，继续检查和更新状态\n        continueUpdate = hasInactiveEngines(engineStatuses);  // 检查是否还有未激活的引擎\n    }\n    const lastActivationTime = Math.max(...engineStatuses);  // 计算最后一个被激活的时间\n    const countActiveEngines = engineStatuses.filter(status => status === lastActivationTime).length;  // 计算在最后一次激活时间激活的引擎数量\n    const enginesReport = engineStatuses.map((status, index) => status === lastActivationTime ? index : '').filter(String).join(' ');  // 创建引擎索引报告\n\n    console.log(countActiveEngines);  // 输出激活的引擎数量\n    console.log(enginesReport.trim());  // 输出激活的引擎索引\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <limits>\nusing namespace std;\n\n// 检查 vector 中是否有引擎处于未激活状态（即状态为 -1）\nbool hasInactiveEngines(const vector<int>& engineStatuses) {\n    return find(engineStatuses.begin(), engineStatuses.end(), -1) != engineStatuses.end();\n}\n\n// 激活指定引擎的相邻引擎\nvoid activateAdjacentEngines(vector<int>& engineStatuses, int currentEngine, int activationTime, int totalEngines) {\n    int leftEngine = currentEngine == 0 ? totalEngines - 1 : currentEngine - 1; // 计算左边相邻引擎的索引\n    int rightEngine = currentEngine == totalEngines - 1 ? 0 : currentEngine + 1; // 计算右边相邻引擎的索引\n    if (engineStatuses[leftEngine] == -1) {\n        engineStatuses[leftEngine] = activationTime; // 若左引擎未激活，则激活\n    }\n    if (engineStatuses[rightEngine] == -1) {\n        engineStatuses[rightEngine] = activationTime; // 若右引擎未激活，则激活\n    }\n}\n\n// 更新所有引擎的激活状态，直到所有引擎都被激活\nvoid updateEngineStatuses(vector<int>& engineStatuses, int startTime) {\n    bool continueUpdate = true;\n    while (continueUpdate) {\n        for (size_t i = 0; i < engineStatuses.size(); i++) {\n            if (engineStatuses[i] == startTime) {\n                activateAdjacentEngines(engineStatuses, i, startTime + 1, engineStatuses.size()); // 激活当前引擎的相邻引擎\n            }\n        }\n        startTime++; // 增加时间步长，检查下一个时间点\n        continueUpdate = hasInactiveEngines(engineStatuses); // 检查是否还有未激活的引擎\n    }\n    int lastActivationTime = *max_element(engineStatuses.begin(), engineStatuses.end()); // 获取最后一个被激活的时间\n    int countActiveEngines = count(engineStatuses.begin(), engineStatuses.end(), lastActivationTime); // 计算最后激活时间的引擎数量\n    cout << countActiveEngines << endl; // 输出最后激活时间的引擎数量\n    for (size_t i = 0; i < engineStatuses.size(); i++) {\n        if (engineStatuses[i] == lastActivationTime) {\n            cout << i << \" \"; // 输出最后激活时间的引擎编号\n        }\n    }\n    cout << endl;\n}\n\nint main() {\n    string input;\n    while (getline(cin, input)) {\n        stringstream ss(input);\n        int numberOfEngines, numberOfEntries;\n        ss >> numberOfEngines >> numberOfEntries;\n\n        vector<int> engineStatuses(numberOfEngines, -1); // 初始状态设置所有引擎为未激活\n        int earliestActivation = numeric_limits<int>::max(); // 设置最早的激活时间为最大值\n\n        for (int i = 0; i < numberOfEntries; i++) {\n            getline(cin, input);\n            stringstream ss2(input);\n            int activationTime, engineIndex;\n            ss2 >> activationTime >> engineIndex;\n            engineStatuses[engineIndex] = activationTime; // 设置激活时间\n            earliestActivation = min(earliestActivation, activationTime); // 更新最早的激活时间\n        }\n        updateEngineStatuses(engineStatuses, earliestActivation); // 根据最早的激活时间开始更新状态\n    }\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n// 检查数组中是否有引擎处于未激活状态（即状态为 -1）\nint hasInactiveEngines(int *engineStatuses, int totalEngines) {\n    for (int i = 0; i < totalEngines; i++) {\n        if (engineStatuses[i] == -1) {\n            return 1;  // 发现未激活的引擎，返回1表示\"真\"\n        }\n    }\n    return 0;  // 所有引擎都已激活，返回0表示\"假\"\n}\n\n// 激活指定引擎的相邻引擎\nvoid activateAdjacentEngines(int *engineStatuses, int currentEngine, int activationTime, int totalEngines) {\n    int leftEngine = currentEngine == 0 ? totalEngines - 1 : currentEngine - 1;  // 计算左边相邻引擎的索引\n    int rightEngine = currentEngine == totalEngines - 1 ? 0 : currentEngine + 1;  // 计算右边相邻引擎的索引\n    if (engineStatuses[leftEngine] == -1) {\n        engineStatuses[leftEngine] = activationTime;  // 若左引擎未激活，则激活\n    }\n    if (engineStatuses[rightEngine] == -1) {\n        engineStatuses[rightEngine] = activationTime;  // 若右引擎未激活，则激活\n    }\n}\n\n// 更新所有引擎的激活状态，直到所有引擎都被激活\nvoid updateEngineStatuses(int *engineStatuses, int startTime, int totalEngines) {\n    int continueUpdate = 1;\n    while (continueUpdate) {\n        for (int i = 0; i < totalEngines; i++) {\n            if (engineStatuses[i] == startTime) {\n                activateAdjacentEngines(engineStatuses, i, startTime + 1, totalEngines);  // 激活当前引擎的相邻引擎\n            }\n        }\n        startTime++;  // 增加时间步长，检查下一个时间点\n        continueUpdate = hasInactiveEngines(engineStatuses, totalEngines);  // 检查是否还有未激活的引擎\n    }\n    int lastActivationTime = -1;\n    int countActiveEngines = 0;\n    for (int i = 0; i < totalEngines; i++) {\n        if (engineStatuses[i] > lastActivationTime) {\n            lastActivationTime = engineStatuses[i];  // 更新最后一个被激活的时间\n        }\n    }\n    for (int i = 0; i < totalEngines; i++) {\n        if (engineStatuses[i] == lastActivationTime) {\n            countActiveEngines++;  // 计算最后激活时间的引擎数量\n        }\n    }\n    printf(\"%d\\n\", countActiveEngines);  // 输出最后激活时间的引擎数量\n    for (int i = 0; i < totalEngines; i++) {\n        if (engineStatuses[i] == lastActivationTime) {\n            printf(\"%d \", i);  // 输出这些引擎的编号\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    char line[1024];\n    while (fgets(line, sizeof(line), stdin)) {  // 从标准输入读取一行\n        int numberOfEngines, numberOfEntries;\n        sscanf(line, \"%d %d\", &numberOfEngines, &numberOfEntries);  // 解析引擎总数和输入的数据条数\n\n        int *engineStatuses = (int *)malloc(numberOfEngines * sizeof(int));\n        memset(engineStatuses, -1, numberOfEngines * sizeof(int));  // 初始状态设置所有引擎为未激活\n        int earliestActivation = INT_MAX;\n\n        for (int i = 0; i < numberOfEntries; i++) {\n            fgets(line, sizeof(line), stdin);  // 读取每个激活信息\n            int activationTime, engineIndex;\n            sscanf(line, \"%d %d\", &activationTime, &engineIndex);  // 解析激活时间和引擎索引\n            engineStatuses[engineIndex] = activationTime;  // 设置激活时间\n            if (activationTime < earliestActivation) {\n                earliestActivation = activationTime;  // 更新最早的激活时间\n            }\n        }\n        updateEngineStatuses(engineStatuses, earliestActivation, numberOfEngines);  // 根据最早的激活时间开始更新状态\n        free(engineStatuses);  // 释放动态分配的内存\n    }\n    return 0;\n}"
  }
}