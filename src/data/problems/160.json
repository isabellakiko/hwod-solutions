{
  "id": "160",
  "title": "简易内存池",
  "examType": "A",
  "score": 200,
  "description": "请实现一个简易内存池,根据请求命令完成内存分配和释放。内存池支持两种操作命令，REQUEST和RELEASE，其格式为：REQUEST=请求的内存大小 表示请求分配指定大小内存，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0，则输出error。RELEASE=释放的内存首地址 表示释放掉之前分配的内存，释放成功无需输出，如果释放不存在的首地址则输出error。\n\n注意：\n内存池总大小为100字节。内存池地址分配必须是连续内存，并优先从低地址分配。内存释放后可被再次分配，已释放的内存在空闲时不能被二次释放。不会释放已申请的内存块的中间地址。释放操作只是针对首地址所对应的单个内存块进行操作，不会影响其它内存块。\n",
  "inputDesc": "首行为整数 N , 表示操作命令的个数，取值范围：0 < N <= 100。\n接下来的N行, 每行将给出一个操作命令，操作命令和参数之间用 “=”分割。\n",
  "outputDesc": "请求分配指定大小内存时，如果分配成功，返回分配到的内存首地址；如果内存不足，或指定的大小为0，则输出error\n释放掉之前分配的内存时，释放成功无需输出，如果释放不存在的首地址则输出error。\n\n第一条指令，申请地址0~9的10个字节内存，返回首地址0\n第二条指令，申请地址10~29的20字节内存，返回首地址10\n第三条指令，释放首地址为0的内存申请，0~9地址内存被释放，变为空闲，释放成功，无需输出\n第四条指令，申请20字节内存，09地址内存连续空间不足20字节，往后查找到3049地址，返回首地址30\n第五条指令，申请10字节，0~9地址内存空间足够，返回首地址0\n我的解题思路如下：\n定义一个used数组，用来存储已被占用的内存区间，即[起始位置，结束位置]。\n初始化给used数组一个 [100,101]，表示存在一个已占有内存区间[100,101]，这个内存区间将作为尾边界使用。\n\n当REQUEST申请size大小的内存时，我们从start=0位置开始申请，即申请[start, start+size-1]区间，接下来看该区间是否和used[i]区间存在交叉，如果存在交xian叉，则说明申请的内存区间中部分内存已被使用，因此我们应该更新 start = used[i][1] + 1位置，重新申请一个区间，这样就必然不和used[i]区间交叉了，但是要继续和used[i+1]区间比较。\n直到找到一个不存在交叉的内存区间，打印此时的start，并将申请到的内存区间插入到used数组中，注意插入位置是 i 。\n如果一直都找不到不存在交叉的内存区间，则打印error。\n\n当RELEASE释放起始位置addr的内存时，我们只需要遍历每一个used[i]，比较used[i][0]和addr是否相同，若相同，则表示找到了要释放的内存，此时只要将used[i]从used中删除即可。\n如果没有找到，则打印error。\n",
  "examples": [
    {
      "input": "5\nREQUEST=10\nREQUEST=20\nRELEASE=0\nREQUEST=20\nREQUEST=10",
      "output": "0\n10\n30\n0",
      "explanation": "申请10字节返回0，申请20字节返回10，释放0，申请20返回30，申请10返回0(复用释放的空间)"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟**问题。\n\n**核心思路：**\n- 维护已占用内存区间列表\n- REQUEST时从低地址找连续空闲区间\n- RELEASE时移除对应区间\n\n**算法步骤：**\n1. 用列表存储已占用区间[start,end]\n2. REQUEST：遍历找不与已占用区间交叉的连续空间\n3. RELEASE：找到首地址匹配的区间并移除\n4. 找不到返回error\n\n**时间复杂度**：O(N²)，N为操作次数",
  "codes": {
    "java": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  // 输入获取\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    String[][] cmds = new String[n][2];\n    for (int i = 0; i < n; i++) cmds[i] = sc.next().split(\"=\");\n\n    getResult(n, cmds);\n  }\n\n  // 算法入口\n  public static void getResult(int n, String[][] cmds) {\n    // used保存被占用的内存 [起始地址，结束地址]，初始时有一个[100,101]作为尾边界限定\n    LinkedList<Integer[]> used = new LinkedList<>();\n    used.add(new Integer[] {100, 101});\n\n    for (String[] cmd : cmds) {\n      String key = cmd[0];\n      String val = cmd[1];\n\n      // 申请内存\n      if (\"REQUEST\".equals(key)) {\n        // 当指令为REQUEST时，对应值为要申请的内存的大小，即size\n        int size = Integer.parseInt(val);\n\n        // 我们默认从start=0位置开始检查可用内存区间\n        int start = 0;\n        boolean flag = true;\n\n        for (int i = 0; i < used.size(); i++) {\n          int end = start + size - 1;\n          // 要申请的内存区间\n          Integer[] range = {start, end};\n\n          // 检查要申请的内存区间和已占有的内存区间是否交叉\n          if (!hasIntersection(used.get(i), range)) {\n            // 若不存在交叉，则将申请区间加入used中\n            used.add(i, range);\n            flag = false;\n            // 并打印此时申请区间的起始位置\n            System.out.println(start);\n            break;\n          } else {\n            // 若存在交叉，则将变更要申请的内存区间的起始位置\n            start = used.get(i)[1] + 1;\n          }\n        }\n\n        // 一旦申请到内存，那么flag就会被赋值为false，否则就保持true，意味着每申请到内存，则打印error\n        if (flag) System.out.println(\"error\");\n      }\n      // 释放内存\n      else {\n        //  当指令为RELEASE时，值为要释放内存的起始地址addr\n        int addr = Integer.parseInt(val);\n        boolean flag = true;\n\n        for (int i = 0; i < used.size(); i++) {\n          // 到已占有内存中找起始位置是addr的，找到则将该区间从used中删除，表示解除占用\n          if (used.get(i)[0] == addr) {\n            used.remove(i);\n            flag = false;\n            break;\n          }\n        }\n\n        // 一旦释放成功，则flag就会被置为false，否则就保持True,意味着没有内存释放，则打印error\n        if (flag) System.out.println(\"error\");\n      }\n    }\n  }\n\n  // 判断两个区间是否存在交集\n  public static boolean hasIntersection(Integer[] range1, Integer[] range2) {\n    int s1 = range1[0];\n    int e1 = range1[1];\n\n    int s2 = range2[0];\n    int e2 = range2[1];\n\n    if (s1 == s2) return true;\n    else if (s1 < s2) return e1 >= s2;\n    else return e2 >= s1;\n  }\n}",
    "python": "# 输入获取\nn = int(input())\ncmds = [input().split(\"=\") for _ in range(n)]\n\n\n# 判断两个区间是否存在交集\ndef hasIntersection(a1, a2):\n    s1, e1 = a1\n    s2, e2 = a2\n\n    if s1 == s2:\n        return True\n    elif s1 < s2:\n        return e1 >= s2\n    else:\n        return e2 >= s1\n\n\n# 算法入口\ndef getResult():\n    # used保存被占用的内存 [起始地址，结束地址]，初始时有一个[100,101]作为尾边界限定\n    used = [[100, 101]]\n\n    for key, val in cmds:\n        # 申请内存\n        if key == \"REQUEST\":\n            # 当指令为REQUEST时，对应值为要申请的内存的大小，即size\n            size = int(val)\n\n            #  我们默认从start=0位置开始检查可用内存区间\n            start = 0\n            flag = True\n\n            for i in range(len(used)):\n                end = start + size - 1\n\n                # 要申请的内存区间\n                ran = [start, end]\n\n                # 检查要申请的内存区间和已占有的内存区间是否交叉\n                if not hasIntersection(used[i], ran):\n                    # 若不存在交叉，则将申请区间加入used中\n                    used.insert(i, ran)\n                    flag = False\n                    # 并打印此时申请区间的起始位置\n                    print(start)\n                    break\n                else:\n                    #  若存在交叉，则将变更要申请的内存区间的起始位置\n                    start = used[i][1] + 1\n\n            # 一旦申请到内存，那么flag就会被赋值为false，否则就保持true，意味着每申请到内存，则打印error\n            if flag:\n                print(\"error\")\n        # 释放内存\n        else:\n            # 当指令为RELEASE时，值为要释放内存的起始地址addr\n            addr = int(val)\n            flag = True\n\n            for i in range(len(used)):\n                # 到已占有内存中找起始位置是addr的，找到则将该区间从used中删除，表示解除占用\n                if used[i][0] == addr:\n                    used.pop(i)\n                    flag = False\n                    break\n\n            # 一旦释放成功，则flag就会被置为false，否则就保持True,意味着没有内存释放，则打印error\n            if flag:\n                print(\"error\")\n\n\n# 算法调用\ngetResult()",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = lines[0] - 0;\n  }\n\n  if (n && lines.length === n + 1) {\n    lines.shift();\n    getResult(lines.map((line) => line.split(\"=\")));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(commands) {\n  // used保存被占用的内存 [起始地址，结束地址]，初始时有一个[100,101]作为尾边界限定\n  const used = [[100, 101]];\n\n  for (let [key, val] of commands) {\n    // 申请内存\n    if (key === \"REQUEST\") {\n      // 当指令为REQUEST时，对应值为要申请的内存的大小，即size\n      const size = val - 0;\n\n      // 我们默认从start=0位置开始检查可用内存区间\n      let start = 0;\n      let flag = true;\n\n      for (let i = 0; i < used.length; i++) {\n        let end = start + size - 1;\n        // 要申请的内存区间\n        const range = [start, end];\n        // 检查要申请的内存区间和已占有的内存区间是否交叉\n        if (!hasIntersection(used[i], range)) {\n          // 若不存在交叉，则将申请区间加入used中\n          used.splice(i, 0, range);\n          flag = false;\n          // 并打印此时申请区间的起始位置\n          console.log(start);\n          break;\n        } else {\n          // 若存在交叉，则将变更要申请的内存区间的起始位置\n          start = used[i][1] + 1;\n        }\n      }\n\n      // 一旦申请到内存，那么flag就会被赋值为false，否则就保持true，意味着每申请到内存，则打印error\n      if (flag) console.log(\"error\");\n    }\n    // 释放内存\n    else {\n      //  当指令为RELEASE时，值为要释放内存的起始地址addr\n      const addr = val - 0;\n      let flag = true;\n\n      for (let i = 0; i < used.length; i++) {\n        // 到已占有内存中找起始位置是addr的，找到则将该区间从used中删除，表示解除占用\n        if (used[i][0] === addr) {\n          used.splice(i, 1);\n          flag = false;\n          break;\n        }\n      }\n\n      // 一旦释放成功，则flag就会被置为false，否则就保持True,意味着没有内存释放，则打印error\n      if (flag) console.log(\"error\");\n    }\n  }\n}\n\n// 判断两个区间是否存在交集\nfunction hasIntersection(area1, area2) {\n  const [s1, e1] = area1;\n  const [s2, e2] = area2;\n\n  if (s1 === s2) return true;\n  else if (s1 < s2) return e1 >= s2;\n  else return e2 >= s1;\n}",
    "cpp": "",
    "c": ""
  }
}