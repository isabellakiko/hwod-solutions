{
  "id": "179",
  "title": "返回矩阵中非1的元素个数",
  "examType": "",
  "score": 200,
  "description": "存在一个m*n的二维数组，其成员取值范围为0，1，2。\n其中值为1的元素具备同化特性，每经过1S，将上下左右值为0的元素同化为1。\n而值为2的元素，免疫同化。\n将数组所有成员随机初始化为0或2，再将矩阵的[0, 0]元素修改成1，在经过足够长的时间后求矩阵中有多少个元素是0或2（即0和2数量之和）。\n",
  "inputDesc": "输入的前两个数字是矩阵大小。后面是数字矩阵内容。\n",
  "outputDesc": "返回矩阵中非1的元素个数。\n\n输入数字前两个数字是矩阵大小。后面的数字是矩阵内容。\n起始位置(0,0)被修改为1后，最终只能同化矩阵为：\n1 1 1 1\n1 2 2 2\n1 2 0 0\n1 2 0 0\n所以矩阵中非1的元素个数为9\n\n本题可以使用广度优先搜索BFS解决。\n关于广度优先搜索，可以看：华为OD机试 - 计算疫情扩散时间（Java & JS & Python）_在一个地图中(地图由n*n个区域组成)_伏城之外的博客-CSDN博客\n",
  "examples": [
    {
      "input": "4 4\n0 0 0 0\n0 2 2 2\n0 2 0 0\n0 2 0 0",
      "output": "9",
      "explanation": "从(0,0)开始同化，2为免疫区域形成屏障，最终有9个非1元素"
    },
    {
      "input": "3 3\n0 0 0\n0 0 0\n0 0 0",
      "output": "0",
      "explanation": "所有区域都被同化为1，非1元素个数为0"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**BFS广度优先搜索**问题。\n\n**核心思路：**\n- 从(0,0)开始BFS，只同化值为0的元素\n- 值为2的元素免疫同化\n\n**算法步骤：**\n1. 将(0,0)设为1并入队\n2. BFS向四个方向扩散\n3. 遇到0则同化为1并入队\n4. 返回m*n减去被同化的元素数量\n\n**时间复杂度**：O(M*N)",
  "codes": {
    "java": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int m = sc.nextInt();\n    int n = sc.nextInt();\n\n    int[][] matrix = new int[m][n];\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    matrix[0][0] = 1;\n\n    System.out.println(getResult(m, n, matrix));\n  }\n\n  public static int getResult(int m, int n, int[][] matrix) {\n    // 上、下、左、右偏移量\n    int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // 广搜队列\n    LinkedList<int[]> queue = new LinkedList<>();\n\n    // 初始时只有矩阵[0,0]位置元素为1\n    queue.add(new int[] {0, 0});\n\n    // count记录矩阵中值为1的元素的个数\n    int count = 1;\n\n    // 广搜\n    while (queue.size() > 0) {\n      int[] pos = queue.removeFirst();\n\n      int x = pos[0];\n      int y = pos[1];\n\n      for (int[] offset : offsets) {\n        int newX = x + offset[0];\n        int newY = y + offset[1];\n\n        if (newX >= 0 && newX < m && newY >= 0 && newY < n && matrix[newX][newY] == 0) {\n          matrix[newX][newY] = 1;\n          count++;\n          queue.add(new int[] {newX, newY});\n        }\n      }\n    }\n\n    return m * n - count;\n  }\n}",
    "python": "# 输入获取\nm, n = map(int, input().split())\nmatrix = [list(map(int, input().split())) for _ in range(m)]\nmatrix[0][0] = 1\n\n\n# 算法入口\ndef getResult():\n    # 上、下、左、右偏移量\n    offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    # 广搜队列, 初始时只有矩阵[0,0]位置元素为1\n    queue = [[0, 0]]\n\n    # count记录矩阵中值为1的元素的个数\n    count = 1\n\n    # 广搜\n    while len(queue) > 0:\n        x, y = queue.pop(0)\n\n        for offset in offsets:\n            newX = x + offset[0]\n            newY = y + offset[1]\n\n            if m > newX >= 0 and n > newY >= 0 and matrix[newX][newY] == 0:\n                matrix[newX][newY] = 1\n                count += 1\n                queue.append([newX, newY])\n\n    return m * n - count\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}