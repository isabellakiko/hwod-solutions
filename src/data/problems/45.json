{
  "id": "45",
  "title": "磁盘容量排序",
  "examType": "A",
  "score": 100,
  "description": "磁盘的容量单位常用的有 M，G，T 这三个等级，它们之间的换算关系为：\n1T = 1024G1G = 1024M\n现在给定 n 块磁盘的容量，请对它们按从小到大的顺序进行稳定排序。\n例如给定5块盘的容量：\n1T，20M，3G，10G6T，3M12G9M\n排序后的结果为：\n20M，3G，3M12G9M，1T，10G6T\n注意单位可以重复出现，上述 3M12G9M 表示的容量即为：3M+12G+9M，和 12M12G 相等。",
  "inputDesc": "输入第一行包含一个整数 n，表示磁盘的个数\n2 ≤ n ≤ 100\n接下的 n 行，每行一个字符串（长度大于2，小于30），表示磁盘的容量，由一个或多个格式为mv的子串组成，其中 m 表示容量大小，v 表示容量单位，例如：20M，1T，30G，10G6T，3M12G9M。\n磁盘容量 m 的范围为 1 到 1024 的正整数容量单位 v 的范围只包含题目中提到的 M，G，T 三种，换算关系如题目描述",
  "outputDesc": "输出 n 行，表示 n 块磁盘容量排序后的结果。",
  "examples": [
    {
      "input": "3\n1G\n1024M\n3M",
      "output": "3M\n1G\n1024M",
      "explanation": "3M最小，1G=1024M，两者容量相等。\n稳定排序保留原相对位置，故1G在1024M之前。"
    },
    {
      "input": "3\n2G4M\n3M2G\n1T",
      "output": "3M2G\n2G4M\n1T",
      "explanation": "3M2G = 3+2048 = 2051M\n2G4M = 2048+4 = 2052M\n1T = 1048576M\n从小到大：3M2G < 2G4M < 1T"
    },
    {
      "input": "5\n1T\n20M\n3G\n10G6T\n3M12G9M",
      "output": "20M\n3G\n3M12G9M\n1T\n10G6T",
      "explanation": "换算后：20M, 3072M, 12300M, 1048576M, 6301696M\n从小到大排序。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**字符串解析+排序**问题。\n\n**换算规则：**\n- 1T = 1024G = 1024×1024M\n- 1G = 1024M\n- 统一转换为M单位比较\n\n**算法步骤：**\n\n1. 解析每个容量字符串，提取数字和单位\n2. 将所有单位转换为M，累加得到总容量\n3. 使用稳定排序（相同容量保持原顺序）\n4. 输出排序后的原始字符串\n\n**解析技巧：**\n- 双指针遍历字符串\n- 遇到M/G/T时截取前面的数字\n\n**时间复杂度**：O(n log n)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = Integer.parseInt(scanner.nextLine());\n \n        List<Map.Entry<Integer, String>> res = new ArrayList<>();\n\n        // 处理n行磁盘容量\n        for (int i = 0; i < n; i++) {\n            String capacity = scanner.nextLine();\n            int sum = 0;\n            int left = 0;\n            int right = 1;\n\n            // 将磁盘容量转化为数值\n            while (right < capacity.length()) {\n                if (capacity.charAt(right) == 'M' || capacity.charAt(right) == 'G' || capacity.charAt(right) == 'T') {\n                    int val = Integer.parseInt(capacity.substring(left, right));\n                    switch (capacity.charAt(right)) {\n                        case 'M':\n                            sum += val;\n                            break;\n                        case 'G':\n                            sum += val * 1024;\n                            break;\n                        case 'T':\n                            sum += val * 1024 * 1024;\n                            break;\n                    }\n                    left = right + 1;  // 更新左指针\n                }\n                right++;  // 移动右指针\n            }\n\n            // 存储容量及其原始字符串\n            res.add(new AbstractMap.SimpleEntry<>(sum, capacity));\n        }\n\n        // 排序后输出结果\n        res.sort(Comparator.comparingInt(Map.Entry::getKey));  // 对容量值进行排序\n        for (Map.Entry<Integer, String> ele : res) {\n            System.out.println(ele.getValue());  // 输出原始字符串\n        }\n    }\n}",
    "python": "import sys\n\n# 读取磁盘数量\nn = int(input())\n\n# 存储处理后的磁盘容量及其原始字符串\nres = []\n\n# 处理n行磁盘容量\nfor _ in range(n):\n    capacity = input()\n    sum = 0\n    left = 0\n    right = 1\n\n    # 将磁盘容量转化为数值\n    while right < len(capacity):\n        if capacity[right] in ['M', 'G', 'T']:\n            val = int(capacity[left:right])\n            if capacity[right] == 'M':\n                sum += val  # M为基本单位\n            elif capacity[right] == 'G':\n                sum += val * 1024  # 1G = 1024M\n            elif capacity[right] == 'T':\n                sum += val * 1024 * 1024  # 1T = 1024G = 1024*1024M\n            left = right + 1  # 更新左指针\n        right += 1  # 移动右指针\n\n    # 存储容量及其原始字符串\n    res.append((sum, capacity))\n\n# 按容量排序后输出\nres.sort(key=lambda x: x[0])\nfor _, capacity in res:\n    print(capacity)",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet input = [];\nrl.on('line', function (line) {\n    input.push(line);\n    if (input.length === parseInt(input[0], 10) + 1) {\n        rl.close();\n    }\n});\n\nrl.on('close', function () {\n    const n = parseInt(input[0], 10);  // 读取磁盘数量\n    let res = [];\n\n    // 处理每一行磁盘容量\n    for (let i = 1; i <= n; i++) {\n        const capacity = input[i];\n        let sum = 0;\n        let left = 0;\n\n        // 将磁盘容量转换为数值\n        for (let right = 1; right < capacity.length; right++) {\n            if (['M', 'G', 'T'].includes(capacity[right])) {\n                const val = parseInt(capacity.slice(left, right), 10);\n                switch (capacity[right]) {\n                    case 'M':\n                        sum += val;\n                        break;\n                    case 'G':\n                        sum += val * 1024;\n                        break;\n                    case 'T':\n                        sum += val * 1024 * 1024;\n                        break;\n                }\n                left = right + 1;\n            }\n        }\n\n        // 存储容量及其原始字符串\n        res.push({ sum, capacity });\n    }\n\n    // 按容量排序后输出\n    res.sort((a, b) => a.sum - b.sum);\n    res.forEach(ele => console.log(ele.capacity));\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n// 定义一个存储容量值和原始字符串的结构体\nstruct Capacity {\n    int sum;\n    string original;\n};\n\nint main() {\n    int n;\n    cin >> n;  // 读取磁盘数量\n    cin.ignore();  // 忽略换行符\n\n    vector<Capacity> res;\n\n    // 处理n行磁盘容量\n    for (int i = 0; i < n; ++i) {\n        string capacity;\n        getline(cin, capacity);\n        int sum = 0;\n        int left = 0;\n\n        // 将磁盘容量转换为数值\n        for (int right = 1; right < capacity.size(); ++right) {\n            if (capacity[right] == 'M' || capacity[right] == 'G' || capacity[right] == 'T') {\n                int val = stoi(capacity.substr(left, right - left));\n                if (capacity[right] == 'M') {\n                    sum += val;\n                } else if (capacity[right] == 'G') {\n                    sum += val * 1024;\n                } else if (capacity[right] == 'T') {\n                    sum += val * 1024 * 1024;\n                }\n                left = right + 1;\n            }\n        }\n\n        // 存储容量及其原始字符串\n        res.push_back({sum, capacity});\n    }\n\n    // 按容量排序后输出\n    sort(res.begin(), res.end(), [](const Capacity &a, const Capacity &b) {\n        return a.sum < b.sum;\n    });\n\n    for (const auto &ele : res) {\n        cout << ele.original << endl;\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LENGTH 100\n\n// 定义一个结构体存储容量值和原始字符串\ntypedef struct {\n    int sum;\n    char original[MAX_LENGTH];\n} Capacity;\n\n// 比较函数，用于qsort排序\nint compare(const void *a, const void *b) {\n    return ((Capacity *)a)->sum - ((Capacity *)b)->sum;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);  // 读取磁盘数量\n    getchar();  // 消费换行符\n\n    Capacity res[n];  // 定义结构体数组存储结果\n\n    // 处理n行磁盘容量\n    for (int i = 0; i < n; i++) {\n        char capacity[MAX_LENGTH];\n        fgets(capacity, MAX_LENGTH, stdin);\n\n        // 移除换行符\n        capacity[strcspn(capacity, \"\\n\")] = 0;\n\n        int sum = 0;\n        int left = 0;\n\n        // 将磁盘容量转换为数值\n        for (int right = 1; right < strlen(capacity); right++) {\n            if (capacity[right] == 'M' || capacity[right] == 'G' || capacity[right] == 'T') {\n                char temp[10];\n                strncpy(temp, &capacity[left], right - left);\n                temp[right - left] = '\\0';\n                int val = atoi(temp);\n                \n                if (capacity[right] == 'M') {\n                    sum += val;\n                } else if (capacity[right] == 'G') {\n                    sum += val * 1024;\n                } else if (capacity[right] == 'T') {\n                    sum += val * 1024 * 1024;\n                }\n                left = right + 1;\n            }\n        }\n\n        // 存储容量及其原始字符串\n        res[i].sum = sum;\n        strcpy(res[i].original, capacity);\n    }\n\n    // 使用qsort进行排序\n    qsort(res, n, sizeof(Capacity), compare);\n\n    // 输出排序后的结果\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", res[i].original);\n    }\n\n    return 0;\n}"
  }
}