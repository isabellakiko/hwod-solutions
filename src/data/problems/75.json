{
  "id": "75",
  "title": "最大矩阵和",
  "examType": "A",
  "score": 100,
  "description": "给定一个二维整数矩阵，要在这个矩阵中选出一个子矩阵，使得这个子矩阵内所有的数字和尽量大，我们把这个子矩阵称为和最大子矩阵，子矩阵的选取原则是原矩阵中一块相互连续的矩形区域。\n",
  "inputDesc": "输入的第一行包含2个整数n, m(1 <= n, m <= 10)，表示一个n行m列的矩阵，下面有n行，每行有m个整数，同一行中，每2个数字之间有1个空格，最后一个数字后面没有空格，所有的数字的在[-1000, 1000]之间。\n",
  "outputDesc": "输出一行一个数字，表示选出的和最大子矩阵内所有的数字和。",
  "examples": [
    {
      "input": "3 4\n-3 5 -1 5\n2 4 -2 4\n-1 3 -1 3",
      "output": "20",
      "explanation": "选取右边3列2行的子矩阵：5+5+4+4+3+3-1-2-1=20。"
    },
    {
      "input": "2 2\n1 2\n3 4",
      "output": "10",
      "explanation": "整个矩阵和为1+2+3+4=10。"
    },
    {
      "input": "2 3\n-1 2 3\n4 -5 6",
      "output": "9",
      "explanation": "选取第三列：3+6=9，或选取2+3+4-5+6=10更大，最大子矩阵和为10。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**动态规划**问题，将二维最大子矩阵和转化为一维最大子数组和。\n\n**算法步骤：**\n1. 枚举子矩阵的起始行i和结束行j\n2. 将第i行到第j行按列压缩成一维数组\n3. 对压缩后的一维数组求最大子数组和\n4. 最大子数组和使用DP：dp[i] = max(dp[i-1], 0) + nums[i]\n5. 取所有情况的最大值\n\n**时间复杂度**：O(N² × M)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int m = sc.nextInt();\n\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    System.out.println(getResult(n, m, matrix));\n  }\n\n  public static int getResult(int n, int m, int[][] matrix) {\n    ArrayList<Integer> dp = new ArrayList<>();\n\n    for (int i = 0; i < n; i++) {\n      dp.add(maxSubArraySum(matrix[i])); // 一行子矩阵最大和\n\n      for (int j = i + 1; j < n; j++) {\n        dp.add(maxSubArraySum(matrixZip(Arrays.copyOfRange(matrix, i, j + 1)))); // 多行子矩阵最大和\n      }\n    }\n\n    return dp.stream().max((a, b) -> a - b).orElse(0); // 求出最大和\n  }\n\n  // 最大子数组和求解\n  public static int maxSubArraySum(int[] nums) {\n    int[] dp = new int[nums.length];\n\n    int res = dp[0] = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n      dp[i] = Math.max(dp[i - 1], 0) + nums[i];\n      res = Math.max(res, dp[i]);\n    }\n\n    return res;\n  }\n\n  // 多行子矩阵，压缩为一行子数组\n  public static int[] matrixZip(int[][] matrix) {\n    int cols = matrix[0].length;\n    int rows = matrix.length;\n    int[] zip = new int[cols];\n\n    for (int c = 0; c < cols; c++) {\n      for (int r = 0; r < rows; r++) {\n        zip[c] += matrix[r][c];\n      }\n    }\n\n    return zip;\n  }\n}",
    "python": "# 输入获取\nn, m = map(int, input().split())\nmatrix = [list(map(int, input().split())) for i in range(n)]\n\n\n# 最大子数组和求解\ndef maxSubArraySum(nums):\n    dp = [0 for i in range(len(nums))]\n    res = dp[0] = nums[0]\n\n    for i in range(1, len(nums)):\n        dp[i] = max(dp[i - 1], 0) + nums[i]\n        res = max(res, dp[i])\n\n    return res\n\n\n# 将多行子矩阵，压缩为一维数组\ndef matrixZip(matrix):\n    cols = len(matrix[0])\n    rows = len(matrix)\n    zip = [0 for i in range(cols)]\n\n    for c in range(cols):\n        for r in range(rows):\n            zip[c] += matrix[r][c]\n\n    return zip\n\n\n# 算法入口\ndef getResult(n, m, matrix):\n    dp = []\n\n    for i in range(n):\n        dp.append(maxSubArraySum(matrix[i]))\n        for j in range(i + 1, n):\n            dp.append(maxSubArraySum(matrixZip(matrix[i:j + 1])))\n\n    dp.sort()\n\n    return dp[-1]\n\n\n# 算法调用\nprint(getResult(n, m, matrix))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nlet lines = [];\nlet n, m;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  // 输入第一行时，提取出m、n\n  if (lines.length === 1) {\n    [n, m] = lines[0].split(\" \").map((ele) => parseInt(ele));\n  }\n\n  // 输入第一行后，再输入n行时，则开始启动算法程序\n  if (lines.length - 1 === n) {\n    // 干掉第一行输入，即lines中存储的全是就是matrix要素\n    lines.shift();\n\n    // matrix是算法程序的入参二维数组\n    let matrix = [];\n    // 将多行输入的matrix要素提取出来存到二维数组中\n    lines.forEach((line) => {\n      matrix.push(\n        line\n          .split(\" \")\n          .map((ele) => parseInt(ele))\n          .slice(0, m)\n      );\n    });\n\n    // 调用算法程序\n    console.log(maxSubMatrixSum(matrix));\n\n    // 将输入归0，重新接收下一轮\n    lines.length = 0;\n  }\n});\n\nfunction maxSubMatrixSum(matrix) {\n  let dp = [];\n  for (let i = 0; i < matrix.length; i++) {\n    dp.push(maxSubArraySum(matrix[i]));\n\n    for (let j = i + 1; j < matrix.length; j++) {\n      dp.push(maxSubArraySum(matrixZip(matrix.slice(i, j + 1))));\n    }\n  }\n\n  return dp.sort((a, b) => b - a)[0];\n}\n\nfunction maxSubArraySum(nums) {\n  let dp = new Array(nums.length);\n\n  let result = (dp[0] = nums[0]);\n\n  for (let i = 1; i < nums.length; i++) {\n    dp[i] = Math.max(dp[i - 1], 0) + nums[i];\n    result = Math.max(result, dp[i]);\n  }\n\n  return result;\n}\n\nfunction matrixZip(matrix) {\n  let cols = matrix[0].length;\n  let rows = matrix.length;\n  let zip = new Array(cols).fill(0);\n\n  for (let c = 0; c < cols; c++) {\n    for (let r = 0; r < rows; r++) {\n      zip[c] += matrix[r][c];\n    }\n  }\n\n  return zip;\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint maxSubArraySum(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> dp(n);\n    int res = dp[0] = nums[0];\n    \n    for (int i = 1; i < n; i++) {\n        dp[i] = max(dp[i-1], 0) + nums[i];\n        res = max(res, dp[i]);\n    }\n    return res;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<int>> matrix(n, vector<int>(m));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n    \n    int ans = INT_MIN;\n    \n    for (int i = 0; i < n; i++) {\n        vector<int> zip(m, 0);\n        for (int j = i; j < n; j++) {\n            for (int k = 0; k < m; k++) {\n                zip[k] += matrix[j][k];\n            }\n            ans = max(ans, maxSubArraySum(zip));\n        }\n    }\n    \n    cout << ans << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <limits.h>\n\nint maxSubArraySum(int* nums, int len) {\n    int dp[100];\n    int res = dp[0] = nums[0];\n    \n    for (int i = 1; i < len; i++) {\n        dp[i] = (dp[i-1] > 0 ? dp[i-1] : 0) + nums[i];\n        if (dp[i] > res) res = dp[i];\n    }\n    return res;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    int matrix[10][10];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n    \n    int ans = INT_MIN;\n    \n    for (int i = 0; i < n; i++) {\n        int zip[10] = {0};\n        for (int j = i; j < n; j++) {\n            for (int k = 0; k < m; k++) {\n                zip[k] += matrix[j][k];\n            }\n            int cur = maxSubArraySum(zip, m);\n            if (cur > ans) ans = cur;\n        }\n    }\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  }
}