{
  "id": "138",
  "title": "解压报文压缩报文还原",
  "examType": "A",
  "score": 200,
  "description": "为了提升数据传输的效率，会对传输的报文进行压缩处理。\n输入一个压缩后的报文，请返回它解压后的原始报文。\n压缩规则：n[str]，表示方括号内部的 str 正好重复 n 次。\n注意 n 为正整数（0 < n <= 100），str只包含小写英文字母，不考虑异常情况。",
  "inputDesc": "输入压缩后的报文：\n1）不考虑无效的输入，报文没有额外的空格，方括号总是符合格式要求的；\n2）原始报文不包含数字，所有的数字只表示重复的次数 n ，例如不会出现像 5b 或 3[8] 的输入；",
  "outputDesc": "解压后的原始报文\n注：原始报文长度不会超过1000，不考虑异常的情况",
  "examples": [
    {
      "input": "[k]2[mn]",
      "output": "kkkmnmn",
      "explanation": "k 重复3次，mn 重复2次，最终得到 kkkmnmn"
    },
    {
      "input": "[m2[c]]",
      "output": "mccmccmcc",
      "explanation": "m2[c] 解压缩后为 mcc，重复三次为 mccmccmcc"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**栈模拟**问题，类似LeetCode 394字符串解码。\n\n**核心思路：**\n- 用栈处理嵌套的压缩结构\n- 遇到[入栈保存当前状态，遇到]出栈并重复字符串\n\n**算法步骤：**\n1. 遍历字符串，字母累加到当前字符串\n2. 数字累加到当前重复次数\n3. 遇到[：将当前字符串和次数入栈，重置\n4. 遇到]：出栈，将当前字符串重复n次拼接到上层\n5. 遍历结束返回结果\n\n**时间复杂度**：O(N×M)，N为压缩串长度，M为最大重复次数",
  "codes": {
    "java": "import java.util.Scanner;\nimport java.util.Stack;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String compressed_string = scanner.next();\n\n        Stack<List<String>> stack = new Stack<>();\n        stack.push(new ArrayList<>(List.of(\"\", \"1\", \"\"))); // 使用栈来存储解压后的字符串和重复次数\n\n        String current_str = \"\"; // 当前字符\n        String current_num = \"\"; // 当前重复次数\n\n        for (char c : compressed_string.toCharArray()) {\n            if (Character.isLetter(c)) { // 如果是字母\n                current_str += c;\n            } else if (Character.isDigit(c)) { // 如果是数字\n                current_num += c;\n            } else if (c == '[') { // 如果是左括号\n                stack.push(new ArrayList<>(List.of(current_str, current_num, \"\"))); // 将当前字符和重复次数入栈\n                current_str = current_num = \"\"; // 重置当前字符和重复次数\n            } else { // 如果是右括号\n                List<String> prev = stack.pop();\n                String prev_str = prev.get(0);\n                int times = Integer.parseInt(prev.get(1));\n                String prev_result = prev.get(2);\n\n                String repeated_str = \"\";\n                for (int i = 0; i < times; i++) {\n                    repeated_str += prev_result + current_str;\n                }\n\n                stack.peek().set(2, stack.peek().get(2) + prev_str + repeated_str); // 更新栈顶元素的结果\n                current_str = \"\"; // 重置当前字符\n            }\n        }\n\n        String result = stack.peek().get(2) + current_str; // 返回最终的结果\n        System.out.println(result);\n    }\n}",
    "python": "compressed_string = input()\nstack = [['', 1, '']]  # 使用栈来存储解压后的字符串和重复次数\ncurrent_str = ''  # 当前字符\ncurrent_num = ''  # 当前重复次数\nfor c in compressed_string:\n    if c.isalpha():  # 如果是字母\n        current_str += c\n    elif c.isdigit():  # 如果是数字\n        current_num += c\n    elif c == '[':  # 如果是左括号\n        stack.append([current_str, int(current_num), ''])  # 将当前字符和重复次数入栈\n        current_str = current_num = ''  # 重置当前字符和重复次数\n    else:  # 如果是右括号\n        prev_str, times, prev_result = stack.pop()  # 弹出栈顶元素\n        stack[-1][-1] += prev_str + times * (prev_result + current_str)  # 更新栈顶元素的结果\n        current_str = ''  # 重置当前字符\nresult = stack.pop()[-1] + current_str  # 返回最终的结果\nprint(result)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet compressed_string = \"\";\n\nrl.on(\"line\", (input) => {\n  compressed_string = input;\n\n  const stack = [];\n  stack.push([\"\", \"1\", \"\"]); // 使用数组来模拟栈，存储解压后的字符串和重复次数\n\n  let current_str = \"\"; // 当前字符\n  let current_num = \"\"; // 当前重复次数\n\n  for (const c of compressed_string) {\n    if (/[a-zA-Z]/.test(c)) { // 如果是字母\n      current_str += c;\n    } else if (/[0-9]/.test(c)) { // 如果是数字\n      current_num += c;\n    } else if (c === '[') { // 如果是左括号\n      stack.push([current_str, current_num, \"\"]); // 将当前字符和重复次数入栈\n      current_str = current_num = \"\"; // 重置当前字符和重复次数\n    } else { // 如果是右括号\n      const prev = stack.pop();\n      const prev_str = prev[0];\n      const times = parseInt(prev[1]);\n      const prev_result = prev[2];\n\n      let repeated_str = \"\";\n      for (let i = 0; i < times; i++) {\n        repeated_str += prev_result + current_str;\n      }\n\n      stack[stack.length - 1][2] += prev_str + repeated_str; // 更新栈顶元素的结果\n      current_str = \"\"; // 重置当前字符\n    }\n  }\n\n  const result = stack[stack.length - 1][2] + current_str; // 返回最终的结果\n  console.log(result);\n\n  rl.close();\n});",
    "cpp": "#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\n\nint main() {\n    std::string compressed_string;\n    std::cin >> compressed_string;\n\n    std::stack<std::vector<std::string>> stack;\n    stack.push({\"\", \"1\", \"\"}); // 使用栈来存储解压后的字符串和重复次数\n\n    std::string current_str = \"\"; // 当前字符\n    std::string current_num = \"\"; // 当前重复次数\n\n    for (char c : compressed_string) {\n        if (isalpha(c)) { // 如果是字母\n            current_str += c;\n        } else if (isdigit(c)) { // 如果是数字\n            current_num += c;\n        } else if (c == '[') { // 如果是左括号\n            stack.push({current_str, current_num, \"\"}); // 将当前字符和重复次数入栈\n            current_str = current_num = \"\"; // 重置当前字符和重复次数\n        } else { // 如果是右括号\n            std::vector<std::string> prev = stack.top();\n            stack.pop();\n            std::string prev_str = prev[0];\n            int times = std::stoi(prev[1]);\n            std::string prev_result = prev[2];\n\n            std::string repeated_str = \"\";\n            for (int i = 0; i < times; i++) {\n                repeated_str += prev_result + current_str;\n            }\n\n            stack.top()[2] += prev_str + repeated_str; // 更新栈顶元素的结果\n            current_str = \"\"; // 重置当前字符\n        }\n    }\n\n    std::string result = stack.top()[2] + current_str; // 返回最终的结果\n    std::cout << result << std::endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX 1000 // 栈的最大长度\n#define MAX_STR_LEN 1000 // 每个字符串的最大长度\n\n// 模拟栈的结构\ntypedef struct {\n    char str[MAX][MAX_STR_LEN]; // 字符串\n    int num[MAX];               // 重复次数\n    char result[MAX][MAX_STR_LEN]; // 解压后的字符串\n    int top;                    // 栈顶指针\n} Stack;\n\n// 初始化栈\nvoid initStack(Stack *stack) {\n    stack->top = -1;\n}\n\n// 压栈\nvoid push(Stack *stack, const char *str, const char *num, const char *result) {\n    if (stack->top + 1 < MAX) {\n        stack->top++;\n        strcpy(stack->str[stack->top], str);\n        stack->num[stack->top] = atoi(num); // 将字符串数字转换为整数\n        strcpy(stack->result[stack->top], result);\n    }\n}\n\n// 出栈\nvoid pop(Stack *stack, char *str, int *num, char *result) {\n    if (stack->top >= 0) {\n        strcpy(str, stack->str[stack->top]);\n        *num = stack->num[stack->top];\n        strcpy(result, stack->result[stack->top]);\n        stack->top--;\n    }\n}\n\nint main() {\n    char compressed_string[MAX_STR_LEN];\n \n    scanf(\"%s\", compressed_string);\n\n    Stack stack;\n    initStack(&stack);\n    push(&stack, \"\", \"1\", \"\"); // 初始化栈，使用空字符串和默认重复次数1\n\n    char current_str[MAX_STR_LEN] = \"\"; // 当前的解压字符串\n    char current_num[MAX_STR_LEN] = \"\"; // 当前的重复次数\n\n    for (int i = 0; i < strlen(compressed_string); i++) {\n        char c = compressed_string[i];\n\n        if (isalpha(c)) { // 如果是字母\n            int len = strlen(current_str);\n            current_str[len] = c;\n            current_str[len + 1] = '\\0';\n        } else if (isdigit(c)) { // 如果是数字\n            int len = strlen(current_num);\n            current_num[len] = c;\n            current_num[len + 1] = '\\0';\n        } else if (c == '[') { // 如果是左括号\n            push(&stack, current_str, current_num, \"\"); // 将当前字符串和重复次数压栈\n            strcpy(current_str, \"\"); // 重置当前字符串\n            strcpy(current_num, \"\"); // 重置当前次数\n        } else if (c == ']') { // 如果是右括号\n            char prev_str[MAX_STR_LEN];\n            int times;\n            char prev_result[MAX_STR_LEN];\n\n            pop(&stack, prev_str, &times, prev_result); // 弹出栈顶元素\n\n            char repeated_str[MAX_STR_LEN] = \"\";\n            for (int j = 0; j < times; j++) { // 根据次数生成重复的字符串\n                strcat(repeated_str, prev_result);\n                strcat(repeated_str, current_str);\n            }\n\n            strcpy(current_str, prev_str); // 拼接上先前的字符串\n            strcat(current_str, repeated_str); // 拼接重复的结果\n        }\n    }\n\n    printf(\"%s\\n\", current_str);\n\n    return 0;\n}"
  }
}