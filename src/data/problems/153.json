{
  "id": "153",
  "title": "寻找最优的路测线路",
  "examType": "A",
  "score": 200,
  "description": "评估一个网络的信号质量，其中一个做法是将网络划分为栅格，然后对每个栅格的信号质量计算。\n路测的时候，希望选择一条信号最好的路线（彼此相连的栅格集合）进行演示。\n现给出 R 行 C 列的整数数组 Cov，每个单元格的数值 S 即为该栅格的信号质量（已归一化，无单位，值越大信号越好）。\n要求从 [0, 0] 到 [R-1, C-1]设计一条最优路测路线。返回该路线得分。\n\n规则：\n路测路线可以上下左右四个方向，不能对角路线的评分是以路线上信号最差的栅格为准的，例如路径 8→4→5→9 的值为4，该线路评分为4。线路最优表示该条线路的评分最高。\n",
  "inputDesc": "第一行表示栅格的行数 R\n第二行表示栅格的列数 C\n第三行开始，每一行表示栅格地图一行的信号值，如5 4 5\n",
  "outputDesc": "最优路线的得分\n\n\n\n用例1图示 用例2图示\n\n\n本题需要我们求解 起点(0,0) 到 终点(r-1, c-1) 的所有路径中 \"最大的\" 最小权值节点的权值。\n\n注：每条路径都由至少一个点组成，而每个点都有权值，因此每条路径自身都有一个最小权值节点。比如路径：5→4→5→6→6，其中最小权值节点的权值就是4\n\n本题需要我们找到起点->终点的所有路径各自的最小权值节点，并比较出其中最大的那个。\n其实这个问题就是单源最短路径的变形题，可以使用Dijkstra算法求解，如果不了解Dijistra算法，可以先看下：\nLeetCode - 743 网络延迟时间（Java & JS & Python）伏城之外 -CSDN博客\n\n下面使用Dijistra算法模拟下用例1的解题过程：\n首先，我们需要定义一个dist数组：\n由于dist[x][y]最终记录的是一个最大值，因此我们需要将dist[x][y]初始化为一个最小值，方便后面被更大值替换，由于本题节点（栅格）的权值（信号强度）最小为0，因此这里dist[x][y]可以初始化为0。\n初始时，我们将dist数组所有元素都初始化为0，其中dist[0][0] = matrix[0][0]，因为起点(0,0)到终点(0,0)的路径中只有一个节点(0,0)。\n\n之后，我们需要定义一个优先队列pq，pq记录路径的终点（x,y），各路径终点的优先级为：对应路径\"最大的\"最小权值节点的权值，即dist[x][y]，即dist[x][y]越大，则对应路径终点(x,y)在优先队列中的优先级越高。\n初始时，将(0,0)加入优先队列。\n\n下面开始从优先队列不停取出优先级最高的节点：\n每当从优先队列中取出一个路径终点（优先级最高），则可以获得如下信息：\n之后基于(ux, uy) 向上下左右四个方向探索，如果新位置(vx, vy)不越界，则进入新位置：\n我们得到了一个新的路径，新路径的终点为(vx, vy)，新路径中最小权值节点的权值w为 min(dist[ux][uy], matrix[vx][vy])\n\n另外，如果 w > dist[vx][vy]，则说明我们找到了起点(0,0)到(vx, vy)的更优路径，即找到了更大的最小权值节点，因此需要更新 dist[vx][vy] = w，然后将新路径加入到pq中重新排优先级。\n按此逻辑一直进行，直到pq为空时，我们就找完了起点(0,0)到所有节点的路径的\"最大的\"最小权值节点的权值。\n最后返回 dist[r-1][c-1] 记录的 起点(0,0) 到 (r-1, c-1) 的所有路径中的\"最大的\"最小权值节点的权值即可。\n\n2023.12.04\n本题的优化思路，由于本题固定求(0,0)到(r-1,c-1)的解，即dist[r-1][c-1]，因此一旦dist[r-1][c-1]确定了，即可停止Dijkstra算法，即不需要找到(0,0)到其余点的dist解。\n因此，当pq弹出的点是(r-1, c-1)时，即可提前结束，因为此时dist[r-1][c-1]已经被求解出来，且是最优解。\n\n",
  "examples": [
    {
      "input": "3\n3\n5 4 5\n1 2 6\n7 4 6",
      "output": "4",
      "explanation": "从(0,0)到(2,2)，最优路径5→4→5→6→6，路径最小值为4"
    },
    {
      "input": "2\n2\n5 1\n4 5",
      "output": "4",
      "explanation": "路径5→4→5，最小值4；或5→1→5，最小值1。选前者得分4"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**Dijkstra变体**问题，求最大的最小值路径。\n\n**核心思路：**\n- dist[i][j]记录(0,0)到(i,j)所有路径中\"最大的\"最小权值\n- 用优先队列按dist值降序处理\n- 每次取最优路径扩展\n\n**算法步骤：**\n1. 初始化dist数组为0，dist[0][0]=matrix[0][0]\n2. 优先队列按dist降序，初始加入(0,0)\n3. 取出优先级最高的点，向四方向扩展\n4. 新路径最小值w=min(当前dist,新点权值)\n5. 若w>dist[新点]则更新并入队\n6. 返回dist[r-1][c-1]\n\n**时间复杂度**：O(RC×log(RC))",
  "codes": {
    "java": "import java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int r = sc.nextInt();\n    int c = sc.nextInt();\n\n    int[][] matrix = new int[r][c];\n    for (int i = 0; i < r; i++) {\n      for (int j = 0; j < c; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    // dist[i]记录的 起点0 到 终点i 的所有路径中“最大的”最小权值节点的权值\n    // 其中 i 是将二维坐标一维化后的值，比如(x,y)坐标一维化后为 x * c + y; (c是列数)\n    // dist[i] 记录的 “最大的”最小权值节点的权值，因此需要初始化为一个 \"最小的\" 最小权值节点的权值，方便后面被更大者取代，由于本题节点的最小权值>=0，因此这里可以初始化为0\n    int[] dist = new int[r * c];\n    // 起点0 到 终点0 路径的最小权值节点就是自身，即matrix[0][0]点的权重\n    dist[0] = matrix[0][0];\n\n    // 优先队列记录路径（终点），并且路径中的最小权值节点的权值越大，优先级越高\n    PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> dist[b] - dist[a]);\n    // 初始时将(0,0)入队\n    pq.add(0);\n\n    // 上下左右的方向偏移量\n    int[][] offsets = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n    while (pq.size() > 0) {\n      // 取出优先队列中优先级最大的路径（终点）\n      int u = pq.poll();\n\n      // 将一维化坐标u，解析为二维坐标(x,y)\n      int x = u / c;\n      int y = u % c;\n\n      // 已找到dist[r-1][c-1]最优解，则可以提前结束\n      if (x == r - 1 && y == c - 1) break;\n\n      // 向上下左右四个方向探索\n      for (int[] offset : offsets) {\n        // 新位置坐标\n        int newX = x + offset[0];\n        int newY = y + offset[1];\n\n        // 新位置越界则无法访问\n        if (newX < 0 || newX >= r || newY < 0 || newY >= c) continue;\n\n        // 新位置的一维化坐标\n        int v = newX * c + newY;\n        // 当前路径（终点u）的最小权值节点的权值为dist[u]\n        // 要加入当前路径的新位置的点的权值 matrix[newX][newY]\n        // 那么形成的新路径的最小权值节点的权值即为 w = min(dist[u], matrix[newX][newY])\n        int w = Math.min(dist[u], matrix[newX][newY]);\n\n        // 形成的新路径的终点为 v（即新位置一维化坐标）\n        // 而dist[v]记录的是起点到点v的所有路径中“最大的”最小权值节点\n        if (dist[v] < w) {\n          // 因此如果dist[v] < w的话，则更新dist[v]\n          dist[v] = w;\n          // 并将新路径加入优先队列，参与下一轮比较\n          pq.add(v);\n        }\n      }\n    }\n\n    // 返回起点（0，0）到终点(r-1, c-1)的所有路径中\"最大的\"最小权值节点的权值\n    System.out.println(dist[r * c - 1]);\n  }\n}",
    "python": "# 输入获取\nr = int(input())\nc = int(input())\nmatrix = [list(map(int, input().split())) for _ in range(r)]\n\n\n# 算法入口\ndef getResult():\n    # dist[i]记录的 起点0 到 终点i 的所有路径中“最大的”最小权值节点的权值\n    # 其中 i 是将二维坐标一维化后的值，比如(x,y)坐标一维化后为 x * c + y; (c是列数)\n    # dist[i] 记录的 “最大的”最小权值节点的权值，因此需要初始化为一个 \"最小的\" 最小权值节点的权值，方便后面被更大者取代，由于本题节点的最小权值>=0，因此这里可以初始化为0\n    dist = [0] * (r * c)\n    # 起点0 到 终点0 路径的最小权值节点就是自身，即matrix[0][0]点的权重\n    dist[0] = matrix[0][0]\n\n    # 优先队列记录路径（终点），并且路径中的最小权值节点的权值越大，优先级越高\n    # 初始时将(0,0)入队\n    pq = [0]\n\n    # 上下左右的方向偏移量\n    offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    while len(pq) > 0:\n        # 取出优先队列中优先级最大的路径（终点）\n        u = pq.pop()\n\n        # 将一维化坐标u，解析为二维坐标(x,y)\n        x = u // c\n        y = u % c\n\n        # 已找到dist[r-1][c-1]最优解，则可以提前结束\n        if x == r - 1 and y == c - 1:\n            break\n\n        # 向上下左右四个方向探索\n        for offsetX, offsetY in offsets:\n            # 新位置坐标\n            newX = x + offsetX\n            newY = y + offsetY\n\n            # 新位置越界则无法访问\n            if newX < 0 or newX >= r or newY < 0 or newY >= c:\n                continue\n\n            # 新位置的一维化坐标\n            v = newX * c + newY\n            # 当前路径（终点u）的最小权值节点的权值为dist[u]\n            # 要加入当前路径的新位置的点的权值 matrix[newX][newY]\n            #  那么形成的新路径的最小权值节点的权值即为 w = min(dist[u], matrix[newX][newY])\n            w = min(dist[u], matrix[newX][newY])\n\n            # 形成的新路径的终点为 v（即新位置一维化坐标）\n            # 而dist[v]记录的是起点到点v的所有路径中“最大的”最小权值节点\n            if dist[v] < w:\n                # 因此如果dist[v] < w的话，则更新dist[v]\n                dist[v] = w\n                # 并将新路径加入优先队列，参与下一轮比较\n                pq.append(v)\n                # 优先级排序，由于24行是pq.pop()，尾部优先级最大，因此这里升序\n                pq.sort(key=lambda i: dist[i])\n\n    # 返回起点（0，0）到终点(r-1, c-1)的所有路径中\"最大的\"最小权值节点的权值\n    return dist[r * c - 1]\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}