{
  "id": "173",
  "title": "空栈压数",
  "examType": "A",
  "score": 200,
  "description": "向一个空栈压入正整数，每当压入一个整数时，执行以下规则（设: 栈顶至栈底整数依次编号为 n1, n2, …, nx，其中n1 为最新压入的整数)\n如果 n1 = n2，则 n1、n2全部出栈，压入新数据 m (m = 2*n1) 如果 n1 = n2 + … + ny( y的范围为[3,x]) ，则 n1, n2, …, ny 全部出栈，压入新数据 m (m = 2*n1)。 如果上述规则都不满足，则不做操作。\n如果 n1 = n2，则 n1、n2全部出栈，压入新数据 m (m = 2*n1)\n如果 n1 = n2 + … + ny( y的范围为[3,x]) ，则 n1, n2, …, ny 全部出栈，压入新数据 m (m = 2*n1)。\n如果上述规则都不满足，则不做操作。\n如：依次向栈压入 6、1、2、3，\n当压入 2 时，栈顶至栈底依次为 [2,1,6]；当压入 3 时，3 = 2 + 1，3、2、1 全部出栈，重新入栈整数6，此时栈顶至栈底依次为 [6,6]；6 = 6，两个 6 全部出栈，压入 12，最终栈中只剩个元素 12。 向栈中输入一串数字，请输出应用此规则后栈中最终存留的数字。\n使用单个空格隔开的正整数的字符串，如 “5 6 7 8”，左边的数字先入栈。\n正整数大小为 [1, 2^31−1]。正整数个数为 [1,1000]。\n最终栈中存留的元素值，元素值使用单个空格隔开，如 \"8 7 6 5\"，从左至右依次为栈顶至栈底的数字。",
  "inputDesc": "",
  "outputDesc": "",
  "examples": [
    {
      "input": "20 50 80 1 1",
      "output": "160",
      "explanation": "解释: 向栈压入 80 时，10+20+50=80，数据合并后入栈 160，压入两个 1 时，合并为 2，最终栈顶至栈底的数字为 2 和 160。"
    },
    {
      "input": "10 20 50 85 1",
      "output": "170",
      "explanation": ""
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**栈模拟**问题。\n\n**核心思路：**\n- 每次入栈后检查是否满足合并条件\n- n1=n2则合并为2*n1\n- n1=n2+...+ny则合并为2*n1\n\n**算法步骤：**\n1. 依次将数字入栈\n2. 入栈后从栈顶向下累加，若等于当前数则合并\n3. 合并后继续检查是否能再次合并\n4. 最终输出栈中所有元素\n\n**时间复杂度**：O(N²)",
  "codes": {
    "java": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String[] inputSequence = scanner.nextLine().split(\" \");\n        // 创建一个 LinkedList 对象用作数字栈\n        LinkedList<Integer> numberStack = new LinkedList<>();\n\n        // 遍历输入的数字序列\n        for (String numberString : inputSequence) {\n            // 将字符串转换为整数\n            int currentNumber = Integer.parseInt(numberString);\n            // 初始化部分和为当前数字\n            int partialSum = currentNumber;\n\n            // 从栈顶向栈底检查是否满足出栈条件\n            for (int index = numberStack.size() - 1; index >= 0; index--) {\n                // 从部分和中减去栈中的元素\n                partialSum -= numberStack.get(index);\n\n                // 如果满足出栈条件，清除子列表并更新当前数字\n                if (partialSum == 0) {\n                    // 清除子列表\n                    numberStack.subList(index, numberStack.size()).clear();\n                    // 更新当前数字\n                    currentNumber *= 2;\n                    // 更新部分和\n                    partialSum = currentNumber;\n                } else if (partialSum < 0) {\n                    // 如果部分和小于0，跳出循环\n                    break;\n                }\n            }\n\n            // 将当前数字入栈\n            numberStack.add(currentNumber);\n        }\n\n        // 输出栈中的元素，从栈顶到栈底\n        // 创建一个 StringJoiner 对象，用于连接栈中的元素\n        StringJoiner outputJoiner = new StringJoiner(\" \");\n        // 当栈不为空时，依次移除栈顶元素并添加到 StringJoiner 中\n        while (!numberStack.isEmpty()) {\n            outputJoiner.add(numberStack.removeLast().toString());\n        }\n        // 输出最终结果\n        System.out.println(outputJoiner.toString());\n    }\n}",
    "python": "def main():\n    # 读取用户输入并使用空格分隔\n    input_sequence = input().split()\n    # 创建一个列表用作数字栈\n    number_stack = []\n\n    # 遍历输入的数字序列\n    for number_string in input_sequence:\n        # 将字符串转换为整数\n        current_number = int(number_string)\n        # 初始化部分和为当前数字\n        partial_sum = current_number\n\n        # 从栈顶向栈底检查是否满足出栈条件\n        index = len(number_stack) - 1\n        while index >= 0:\n            # 从部分和中减去栈中的元素\n            partial_sum -= number_stack[index]\n\n            # 如果满足出栈条件，清除子列表并更新当前数字\n            if partial_sum == 0:\n                # 清除子列表\n                number_stack = number_stack[:index]\n                # 更新当前数字\n                current_number *= 2\n                # 更新部分和\n                partial_sum = current_number\n            elif partial_sum < 0:\n                # 如果部分和小于0，跳出循环\n                break\n\n            index -= 1\n\n        # 将当前数字入栈\n        number_stack.append(current_number)\n\n    # 输出栈中的元素，从栈顶到栈底\n    output = ' '.join(map(str, reversed(number_stack)))\n    print(output)\n\n\nif __name__ == \"__main__\":\n    main()",
    "javascript": "const readline = require('readline');\n\n// 创建一个 readline.Interface 实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 读取用户输入\nrl.on('line', (input) => {\n  const inputSequence = input.split(' ');\n  // 创建一个数组用作数字栈\n  const numberStack = [];\n\n  // 遍历输入的数字序列\n  for (const numberString of inputSequence) {\n    // 将字符串转换为整数\n    let currentNumber = parseInt(numberString, 10);\n    // 初始化部分和为当前数字\n    let partialSum = currentNumber;\n\n    // 从栈顶向栈底检查是否满足出栈条件\n    for (let index = numberStack.length - 1; index >= 0; index--) {\n      // 从部分和中减去栈中的元素\n      partialSum -= numberStack[index];\n\n      // 如果满足出栈条件，清除子列表并更新当前数字\n      if (partialSum === 0) {\n        // 清除子列表\n        numberStack.splice(index);\n        // 更新当前数字\n        currentNumber *= 2;\n        // 更新部分和\n        partialSum = currentNumber;\n      } else if (partialSum < 0) {\n        // 如果部分和小于0，跳出循环\n        break;\n      }\n    }\n\n    // 将当前数字入栈\n    numberStack.push(currentNumber);\n  }\n\n  // 输出栈中的元素，从栈顶到栈底\n  const output = numberStack.reverse().join(' ');\n  console.log(output);\n\n  // 关闭 readline.Interface 实例\n  rl.close();\n});",
    "cpp": "#include <iostream>\n\nint main() {\n    // 读取用户输入\n    int input_sequence[1000];\n    int input_size = 0;\n    int temp;\n    while (std::cin >> temp) {\n        input_sequence[input_size++] = temp;\n    }\n\n    // 创建一个普通数组用作数字栈\n    int number_stack[1000];\n    int stack_size = 0;\n\n    // 遍历输入的数字序列\n    for (int i = 0; i < input_size; ++i) {\n        int current_number = input_sequence[i];\n        // 初始化部分和为当前数字\n        int partial_sum = current_number;\n\n        // 从栈顶向栈底检查是否满足出栈条件\n        int index = stack_size - 1;\n        while (index >= 0) {\n            // 从部分和中减去栈中的元素\n            partial_sum -= number_stack[index];\n\n            // 如果满足出栈条件，清除子列表并更新当前数字\n            if (partial_sum == 0) {\n                // 清除子列表\n                stack_size = index;\n                // 更新当前数字\n                current_number *= 2;\n                // 更新部分和\n                partial_sum = current_number;\n            } else if (partial_sum < 0) {\n                // 如果部分和小于0，跳出循环\n                break;\n            }\n\n            index -= 1;\n        }\n\n        // 将当前数字入栈\n        number_stack[stack_size++] = current_number;\n    }\n\n    // 输出栈中的元素，从栈顶到栈底\n    for (int i = stack_size - 1; i >= 0; --i) {\n        std::cout << number_stack[i];\n        if (i > 0) {\n            std::cout << \" \";\n        }\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义一个栈结构体，用于存储整数\ntypedef struct {\n    int *data;      // 栈中存储的数据\n    int top;        // 栈顶索引\n    int capacity;   // 栈的容量\n} Stack;\n\n// 初始化栈，分配内存并设置初始值\nStack* createStack(int capacity) {\n    Stack *stack = (Stack*)malloc(sizeof(Stack));\n    stack->data = (int*)malloc(capacity * sizeof(int));\n    stack->top = -1;   // 初始化栈顶索引为-1，表示空栈\n    stack->capacity = capacity;\n    return stack;\n}\n\n// 判断栈是否为空\nint isEmpty(Stack *stack) {\n    return stack->top == -1;\n}\n\n// 向栈中压入元素\nvoid push(Stack *stack, int value) {\n    stack->data[++stack->top] = value;\n}\n\n// 从栈中弹出元素\nint pop(Stack *stack) {\n    return stack->data[stack->top--];\n}\n\n// 返回栈顶元素但不弹出\nint peek(Stack *stack) {\n    return stack->data[stack->top];\n}\n\n// 释放栈的内存\nvoid freeStack(Stack *stack) {\n    free(stack->data);\n    free(stack);\n}\n\n// 主函数，负责处理输入输出和逻辑\nint main() {\n    char input[10000]; // 存储输入字符串\n    fgets(input, sizeof(input), stdin); // 读取输入字符串\n\n    // 初始化栈，容量设为1000\n    Stack *stack = createStack(1000);\n\n    // 解析输入的整数序列\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        int currentNumber = atoi(token);  // 将当前字符串转换为整数\n        int partialSum = currentNumber;   // 初始化部分和为当前数字\n\n        // 从栈顶向栈底检查是否满足出栈条件\n        for (int index = stack->top; index >= 0; index--) {\n            partialSum -= stack->data[index]; // 从部分和中减去栈中的元素\n\n            // 如果满足出栈条件，清除子列表并更新当前数字\n            if (partialSum == 0) {\n                stack->top = index - 1;  // 调整栈顶位置以清除子列表\n                currentNumber *= 2;      // 更新当前数字为原数字的2倍\n                partialSum = currentNumber; // 更新部分和\n            } else if (partialSum < 0) {\n                // 如果部分和小于0，跳出循环\n                break;\n            }\n        }\n\n        // 将当前数字压入栈中\n        push(stack, currentNumber);\n\n        // 获取下一个输入的整数\n        token = strtok(NULL, \" \");\n    }\n\n    // 输出栈中的元素，从栈顶到栈底\n    int first = 1; // 用于控制输出格式\n    while (!isEmpty(stack)) {\n        if (!first) {\n            printf(\" \"); // 在元素之间输出空格\n        }\n        printf(\"%d\", pop(stack)); // 输出栈顶元素\n        first = 0;\n    }\n    printf(\"\\n\"); // 输出换行符\n\n    // 释放栈的内存\n    freeStack(stack);\n\n    return 0;\n}"
  }
}