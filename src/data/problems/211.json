{
  "id": "211",
  "title": "寻找最大价值的矿堆",
  "examType": "B",
  "score": 200,
  "description": "给你一个由 '0' (空地)、'1' (银矿)、'2'(金矿) 组成的的地图，矿堆只能由上下左右相邻的金矿或银矿连接形成。超出地图范围可以认为是空地。\n假设银矿价值1，金矿价值2 ，请你找出地图中最大价值的矿堆并输出该矿堆的价值。\n",
  "inputDesc": "地图元素信息如：\n22220 00000 00000 11111\n地图范围最大 300*3000 ≤ 地图元素 ≤ 2\n",
  "outputDesc": "矿堆的最大价值\n\n\n本题可以使用深度优先搜索解决。\n首先，根据输入得到一个地图矩阵。\n然后，定义一个visited集合，用于记录访问过的点的坐标，或者将访问过的点赋值为0，避免一些点被二次访问。\n之后，开始遍历矩阵的每一个元素，如果\n那么就可以从该点向上、下、左、右四个方向开始深搜，对于新点依旧按照上面规则判断是否可以继续深搜。\n2023.05.25\n经过测试，本题的深度优先搜索（递归实现）在地图矩阵达到50*50以上时就会发生栈内存溢出，因此本题可以使用深度优先搜索（栈实现）。\n深度优先搜索的栈实现，非常类似于广度优先搜索，其实就是将广度优先搜索的队列结构，换成栈结构，具体区别可以看：\n华为OD机试 - 计算疫情扩散时间（Java & JS & Python）_伏城之外的博客-CSDN博客\n\n在线OJ - 寻找最大价值的矿堆\n",
  "examples": [
    {
      "input": "22220\n00000\n00000\n11111",
      "output": "8",
      "explanation": "金矿堆4个金矿价值8，银矿堆5个银矿价值5，最大为8"
    },
    {
      "input": "22220\n00020\n00010\n11111",
      "output": "13",
      "explanation": "金矿和银矿连通形成一个矿堆，价值4*2+5*1=13"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**DFS连通块**问题。\n\n**核心思路：**\n- 遍历地图找矿堆连通块\n- 累加每个连通块的价值\n\n**算法步骤：**\n1. 遍历地图每个位置\n2. 遇到矿(值>0)则DFS搜索连通块\n3. 累加连通块内所有矿的价值\n4. 标记访问过的位置避免重复\n5. 返回最大矿堆价值\n\n**时间复杂度**：O(N*M)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class Main {\n  // 地图矩阵\n  static ArrayList<ArrayList<Integer>> matrix;\n\n  // 记录地图矩阵的行数row，列数col\n  static int row;\n  static int col;\n\n  // 上下左右，四个方向的偏移量\n  static int[][] offsets = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    matrix = new ArrayList<>();\n\n    // 假设存在空行作为输入截止条件\n    //    while (sc.hasNextLine()) {\n    //      String line = sc.nextLine();\n    //\n    //      // 由于本题没有说明输入截止条件，因此使用空行作为输入截止条件\n    //      if (\"\".equals(line)) {\n    //        System.out.println(getResult());\n    //        break;\n    //      } else {\n    //        matrix.add(\n    //            new ArrayList<>(\n    //\n    // Arrays.stream(line.split(\"\")).map(Integer::parseInt).collect(Collectors.toList())));\n    //      }\n    //    }\n\n    // 没有空行作为输入截止条件\n    while (sc.hasNextLine()) {\n      matrix.add(\n          new ArrayList<>(\n              Arrays.stream(sc.nextLine().split(\"\"))\n                  .map(Integer::parseInt)\n                  .collect(Collectors.toList())));\n    }\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    row = matrix.size();\n    if (row == 0) return 0;\n\n    col = matrix.get(0).size();\n\n    // 记录最大矿堆价值\n    int ans = 0;\n\n    // 遍历矩阵元素\n    for (int i = 0; i < row; i++) {\n      for (int j = 0; j < col; j++) {\n        // 如果点(i,j)没有被访问过，且点(i,j)上有矿，则进入深搜\n        if (matrix.get(i).get(j) > 0) {\n          ans = Math.max(ans, dfs(i, j));\n        }\n      }\n    }\n\n    return ans;\n  }\n\n  public static int dfs(int i, int j) {\n    int sum = matrix.get(i).get(j);\n    matrix.get(i).set(j, 0);\n\n    LinkedList<int[]> stack = new LinkedList<>();\n    stack.add(new int[] {i, j});\n\n    while (stack.size() > 0) {\n      int[] pos = stack.removeLast();\n      int x = pos[0], y = pos[1];\n\n      for (int[] offset : offsets) {\n        int newX = x + offset[0];\n        int newY = y + offset[1];\n\n        if (newX >= 0 && newX < row && newY >= 0 && newY < col && matrix.get(newX).get(newY) > 0) {\n          sum += matrix.get(newX).get(newY);\n          matrix.get(newX).set(newY, 0);\n          stack.add(new int[] {newX, newY});\n        }\n      }\n    }\n\n    return sum;\n  }\n}",
    "python": "# 上下左右，四个方向的偏移量\noffsets = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n\n# 广搜\ndef dfs(x, y, matrix, row, col):\n    total = matrix[x][y]\n    matrix[x][y] = 0\n\n    stack = [[x, y]]\n\n    while len(stack) > 0:\n        x, y = stack.pop()\n\n        for offset in offsets:\n            newX = x + offset[0]\n            newY = y + offset[1]\n\n            if row > newX >= 0 and col > newY >= 0 and matrix[newX][newY] > 0:\n                total += matrix[newX][newY]\n                matrix[newX][newY] = 0\n                stack.append([newX, newY])\n\n    return total\n\n\n# 算法入口\ndef getResult(matrix):\n    # 记录地图矩阵的行数row\n    row = len(matrix)\n\n    if row == 0:\n        return 0\n\n    # 记录地图矩阵的行数col\n    col = len(matrix[0])\n\n    # 记录最大矿堆价值\n    ans = 0\n\n    # 遍历矩阵元素\n    for i in range(row):\n        for j in range(col):\n            # 如果点(i,j)没有被访问过，且点(i,j)上有矿，则进入深搜\n            if matrix[i][j] > 0:\n                ans = max(ans, dfs(i, j, matrix, row, col))\n\n    return ans\n\n\n# 输入获取\nmatrix = []\n\n# 假设存在空行作为输入截止条件\n# while True:\n#     line = input()\n#\n#     if line == \"\":\n#         print(getResult(matrix))\n#         break\n#     else:\n#         matrix.append(list(map(int, list(line))))\n\n# 没有空行作为输入截止条件\nwhile True:\n    try:\n        matrix.append(list(map(int, list(input()))))\n    except:\n        break\nprint(getResult(matrix))",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}