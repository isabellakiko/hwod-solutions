{
  "id": "68",
  "title": "字符串摘要",
  "examType": "A",
  "score": 100,
  "description": "给定一个字符串的摘要算法，请输出给定字符串的摘要值\n去除字符串中非字母的符号。如果出现连续字符(不区分大小写) ，则输出：该字符 (小写) + 连续出现的次数。如果是非连续的字符(不区分大小写)，则输出：该字符(小写) + 该字母之后字符串中出现的该字符的次数对按照以上方式表示后的字符串进行排序：字母和紧随的数字作为一组进行排序，数字大的在前，数字相同的，则按字母进行排序，字母小的在前。\n",
  "inputDesc": "一行字符串，长度为[1,200]\n",
  "outputDesc": "摘要字符串",
  "examples": [
    {
      "input": "bAaAcBb",
      "output": "a3b2b2c0",
      "explanation": "b非连续后有2个b→b2；aAa连续3次→a3；c非连续后无c→c0；Bb连续→b2。按数字降序、字母升序排列。"
    },
    {
      "input": "aabbcc",
      "output": "a2b2c2",
      "explanation": "aa连续→a2，bb连续→b2，cc连续→c2。数字相同按字母排序。"
    },
    {
      "input": "ABCabc",
      "output": "a1b1c1",
      "explanation": "A非连续后有1个a→a1，B后有1个b→b1，C后有1个c→c1。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**字符串处理**问题。\n\n**算法步骤：**\n1. 去除非字母字符，转小写\n2. 统计每个字母的总出现次数\n3. 遍历字符串，判断连续/非连续\n4. 连续：输出字母+连续次数\n5. 非连续：输出字母+后续出现次数\n6. 按数字降序、字母升序排列\n\n**时间复杂度**：O(N log N)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n  // 字母数字类\n  static class Letter {\n    char letter;\n    int num;\n\n    public Letter(char letter, int num) {\n      this.letter = letter;\n      this.num = num;\n    }\n\n    @Override\n    public String toString() {\n      return this.letter + \"\" + this.num;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  public static String getResult(String s) {\n    // 不区分大小写\n    s = s.toLowerCase();\n\n    // 统计每个字母出现的次数\n    int[] count = new int[128];\n\n    // 去除字符串中的非字母\n    StringBuilder sb = new StringBuilder();\n\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      if (c >= 'a' && c <= 'z') {\n        count[c]++;\n        sb.append(c);\n      }\n    }\n\n    // 加空格是为了避免后续的收尾操作，如果有疑问可以移除下面加空格操作\n    s = sb + \" \";\n\n    // 记录连续字母和非连续字母\n    ArrayList<Letter> ans = new ArrayList<>();\n\n    // 上一个位置的字母\n    char pre = s.charAt(0);\n    // 该字母连续次数记为1\n    int repeat = 1;\n    // 后续该字母还有count[pre]-=1个\n    count[pre]--;\n\n    for (int i = 1; i < s.length(); i++) {\n      // 当前位置的字母\n      char cur = s.charAt(i);\n      // 后续该字母还有count[cur]-=1个\n      count[cur]--;\n\n      if (cur == pre) {\n        // 如果当前位置和上一个位置的字母相同，则产生连续\n        // 连续次数+1\n        repeat++;\n      } else {\n        // 如果当前位置和上一个位置的字母不同，则连续打断\n        // 如果pre字母连续次数>1，则是真连续，那么就是pre+repeat,否则就是假连续,是pre+count[pre]\n        ans.add(new Letter(pre, repeat > 1 ? repeat : count[pre]));\n        // 更新pre为cur\n        pre = cur;\n        // 更新pre连续次数为1\n        repeat = 1;\n      }\n    }\n\n    // 字母和紧随的数字作为一组进行排序，数字大的在前，数字相同的，则按字母进行排序，字母小的在前\n    ans.sort((a, b) -> a.num != b.num ? b.num - a.num : a.letter - b.letter);\n\n    StringBuilder res = new StringBuilder();\n    for (Letter an : ans) {\n      res.append(an.toString());\n    }\n    return res.toString();\n  }\n}",
    "python": "# 输入获取\ns = input()\n\n\n# 算法入口\ndef getResult():\n    global s\n\n    # 不区分大小写\n    s = s.lower()\n\n    # 统计每个字母出现的次数\n    count = {}\n    # 去除字符串中的非字母\n    letters = []\n\n    for c in s:\n        if 'z' >= c >= 'a':\n            count[c] = count.get(c, 0) + 1\n            letters.append(c)\n\n    # 加空格是为了避免后续的收尾操作，如果有疑问可以移除下面加空格操作\n    s = \"\".join(letters) + \" \"\n    count[' '] = 1\n\n    # 记录连续字母和非连续字母\n    ans = []\n\n    # 上一个位置的字母\n    pre = s[0]\n    # 该字母连续次数记为1\n    repeat = 1\n    # 后续该字母还有count[pre]-=1个\n    count[pre] -= 1\n\n    for i in range(1, len(s)):\n        # 当前位置的字母\n        cur = s[i]\n        # 后续该字母还有count[cur]-=1个\n        count[cur] -= 1\n\n        if cur == pre:\n            # 如果当前位置和上一个位置的字母相同，则产生连续\n            # 连续次数+1\n            repeat += 1\n        else:\n            # 如果当前位置和上一个位置的字母不同，则连续打断\n            # 如果pre字母连续次数>1，则是真连续，那么就是pre+repeat,否则就是假连续,是pre+count[pre]\n            ans.append([pre, repeat if repeat > 1 else count[pre]])\n            # 更新pre为cur\n            pre = cur\n            # 更新pre连续次数为1\n            repeat = 1\n\n    # 字母和紧随的数字作为一组进行排序，数字大的在前，数字相同的，则按字母进行排序，字母小的在前\n    ans.sort(key=lambda x: (-x[1], x[0]))\n\n    return \"\".join(map(lambda x: x[0]+str(x[1]), ans))\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', (line) => {\n    let s = line.toLowerCase();\n    const count = {};\n    let letters = '';\n    \n    for (const c of s) {\n        if (c >= 'a' && c <= 'z') {\n            count[c] = (count[c] || 0) + 1;\n            letters += c;\n        }\n    }\n    \n    s = letters + ' ';\n    count[' '] = 1;\n    \n    const ans = [];\n    let pre = s[0];\n    let repeat = 1;\n    count[pre]--;\n    \n    for (let i = 1; i < s.length; i++) {\n        const cur = s[i];\n        count[cur]--;\n        \n        if (cur === pre) {\n            repeat++;\n        } else {\n            ans.push([pre, repeat > 1 ? repeat : count[pre]]);\n            pre = cur;\n            repeat = 1;\n        }\n    }\n    \n    ans.sort((a, b) => a[1] !== b[1] ? b[1] - a[1] : a[0].charCodeAt(0) - b[0].charCodeAt(0));\n    console.log(ans.map(x => x[0] + x[1]).join(''));\n    rl.close();\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\nusing namespace std;\n\nint main() {\n    string s;\n    getline(cin, s);\n    \n    int count[128] = {0};\n    string letters;\n    \n    for (char c : s) {\n        c = tolower(c);\n        if (c >= 'a' && c <= 'z') {\n            count[(int)c]++;\n            letters += c;\n        }\n    }\n    \n    s = letters + \" \";\n    count[' '] = 1;\n    \n    vector<pair<char, int>> ans;\n    char pre = s[0];\n    int repeat = 1;\n    count[(int)pre]--;\n    \n    for (int i = 1; i < s.length(); i++) {\n        char cur = s[i];\n        count[(int)cur]--;\n        \n        if (cur == pre) {\n            repeat++;\n        } else {\n            ans.push_back({pre, repeat > 1 ? repeat : count[(int)pre]});\n            pre = cur;\n            repeat = 1;\n        }\n    }\n    \n    sort(ans.begin(), ans.end(), [](const pair<char,int>& a, const pair<char,int>& b) {\n        if (a.second != b.second) return a.second > b.second;\n        return a.first < b.first;\n    });\n    \n    for (auto& p : ans) {\n        cout << p.first << p.second;\n    }\n    cout << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint main() {\n    char line[201];\n    fgets(line, sizeof(line), stdin);\n    \n    int count[128] = {0};\n    char letters[201];\n    int len = 0;\n    \n    for (int i = 0; line[i]; i++) {\n        char c = tolower(line[i]);\n        if (c >= 'a' && c <= 'z') {\n            count[(int)c]++;\n            letters[len++] = c;\n        }\n    }\n    letters[len] = ' ';\n    letters[len + 1] = '\\0';\n    count[' '] = 1;\n    \n    char ans_letter[201];\n    int ans_num[201];\n    int ans_len = 0;\n    \n    char pre = letters[0];\n    int repeat = 1;\n    count[(int)pre]--;\n    \n    for (int i = 1; letters[i]; i++) {\n        char cur = letters[i];\n        count[(int)cur]--;\n        \n        if (cur == pre) {\n            repeat++;\n        } else {\n            ans_letter[ans_len] = pre;\n            ans_num[ans_len] = repeat > 1 ? repeat : count[(int)pre];\n            ans_len++;\n            pre = cur;\n            repeat = 1;\n        }\n    }\n    \n    // 简单冒泡排序\n    for (int i = 0; i < ans_len - 1; i++) {\n        for (int j = 0; j < ans_len - 1 - i; j++) {\n            if (ans_num[j] < ans_num[j+1] || (ans_num[j] == ans_num[j+1] && ans_letter[j] > ans_letter[j+1])) {\n                char tc = ans_letter[j]; ans_letter[j] = ans_letter[j+1]; ans_letter[j+1] = tc;\n                int tn = ans_num[j]; ans_num[j] = ans_num[j+1]; ans_num[j+1] = tn;\n            }\n        }\n    }\n    \n    for (int i = 0; i < ans_len; i++) {\n        printf(\"%c%d\", ans_letter[i], ans_num[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}"
  }
}