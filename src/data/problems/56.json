{
  "id": "56",
  "title": "运维日志排序",
  "examType": "A",
  "score": 100,
  "description": "[运维工程师]采集到某产品线网运行一天产生的日志n条，现需根据日志时间先后顺序对日志进行排序，日志时间格式为H:M:S.N。\nH表示小时(0~23)M表示分钟(0~59)S表示秒(0~59)N表示毫秒(0~999)\n时间可能并没有补全，也就是说，01:01:01.001也可能表示为1:1:1.1。",
  "inputDesc": "第一行输入一个整数n表示日志条数，1<=n<=100000，接下来n行输入n个时间。",
  "outputDesc": "按时间升序排序之后的时间，如果有两个时间表示的时间相同，则保持输入顺序。",
  "examples": [
    {
      "input": "2\n0:41:8.9\n0:1:09.211",
      "output": "0:1:09.211\n0:41:8.9",
      "explanation": "0:1:09.211 = 69.211秒\n0:41:8.9 = 2468.9秒\n按时间升序排列。"
    },
    {
      "input": "3\n0:41:08.023\n0:1:09.211\n0:01:22.0",
      "output": "0:1:09.211\n0:01:22.0\n0:41:08.023",
      "explanation": "三个时间分别为69.211秒、82.0秒、2468.023秒。\n按升序排列。"
    },
    {
      "input": "2\n0:41:08.023\n0:41:08.23",
      "output": "0:41:08.023\n0:41:08.23",
      "explanation": "两个时间：2468.023秒和2468.23秒。\n23毫秒 < 230毫秒，但表示形式相同时保持原顺序。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**字符串解析+排序**问题。\n\n**算法步骤：**\n\n1. 解析时间字符串H:M:S.N，提取小时、分钟、秒、毫秒\n2. 将时间转换为统一的毫秒数便于比较\n3. 使用稳定排序按毫秒数升序排列\n4. 输出排序后的原始时间字符串\n\n**注意事项：**\n- 时间格式不一定补全（如1:1:1.1）\n- 相同时间需保持原顺序（稳定排序）\n\n**时间复杂度**：O(N log N)",
  "codes": {
    "java": "import java.util.*;\nimport java.util.regex.*;\n\npublic class Main {\n    \n    /* 将时间字符串转换为毫秒数 */\npublic static int convertToMillisecond(String timeStr) {\n    Pattern pattern = Pattern.compile(\"(\\\\d+):(\\\\d+):(\\\\d+).(\\\\d+)\");\n    Matcher matcher = pattern.matcher(timeStr);\n    return matcher.find() ? ((Integer.parseInt(matcher.group(1)) * 60 + Integer.parseInt(matcher.group(2))) * 60 + Integer.parseInt(matcher.group(3))) * 1000 + Integer.parseInt(matcher.group(4)) : 0;\n}\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        List<String> logs = new ArrayList<>();\n        int n = scanner.nextInt();\n        scanner.nextLine(); // 忽略换行符\n        for (int i = 0; i < n; i++) {\n            String log = scanner.nextLine();\n            logs.add(log);\n        }\n        /* 日志排序 */\n        Collections.sort(logs, new Comparator<String>() {\n            public int compare(String log1, String log2) {\n                int time1 = convertToMillisecond(log1);\n                int time2 = convertToMillisecond(log2);\n                return time1 - time2;\n            }\n        });\n        for (String log : logs) {\n            System.out.println(log);\n        }\n    }\n}",
    "python": "import re\n\ndef convertToMillisecond(timeStr):\n    hour, minute, second, millisecond = map(int, re.findall(r'\\d+', timeStr))\n    return hour * 60 * 60 * 1000 + minute * 60 * 1000 + second * 1000 + millisecond\nlogs = []\nn = int(input())\n\nfor i in range(n):\n    log = input()\n    logs.append(log)\n\n# 日志排序\nlogs.sort(key=lambda log: convertToMillisecond(log))\n\nfor log in logs:\n    print(log)",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst logs = [];\nlet n;\n\nrl.on('line', (input) => {\n  if (!n) {\n    n = parseInt(input);\n  } else {\n    logs.push(input);\n  }\n\n  if (logs.length === n) {\n    /* 日志排序 */\n    logs.sort((log1, log2) => {\n      const time1 = convertToMillisecond(log1);\n      const time2 = convertToMillisecond(log2);\n      return time1 < time2 ? -1 : 1;\n    });\n\n    for (const log of logs) {\n      console.log(log);\n    }\n\n    rl.close();\n  }\n});\n\nfunction convertToMillisecond(timeStr) {\n  const match = timeStr.match(/(\\d+):(\\d+):(\\d+).(\\d+)/);\n  return (parseInt(match[1]) * 3600000) + (parseInt(match[2]) * 60000) + (parseInt(match[3]) * 1000) + parseInt(match[4]);\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <regex>\n#include <algorithm>\n\nusing namespace std;\n\nint convertToMillisecond(string timeStr) {\n    regex pattern(\"(\\\\d+):(\\\\d+):(\\\\d+).(\\\\d+)\");\n    smatch matcher;\n    return regex_search(timeStr, matcher, pattern) ? ((stoi(matcher[1]) * 60 + stoi(matcher[2])) * 60 + stoi(matcher[3])) * 1000 + stoi(matcher[4]) : 0;\n}\nint main() {\n    vector<string> logs;\n    int n;\n    cin >> n;\n    cin.ignore(); // 忽略换行符\n    for (int i = 0; i < n; i++) {\n        string log;\n        getline(cin, log);\n        logs.push_back(log);\n    }\n    /* 日志排序 */\n    sort(logs.begin(), logs.end(), [](const string& log1, const string& log2) {\n        int time1 = convertToMillisecond(log1);\n        int time2 = convertToMillisecond(log2);\n        return time1 < time2;\n    });\n    for (const string& log : logs) {\n        cout << log << endl;\n    }\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* 将时间字符串转换为毫秒数 */\nint convertToMillisecond(const char *timeStr) {\n    int hours = 0, minutes = 0, seconds = 0, milliseconds = 0;\n    sscanf(timeStr, \"%d:%d:%d.%d\", &hours, &minutes, &seconds, &milliseconds);\n    return ((hours * 60 + minutes) * 60 + seconds) * 1000 + milliseconds;\n}\n\n/* 比较函数，用于qsort */\nint compare(const void *a, const void *b) {\n    const char **log1 = (const char **)a;\n    const char **log2 = (const char **)b;\n    \n    int time1 = convertToMillisecond(*log1);\n    int time2 = convertToMillisecond(*log2);\n    \n    return time1 - time2;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    getchar(); // 忽略换行符\n\n    char **logs = (char **)malloc(n * sizeof(char *));\n    for (int i = 0; i < n; i++) {\n        logs[i] = (char *)malloc(50 * sizeof(char)); // 假设每个时间字符串长度不超过50\n        fgets(logs[i], 50, stdin);\n        \n        // 去除fgets输入中的换行符\n        logs[i][strcspn(logs[i], \"\\n\")] = '\\0';\n    }\n\n    /* 对日志进行排序 */\n    qsort(logs, n, sizeof(char *), compare);\n\n    /* 输出排序后的日志 */\n    for (int i = 0; i < n; i++) {\n        printf(\"%s\\n\", logs[i]);\n        free(logs[i]); // 释放每个日志字符串的内存\n    }\n    free(logs); // 释放日志指针数组的内存\n\n    return 0;\n}"
  }
}