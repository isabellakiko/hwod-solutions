{
  "id": "136",
  "title": "荒岛求生",
  "examType": "A",
  "score": 200,
  "description": "一个荒岛上有若干人，岛上只有一条路通往岛屿两端的港口，大家需要逃往两端的港口才可逃生。\n假定每个人移动的速度一样，且只可选择向左或向右逃生。\n若两个人相遇，则进行决斗，战斗力强的能够活下来，并损失掉与对方相同的战斗力；若战斗力相同，则两人同归于尽。",
  "inputDesc": "给定一行非 0 整数数组，元素个数不超过30000；\n正负表示逃生方向（正表示向右逃生，负表示向左逃生），绝对值表示战斗力，越左边的数字表示里左边港口越近，逃生方向相同的人永远不会发生决斗。",
  "outputDesc": "能够逃生的人总数，没有人逃生输出0，输入异常时输出-1。",
  "examples": [
    {
      "input": "10 8 -8 -5",
      "output": "2",
      "explanation": "第2个人(8)和第3个人(-8)同归于尽，第4个人(-5)向左逃生成功，第1个人(10)向右逃生成功"
    },
    {
      "input": "5 -3 4 -2",
      "output": "2",
      "explanation": "5向右，-3向左不相遇；4和-2决斗，4胜剩余2战斗力，最终2人逃生"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**栈模拟**问题，类似LeetCode 735行星碰撞。\n\n**核心思路：**\n- 正数向右逃生，负数向左逃生\n- 只有向右的人遇到向左的人才会决斗\n- 用栈维护向右逃生的人\n\n**算法步骤：**\n1. 遍历每个人，正数直接入栈\n2. 负数与栈顶正数决斗，战斗力相减\n3. 胜者继续，败者出局，平局双亡\n4. 最终栈中元素数量即为逃生人数\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    // 定义一个名为asteroidCollision的方法，接受一个整数列表作为参数\n    public static int asteroidCollision(List<Integer> people) {\n        // 创建一个新的ArrayList，用于存储幸存者\n        List<Integer> survivors = new ArrayList<>();\n        \n        // 遍历输入的整数列表\n        for (int person : people) {\n            // 如果person等于0，则返回-1\n            if (person == 0) {\n                return -1;\n            }\n            \n            // 初始化一个布尔变量alive为true\n            boolean alive = true;\n            \n            // 当alive为true且person小于0，且survivors不为空，且survivors列表中最后一个元素大于0时，执行循环\n            while (alive && person < 0 && !survivors.isEmpty() && survivors.get(survivors.size() - 1) > 0) {\n                // 更新alive的值，判断当前person是否比survivors列表中最后一个元素的相反数大\n                alive = survivors.get(survivors.size() - 1) < -person;\n                \n                // 如果survivors列表中最后一个元素小于等于person的相反数，则移除该元素\n                if (survivors.get(survivors.size() - 1) <= -person) {\n                \tperson = person + \t survivors.get(survivors.size() - 1);\n                    survivors.remove(survivors.size() - 1);\n                }\n            }\n            \n            // 如果alive为true，则将person添加到survivors列表中\n            if (alive) {\n                survivors.add(person);\n            }\n        }\n        \n        // 返回survivors列表的大小\n        return survivors.size();\n    }\n\n     public static void main(String[] args) {\n         Scanner scanner = new Scanner(System.in);\n        \n        // 读取一行输入，并使用空格分隔字符串\n        String[] input = scanner.nextLine().split(\" \");\n        \n        // 创建一个整数列表，用于存储输入的整数\n        List<Integer> people = new ArrayList<>();\n        \n        // 将输入的字符串数组转换为整数，并添加到people列表中\n        for (String s : input) {\n            people.add(Integer.parseInt(s));\n        }\n\n        // 如果people列表的大小大于30000，则输出-1\n        if (people.size() > 30000) {\n            System.out.println(-1);\n        } else {\n            // 调用asteroidCollision方法，并将结果输出\n            int result = asteroidCollision(people);\n            System.out.println(result);\n        }\n    }\n}",
    "python": "def asteroidCollision(people: list[int]) -> int:\n    survivors = []\n    for person in people:\n        if person == 0:\n            return -1\n        alive = True\n        # 当前人向左逃生，且有人向右逃生时进行决斗\n        while alive and person < 0 and survivors and survivors[-1] > 0:\n            # 决斗结果：当前人战斗力大于对手\n            alive = survivors[-1] < - person\n             # 如果战斗力相等或当前人战斗力更大，移除对手\n            if survivors[-1] <= -person:\n                person = person + survivors[-1] \n\n                survivors.pop()\n            else:\n                survivors[-1] = survivors[-1] + person\n                print(survivors[-1])\n        # 如果当前人仍然存活，将其添加到逃生者列表\n        if alive:\n            survivors.append(person)\n    return len(survivors)\n\ntry:\n    # 从输入获取人员列表\n    people = list(map(int, input().split()))\n\n    # 检查输入是否异常\n    if len(people) > 30000:\n        raise ValueError(\"输入异常\")\n\n    # 调用函数并输出结果\n    result = asteroidCollision(people)\n    print(result)\nexcept ValueError as e:\n    print(-1)",
    "javascript": "function asteroidCollision(people) {\n    // 创建一个空数组，用于存储幸存者\n    const survivors = [];\n    \n    // 遍历输入的整数数组\n    for (let person of people) {\n        // 如果person等于0，则返回-1\n        if (person === 0) {\n            return -1;\n        }\n        \n        // 初始化一个布尔变量alive为true\n        let alive = true;\n        \n        // 当alive为true且person小于0，且survivors长度大于0，且survivors数组中最后一个元素大于0时，执行循环\n        while (alive && person < 0 && survivors.length > 0 && survivors[survivors.length - 1] > 0) {\n            // 更新alive的值，判断当前person是否比survivors数组中最后一个元素的相反数大\n            alive = survivors[survivors.length - 1] < -person;\n            \n            // 如果survivors数组中最后一个元素小于等于person的相反数，则移除该元素\n            if (survivors[survivors.length - 1] <= -person) {\n            person =  person + survivors[survivors.length - 1]\n                survivors.pop();\n            }\n        }\n        \n        // 如果alive为true，则将person添加到survivors数组中\n        if (alive) {\n            survivors.push(person);\n        }\n    }\n    \n    // 返回survivors数组的长度\n    return survivors.length;\n}\n\n// 导入readline模块\nconst readline = require('readline');\n// 创建一个readline接口实例\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 当接收到一行输入时，执行以下操作\nrl.on('line', (input) => {\n    // 将输入的字符串以空格分隔，并将每个子字符串转换为数字，存储在people数组中\n    const people = input.split(' ').map(Number);\n\n    // 如果people数组的长度大于30000，则输出-1\n    if (people.length > 30000) {\n        console.log(-1);\n    } else {\n        // 调用asteroidCollision函数，并将结果输出\n        const result = asteroidCollision(people);\n        console.log(result);\n    }\n\n    // 关闭readline接口\n    rl.close();\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n// 定义一个名为asteroidCollision的函数，接受一个整数向量作为参数\nint asteroidCollision(vector<int>& people) {\n    // 创建一个新的vector，用于存储幸存者\n    vector<int> survivors;\n\n    // 遍历输入的整数向量\n    for (int person : people) {\n        // 如果person等于0，则返回-1\n        if (person == 0) {\n            return -1;\n        }\n\n        // 初始化一个布尔变量alive为true\n        bool alive = true;\n\n        // 当alive为true且person小于0，且survivors不为空，且survivors向量中最后一个元素大于0时，执行循环\n        while (alive && person < 0 && !survivors.empty() && survivors.back() > 0) {\n            // 更新alive的值，判断当前person是否比survivors向量中最后一个元素的相反数大\n            alive = survivors.back() < -person;\n\n            // 如果survivors向量中最后一个元素小于等于person的相反数，则移除该元素\n            if (survivors.back() <= -person) {\n                person = person + survivors.back();\n                survivors.pop_back();\n            }\n        }\n\n        // 如果alive为true，则将person添加到survivors向量中\n        if (alive) {\n            survivors.push_back(person);\n        }\n    }\n\n    // 返回survivors向量的大小\n    return survivors.size();\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n    stringstream ss(input);\n\n    // 创建一个整数向量，用于存储输入的整数\n    vector<int> people;\n    int num;\n\n    // 将输入的字符串转换为整数，并添加到people向量中\n    while (ss >> num) {\n        people.push_back(num);\n    }\n\n    // 如果people向量的大小大于30000，则输出-1\n    if (people.size() > 30000) {\n        cout << -1 << endl;\n    } else {\n        // 调用asteroidCollision函数，并将结果输出\n        int result = asteroidCollision(people);\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_PEOPLE 30000\n\n// 定义一个方法 asteroidCollision，接受一个整数数组 people 及其大小 n 作为参数\nint asteroidCollision(int *people, int n) {\n    // 定义一个数组 survivors 来存储幸存者\n    int survivors[MAX_PEOPLE];\n    int survivors_size = 0; // 幸存者列表的大小\n\n    // 遍历输入的整数数组\n    for (int i = 0; i < n; i++) {\n        int person = people[i];\n\n        // 如果 person 等于 0，返回 -1，表示输入异常\n        if (person == 0) {\n            return -1;\n        }\n\n        bool alive = true;\n\n        // 当 alive 为 true 且 person 小于 0 且 survivors 不为空且 survivors 列表中最后一个元素大于 0 时，执行循环\n        while (alive && person < 0 && survivors_size > 0 && survivors[survivors_size - 1] > 0) {\n            // 更新 alive 的值，判断当前 person 是否比 survivors 列表中最后一个元素的相反数大\n            alive = survivors[survivors_size - 1] < -person;\n\n            // 如果 survivors 列表中最后一个元素小于等于 person 的相反数，则移除该元素\n            if (survivors[survivors_size - 1] <= -person) {\n                person += survivors[survivors_size - 1]; // 更新 person 的战斗力\n                survivors_size--; // 移除最后一个幸存者\n            }\n        }\n\n        // 如果 alive 为 true，则将 person 添加到 survivors 列表中\n        if (alive) {\n            survivors[survivors_size++] = person;\n        }\n    }\n\n    // 返回 survivors 列表的大小\n    return survivors_size;\n}\n\nint main() {\n    char input[500000]; // 假设输入的最大长度不超过 500000 个字符\n    int people[MAX_PEOPLE];\n    int count = 0;\n\n    // 读取一行输入\n    if (fgets(input, sizeof(input), stdin) == NULL) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    // 将输入字符串分割为整数并存储在 people 数组中\n    char *token = strtok(input, \" \");\n    while (token != NULL && count < MAX_PEOPLE) {\n        people[count++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    // 如果输入的数量超过 30000，输出 -1\n    if (count > MAX_PEOPLE) {\n        printf(\"-1\\n\");\n    } else {\n        // 调用 asteroidCollision 方法，并将结果输出\n        int result = asteroidCollision(people, count);\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}"
  }
}