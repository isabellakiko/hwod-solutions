{
  "id": "182",
  "title": "传递悄悄话",
  "examType": "B",
  "score": 100,
  "description": "给定一个二叉树，每个节点上站一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。\n初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。",
  "inputDesc": "给定二叉树\n0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2\n注：-1表示空节点\n",
  "outputDesc": "返回所有节点都接收到悄悄话花费的时间\n38",
  "examples": [
    {
      "input": "0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2",
      "output": "38",
      "explanation": "根节点0，左子树9，右子树20->15->3路径最长，0+20+15+3=38"
    },
    {
      "input": "0 5 10",
      "output": "10",
      "explanation": "根节点0，左子节点5，右子节点10，最大路径0+10=10"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二叉树BFS**问题。\n\n**核心思路：**\n- 层次遍历二叉树\n- 累加从根到叶子的路径时间\n- 求最大路径时间\n\n**算法步骤：**\n1. BFS遍历二叉树\n2. 子节点时间=父节点时间+自身时间\n3. 记录最大时间\n4. 遍历结束返回最大值\n\n**时间复杂度**：O(N)" 读取一行输入，这行输入包含了一系列的整数，每个整数代表从父节点到子节点的悄悄话传递时间。 处理根节点： 将根节点（索引为0）加入队列，并设置其悄悄话接收时间为0。 层次遍历： 当队列不为空时，循环执行以下步骤： 从队列中取出一个节点（包括节点索引和该节点的悄悄话接收时间）。计算左右子节点的索引。检查左右子节点是否存在（索引有效且不为-1）。 更新子节点时间： 如果子节点存在，将当前节点的悄悄话接收时间加上从当前节点到子节点的悄悄话传递时间，得到子节点的悄悄话接收时间。将子节点及其悄悄话接收时间加入队列。 更新最大时间： 每次子节点的悄悄话接收时间被计算后，更新最大时间为当前子节点时间和已记录的最大时间中的较大值。\n读取一行输入，这行输入包含了一系列的整数，每个整数代表从父节点到子节点的悄悄话传递时间。\n将根节点（索引为0）加入队列，并设置其悄悄话接收时间为0。\n当队列不为空时，循环执行以下步骤： 从队列中取出一个节点（包括节点索引和该节点的悄悄话接收时间）。计算左右子节点的索引。检查左右子节点是否存在（索引有效且不为-1）。\n从队列中取出一个节点（包括节点索引和该节点的悄悄话接收时间）。计算左右子节点的索引。检查左右子节点是否存在（索引有效且不为-1）。\n如果子节点存在，将当前节点的悄悄话接收时间加上从当前节点到子节点的悄悄话传递时间，得到子节点的悄悄话接收时间。将子节点及其悄悄话接收时间加入队列。\n每次子节点的悄悄话接收时间被计算后，更新最大时间为当前子节点时间和已记录的最大时间中的较大值。\n给定的输入数组0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2代表一棵二叉树，其中每个值代表从父节点到子节点的悄悄话传递时间。数组中的-1表示没有子节点。数组索引代表节点的顺序，按照完全二叉树的顺序排列。\n模拟计算过程如下：\n初始化队列： 将根节点索引0加入队列，此时队列为[0]。 开始层次遍历： 队列非空，继续遍历。 处理根节点： 取出队列头部元素（根节点索引0），队列变为[]。计算左子节点索引1（2*0+1），右子节点索引2（2*0+2）。左子节点值为9，更新为0+9=9，加入队列，队列变为[1]。右子节点值为20，更新为0+20=20，加入队列，队列变为[1, 2]。更新maxTime为20。 处理索引为1的节点： 取出队列头部元素1，队列变为[2]。计算左子节点索引3（2*1+1），右子节点索引4（2*1+2）。左右子节点值均为-1，没有子节点，不做操作。 处理索引为2的节点： 取出队列头部元素2，队列变为[]。计算左子节点索引5（2*2+1），右子节点索引6（2*2+2）。左子节点值为15，更新为20+15=35，加入队列，队列变为[5]。右子节点值为7，更新为20+7=27，加入队列，队列变为[5, 6]。更新maxTime为35。 处理索引为5的节点： 取出队列头部元素5，队列变为[6]。计算左子节点索引11（2*5+1），右子节点索引12（2*5+2）。左子节点值为3，更新为35+3=38，加入队列，队列变为[6, 11]。右子节点值为2，更新为35+2=37，加入队列，队列变为[6, 11, 12]。更新maxTime为38。 处理索引为6的节点： 取出队列头部元素6，队列变为[11, 12]。计算左子节点索引13（2*6+1），右子节点索引14（2*6+2）。由于索引超出数组长度，没有子节点，不做操作。 处理索引为11和12的节点： 取出队列头部元素11和12，队列变为[]。由于索引超出数组长度，没有子节点，不做操作。 结束遍历： 队列为空，遍历结束。 输出结果： 最大时间maxTime为38，这是最后一个节点接收悄悄话的时间。\n初始化队列：\n将根节点索引0加入队列，此时队列为[0]。\n开始层次遍历：\n队列非空，继续遍历。\n处理根节点：\n取出队列头部元素（根节点索引0），队列变为[]。计算左子节点索引1（2*0+1），右子节点索引2（2*0+2）。左子节点值为9，更新为0+9=9，加入队列，队列变为[1]。右子节点值为20，更新为0+20=20，加入队列，队列变为[1, 2]。更新maxTime为20。\n处理索引为1的节点：\n取出队列头部元素1，队列变为[2]。计算左子节点索引3（2*1+1），右子节点索引4（2*1+2）。左右子节点值均为-1，没有子节点，不做操作。\n处理索引为2的节点：\n取出队列头部元素2，队列变为[]。计算左子节点索引5（2*2+1），右子节点索引6（2*2+2）。左子节点值为15，更新为20+15=35，加入队列，队列变为[5]。右子节点值为7，更新为20+7=27，加入队列，队列变为[5, 6]。更新maxTime为35。\n处理索引为5的节点：\n取出队列头部元素5，队列变为[6]。计算左子节点索引11（2*5+1），右子节点索引12（2*5+2）。左子节点值为3，更新为35+3=38，加入队列，队列变为[6, 11]。右子节点值为2，更新为35+2=37，加入队列，队列变为[6, 11, 12]。更新maxTime为38。\n处理索引为6的节点：\n取出队列头部元素6，队列变为[11, 12]。计算左子节点索引13（2*6+1），右子节点索引14（2*6+2）。由于索引超出数组长度，没有子节点，不做操作。\n处理索引为11和12的节点：\n取出队列头部元素11和12，队列变为[]。由于索引超出数组长度，没有子节点，不做操作。\n结束遍历：\n队列为空，遍历结束。\n输出结果：\n最大时间maxTime为38，这是最后一个节点接收悄悄话的时间。\n因此，所有节点接收悄悄话的总时间为38。\n",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建扫描器读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取一行输入并将其转换为整数数组，数组中的每个元素代表从父节点到当前节点的时间\n        int[] whisperTimes = Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 关闭扫描器\n        scanner.close();\n\n        // 记录最后一个节点接收悄悄话的时间\n        int maxTime = 0;\n\n        // 使用队列来进行二叉树的层次遍历\n        Queue<Integer> nodeQueue = new LinkedList<>();\n        // 将根节点索引0加入队列\n        nodeQueue.add(0);\n\n        // 当队列不为空时，继续遍历\n        while (!nodeQueue.isEmpty()) {\n            // 从队列中取出一个节点索引\n            int parentNodeIndex = nodeQueue.poll();\n\n            // 计算左子节点索引\n            int leftChildIndex = 2 * parentNodeIndex + 1;\n            // 计算右子节点索引\n            int rightChildIndex = 2 * parentNodeIndex + 2;\n\n            // 如果左子节点存在，处理左子节点\n            if (leftChildIndex < whisperTimes.length && whisperTimes[leftChildIndex] != -1) {\n                // 更新左子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n                // 将左子节点加入队列\n                nodeQueue.add(leftChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[leftChildIndex]);\n            }\n\n            // 如果右子节点存在，处理右子节点\n            if (rightChildIndex < whisperTimes.length && whisperTimes[rightChildIndex] != -1) {\n                // 更新右子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n                // 将右子节点加入队列\n                nodeQueue.add(rightChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[rightChildIndex]);\n            }\n        }\n\n        // 所有节点都接收到悄悄话后，打印最大时间\n        System.out.println(maxTime);\n    }\n}",
    "python": "from collections import deque\n\n# 读取一行输入并将其转换为整数列表\n# 列表中的每个元素代表从父节点到当前节点的时间\nwhisper_times = list(map(int, input().split()))\n\n# 记录最后一个节点接收悄悄话的时间\nmax_time = 0\n\n# 使用队列来进行二叉树的层次遍历\nnode_queue = deque([0])  # 将根节点索引0加入队列\n\n# 当队列不为空时，继续遍历\nwhile node_queue:\n    # 从队列中取出一个节点索引\n    parent_node_index = node_queue.popleft()\n\n    # 计算左子节点索引\n    left_child_index = 2 * parent_node_index + 1\n    # 计算右子节点索引\n    right_child_index = 2 * parent_node_index + 2\n\n    # 如果左子节点存在，处理左子节点\n    if left_child_index < len(whisper_times) and whisper_times[left_child_index] != -1:\n        # 更新左子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[left_child_index] += whisper_times[parent_node_index]\n        # 将左子节点加入队列\n        node_queue.append(left_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[left_child_index])\n\n    # 如果右子节点存在，处理右子节点\n    if right_child_index < len(whisper_times) and whisper_times[right_child_index] != -1:\n        # 更新右子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[right_child_index] += whisper_times[parent_node_index]\n        # 将右子节点加入队列\n        node_queue.append(right_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[right_child_index])\n\n# 所有节点都接收到悄悄话后，打印最大时间\nprint(max_time)",
    "javascript": "",
    "cpp": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    // 数组中的每个元素代表从父节点到当前节点的时间\n    string line;\n    getline(cin, line);\n    istringstream iss(line);\n    vector<int> whisperTimes;\n    int time;\n    while (iss >> time) {\n        whisperTimes.push_back(time);\n    }\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用队列来进行二叉树的层次遍历\n    queue<int> nodeQueue;\n    // 将根节点索引0加入队列\n    nodeQueue.push(0);\n\n    // 当队列不为空时，继续遍历\n    while (!nodeQueue.empty()) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = nodeQueue.front();\n        nodeQueue.pop();\n\n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < whisperTimes.size() && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            nodeQueue.push(leftChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[leftChildIndex]);\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < whisperTimes.size() && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            nodeQueue.push(rightChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[rightChildIndex]);\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    cout << maxTime << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 10000 // 假设二叉树节点数不超过10000\n\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    char input[MAX_SIZE];\n    fgets(input, sizeof(input), stdin);\n    \n    int whisperTimes[MAX_SIZE];\n    int i = 0, time;\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        sscanf(token, \"%d\", &time);\n        whisperTimes[i++] = time;\n        token = strtok(NULL, \" \");\n    }\n    int length = i; // 数组长度\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用数组模拟队列进行二叉树的层次遍历\n    int queue[MAX_SIZE];\n    int front = 0, rear = 0; // 队列的头和尾索引\n\n    // 将根节点索引0加入队列\n    queue[rear++] = 0;\n\n    // 当队列不为空时，继续遍历\n    while (front < rear) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = queue[front++];\n        \n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < length && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            queue[rear++] = leftChildIndex;\n            // 更新最大时间\n            if (whisperTimes[leftChildIndex] > maxTime) {\n                maxTime = whisperTimes[leftChildIndex];\n            }\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < length && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            queue[rear++] = rightChildIndex;\n            // 更新最大时间\n            if (whisperTimes[rightChildIndex] > maxTime) {\n                maxTime = whisperTimes[rightChildIndex];\n            }\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    printf(\"%d\\n\", maxTime);\n    return 0;\n}"
  }
}