{
  "id": "182",
  "title": "传递悄悄话",
  "examType": "B",
  "score": 100,
  "description": "给定一个二叉树，每个节点上站一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。\n初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。",
  "inputDesc": "给定二叉树\n0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2\n注：-1表示空节点\n",
  "outputDesc": "返回所有节点都接收到悄悄话花费的时间\n38",
  "examples": [
    {
      "input": "0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2",
      "output": "38",
      "explanation": "根节点0，左子树9，右子树20->15->3路径最长，0+20+15+3=38"
    },
    {
      "input": "0 5 10",
      "output": "10",
      "explanation": "根节点0，左子节点5，右子节点10，最大路径0+10=10"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二叉树BFS**问题。\n\n**核心思路：**\n- 层次遍历二叉树\n- 累加从根到叶子的路径时间\n- 求最大路径时间\n\n**算法步骤：**\n1. BFS遍历二叉树\n2. 子节点时间=父节点时间+自身时间\n3. 记录最大时间\n4. 遍历结束返回最大值\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建扫描器读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取一行输入并将其转换为整数数组，数组中的每个元素代表从父节点到当前节点的时间\n        int[] whisperTimes = Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 关闭扫描器\n        scanner.close();\n\n        // 记录最后一个节点接收悄悄话的时间\n        int maxTime = 0;\n\n        // 使用队列来进行二叉树的层次遍历\n        Queue<Integer> nodeQueue = new LinkedList<>();\n        // 将根节点索引0加入队列\n        nodeQueue.add(0);\n\n        // 当队列不为空时，继续遍历\n        while (!nodeQueue.isEmpty()) {\n            // 从队列中取出一个节点索引\n            int parentNodeIndex = nodeQueue.poll();\n\n            // 计算左子节点索引\n            int leftChildIndex = 2 * parentNodeIndex + 1;\n            // 计算右子节点索引\n            int rightChildIndex = 2 * parentNodeIndex + 2;\n\n            // 如果左子节点存在，处理左子节点\n            if (leftChildIndex < whisperTimes.length && whisperTimes[leftChildIndex] != -1) {\n                // 更新左子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n                // 将左子节点加入队列\n                nodeQueue.add(leftChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[leftChildIndex]);\n            }\n\n            // 如果右子节点存在，处理右子节点\n            if (rightChildIndex < whisperTimes.length && whisperTimes[rightChildIndex] != -1) {\n                // 更新右子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n                // 将右子节点加入队列\n                nodeQueue.add(rightChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[rightChildIndex]);\n            }\n        }\n\n        // 所有节点都接收到悄悄话后，打印最大时间\n        System.out.println(maxTime);\n    }\n}",
    "python": "from collections import deque\n\n# 读取一行输入并将其转换为整数列表\n# 列表中的每个元素代表从父节点到当前节点的时间\nwhisper_times = list(map(int, input().split()))\n\n# 记录最后一个节点接收悄悄话的时间\nmax_time = 0\n\n# 使用队列来进行二叉树的层次遍历\nnode_queue = deque([0])  # 将根节点索引0加入队列\n\n# 当队列不为空时，继续遍历\nwhile node_queue:\n    # 从队列中取出一个节点索引\n    parent_node_index = node_queue.popleft()\n\n    # 计算左子节点索引\n    left_child_index = 2 * parent_node_index + 1\n    # 计算右子节点索引\n    right_child_index = 2 * parent_node_index + 2\n\n    # 如果左子节点存在，处理左子节点\n    if left_child_index < len(whisper_times) and whisper_times[left_child_index] != -1:\n        # 更新左子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[left_child_index] += whisper_times[parent_node_index]\n        # 将左子节点加入队列\n        node_queue.append(left_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[left_child_index])\n\n    # 如果右子节点存在，处理右子节点\n    if right_child_index < len(whisper_times) and whisper_times[right_child_index] != -1:\n        # 更新右子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[right_child_index] += whisper_times[parent_node_index]\n        # 将右子节点加入队列\n        node_queue.append(right_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[right_child_index])\n\n# 所有节点都接收到悄悄话后，打印最大时间\nprint(max_time)",
    "javascript": "",
    "cpp": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    // 数组中的每个元素代表从父节点到当前节点的时间\n    string line;\n    getline(cin, line);\n    istringstream iss(line);\n    vector<int> whisperTimes;\n    int time;\n    while (iss >> time) {\n        whisperTimes.push_back(time);\n    }\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用队列来进行二叉树的层次遍历\n    queue<int> nodeQueue;\n    // 将根节点索引0加入队列\n    nodeQueue.push(0);\n\n    // 当队列不为空时，继续遍历\n    while (!nodeQueue.empty()) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = nodeQueue.front();\n        nodeQueue.pop();\n\n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < whisperTimes.size() && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            nodeQueue.push(leftChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[leftChildIndex]);\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < whisperTimes.size() && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            nodeQueue.push(rightChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[rightChildIndex]);\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    cout << maxTime << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 10000 // 假设二叉树节点数不超过10000\n\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    char input[MAX_SIZE];\n    fgets(input, sizeof(input), stdin);\n    \n    int whisperTimes[MAX_SIZE];\n    int i = 0, time;\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        sscanf(token, \"%d\", &time);\n        whisperTimes[i++] = time;\n        token = strtok(NULL, \" \");\n    }\n    int length = i; // 数组长度\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用数组模拟队列进行二叉树的层次遍历\n    int queue[MAX_SIZE];\n    int front = 0, rear = 0; // 队列的头和尾索引\n\n    // 将根节点索引0加入队列\n    queue[rear++] = 0;\n\n    // 当队列不为空时，继续遍历\n    while (front < rear) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = queue[front++];\n        \n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < length && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            queue[rear++] = leftChildIndex;\n            // 更新最大时间\n            if (whisperTimes[leftChildIndex] > maxTime) {\n                maxTime = whisperTimes[leftChildIndex];\n            }\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < length && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            queue[rear++] = rightChildIndex;\n            // 更新最大时间\n            if (whisperTimes[rightChildIndex] > maxTime) {\n                maxTime = whisperTimes[rightChildIndex];\n            }\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    printf(\"%d\\n\", maxTime);\n    return 0;\n}"
  }
}