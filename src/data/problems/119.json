{
  "id": "119",
  "title": "可以处理的最大任务数",
  "examType": "A",
  "score": 200,
  "description": "在某个项目中有多个任务(用tasks数组表示)需要您进行处理，其中tasks[i]=[si,ei],你可以在si <= day <= ei中的任意一天处理该任务，请返回你可以处理的最大任务数",
  "inputDesc": "第一行为任务数量n，1 <=n<= 100000。后面n行表示各个任务的开始时间和终止时间，使用si,ei表示,1 <= si <= ei <= 100000",
  "outputDesc": "输出为一个整数，表示可以处理的最大任务数。\n输入\n输出",
  "examples": [
    {
      "input": "3\n1 1\n1 2\n1 3",
      "output": "3",
      "explanation": "三个任务可在第1、2、3天分别完成"
    },
    {
      "input": "3\n1 1\n1 1\n1 1",
      "output": "1",
      "explanation": "三个任务都只能在第1天完成，最多完成1个"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心+优先队列**问题。\n\n**核心思路：**\n- 每天只能处理一个任务\n- 优先处理结束时间最早的任务\n- 用优先队列维护当前可执行任务\n\n**算法步骤：**\n1. 按开始时间将任务分组\n2. 遍历每一天，将当天开始的任务入队\n3. 移除已过期任务（结束时间<当天）\n4. 取结束时间最早的任务执行\n\n**时间复杂度**：O(T×logN)，T为时间范围",
  "codes": {
    "java": "import java.util.*;\n\nclass Main {\n    // 定义一个Task类来存储每个任务的开始时间和结束时间\n    static class Task {\n        int startTime;  // 任务开始时间\n        int endTime;    // 任务结束时间\n\n        // Task类的构造函数，用于初始化任务的开始时间和结束时间\n        Task(int startTime, int endTime) {\n            this.startTime = startTime;\n            this.endTime = endTime;\n        }\n    }\n\n    // 创建一个List数组，用于存储所有的任务，每个时间点对应一个任务列表\n    static List<Task>[] a = new List[100001];\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt(); // 读取任务的总数\n        \n        // 初始化任务列表数组\n        for (int i = 0; i < 100001; i++) {\n            a[i] = new ArrayList<>();\n        }\n\n        // 读取每个任务的开始时间和结束时间，并将其添加到对应的任务列表中\n        for (int i = 0; i < n; i++) { \n            int x = sc.nextInt(); // 任务开始时间\n            int y = sc.nextInt(); // 任务结束时间\n            a[x].add(new Task(x, y)); // 创建任务并添加到任务列表中\n        }\n\n         \n        int ans = 0; // 用于记录能完成的任务数量\n        // 创建一个优先队列，根据任务的结束时间进行排序，确保每次都处理结束时间最早的任务\n        PriorityQueue<Task> pq = new PriorityQueue<>(Comparator.comparingInt(t -> t.endTime));\n\n        // 遍历每个时间点\n        for (int i = 0; i < 100001; i++) {\n            // 如果优先队列不为空且队列顶部的任务结束时间小于当前时间，则将其移除\n            while (!pq.isEmpty() && pq.peek().endTime < i) {\n                pq.poll();\n            }\n\n            // 如果当前时间点有任务\n            if (a[i] != null) {\n                // 将当前时间点的所有任务加入优先队列\n                for (Task task : a[i]) {\n                    pq.add(task);\n                }\n            }\n\n            // 如果优先队列不为空，则从队列中移除一个任务，并将完成任务的数量加一\n            if (!pq.isEmpty()) {\n                ans++;\n                pq.poll();\n            }\n        }\n\n        // 输出能完成的任务数量\n        System.out.println(ans);\n    }\n}",
    "python": "import heapq  # 导入heapq模块用于实现优先队列\n\n# 定义一个Task类来存储每个任务的开始时间和结束时间\nclass Task:\n    def __init__(self, startTime, endTime):\n        self.startTime = startTime  # 任务开始时间\n        self.endTime = endTime      # 任务结束时间\n\n    def __lt__(self, other):\n        # 定义小于操作，用于优先队列中比较Task对象，根据结束时间进行排序\n        return self.endTime < other.endTime\n\n# 创建一个列表，用于存储所有的任务，每个时间点对应一个任务列表\na = [[] for _ in range(100001)]\n\n# 读取任务的总数\nn = int(input())\n\n# 读取每个任务的开始时间和结束时间，并将其添加到对应的任务列表中\nfor _ in range(n):\n    x, y = map(int, input().split())  # 读取任务开始时间和结束时间\n    a[x].append(Task(x, y))  # 创建任务并添加到任务列表中\n\nans = 0  # 用于记录能完成的任务数量\n# 创建一个优先队列，根据任务的结束时间进行排序，确保每次都处理结束时间最早的任务\npq = []\n\n# 遍历每个时间点\nfor i in range(100001):\n    # 如果优先队列不为空且队列顶部的任务结束时间小于当前时间，则将其移除\n    while pq and pq[0].endTime < i:\n        heapq.heappop(pq)\n\n    # 如果当前时间点有任务\n    for task in a[i]:\n        # 将当前时间点的所有任务加入优先队列\n        heapq.heappush(pq, task)\n\n    # 如果优先队列不为空，则从队列中移除一个任务，并将完成任务的数量加一\n    if pq:\n        ans += 1\n        heapq.heappop(pq)\n\n# 输出能完成的任务数量\nprint(ans)",
    "javascript": "",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n// 定义一个Task结构体来存储每个任务的开始时间和结束时间\nstruct Task {\n    int startTime;  // 任务开始时间\n    int endTime;    // 任务结束时间\n\n    // Task结构体的构造函数，用于初始化任务的开始时间和结束时间\n    Task(int start, int end) : startTime(start), endTime(end) {}\n};\n\n// 比较函数，用于优先队列根据任务的结束时间进行排序\nstruct compare {\n    bool operator()(const Task& a, const Task& b) {\n        return a.endTime > b.endTime;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n; // 读取任务的总数\n\n    // 使用vector来动态存储任务列表，每个时间点对应一个任务列表\n    vector<vector<Task>> tasks(100001);\n\n    // 读取每个任务的开始时间和结束时间，并将其添加到对应的任务列表中\n    for (int i = 0; i < n; i++) {\n        int startTime, endTime;\n        cin >> startTime >> endTime;\n        tasks[startTime].emplace_back(startTime, endTime);\n    }\n\n    priority_queue<Task, vector<Task>, compare> pq; // 创建一个优先队列\n\n    int ans = 0; // 用于记录能完成的任务数量\n\n    // 遍历每个时间点\n    for (int i = 0; i < 100001; i++) {\n        // 如果优先队列不为空且队列顶部的任务结束时间小于当前时间，则将其移除\n        while (!pq.empty() && pq.top().endTime < i) {\n            pq.pop();\n        }\n\n        // 将当前时间点的所有任务加入优先队列\n        for (const auto& task : tasks[i]) {\n            pq.push(task);\n        }\n\n        // 如果优先队列不为空，则从队列中移除一个任务，并将完成任务的数量加一\n        if (!pq.empty()) {\n            ans++;\n            pq.pop();\n        }\n    }\n\n    cout << ans << endl; // 输出能完成的任务数量\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 定义任务结构体，用于存储每个任务的开始时间和结束时间\ntypedef struct {\n    int startTime;  // 任务开始时间\n    int endTime;    // 任务结束时间\n} Task;\n\n// 优先队列的比较函数，用于比较两个任务的结束时间\nint cmp(const void *a, const void *b) {\n    Task *taskA = (Task *)a;\n    Task *taskB = (Task *)b;\n    return taskA->endTime - taskB->endTime;\n}\n\n// 定义任务列表，每个时间点对应一个任务列表\nTask *tasks[100001];\nint taskCounts[100001] = {0}; // 存储每个时间点任务的数量\n\nint main() {\n    int n; // 任务总数\n    scanf(\"%d\", &n);\n\n    // 读取每个任务的开始时间和结束时间，并将其添加到对应的任务列表中\n    for (int i = 0; i < n; i++) {\n        int x, y; // 任务开始时间和结束时间\n        scanf(\"%d %d\", &x, &y);\n        Task newTask = {x, y}; // 创建新任务\n        tasks[x] = (Task *)realloc(tasks[x], (taskCounts[x] + 1) * sizeof(Task)); // 为新任务分配空间\n        tasks[x][taskCounts[x]] = newTask; // 将新任务添加到列表中\n        taskCounts[x]++; // 更新任务数量\n    }\n\n    int ans = 0; // 用于记录能完成的任务数量\n    Task pq[100001]; // 创建一个优先队列\n    int pqSize = 0; // 优先队列的大小\n\n    // 遍历每个时间点\n    for (int i = 0; i < 100001; i++) {\n        // 如果优先队列不为空且队列顶部的任务结束时间小于当前时间，则将其移除\n        while (pqSize > 0 && pq[0].endTime < i) {\n            pq[0] = pq[--pqSize]; // 移除队列顶部的任务\n            qsort(pq, pqSize, sizeof(Task), cmp); // 重新排序优先队列\n        }\n\n        // 如果当前时间点有任务\n        if (taskCounts[i] > 0) {\n            // 将当前时间点的所有任务加入优先队列\n            for (int j = 0; j < taskCounts[i]; j++) {\n                pq[pqSize++] = tasks[i][j];\n                qsort(pq, pqSize, sizeof(Task), cmp); // 重新排序优先队列\n            }\n        }\n\n        // 如果优先队列不为空，则从队列中移除一个任务，并将完成任务的数量加一\n        if (pqSize > 0) {\n            ans++;\n            pq[0] = pq[--pqSize]; // 移除队列顶部的任务\n            qsort(pq, pqSize, sizeof(Task), cmp); // 重新排序优先队列\n        }\n    }\n\n    // 输出能完成的任务数量\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  }
}