{
  "id": "106",
  "title": "查找充电设备组合",
  "examType": "A",
  "score": 100,
  "description": "某个充电站，可提供 n 个充电设备，每个充电设备均有对应的输出功率。\n任意个充电设备组合的输出功率总和，均构成功率集合 P 的 1 个元素。\n功率集合 P 的最优元素，表示最接近充电站最大输出功率 p_max 的元素。",
  "inputDesc": "输入为 3 行：\n第 1 行为充电设备个数 n第 2 行为每个充电设备的输出功率第 3 行为充电站最大输出功率 p_max\n充电设备个数 n > 0最优元素必须小于或等于充电站最大输出功率 p_max",
  "outputDesc": "功率集合 P 的最优元素",
  "examples": [
    {
      "input": "4\n50 20 20 60\n90",
      "output": "90",
      "explanation": "4个设备功率50,20,20,60，最大功率90。选50+20+20=90，最接近90"
    },
    {
      "input": "2\n50 40\n30",
      "output": "0",
      "explanation": "所有设备功率都>30，无法组合，返回0"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**01背包**问题。\n\n**核心思路：**\n- p_max = 背包容量\n- 设备功率 = 物品重量 = 物品价值\n- 求不超过p_max的最大功率和\n\n**状态转移：**\n- dp[i][j] = 前i个设备在功率j内的最大值\n- dp[i][j] = max(dp[i-1][j], dp[i-1][j-p]+p)\n\n**时间复杂度**：O(N×P)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建Scanner对象\n        Scanner scanner = new Scanner(System.in);\n        // 读取输入的整数\n        int n = scanner.nextInt();\n\n        // 创建一个长度为n的整型数组\n        int[] power = new int[n];\n        // 循环读取n个整数，存入数组中\n        for (int i = 0; i < n; i++) {\n            power[i] = scanner.nextInt();\n        }\n\n        // 读取输入的整数\n        int p_max = scanner.nextInt();\n\n        // 创建一个n+1行，p_max+1列的二维整型数组\n        int[][] dp = new int[n + 1][p_max + 1];\n\n        // 循环计算dp数组的每个元素\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= p_max; j++) {\n                // 如果当前能量值大于当前承受的伤害值，则不受伤\n                if (power[i - 1] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else { // 否则需要扣除相应的能量值\n                    dp[i][j] = Math.max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]);\n                }\n            }\n        }\n\n        // 输出结果\n        System.out.println(dp[n][p_max]);\n    }\n}",
    "python": "n = int(input()) # 充电设备个数\npower = list(map(int, input().split())) # 每个充电设备的输出功率\np_max = int(input()) # 充电站最大输出功率\n\ndp = [[0] * (p_max + 1) for _ in range(n + 1)] # 初始化为0\n\nfor i in range(1, n + 1):\n    for j in range(1, p_max + 1):\n        if power[i - 1] > j: # 当前充电设备的功率大于当前总功率j，不能选\n            dp[i][j] = dp[i - 1][j] # 不选当前充电设备\n        else:\n            dp[i][j] = max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]) # 选或不选当前充电设备\n\nprint(dp[n][p_max]) # 输出最大功率",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet n, power, p_max;\nlet dp = [];\n\n// 监听输入流中的每一行数据\nrl.on('line', (line) => {\n  // 如果n还未赋值，则将输入的第一行数据赋值给n\n  if (!n) {\n    n = parseInt(line.trim());\n  } \n  // 如果power还未赋值，则将输入的第二行数据转化为数组赋值给power\n  else if (!power) {\n    power = line.trim().split(' ').map(Number);\n  } \n  // 如果p_max还未赋值，则将输入的第三行数据赋值给p_max，并进行动态规划\n  else if (!p_max) {\n    p_max = parseInt(line.trim());\n    // 初始化dp数组\n    dp = new Array(n + 1).fill().map(() => new Array(p_max + 1).fill(0));\n    // 进行动态规划\n    for (let i = 1; i <= n; i++) {\n      for (let j = 1; j <= p_max; j++) {\n        if (power[i - 1] > j) {\n          dp[i][j] = dp[i - 1][j];\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]);\n        }\n      }\n    }\n    // 输出结果\n    console.log(dp[n][p_max]);\n    // 关闭接口实例\n    rl.close();\n  }\n});",
    "cpp": "#include <iostream>\nusing namespace std;\n\nint main() {\n    int n; // 充电设备个数\n    cin >> n;\n\n    int power[n]; // 每个充电设备的输出功率\n    for (int i = 0; i < n; i++) {\n        cin >> power[i];\n    }\n\n    int p_max; // 充电站最大输出功率\n    cin >> p_max;\n\n    int dp[n + 1][p_max + 1] = {}; // 初始化为0\n\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= p_max; j++) {\n            if (power[i - 1] > j) { // 当前充电设备的功率大于当前总功率j，不能选\n                dp[i][j] = dp[i - 1][j]; // 不选当前充电设备\n            } else {\n                dp[i][j] = max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]); // 选或不选当前充电设备\n            }\n        }\n    }\n\n    cout << dp[n][p_max] << endl; // 输出最大功率\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h> // 用于memset函数\n\nint max(int a, int b) {\n    return (a > b) ? a : b; // 返回两个整数中的较大值\n}\n\nint main() {\n    int n; // 充电设备个数\n    scanf(\"%d\", &n); // 输入充电设备的个数\n\n    int power[n]; // 每个充电设备的输出功率\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &power[i]); // 输入每个充电设备的输出功率\n    }\n\n    int p_max; // 充电站最大输出功率\n    scanf(\"%d\", &p_max); // 输入充电站的最大输出功率\n\n    // 定义一个二维数组dp，初始化为0\n    int dp[n + 1][p_max + 1];\n    memset(dp, 0, sizeof(dp)); // 使用memset将数组dp初始化为0\n\n    // 动态规划计算最大输出功率\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= p_max; j++) {\n            if (power[i - 1] > j) { // 如果当前充电设备的功率大于当前总功率j，不能选择这个设备\n                dp[i][j] = dp[i - 1][j]; // 不选择当前充电设备，最大功率为上一个状态的值\n            } else {\n                // 选择当前充电设备与不选择当前充电设备的最大值\n                dp[i][j] = max(dp[i - 1][j], power[i - 1] + dp[i - 1][j - power[i - 1]]);\n            }\n        }\n    }\n\n    // 输出结果，即充电站可以达到的最大输出功率\n    printf(\"%d\\n\", dp[n][p_max]);\n\n    return 0;\n}"
  }
}