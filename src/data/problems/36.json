{
  "id": "36",
  "title": "服务器广播需要广播的服务器数量",
  "examType": "A",
  "score": 100,
  "description": "服务器连接方式包括直接相连，间接连接。\nA和B直接连接，B和C直接连接，则A和C间接连接。\n直接连接和间接连接都可以发送广播。\n给出一个N*N数组，代表N个服务器，\nmatrix[i][j] == 1， 则代表i和j直接连接；不等于 1 时，代表i和j不直接连接。\nmatrix[i][i] == 1，\n即自己和自己直接连接。matrix[i][j] == matrix[j][i]。\n计算初始需要给几台服务器广播， 才可以使每个服务器都收到广播。",
  "inputDesc": "输入为N行，每行有N个数字，为0或1，由空格分隔，\n构成N*N的数组，N的范围为 1 <= N <= 40",
  "outputDesc": "输出一个数字，为需要广播的服务器的数量",
  "examples": [
    {
      "input": "1 0 0\n0 1 0\n0 0 1",
      "output": "3",
      "explanation": "3×3矩阵，3台服务器互不连接（只有对角线为1）。\n每台服务器都是独立的连通分量，需要分别广播3次。"
    },
    {
      "input": "1 1\n1 1",
      "output": "1",
      "explanation": "2×2矩阵，2台服务器相互连接。\n它们属于同一个连通分量，只需广播1台即可。"
    },
    {
      "input": "1 1 0\n1 1 0\n0 0 1",
      "output": "2",
      "explanation": "3×3矩阵，服务器0和1相连，服务器2独立。\n共2个连通分量，需要广播2次。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**图的连通分量**问题。\n\n**核心思想：**\n- 每个连通分量只需要广播1台服务器\n- 答案 = 连通分量的数量\n\n**算法步骤：**\n\n1. 读取N×N的邻接矩阵\n2. 使用DFS/BFS遍历图\n3. 每发现一个未访问的节点，就找出其所在的整个连通分量\n4. 统计连通分量的数量\n\n**时间复杂度**：O(N²)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n    \n        Scanner in = new Scanner(System.in);\n\n        // 首先读取第一行，并将其通过空格拆分成字符串数组\n        String[] str = in.nextLine().split(\" \");\n        int n = str.length;  // 服务器的数量，n 为矩阵的维度\n\n        // 创建 n*n 的二维数组来存储服务器连接状态\n        int[][] arr = new int[n][n];\n\n        // 将第一行的连接状态转换为整数并存入数组 arr\n        for(int i = 0; i < n; i++) {   \n            arr[0][i] = Integer.parseInt(str[i]);\n        }\n\n        // 读取剩下的 n-1 行，并逐行存入 arr 矩阵\n        for(int i = 1; i < n; i++) {   \n            String[] s = in.nextLine().split(\" \");\n            for(int j = 0; j < n; j++) {\n                arr[i][j] = Integer.parseInt(s[j]);\n            }\n        }\n\n        int count = 0;  // 计数器，记录连通分量的数量（即需要广播的服务器数量）\n\n        // 使用队列来记录访问过的节点（服务器）\n        Queue<Integer> queue = new LinkedList<>();\n\n        // 遍历每个服务器，如果该服务器没有被访问过，就执行 DFS，找到其所有连通的服务器\n        for(int i = 0; i < n; i++) {\n            if(!queue.contains(i)) {  // 如果该服务器不在已访问队列中\n                dfs(arr, queue, i);  // 执行深度优先搜索\n                count++;  // 每次找到一个新的连通分量，计数器加1\n            }\n        }\n\n        // 输出需要广播的服务器数量\n        System.out.println(count);\n    }\n    \n    // 深度优先搜索函数，递归查找服务器的所有连通节点\n    public static void dfs(int[][] arr, Queue<Integer> queue, int index) {\n        queue.offer(index);  // 将当前服务器加入已访问队列\n\n        // 从当前服务器开始，查找所有直接相连的服务器\n        for (int i = index + 1; i < arr.length; i++) {\n            // 如果服务器 i 和当前服务器相连且还没有访问过，则继续递归搜索\n            if (arr[index][i] == 1 && !queue.contains(i)) {\n                dfs(arr, queue, i);\n            }\n        }\n    }\n}",
    "python": "import sys\n\n# 深度优先搜索函数，递归遍历图中与当前服务器相连的所有服务器\ndef dfs(arr, visited, index):\n    visited[index] = True  # 标记当前服务器为已访问\n    flag = True  # 标记是否存在相连的服务器\n    for i in range(index + 1, len(arr)):  # 遍历所有服务器\n        if arr[index][i] == 1:  # 如果当前服务器与服务器 i 相连\n            flag = False  # 发现相连的服务器，设置 flag 为 False\n            dfs(arr, visited, i)  # 递归搜索与服务器 i 相连的所有服务器\n    if flag:  # 如果没有发现相连的服务器，即 flag 仍为 True\n        global count  # 使用全局变量 count 计数\n        count += 1  # 说明这是一个新的连通分量，计数加 1\n\n# 初始化计数器\ncount = 0\n\n# 读取输入的第一行，表示服务器的连接矩阵的第一行\nstr = input().split(\" \")\nn = len(str)  # 服务器的数量，也就是矩阵的维度\n\n# 初始化 n*n 的二维数组 arr 来存储服务器连接状态\narr = [[0]*n for _ in range(n)]\n\n# 将第一行数据存入 arr 的第一行\nfor i in range(n):\n    arr[0][i] = int(str[i])\n\n# 读取剩下的行并存入 arr 中\nfor i in range(1, n):\n    s = input().split(\" \")\n    for j in range(n):\n        arr[i][j] = int(s[j])\n\n# 初始化 visited 数组，用来标记每个服务器是否已经被访问\nvisited = [False] * n\n\n# 遍历每个服务器，执行 DFS 查找连通分量\nfor i in range(n):\n    if not visited[i]:  # 如果该服务器没有被访问\n        dfs(arr, visited, i)  # 递归查找所有与该服务器相连的服务器\n\n# 输出连通分量的数量，即需要广播的服务器数量\nprint(count)",
    "javascript": "const readline = require('readline');\n\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n// 深度优先搜索函数，递归查找与当前服务器相连的所有服务器\nfunction dfs(arr, visited, index) {\n  visited[index] = true;  // 标记当前服务器为已访问\n  let flag = true;  // 标记是否发现相连的服务器\n  for (let i = index + 1; i < arr.length; i++) {  // 遍历服务器\n    if (arr[index][i] === 1) {  // 如果服务器 i 和当前服务器相连\n      flag = false;  // 发现相连的服务器，设置 flag 为 false\n      dfs(arr, visited, i);  // 递归搜索与服务器 i 相连的服务器\n    }\n  }\n  if (flag) {  // 如果 flag 仍为 true，表示该服务器为单独的连通分量\n    count++;  // 增加连通分量计数\n  }\n}\n\n// 初始化计数器\nlet count = 0;\nlet input = '';\n\n \nrl.on('line', (line) => {\n  input += line + '\\n';  // 收集每一行输入\n}).on('close', () => {\n  const lines = input.trim().split('\\n');  // 将输入按行拆分\n  const str = lines[0].split(' ');  // 读取第一行\n  const n = str.length;  // 获取服务器数量\n  const arr = Array(n).fill(0).map(() => Array(n).fill(0));  // 初始化二维数组\n  \n  // 将第一行输入转换为二维数组的第一行\n  for (let i = 0; i < n; i++) {\n    arr[0][i] = parseInt(str[i]);\n  }\n  \n  // 读取剩余行并存入二维数组\n  for (let i = 1; i < n; i++) {\n    const s = lines[i].split(' ');\n    for (let j = 0; j < n; j++) {\n      arr[i][j] = parseInt(s[j]);\n    }\n  }\n  \n  // 初始化访问数组，记录每个服务器是否已访问\n  const visited = Array(n).fill(false);\n  \n  // 遍历每个服务器，查找未访问过的服务器并进行 DFS\n  for (let i = 0; i < n; i++) {\n    if (!visited[i]) {\n      dfs(arr, visited, i);\n    }\n  }\n\n  // 输出连通分量的数量\n  console.log(count);\n});",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint count = 0;  // 全局变量，用于记录连通分量的数量\n\n// 深度优先搜索函数，递归查找与当前服务器相连的服务器\nvoid dfs(vector<vector<int>>& arr, vector<bool>& visited, int index) {\n    visited[index] = true;  // 标记当前服务器为已访问\n    bool flag = true;  // 标记是否发现相连的服务器\n\n    // 遍历当前服务器的所有可能相连的服务器\n    for (int i = index + 1; i < arr.size(); i++) {\n        if (arr[index][i] == 1) {  // 如果服务器 i 和当前服务器直接相连\n            flag = false;  // 发现相连服务器，设置 flag 为 false\n            dfs(arr, visited, i);  // 递归查找与服务器 i 相连的服务器\n        }\n    }\n\n    if (flag) {  // 如果 flag 仍然为 true，表示这是一个新的连通分量\n        count++;  // 增加连通分量计数\n    }\n}\n\nint main() {\n    string input;\n    getline(cin, input);  // 读取输入的第一行\n    vector<string> str;  // 用于存储拆分后的字符串\n    size_t pos = 0;\n\n    // 将输入按空格拆分存入 str\n    while ((pos = input.find(\" \")) != string::npos) {\n        str.push_back(input.substr(0, pos));\n        input.erase(0, pos + 1);\n    }\n    str.push_back(input);  // 最后一个元素也存入 str\n\n    int n = str.size();  // 服务器数量\n    vector<vector<int>> arr(n, vector<int>(n, 0));  // 初始化 n*n 的二维数组\n\n    // 将第一行输入数据存入 arr 的第一行\n    for (int i = 0; i < n; i++) {\n        arr[0][i] = stoi(str[i]);\n    }\n\n    // 读取剩余行并存入 arr\n    for (int i = 1; i < n; i++) {\n        getline(cin, input);\n        pos = 0;\n        vector<string> s;\n        while ((pos = input.find(\" \")) != string::npos) {\n            s.push_back(input.substr(0, pos));\n            input.erase(0, pos + 1);\n        }\n        s.push_back(input);  // 最后一个元素也存入 s\n\n        // 将该行数据存入 arr\n        for (int j = 0; j < n; j++) {\n            arr[i][j] = stoi(s[j]);\n        }\n    }\n\n    vector<bool> visited(n, false);  // 初始化 visited 数组，标记服务器是否已访问\n\n    // 遍历每个服务器，查找未访问过的服务器并进行 DFS\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(arr, visited, i);\n        }\n    }\n\n    // 输出连通分量的数量\n    cout << count << endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\nint count = 0;  // 全局变量，用于记录连通分量的数量\n\n// 深度优先搜索函数，递归查找与当前服务器相连的服务器\nvoid dfs(int** arr, bool* visited, int n, int index) {\n    visited[index] = true;  // 标记当前服务器为已访问\n    bool flag = true;  // 标记是否发现相连的服务器\n\n    // 遍历当前服务器的所有可能相连的服务器\n    for (int i = index + 1; i < n; i++) {\n        if (arr[index][i] == 1) {  // 如果服务器 i 和当前服务器直接相连\n            flag = false;  // 发现相连服务器，设置 flag 为 false\n            dfs(arr, visited, n, i);  // 递归查找与服务器 i 相连的服务器\n        }\n    }\n\n    if (flag) {  // 如果 flag 仍然为 true，表示这是一个新的连通分量\n        count++;  // 增加连通分量计数\n    }\n}\n\nint main() {\n    char input[1024];\n    \n    // 读取输入的第一行\n    fgets(input, sizeof(input), stdin);\n\n    // 按空格拆分输入的字符串，计算服务器数量\n    int n = 0;\n    char* token = strtok(input, \" \");\n    int* str = (int*)malloc(sizeof(int) * 100);  // 假设最多100个服务器\n\n    while (token != NULL) {\n        str[n++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    // 初始化 n*n 的二维数组\n    int** arr = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        arr[i] = (int*)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            arr[i][j] = 0;\n        }\n    }\n\n    // 将第一行输入数据存入 arr 的第一行\n    for (int i = 0; i < n; i++) {\n        arr[0][i] = str[i];\n    }\n\n    // 读取剩余行并存入 arr\n    for (int i = 1; i < n; i++) {\n        fgets(input, sizeof(input), stdin);\n        token = strtok(input, \" \");\n        for (int j = 0; j < n; j++) {\n            arr[i][j] = atoi(token);\n            token = strtok(NULL, \" \");\n        }\n    }\n\n    // 初始化 visited 数组，标记服务器是否已访问\n    bool* visited = (bool*)malloc(n * sizeof(bool));\n    for (int i = 0; i < n; i++) {\n        visited[i] = false;\n    }\n\n    // 遍历每个服务器，查找未访问过的服务器并进行 DFS\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(arr, visited, n, i);\n        }\n    }\n\n    // 输出连通分量的数量\n    printf(\"%d\\n\", count);\n\n    return 0;\n}"
  }
}