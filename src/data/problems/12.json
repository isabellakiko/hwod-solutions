{
  "id": "12",
  "title": "分披萨",
  "examType": "A",
  "score": 100,
  "description": "\"吃货\"和\"馋嘴\"两人到披萨店点了一份铁盘（圆形）披萨，并嘱咐店员将披萨按放射状切成大小相同的偶数个小块。但是粗心的服务员将披萨切成了每块大小都完全不同奇数块，且肉眼能分辨出大小。\n由于两人都想吃到最多的披萨，他们商量了一个他们认为公平的分法：从\"吃货\"开始，轮流取披萨。除了第一块披萨可以任意选取外，其他都必须从缺口开始选。\n他俩选披萨的思路不同。\"馋嘴\"每次都会选最大块的披萨，而且\"吃货\"知道\"馋嘴\"的想法。\n已知披萨小块的数量以及每块的大小，求\"吃货\"能分得的最大的披萨大小的总和。",
  "inputDesc": "第 1 行为一个正整数奇数 N，表示披萨小块数量。\n3 ≤ N < 500\n接下来的第 2 行到第 N + 1 行（共 N 行），每行为一个正整数，表示第 i 块披萨的大小\n1 ≤ i ≤ N\n披萨小块从某一块开始，按照一个方向次序顺序编号为 1 ~ N\n每块披萨的大小范围为 [1, 2147483647]",
  "outputDesc": "\"吃货\"能分得到的最大的披萨大小的总和。",
  "examples": [
    {
      "input": "5\n8\n2\n10\n5\n7",
      "output": "19",
      "explanation": "披萨按顺序排列为 [8,2,10,5,7]（环形）。\n\n一种最优拿法：\n1. \"吃货\"先拿大小为10的披萨（打开缺口）\n2. \"馋嘴\"从缺口两端选较大的，拿5（因为5<7，实际会拿边界较大值）\n3. \"吃货\"拿7\n4. \"馋嘴\"拿8\n5. \"吃货\"拿2\n\n\"吃货\"总共拿到：10 + 7 + 2 = 19"
    },
    {
      "input": "3\n1\n2\n3",
      "output": "4",
      "explanation": "披萨 [1,2,3]（环形），\"吃货\"先拿3，\"馋嘴\"拿2，\"吃货\"拿1。总共 3+1=4。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**博弈论 + 记忆化搜索**问题。\n\n**关键理解：**\n- 披萨是环形排列的\n- \"吃货\"先手，可以任选一块开始\n- 之后双方只能从缺口两端选择\n- \"馋嘴\"总是贪心选较大的，\"吃货\"知道这一点\n\n**算法步骤：**\n\n1. **枚举起点**：\"吃货\"枚举第一块披萨的选择（共n种）\n2. **记忆化递归**：对于剩余的环形区间 [L, R]，计算\"吃货\"能获得的最大值\n3. **模拟\"馋嘴\"的贪心**：\"馋嘴\"总是选两端较大的\n4. **\"吃货\"的最优决策**：在\"馋嘴\"行动后，\"吃货\"选择能使自己总和最大的那端\n\n**状态定义**：`dp[L][R]` = 从左边界L到右边界R，\"吃货\"能获得的最大值\n\n**时间复杂度**：O(n²)，每个状态只计算一次",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    static int n;  // 披萨的数量\n    static int[] a;  // 每块披萨的美味值\n    static int[][] dp;  // 记忆化数组，用于存储已计算过的状态\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();  // 输入披萨的数量\n        a = new int[n];  // 初始化存储每块披萨美味值的数组\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();  // 输入每块披萨的美味值\n        }\n        dp = new int[n][n];  // 初始化记忆化数组，其维度为披萨数量的平方\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);  // 初始化记忆化数组，将所有值设为-1，表示未计算\n        }\n\n        int ans = 0;  // 初始化最大美味值为0\n        // 遍历每块披萨，尝试以每块披萨作为起点计算最大美味值\n        for (int i = 0; i < n; i++) {\n            // 更新最大美味值，allocation函数计算从当前披萨开始的最大美味值\n            ans = Math.max(ans, allocation((i + 1) % n, (i + n - 1) % n) + a[i]);\n        }\n\n        System.out.println(ans);  // 输出最多能吃到的披萨的美味值总和\n    }\n\n    static int allocation(int L, int R) {\n        // 如果当前状态已经计算过，则直接返回结果\n        if (dp[L][R] != -1) {\n            return dp[L][R];\n        }\n        // 根据贪心策略，选择当前美味值较大的披萨\n        if (a[L] > a[R]) {\n            L = (L + 1) % n;  // 如果左边的披萨更美味，则吃掉左边的披萨\n        } else {\n            R = (R + n - 1) % n;  // 如果右边的披萨更美味，则吃掉右边的披萨\n        }\n        // 如果只剩下一块披萨，则直接返回这块披萨的美味值\n        if (L == R) {\n            dp[L][R] = a[L];\n        } else {\n            // 否则，递归计算剩下披萨的最大美味值，并更新记忆化数组\n            dp[L][R] = Math.max(a[L] + allocation((L + 1) % n, R), a[R] + allocation(L, (R + n - 1) % n));\n        }\n        return dp[L][R];  // 返回当前状态下的最大美味值\n    }\n}",
    "python": "# 用于读取输入的标准库\nimport sys\n\n# 用于存储输入行的数组\nlines = []\n# 读取标准输入\nfor line in sys.stdin:\n    lines.append(line.strip())\n\n# 披萨的数量\nn = int(lines[0])\n# 每块披萨的美味值\na = list(map(int, lines[1:1 + n]))\n# 记忆化数组，用于存储已计算过的状态\ndp = [[-1 for _ in range(n)] for _ in range(n)]\n\n# 计算最大美味值的函数\ndef allocation(L, R):\n    # 如果已计算过，直接返回结果\n    if dp[L][R] != -1:\n        return dp[L][R]\n    # 根据美味值选择吃掉左边或右边的披萨\n    if a[L] > a[R]:\n        L = (L + 1) % n\n    else:\n        R = (R + n - 1) % n\n    # 如果只剩一块披萨，返回其美味值\n    if L == R:\n        dp[L][R] = a[L]\n    else:\n        dp[L][R] = max(a[L] + allocation((L + 1) % n, R), a[R] + allocation(L, (R + n - 1) % n))\n    return dp[L][R]\n\n# 初始化最大美味值为 0\nans = 0\n# 计算并更新最大美味值\nfor i in range(n):\n    ans = max(ans, allocation((i + 1) % n, (i + n - 1) % n) + a[i])\n\n# 输出最多能吃到的披萨的美味值总和\nprint(ans)",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n\nlet lines = [];\nrl.on('line', line => lines.push(line.trim()));\nrl.on('close', () => {\n  const n = parseInt(lines[0]);\n  const a = [];\n  for (let i = 1; i <= n; i++) a.push(parseInt(lines[i]));\n  \n  const dp = Array.from({length: n}, () => Array(n).fill(-1));\n  \n  function allocation(L, R) {\n    if (dp[L][R] !== -1) return dp[L][R];\n    \n    // \"馋嘴\"贪心选较大的\n    if (a[L] > a[R]) {\n      L = (L + 1) % n;\n    } else {\n      R = (R + n - 1) % n;\n    }\n    \n    if (L === R) {\n      dp[L][R] = a[L];\n    } else {\n      dp[L][R] = Math.max(\n        a[L] + allocation((L + 1) % n, R),\n        a[R] + allocation(L, (R + n - 1) % n)\n      );\n    }\n    return dp[L][R];\n  }\n  \n  let ans = 0;\n  for (let i = 0; i < n; i++) {\n    ans = Math.max(ans, allocation((i + 1) % n, (i + n - 1) % n) + a[i]);\n  }\n  \n  console.log(ans);\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm> // 用于 std::max 函数\n\nusing namespace std;\n\nint n; // 披萨的数量\nvector<int> a; // 每块披萨的美味值\nvector<vector<int>> dp; // 记忆化数组，用于存储已计算过的状态\n\n// 计算最大美味值的函数\nint allocation(int L, int R) {\n    if (dp[L][R] != -1) {\n        return dp[L][R]; // 如果已计算过，直接返回结果\n    }\n    if (a[L] > a[R]) {\n        L = (L + 1) % n; // 左边披萨更美味，吃掉左边的\n    } else {\n        R = (R + n - 1) % n; // 右边披萨更美味，吃掉右边的\n    }\n    if (L == R) {\n        dp[L][R] = a[L]; // 只剩一块披萨时，返回其美味值\n    } else {\n        // 否则，递归计算剩下披萨的最大美味值，并更新记忆化数组\n        dp[L][R] = max(a[L] + allocation((L + 1) % n, R), a[R] + allocation(L, (R + n - 1) % n));\n    }\n    return dp[L][R]; // 返回当前状态下的最大美味值\n}\n\nint main() {\n    cin >> n; // 输入披萨的数量\n    a.resize(n); // 调整数组大小以存储每块披萨的美味值\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i]; // 输入每块披萨的美味值\n    }\n    dp.assign(n, vector<int>(n, -1)); // 初始化记忆化数组\n\n    int ans = 0; // 初始化最大美味值为 0\n    for (int i = 0; i < n; ++i) {\n        // 更新最大美味值，allocation函数计算从当前披萨开始的最大美味值\n        ans = max(ans, allocation((i + 1) % n, (i + n - 1) % n) + a[i]);\n    }\n\n    cout << ans << endl;  // 输出最多能吃到的披萨的美味值\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n;  // 披萨的数量\n    int *a; // 存储每块披萨美味值的数组\n    int **dp; // 记忆化数组，用于存储已计算过的状态\n\n    // 读取披萨的数量\n    scanf(\"%d\", &n);\n    a = (int *)malloc(n * sizeof(int));\n\n    // 读取每块披萨的美味值\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    // 初始化记忆化数组\n    dp = (int **)malloc(n * sizeof(int *));\n    for (int i = 0; i < n; i++) {\n        dp[i] = (int *)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = -1;\n        }\n    }\n\n    // 计算最大美味值的函数声明\n    int allocation(int, int, int, int *, int **);\n\n    int ans = 0; // 初始化最大美味值为 0\n    for (int i = 0; i < n; i++) {\n        ans = (ans > allocation((i + 1) % n, (i + n - 1) % n, n, a, dp) + a[i]) ? ans : allocation((i + 1) % n, (i + n - 1) % n, n, a, dp) + a[i];\n    }\n\n    // 输出最多能吃到的披萨的美味值总和\n    printf(\"%d\\n\", ans);\n\n    // 释放分配的内存\n    for (int i = 0; i < n; i++) {\n        free(dp[i]);\n    }\n    free(dp);\n    free(a);\n\n    return 0;\n}\n\n// 计算最大美味值的函数\nint allocation(int L, int R, int n, int *a, int **dp) {\n    if (dp[L][R] != -1) {\n        return dp[L][R]; // 如果已计算过，直接返回结果\n    }\n    if (a[L] > a[R]) {\n        L = (L + 1) % n; // 左边披萨更美味，吃掉左边的\n    } else {\n        R = (R + n - 1) % n; // 右边披萨更美味，吃掉右边的\n    }\n    if (L == R) {\n        dp[L][R] = a[L]; // 只剩一块披萨时，返回其美味值\n    } else {\n        dp[L][R] = (a[L] + allocation((L + 1) % n, R, n, a, dp)) > (a[R] + allocation(L, (R + n - 1) % n, n, a, dp)) ? (a[L] + allocation((L + 1) % n, R, n, a, dp)) : (a[R] + allocation(L, (R + n - 1) % n, n, a, dp));\n    }\n    return dp[L][R]; // 返回当前状态下的最大美味值\n}"
  }
}