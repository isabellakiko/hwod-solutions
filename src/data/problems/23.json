{
  "id": "23",
  "title": "找等值元素",
  "examType": "A",
  "score": 100,
  "description": "给一个二维数组 nums，对于每一个元素 nums[i]，找出距离最近的且值相等的元素，\n输出横纵坐标差值的绝对值之和，如果没有等值元素，则输出-1。",
  "inputDesc": "输入第一行为二维数组的行\n输入第二行为二维数组的列\n输入的数字以空格隔开。\n针对数组 nums[i][j]，满足 0 < i ≤ 100，0 < j ≤ 100对于每个数字，最多存在 100 个与其相等的数字",
  "outputDesc": "数组形式返回所有坐标值。",
  "examples": [
    {
      "input": "3\n5\n0 3 5 4 2\n2 5 7 8 3\n2 5 4 2 4",
      "output": "[[-1, 4, 2, 3, 3], [1, 1, -1, -1, 4], [1, 1, 2, 3, 2]]",
      "explanation": "3行5列矩阵：\n0 3 5 4 2\n2 5 7 8 3\n2 5 4 2 4\n\n计算每个元素到最近等值元素的曼哈顿距离：\n- (0,0)=0：无其他0，输出-1\n- (0,1)=3：最近的3在(1,4)，距离=|0-1|+|1-4|=4\n- (0,2)=5：最近的5在(1,1)，距离=|0-1|+|2-1|=2\n- (1,2)=7：无其他7，输出-1\n- (1,3)=8：无其他8，输出-1"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**哈希表 + 曼哈顿距离**问题。\n\n**算法步骤：**\n\n1. **预处理**：用哈希表记录每个数值出现的所有位置坐标\n2. **遍历矩阵**：对于每个元素 (i,j)\n   - 如果该值只出现一次，结果为 -1\n   - 否则遍历所有相同值的位置，计算曼哈顿距离，取最小值\n3. **曼哈顿距离**：|x1-x2| + |y1-y2|\n\n**时间复杂度**：O(n*m*k)，k为相同数字的最大个数（题目保证≤100）",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 读取输入的行数和列数\n        int rows = sc.nextInt(); // 输入行数\n        int cols = sc.nextInt(); // 输入列数\n\n        // 创建一个二维数组来存储输入的矩阵\n        int[][] mat = new int[rows][cols];\n        // 创建一个哈希表来记录每个数字在矩阵中的所有位置\n        Map<Integer, List<int[]>> posMap = new HashMap<>();\n\n        // 读取输入的矩阵数据并同时记录每个数字出现的位置\n        for (int r = 0; r < rows; r++) { // 遍历每一行\n            for (int c = 0; c < cols; c++) { // 遍历每一列\n                int val = sc.nextInt(); // 读取当前元素\n                mat[r][c] = val; // 将元素存入矩阵\n                // 如果哈希表中还没有这个数字，则初始化一个列表来存储位置\n                posMap.putIfAbsent(val, new ArrayList<>());\n                // 将当前元素的坐标 (r, c) 加入到数字对应的列表中\n                posMap.get(val).add(new int[]{r, c});\n            }\n        }\n\n        // 用来存放最终输出的结果矩阵\n        int[][] res = new int[rows][cols];\n\n        // 遍历矩阵中的每个元素，计算到最近的相同元素的距离\n        for (int r = 0; r < rows; r++) { // 遍历每一行\n            for (int c = 0; c < cols; c++) { // 遍历每一列\n                int val = mat[r][c]; // 获取当前元素的值\n                // 如果这个数字只出现一次，即只有一个位置，则没有相同元素，输出 -1\n                if (posMap.get(val).size() == 1) {\n                    res[r][c] = -1; // 该位置没有相同元素，返回 -1\n                } else {\n                    // 否则调用 bfs 函数，计算到最近的相同元素的距离\n                    res[r][c] = bfs(mat, posMap.get(val), r, c);\n                }\n            }\n        }\n\n        // 将结果矩阵转换为字符串并输出\n         String[] resultStrings = new String[res.length];\n        for (int i = 0; i < res.length; i++) {\n            resultStrings[i] = Arrays.toString(res[i]);\n        }\n        System.out.println(Arrays.toString(resultStrings));\n        \n    }\n\n    //  搜索函数，用于找到与 (x, y) 坐标最近的相同元素\n    private static int bfs(int[][] mat, List<int[]> positions, int x, int y) {\n        int minDist = Integer.MAX_VALUE; // 初始化最小距离为最大值\n        // 遍历所有相同数字的坐标\n        for (int[] p : positions) {\n            int px = p[0]; // 相同数字的行坐标\n            int py = p[1]; // 相同数字的列坐标\n            // 如果这个相同数字的位置与当前坐标不同\n            if (px != x || py != y) {\n                // 计算当前元素与相同数字的曼哈顿距离\n                int dist = Math.abs(px - x) + Math.abs(py - y);\n                // 更新最小距离\n                minDist = Math.min(minDist, dist);\n            }\n        }\n        return minDist; // 返回最小的距离\n    }\n}",
    "python": "import sys\nfrom collections import defaultdict\n\n# 读取输入的行数和列数\nn = int(input())\nm = int(input())\n\n# 读取矩阵数据\nmatrix = [list(map(int, input().split())) for _ in range(n)]\n\n# 用字典记录每个数字出现的位置\nposMap = defaultdict(list)\n\n# 遍历矩阵，记录每个数字的位置\nfor i in range(n):\n    for j in range(m):\n        num = matrix[i][j]\n        posMap[num].append((i, j))\n\n# 初始化结果矩阵\nresult = [[-1] * m for _ in range(n)]\n\n# 遍历矩阵中的每个元素，计算到最近的相同元素的距离\nfor i in range(n):\n    for j in range(m):\n        num = matrix[i][j]\n        minDist = float('inf')\n        \n        # 如果该数字只出现一次，则返回 -1\n        if len(posMap[num]) == 1:\n            result[i][j] = -1\n        else:\n            # 遍历相同数字的所有位置，计算曼哈顿距离\n            for (x, y) in posMap[num]:\n                if (x, y) != (i, j):\n                    dist = abs(x - i) + abs(y - j)\n                    minDist = min(minDist, dist)\n            \n            result[i][j] = minDist\nprint(result)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst lines = [];\nlet n, m;\n\nrl.on('line', (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    n = parseInt(lines[0]);\n    m = parseInt(lines[1]);\n  }\n\n  if (n && lines.length === n + 2) {\n    const matrix = lines.slice(2).map(line => line.split(' ').map(Number));\n    const posMap = {};\n\n    // 记录每个数字出现的位置\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        const num = matrix[i][j];\n        if (!posMap[num]) posMap[num] = [];\n        posMap[num].push([i, j]);\n      }\n    }\n\n    const result = Array.from({ length: n }, () => Array(m).fill(-1));\n\n    // 遍历矩阵，计算最近的相同元素的距离\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < m; j++) {\n        const num = matrix[i][j];\n        const positions = posMap[num];\n\n        if (positions.length > 1) {\n          result[i][j] = findMinDistance(positions, i, j);\n        }\n      }\n    }\n\n    \n    console.log(JSON.stringify(result).replace(/,/g, \", \"));\n    rl.close();\n  }\n});\n\n// 计算当前位置到相同数字最近元素的曼哈顿距离\nfunction findMinDistance(positions, x, y) {\n  let minDist = Infinity;\n  for (const [px, py] of positions) {\n    if (px !== x || py !== y) {\n      const dist = Math.abs(px - x) + Math.abs(py - y);\n      minDist = Math.min(minDist, dist);\n    }\n  }\n  return minDist;\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n#include <cmath>\nusing namespace std;\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n\n    vector<vector<int>> matrix(rows, vector<int>(cols));\n    unordered_map<int, vector<pair<int, int>>> posMap;\n\n    // 读取输入的矩阵数据并记录每个数字出现的位置\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cin >> matrix[i][j];\n            posMap[matrix[i][j]].emplace_back(i, j);\n        }\n    }\n\n    vector<vector<int>> result(rows, vector<int>(cols, -1));\n\n    // 遍历矩阵中的每个元素，计算到最近的相同元素的距离\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int num = matrix[i][j];\n            int minDist = INT_MAX;\n            \n            // 如果该数字只出现一次，则直接设为 -1\n            if (posMap[num].size() > 1) {\n                // 遍历相同数字的所有位置，计算曼哈顿距离\n                for (const auto& pos : posMap[num]) {\n                    int x = pos.first;\n                    int y = pos.second;\n                    if (x != i || y != j) {\n                        int dist = abs(x - i) + abs(y - j);\n                        minDist = min(minDist, dist);\n                    }\n                }\n                result[i][j] = minDist;\n            }\n        }\n    }\n    cout << \"[\";\n    // 输出结果矩阵\n    for (int i = 0; i < rows; i++) {\n        cout << \"[\";\n        for (int j = 0; j < cols; j++) {\n            cout << result[i][j];\n            if (j != cols - 1) {\n                cout << \", \";\n            }\n        }\n        cout << \"]\" ;\n        if (i != rows - 1) {\n                cout << \", \";\n        }\n    }  \n    cout << \"]\" ;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\n// 定义最大数字值及矩阵大小的上限\n#define MAX_NUM 101\n#define MAX_SIZE 100\n\n// 定义二维数组，用于记录数字出现的坐标\nint posMap[MAX_NUM][MAX_SIZE][2];\nint posCount[MAX_NUM];  // 记录每个数字出现的次数\n\nint main() {\n    int rows, cols;\n    \n    // 输入矩阵的行数和列数\n    scanf(\"%d %d\", &rows, &cols);\n    \n    int matrix[MAX_SIZE][MAX_SIZE];   // 定义一个二维数组来存储输入的矩阵\n    int result[MAX_SIZE][MAX_SIZE];   // 定义一个二维数组来存储结果\n    \n    // 初始化 posMap 数组的计数\n    for (int i = 0; i < MAX_NUM; i++) {\n        posCount[i] = 0;\n    }\n    \n    // 读取输入的矩阵数据并记录每个数字出现的位置\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &matrix[i][j]);  // 输入矩阵的元素\n            int num = matrix[i][j];\n            // 记录数字的位置\n            posMap[num][posCount[num]][0] = i;\n            posMap[num][posCount[num]][1] = j;\n            posCount[num]++;  // 计数加一\n        }\n    }\n\n    // 初始化结果矩阵为 -1\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            result[i][j] = -1;\n        }\n    }\n\n    // 遍历矩阵中的每个元素，计算到最近的相同元素的距离\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int num = matrix[i][j];  // 获取当前元素的值\n            int minDist = INT_MAX;   // 初始化最小距离为最大值\n            \n            // 如果该数字出现多次，计算到最近的相同数字的距离\n            if (posCount[num] > 1) {\n                for (int k = 0; k < posCount[num]; k++) {\n                    int x = posMap[num][k][0];\n                    int y = posMap[num][k][1];\n                    if (x != i || y != j) {  // 排除当前位置\n                        // 计算曼哈顿距离\n                        int dist = abs(x - i) + abs(y - j);\n                        if (dist < minDist) {\n                            minDist = dist;  // 更新最小距离\n                        }\n                    }\n                }\n                result[i][j] = minDist;  // 记录结果\n            }\n        }\n    }\n\n    // 输出结果矩阵\n    printf(\"[\");\n    for (int i = 0; i < rows; i++) {\n        printf(\"[\");\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d\", result[i][j]);\n            if (j != cols - 1) {\n                printf(\", \");\n            }\n        }\n        printf(\"]\");\n        if (i != rows - 1) {\n            printf(\", \");\n        }\n    }\n    printf(\"]\\n\");\n\n    return 0;\n}"
  }
}