{
  "id": "215",
  "title": "最长的顺子",
  "examType": "B",
  "score": 200,
  "description": "斗地主起源于湖北十堰房县，据说是一位叫吴修全的年轻人根据当地流行的扑克玩法“跑得快”改编的，如今已风靡整个中国，并流行于互联网上。\n牌型：单顺，又称顺子，最少5张牌，最多12张牌(3…A)不能有2，也不能有大小王，不计花色。\n例如： 3-4-5-6-7-8，7-8-9-10-J-Q，3-4-5-6-7-8-9-10-J-Q-K-A\n可用的牌 3<4<5<6<7<8<9<10<J<Q<K<A<2<B(小王)<C(大王)，每种牌除大小王外有四种花色\n(共有13×4+2张牌)\n输入：\n手上有的牌已经出过的牌(包括对手出的和自己出的牌)\n输出：\n对手可能构成的最长的顺子(如果有相同长度的顺子，输出牌面最大的那一个)，如果无法构成顺子，则输出 NO-CHAIN。\n",
  "inputDesc": "输入的第一行为当前手中的牌\n输入的第二行为已经出过的牌\n",
  "outputDesc": "最长的顺子\n\n本题我的解题思路分为两步：\n首先，对手的牌 = 总牌 - 我的牌 - 已打出的牌\n这里主要难点在于，如何记录牌面对应的牌数量。我的思路是：\n定义一个数组count，将数组count的索引和牌面关联（定义一个字典mapToV），数组count的元素值就是对应牌面的数量。\n这样可以得出一个数组：\n然后，就可以很简单的完成：对手的牌 = 总牌 - 我的牌 - 已打出的牌\n\n比如用例1，对手的牌就可以表示为：\nint[] count = {0, 0, 0, 1, 1, 2, 2, 0, 3, 3, 3, 3, 3, 3, 3, 0, 4, 1, 1};\n接下来我们可以定义一个 L 指针，作为顺子的左边界，L指针的运动范围是count数组的索引3~索引10。\n因为，顺子只能由牌面3~牌面A组成，因此左边界起始位置是牌面3，即索引3。而顺子至少要由5张牌组成，因此，左边界的结束位置是牌面10，即索引10，对应的顺子是10,J,Q,K,A。\n之后，定义一个临时右边界指针R，区间[L,R]之间就是顺子的范围，R的从L位置开始扫描：\n当顺子发生中断，则下一次L的扫描位置，应该是R+1，比如下面标红的范围，L=3，R=6，当R=7时，顺子中断，则下个顺子从L=4位置开始扫描的话，依旧不能组成顺子，因此我们应该让下个顺子的L直接跳到R+1=8的位置开始扫描。\nint[] count = {0, 0, 0, 1, 1, 2, 2, 0, 3, 3, 3, 3, 3, 3, 3, 0, 4, 1, 1};\n最后，将最长的顺子输出即可。\n需要注意的是，我们可以在上面过程中，实时保存最长顺子，当遇到同长度的顺子时，必然是后面的顺子更优。\n",
  "examples": [],
  "solution": "",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String[] my = sc.nextLine().split(\"-\");\n    String[] used = sc.nextLine().split(\"-\");\n\n    System.out.println(getResult(my, used));\n  }\n\n  public static String getResult(String[] my, String[] used) {\n    // 牌面值 映射为 count列表索引值\n    HashMap<String, Integer> mapToV = new HashMap<>();\n    mapToV.put(\"3\", 3);\n    mapToV.put(\"4\", 4);\n    mapToV.put(\"5\", 5);\n    mapToV.put(\"6\", 6);\n    mapToV.put(\"7\", 7);\n    mapToV.put(\"8\", 8);\n    mapToV.put(\"9\", 9);\n    mapToV.put(\"10\", 10);\n    mapToV.put(\"J\", 11);\n    mapToV.put(\"Q\", 12);\n    mapToV.put(\"K\", 13);\n    mapToV.put(\"A\", 14);\n    mapToV.put(\"2\", 16);\n    mapToV.put(\"B\", 17);\n    mapToV.put(\"C\", 18);\n\n    // count每个索引值对应一个牌面值，count元素值就是对应牌面的数量\n    // 牌面值             3  4  5  6  7  8  9  10 J  Q  K  A     2  B  C\n    // 索引值             3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18\n    int[] count = {0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 1, 1};\n\n    // count列表索引值 隐射为 牌面值\n    HashMap<Integer, String> mapToK = new HashMap<>();\n    mapToK.put(3, \"3\");\n    mapToK.put(4, \"4\");\n    mapToK.put(5, \"5\");\n    mapToK.put(6, \"6\");\n    mapToK.put(7, \"7\");\n    mapToK.put(8, \"8\");\n    mapToK.put(9, \"9\");\n    mapToK.put(10, \"10\");\n    mapToK.put(11, \"J\");\n    mapToK.put(12, \"Q\");\n    mapToK.put(13, \"K\");\n    mapToK.put(14, \"A\");\n    mapToK.put(16, \"2\");\n    mapToK.put(17, \"B\");\n    mapToK.put(18, \"C\");\n\n    // 总牌数 减去 自己手中牌数\n    for (String k : my) {\n      count[mapToV.get(k)] -= 1;\n    }\n\n    // 总牌数 减去 已打出去的牌数\n    for (String k : used) {\n      count[mapToV.get(k)] -= 1;\n    }\n\n    String ans = \"NO-CHAIN\";\n    int maxLen = 0;\n\n    // l为顺子的左边界，[3,10]，即顺子的左边界值最少是count索引3，最多是count索引10\n    int l = 3;\n    while (l <= 10) {\n      ArrayList<String> tmp = new ArrayList<>();\n      StringJoiner sj = new StringJoiner(\"-\");\n      for (int r = l; r < 16; r++) {\n        // 如果对应牌数>=1，则可以组顺子\n        if (count[r] >= 1) {\n          tmp.add(mapToK.get(r));\n          sj.add(mapToK.get(r));\n        } else {\n          // 如果对应牌数 == 0，则顺子中断\n          // 顺子必须大于五张牌，且总是记录最长，遇到长度相同的，记录后面发现的顺子\n          if (tmp.size() >= 5 && tmp.size() >= maxLen) {\n            maxLen = tmp.size();\n            ans = sj.toString();\n          }\n          // 顺子中断处+1，即为下一次顺子的起始位置\n          l = r;\n          break;\n        }\n      }\n      l++;\n    }\n\n    return ans;\n  }\n}",
    "python": "# 输入获取\nmy = input().split(\"-\")\nused = input().split(\"-\")\n\n\n# 算法入口\ndef getResult():\n    # 牌面值 映射为 count列表索引值\n    mapToV = {\n        \"3\": 3,\n        \"4\": 4,\n        \"5\": 5,\n        \"6\": 6,\n        \"7\": 7,\n        \"8\": 8,\n        \"9\": 9,\n        \"10\": 10,\n        \"J\": 11,\n        \"Q\": 12,\n        \"K\": 13,\n        \"A\": 14,\n        \"2\": 16,\n        \"B\": 17,\n        \"C\": 18\n    }\n\n    # count每个索引值对应一个牌面值，count元素值就是对应牌面的数量\n    # 牌面值           3  4  5  6  7  8  9  10 J  Q  K  A     2  B  C\n    # 索引值           3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18\n    count = [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 1, 1]\n\n    # count列表索引值 隐射为 牌面值\n    mapToK = {\n        3: \"3\",\n        4: \"4\",\n        5: \"5\",\n        6: \"6\",\n        7: \"7\",\n        8: \"8\",\n        9: \"9\",\n        10: \"10\",\n        11: \"J\",\n        12: \"Q\",\n        13: \"K\",\n        14: \"A\",\n        16: \"2\",\n        17: \"B\",\n        18: \"C\"\n    }\n\n    # 总牌数 减去 自己手中牌数\n    for k in my:\n        count[mapToV[k]] -= 1\n\n    # 总牌数 减去 已打出去的牌数\n    for k in used:\n        count[mapToV[k]] -= 1\n\n    ans = \"NO-CHAIN\"\n    maxLen = 0\n\n    # l为顺子的左边界，[3,10]，即顺子的左边界值最少是count索引3，最多是count索引10\n    l = 3\n    while l <= 10:\n        tmp = []\n        for r in range(l, 16):\n            # 如果对应牌数>=1，则可以组顺子\n            if count[r] >= 1:\n                tmp.append(mapToK[r])\n            # 如果对应牌数 == 0，则顺子中断\n            else:\n                # 顺子必须大于五张牌，且总是记录最长，遇到长度相同的，记录后面发现的顺子\n                if len(tmp) >= 5 and len(tmp) >= maxLen:\n                    maxLen = len(tmp)\n                    ans = \"-\".join(tmp)\n                # 顺子中断处+1，即为下一次顺子的起始位置\n                l = r\n                break\n        l += 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const my = lines[0].split(\"-\");\n    const used = lines[1].split(\"-\");\n    console.log(getResult(my, used));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(my, used) {\n  // 牌面值 映射为 count列表索引值\n  const mapToV = new Map([\n    [\"3\", 3],\n    [\"4\", 4],\n    [\"5\", 5],\n    [\"6\", 6],\n    [\"7\", 7],\n    [\"8\", 8],\n    [\"9\", 9],\n    [\"10\", 10],\n    [\"J\", 11],\n    [\"Q\", 12],\n    [\"K\", 13],\n    [\"A\", 14],\n    [\"2\", 16],\n    [\"B\", 17],\n    [\"C\", 18],\n  ]);\n\n  /* count每个索引值对应一个牌面值，count元素值就是对应牌面的数量\n     牌面值               3  4  5  6  7  8  9  10 J  Q  K  A     2  B  C\n     索引值               3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 */\n  const count = [0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 1, 1];\n\n  // count列表索引值 隐射为 牌面值\n  const mapToK = new Map([\n    [3, \"3\"],\n    [4, \"4\"],\n    [5, \"5\"],\n    [6, \"6\"],\n    [7, \"7\"],\n    [8, \"8\"],\n    [9, \"9\"],\n    [10, \"10\"],\n    [11, \"J\"],\n    [12, \"Q\"],\n    [13, \"K\"],\n    [14, \"A\"],\n    [16, \"2\"],\n    [17, \"B\"],\n    [18, \"C\"],\n  ]);\n\n  // 总牌数 减去 自己手中牌数\n  for (let k of my) {\n    count[mapToV.get(k)] -= 1;\n  }\n\n  // 总牌数 减去 已打出去的牌数\n  for (let k of used) {\n    count[mapToV.get(k)] -= 1;\n  }\n\n  let ans = \"NO-CHAIN\";\n  let maxLen = 0;\n\n  // l为顺子的左边界，[3,10]，即顺子的左边界值最少是count索引3，最多是count索引10\n  let l = 3;\n  while (l <= 10) {\n    const tmp = [];\n    for (let r = l; r < 16; r++) {\n      // 如果对应牌数>=1，则可以组顺子\n      if (count[r] >= 1) {\n        tmp.push(mapToK.get(r));\n      } else {\n        // 如果对应牌数 == 0，则顺子中断\n        // 顺子必须大于五张牌，且总是记录最长，遇到长度相同的，记录后面发现的顺子\n        if (tmp.length >= 5 && tmp.length >= maxLen) {\n          maxLen = tmp.length;\n          ans = tmp.join(\"-\");\n        }\n        // 顺子中断处+1，即为下一次顺子的起始位置\n        l = r;\n        break;\n      }\n    }\n    l++;\n  }\n\n  return ans;\n}",
    "cpp": "",
    "c": ""
  }
}