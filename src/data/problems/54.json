{
  "id": "54",
  "title": "计算三叉搜索树的高度",
  "examType": "A",
  "score": 100,
  "description": "定义构造三叉搜索树规则如下：\n每个节点都存有一个数，当插入一个新的数时，从根节点向下寻找，直到找到一个合适的空节点插入。查找的规则是：\n如果数小于节点的数减去500，则将数插入节点的左子树 如果数大于节点的数加上500，则将数插入节点的右子树 否则，将数插入节点的中子树\n如果数小于节点的数减去500，则将数插入节点的左子树\n如果数大于节点的数加上500，则将数插入节点的右子树\n否则，将数插入节点的中子树\n给你一系列数，请按以上规则，按顺序将数插入树中，构建出一棵三叉搜索树，最后输出树的高度。",
  "inputDesc": "第一行为一个数 N，表示有 N 个数，1 ≤ N ≤ 10000\n第二行为 N 个空格分隔的整数，每个数的范围为[1,10000]",
  "outputDesc": "输出树的高度（根节点的高度为1）",
  "examples": [
    {
      "input": "4\n2000 5000 8000 1800",
      "output": "3",
      "explanation": "插入过程：\n2000→根节点\n5000→5000>2500，插入右子树\n8000→8000>5500，插入右-右\n1800→1800在[1500,2500]，插入中子树\n最大深度为3。"
    },
    {
      "input": "2\n4000 3000",
      "output": "2",
      "explanation": "插入过程：\n4000→根节点\n3000→3000在[3500,4500]，插入中子树\n最大深度为2。"
    },
    {
      "input": "8\n2000 5000 8000 1800 7500 4500 1400 8100",
      "output": "4",
      "explanation": "插入过程形成较深的树结构。\n路径：根(2000)→右(5000)→中(4500)→中\n或：根→右→右(8000)→中(8100)\n最大深度为4。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**树的构建与遍历**问题。\n\n**三叉搜索树插入规则：**\n- 左子树：新数 < 节点值 - 500\n- 右子树：新数 > 节点值 + 500\n- 中子树：其他情况（差值在500以内）\n\n**算法步骤：**\n\n1. 按顺序插入每个数，构建三叉搜索树\n2. 递归计算树的高度：max(左高度, 中高度, 右高度) + 1\n\n**时间复杂度**：O(N × H)，H为树高\n**空间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.Scanner;\n\n// 主类\npublic class Main {\n  \n    // 静态内部类：树\n    static class Tree {\n        // 插入方法：向树中插入值\n        public TreeNode insert(TreeNode root, int val) {\n            if (root == null) {\n                return new TreeNode(val); // 如果根节点为空，创建新节点作为根节点\n            }\n            if (val < root.val - 500) {\n                root.left = insert(root.left, val); // 如果值小于根节点值减500，插入到左子树\n            } else if (val > root.val + 500) {\n                root.right = insert(root.right, val); // 如果值大于根节点值加500，插入到右子树\n            } else {\n                root.mid = insert(root.mid, val); // 如果值在根节点值加减500范围内，插入到中间子树\n            }\n            return root; // 返回根节点\n        }\n\n        // 获取树的高度\n        public int getHeight(TreeNode root) {\n            if (root == null) {\n                return 0; // 如果根节点为空，高度为0\n            }\n            int leftHeight = getHeight(root.left); // 计算左子树的高度\n            int midHeight = getHeight(root.mid); // 计算中间子树的高度\n            int rightHeight = getHeight(root.right); // 计算右子树的高度\n            return Math.max(Math.max(leftHeight, midHeight), rightHeight) + 1; // 返回三者中最大的高度加1\n        }\n    }\n\n    // 静态内部类：树节点\n    static class TreeNode {\n        int val; // 节点值\n        TreeNode left, mid, right; // 左子节点、中间子节点、右子节点\n        TreeNode(int x) { val = x; } // 构造方法，初始化节点值\n    }\n\n     \n    public static void main(String[] args) {\n        Tree tree = new Tree(); // 创建树对象\n        Scanner scanner = new Scanner(System.in); // 创建扫描器读取输入\n        int N = scanner.nextInt();  // 读取第一个整数作为后续要输入的节点数量\n        TreeNode root = null; // 初始化根节点为null\n        for (int i = 0; i < N; i++) {\n            int num = scanner.nextInt();  // 循环读取N个整数作为节点值\n            root = tree.insert(root, num);  // 将每个整数插入树中\n        }\n        scanner.close(); // 关闭扫描器\n        int height = tree.getHeight(root);  // 获取树的高度\n        System.out.println(height);  // 输出树的高度\n    }\n}",
    "python": "class TreeNode:\n    def __init__(self, val):\n        self.val = val  # 节点值\n        self.left = self.mid = self.right = None  # 左、中、右子节点\n\nclass Tree:\n    # 插入方法：向树中插入值\n    def insert(self, root, val):\n        if root is None:\n            return TreeNode(val)  # 如果根节点为空，创建新节点作为根节点\n        if val < root.val - 500:\n            root.left = self.insert(root.left, val)  # 如果值小于根节点值减500，插入到左子树\n        elif val > root.val + 500:\n            root.right = self.insert(root.right, val)  # 如果值大于根节点值加500，插入到右子树\n        else:\n            root.mid = self.insert(root.mid, val)  # 如果值在根节点值加减500范围内，插入到中间子树\n        return root  # 返回根节点\n\n    # 获取树的高度\n    def get_height(self, root):\n        if root is None:\n            return 0  # 如果根节点为空，高度为0\n        left_height = self.get_height(root.left)  # 计算左子树的高度\n        mid_height = self.get_height(root.mid)  # 计算中间子树的高度\n        right_height = self.get_height(root.right)  # 计算右子树的高度\n        return max(left_height, mid_height, right_height) + 1  # 返回三者中最大的高度加1\n\nif __name__ == '__main__':\n    tree = Tree()  # 创建树对象\n    N = int(input())  # 读取节点数量\n    root = None  # 初始化根节点为None\n    nums = list(map(int, input().split()))\n    for num in nums:\n        root = tree.insert(root, num)  # 将每个整数插入树中     \n    height = tree.get_height(root)  # 获取树的高度\n    print(height)  # 输出树的高度",
    "javascript": "class TreeNode {\n    // 构造函数：创建树节点\n    constructor(val) {\n        this.val = val; // 节点值\n        this.left = this.mid = this.right = null; // 初始化左、中、右子节点为null\n    }\n}\n\nclass Tree {\n    // 插入方法：向树中插入值\n    insert(root, val) {\n        if (root === null) {\n            return new TreeNode(val); // 如果根节点为空，创建新节点作为根节点\n        }\n        if (val < root.val - 500) {\n            root.left = this.insert(root.left, val); // 如果值小于根节点值减500，插入到左子树\n        } else if (val > root.val + 500) {\n            root.right = this.insert(root.right, val); // 如果值大于根节点值加500，插入到右子树\n        } else {\n            root.mid = this.insert(root.mid, val); // 如果值在根节点值加减500范围内，插入到中间子树\n        }\n        return root; // 返回根节点\n    }\n\n    // 获取树的高度\n    getHeight(root) {\n        if (root === null) {\n            return 0; // 如果根节点为空，高度为0\n        }\n        let leftHeight = this.getHeight(root.left); // 计算左子树的高度\n        let midHeight = this.getHeight(root.mid); // 计算中间子树的高度\n        let rightHeight = this.getHeight(root.right); // 计算右子树的高度\n        return Math.max(leftHeight, midHeight, rightHeight) + 1; // 返回三者中最大的高度加1\n    }\n}\n\n// 主程序\nconst readline = require('readline').createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst tree = new Tree();\nlet root = null;\n\nreadline.on('line', N => {\n    N = parseInt(N);\n    readline.on('line', nums => {\n        nums.split(' ').forEach(num => {\n            root = tree.insert(root, parseInt(num)); // 将每个整数插入树中\n        });\n        const height = tree.getHeight(root); // 获取树的高度\n        console.log(height); // 输出树的高度\n        readline.close();\n    });\n});",
    "cpp": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n// 树节点结构体\nstruct TreeNode {\n    int val; // 节点值\n    TreeNode *left, *mid, *right; // 左、中、右子节点指针\n    TreeNode(int x) : val(x), left(nullptr), mid(nullptr), right(nullptr) {} // 构造函数\n};\n\n// 树类\nclass Tree {\npublic:\n    // 插入方法：向树中插入值\n    TreeNode* insert(TreeNode* root, int val) {\n        if (root == nullptr) {\n            return new TreeNode(val); // 如果根节点为空，创建新节点作为根节点\n        }\n        if (val < root->val - 500) {\n            root->left = insert(root->left, val); // 如果值小于根节点值减500，插入到左子树\n        } else if (val > root->val + 500) {\n            root->right = insert(root->right, val); // 如果值大于根节点值加500，插入到右子树\n        } else {\n            root->mid = insert(root->mid, val); // 如果值在根节点值加减500范围内，插入到中间子树\n        }\n        return root; // 返回根节点\n    }\n\n    // 获取树的高度\n    int getHeight(TreeNode* root) {\n        if (root == nullptr) {\n            return 0; // 如果根节点为空，高度为0\n        }\n        int leftHeight = getHeight(root->left); // 计算左子树的高度\n        int midHeight = getHeight(root->mid); // 计算中间子树的高度\n        int rightHeight = getHeight(root->right); // 计算右子树的高度\n        return max({leftHeight, midHeight, rightHeight}) + 1; // 返回三者中最大的高度加1\n    }\n};\n\nint main() {\n    Tree tree; // 创建树对象\n    int N;\n    cin >> N; // 读取节点数量\n    TreeNode* root = nullptr; // 初始化根节点为null\n    for (int i = 0; i < N; ++i) {\n        int num;\n        cin >> num; // 循环读取节点值\n        root = tree.insert(root, num); // 将每个整数插入树中\n    }\n    int height = tree.getHeight(root); // 获取树的高度\n    cout << height << endl; // 输出树的高度\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 树节点结构体\ntypedef struct TreeNode {\n    int val; // 节点值\n    struct TreeNode *left, *mid, *right; // 左、中、右子节点指针\n} TreeNode;\n\n// 创建新节点\nTreeNode* createNode(int val) {\n    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode)); // 分配内存\n    node->val = val; // 设置节点值\n    node->left = node->mid = node->right = NULL; // 初始化子节点为NULL\n    return node; // 返回新创建的节点\n}\n\n// 向树中插入值\nTreeNode* insert(TreeNode* root, int val) {\n    if (root == NULL) {\n        return createNode(val); // 如果根节点为空，创建新节点作为根节点\n    }\n    if (val < root->val - 500) {\n        root->left = insert(root->left, val); // 如果值小于根节点值减500，插入到左子树\n    } else if (val > root->val + 500) {\n        root->right = insert(root->right, val); // 如果值大于根节点值加500，插入到右子树\n    } else {\n        root->mid = insert(root->mid, val); // 如果值在根节点值加减500范围内，插入到中间子树\n    }\n    return root; // 返回根节点\n}\n\n// 获取树的高度\nint getHeight(TreeNode* root) {\n    if (root == NULL) {\n        return 0; // 如果根节点为空，高度为0\n    }\n    int leftHeight = getHeight(root->left); // 计算左子树的高度\n    int midHeight = getHeight(root->mid); // 计算中间子树的高度\n    int rightHeight = getHeight(root->right); // 计算右子树的高度\n    int maxHeight = leftHeight > midHeight ? leftHeight : midHeight; // 计算左子树和中间子树的最大高度\n    maxHeight = maxHeight > rightHeight ? maxHeight : rightHeight; // 计算最大高度\n    return maxHeight + 1; // 返回最大高度加1\n}\n\nint main() {\n    int N, num;\n    scanf(\"%d\", &N); // 读取节点数量\n    TreeNode* root = NULL; // 初始化根节点为NULL\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d\", &num); // 循环读取节点值\n        root = insert(root, num); // 将每个整数插入树中\n    }\n    int height = getHeight(root); // 获取树的高度\n    printf(\"%d\\n\", height); // 输出树的高度\n    return 0;\n}"
  }
}