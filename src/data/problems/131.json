{
  "id": "131",
  "title": "树状结构查询",
  "examType": "A",
  "score": 200,
  "description": "通常使用多行的节点、父节点表示一棵树，比如\n西安 陕西 陕西 中国 江西 中国 中国 亚洲 泰国 亚洲\n输入一个节点之后，请打印出来树中他的所有下层节点",
  "inputDesc": "第一行输入行数，下面是多行数据，每行以空格区分节点和父节点\n接着是查询节点",
  "outputDesc": "输出查询节点的所有下层节点。以字典序排序",
  "examples": [
    {
      "input": "5\nb a\nc a\nd c\ne c\nf d\nc",
      "output": "d\ne\nf",
      "explanation": "树结构：a为根，b/c为a的子节点，d/e为c的子节点，f为d的子节点。查询c的下层节点有d/e/f"
    },
    {
      "input": "5\nb a\nc a\nd c\ne c\nf d\na",
      "output": "b\nc\nd\ne\nf",
      "explanation": "查询根节点a的所有下层节点，按字典序输出"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**树结构BFS/DFS遍历**问题。\n\n**核心思路：**\n- 构建父子节点映射关系\n- 从目标节点BFS/DFS遍历所有子孙节点\n- 结果按字典序排序输出\n\n**算法步骤：**\n1. 用HashMap存储每个节点的子节点集合\n2. 从目标节点开始BFS遍历\n3. 收集所有访问到的节点\n4. 按字典序排序后输出\n\n**时间复杂度**：O(NlogN)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt(); // 输入行数\n\n    HashMap<String, HashSet<String>> tree = new HashMap<>(); // 创建一个HashMap用于存储树的关系\n\n    // 读取输入的树的关系，并将子节点和父节点存入HashMap中\n    for (int i = 0; i < n; i++) {\n      String childNode = sc.next(); // 子节点\n      String parentNode = sc.next(); // 父节点\n\n      tree.computeIfAbsent(parentNode, k -> new HashSet<>()).add(childNode); // 将子节点添加到父节点的集合中\n    }\n\n    String targetNode = sc.next(); // 输入要查询的节点\n\n    if (!tree.containsKey(targetNode)) { // 如果树中不包含要查询的节点，则输出空行并结束程序\n      System.out.println(\"\");\n      return;\n    }\n\n    LinkedList<String> queue = new LinkedList<>(tree.get(targetNode)); // 创建一个队列，用于存储要遍历的节点\n\n    ArrayList<String> result = new ArrayList<>(); // 创建一个ArrayList，用于存储查询节点的所有下层节点\n\n    // 遍历队列，将节点添加到结果集中，并将该节点的子节点添加到队列中\n    while (!queue.isEmpty()) {\n      String node = queue.removeFirst(); // 从队列中取出节点\n      result.add(node); // 将节点添加到结果集中\n\n      if (tree.containsKey(node)) { // 如果节点在树中有子节点，则将子节点添加到队列中\n        queue.addAll(tree.get(node));\n      }\n    }\n\n    result.sort(String::compareTo); // 对结果集进行排序\n\n    result.forEach(System.out::println); // 打印结果集中的每个节点\n  }\n}",
    "python": "n = int(input())  # 输入行数\n\ntree = {}  # 创建一个字典用于存储树的关系\n\n# 读取输入的树的关系，并将子节点和父节点存入字典中\nfor _ in range(n):\n    childNode, parentNode = input().split()  # 子节点和父节点\n\n    if parentNode not in tree:\n        tree[parentNode] = set()  # 如果父节点不在字典中，则创建一个空集合\n\n    tree[parentNode].add(childNode)  # 将子节点添加到父节点的集合中\n\ntargetNode = input()  # 输入要查询的节点\n\nif targetNode not in tree:  # 如果字典中不包含要查询的节点，则输出空行并结束程序\n    print(\"\")\n    exit()\n\nqueue = list(tree[targetNode])  # 创建一个队列，用于存储要遍历的节点\n\nresult = []  # 创建一个列表，用于存储查询节点的所有下层节点\n\n# 遍历队列，将节点添加到结果集中，并将该节点的子节点添加到队列中\nwhile queue:\n    node = queue.pop(0)  # 从队列中取出节点\n    result.append(node)  # 将节点添加到结果集中\n\n    if node in tree:  # 如果节点在字典中有子节点，则将子节点添加到队列中\n        queue.extend(tree[node])\n\nresult.sort()  # 对结果集进行排序\n\nfor node in result:  # 打印结果集中的每个节点\n    print(node)",
    "javascript": "const readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = []; // 存储输入的所有行数据\nlet n; // 树的行数\n\nrl.on(\"line\", (line) => { // 监听每一行的输入\n  lines.push(line); // 将输入的行添加到lines数组中\n\n  if (lines.length == 1) { // 如果lines数组中只有一行数据，表示树的行数\n    n = parseInt(lines[0]); // 将树的行数转换为整数并赋值给n\n  }\n\n  if (n && lines.length === n + 2) { // 当树的行数和输入的行数匹配时，进行处理\n    lines.shift(); // 移除第一行树的行数\n    const target = lines.pop(); // 弹出最后一行作为查询的节点\n\n    const tree = {}; // 存储树的结构，使用对象表示，key为父节点，value为子节点的集合\n    for (let str of lines) { // 遍历除了树的行数和查询节点之外的行\n      const [node, parent] = str.split(\" \"); // 将每一行以空格分割成节点和父节点\n      if (!tree[parent]) tree[parent] = new Set(); // 如果父节点不存在于树结构中，则创建一个新的集合\n      tree[parent].add(node); // 将节点添加到父节点的集合中\n    }\n\n    if (!tree[target]) return console.log(\"\"); // 如果查询的节点不存在于树结构中，直接输出空字符串\n\n    const queue = [...tree[target]]; // 将查询的节点的子节点集合放入队列中\n\n    const result = []; // 存储查询节点的所有下层节点\n    while (queue.length > 0) { // 当队列不为空时，进行循环\n      const node = queue.shift(); // 弹出队列中的第一个节点\n      result.push(node); // 将节点添加到结果数组中\n\n      if (tree[node]) { // 如果节点存在子节点\n        queue.push(...tree[node]); // 将子节点添加到队列中\n      }\n    }\n\n    result.sort().forEach((v) => console.log(v)); // 对结果数组进行字典序排序，并逐行输出\n\n   }\n});",
    "cpp": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n  int n;\n  cin >> n; // 输入行数\n\n  unordered_map<string, unordered_set<string>> tree; // 创建一个unordered_map用于存储树的关系\n\n  // 读取输入的树的关系，并将子节点和父节点存入unordered_map中\n  for (int i = 0; i < n; i++) {\n    string childNode, parentNode;\n    cin >> childNode >> parentNode; // 子节点和父节点\n\n    tree[parentNode].insert(childNode); // 将子节点添加到父节点的集合中\n  }\n\n  string targetNode;\n  cin >> targetNode; // 输入要查询的节点\n\n  if (tree.find(targetNode) == tree.end()) { // 如果树中不包含要查询的节点，则输出空行并结束程序\n    cout << endl;\n    return 0;\n  }\n\n  queue<string> q;\n  for (const string& node : tree[targetNode]) {\n    q.push(node); // 将要遍历的节点添加到队列中\n  }\n\n  vector<string> result; // 创建一个vector，用于存储查询节点的所有下层节点\n\n  // 遍历队列，将节点添加到结果集中，并将该节点的子节点添加到队列中\n  while (!q.empty()) {\n    string node = q.front(); // 从队列中取出节点\n    q.pop();\n\n    result.push_back(node); // 将节点添加到结果集中\n\n    if (tree.find(node) != tree.end()) { // 如果节点在树中有子节点，则将子节点添加到队列中\n      for (const string& child : tree[node]) {\n        q.push(child);\n      }\n    }\n  }\n\n  sort(result.begin(), result.end()); // 对结果集进行排序\n\n  for (const string& node : result) {\n    cout << node << endl; // 打印结果集中的每个节点\n  }\n\n  return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_NODES 100\n#define MAX_NAME_LEN 100\n\n// 定义一个结构体来表示树的关系，每个父节点及其子节点\nstruct Tree {\n    char parent[MAX_NAME_LEN];  // 父节点名称\n    char child[MAX_NAME_LEN];   // 子节点名称\n};\n\n// 定义一个二维数组来存储每个节点的子节点\nchar children[MAX_NODES][MAX_NAME_LEN][MAX_NAME_LEN]; // 每个节点的子节点\nint children_count[MAX_NODES];  // 记录每个节点有多少个子节点\n\n// 存储所有节点的名称，避免查找时每次都从输入的字符中查找\nchar nodes[MAX_NODES][MAX_NAME_LEN]; \nint node_count = 0;  // 节点总数\n\n// 存储查询结果的数组\nchar result[MAX_NODES][MAX_NAME_LEN];\nint result_count = 0;  // 记录结果集中节点的个数\n\n// 查找节点名称是否存在，如果存在返回索引，不存在则添加新节点并返回新索引\nint find_or_add_node(char *name) {\n    for (int i = 0; i < node_count; i++) {\n        if (strcmp(nodes[i], name) == 0) {\n            return i;  // 如果找到了，返回该节点的索引\n        }\n    }\n    strcpy(nodes[node_count], name);  // 如果没有找到，添加新节点\n    return node_count++;  // 返回新节点的索引，并增加节点总数\n}\n\n// 使用深度优先搜索（DFS）遍历树，收集目标节点的所有子节点\nvoid dfs(int index) {\n    for (int i = 0; i < children_count[index]; i++) {\n        int child_index = find_or_add_node(children[index][i]);\n        // 将子节点添加到结果集中\n        strcpy(result[result_count++], nodes[child_index]);\n        // 递归遍历子节点的子节点\n        dfs(child_index);\n    }\n}\n\n// 比较函数，用于qsort的字典序排序\nint compare(const void *a, const void *b) {\n    return strcmp((char *)a, (char *)b);\n}\n\n// 主函数\nint main() {\n    int n;  // 输入的行数\n    scanf(\"%d\", &n);  // 读取行数\n\n    struct Tree tree[MAX_NODES];  // 存储树的父子节点关系\n\n    // 读取输入的节点关系\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s %s\", tree[i].child, tree[i].parent);  // 读取子节点和父节点\n    }\n\n    // 建立节点关系\n    for (int i = 0; i < n; i++) {\n        // 获取父节点和子节点的索引\n        int parent_index = find_or_add_node(tree[i].parent);\n        int child_index = find_or_add_node(tree[i].child);\n        // 将子节点加入父节点的子节点列表\n        strcpy(children[parent_index][children_count[parent_index]++], tree[i].child);\n    }\n\n    char target_node[MAX_NAME_LEN];  // 目标节点\n    scanf(\"%s\", target_node);  // 读取查询的目标节点\n\n    int target_index = find_or_add_node(target_node);  // 找到目标节点的索引\n\n    // 使用DFS收集所有下层节点\n    dfs(target_index);\n\n    // 对结果集中收集的节点进行字典序排序\n    qsort(result, result_count, MAX_NAME_LEN, compare);\n\n    // 输出排序后的所有下层节点\n    for (int i = 0; i < result_count; i++) {\n        printf(\"%s\\n\", result[i]);\n    }\n\n    return 0;\n}"
  }
}