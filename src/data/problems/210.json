{
  "id": "210",
  "title": "天然蓄水库",
  "examType": "B",
  "score": 200,
  "description": "公元2919年，人类终于发现了一颗宜居星球——X星。 现想在X星一片连绵起伏的山脉间建一个天热蓄水库，如何选取水库边界，使蓄水量最大？\n要求：\n山脉用正整数数组s表示，每个元素代表山脉的高度。选取山脉上两个点作为蓄水库的边界，则边界内的区域可以蓄水，蓄水量需排除山脉占用的空间蓄水量的高度为两边界的最小值。如果出现多个满足条件的边界，应选取距离最近的一组边界。\n输出边界下标（从0开始）和最大蓄水量；如果无法蓄水，则返回0，此时不返回边界。 例如，当山脉为s=[3,1,2]时，则选取s[0]和s[2]作为水库边界，则蓄水量为1，此时输出：0 2:1 当山脉s=[3,2,1]时，不存在合理的边界，此时输出：0。\n",
  "inputDesc": "一行正整数，用空格隔开，例如输入\n1 2 3\n表示s=[1,2,3]\n",
  "outputDesc": "当存在合理的水库边界时，输出左边界、空格、右边界、英文冒号、蓄水量；例如\n0 2:1\n当不存在合理的书库边界时，输出0；例如\n0\n\n\n\n用例1图示如下：\n\n选择山峰1和山峰6作为边界，则可获得最大蓄水量19\n\n\n用例2图示如下\n\n\n选择山峰1和山峰6作为边界，则可获得最大蓄水量15\n\n其实用例2还可以选择山峰1和山峰8作为边界，也可以获得最大蓄水量15，如下图所示\n\n但是此时两边界山峰的距离是6，相较于选择山峰1，6作为边界时距离4而言，更远。\n按照题目要求，我们需要找到：蓄水量最大的，且距离最近的两个边界山峰。\n\n我一开始的解题思路是双指针，类似于下面这题\n华为OD机试 - 太阳能板最大面积（Java & JS & Python）_伏城之外的博客-CSDN博客\n\n但是经过如下几个用例测试，发现本题无法像上面链接题目一样找到一个O(n)的解法，双边指针无法找到一个固定的策略进行运动。\n\n\n\n因此，我开始寻找其他的思路，直到发现了LeetCode - 42 接雨水_伏城之外的博客-CSDN博客\n\n其实，我们不应该从横向来思考本题，可以从纵向来思考本题。什么意思呢？\n我们按照接雨水那个思路，把用例1中所有能接水的山峰全部接满，即如下图所示\n\n此时从纵向来看只有有两条水位线，如下图所示\n\n\n\n从上图可以看出，每条水位线都有都可能与多个山峰相交，但是我们只需要关注：\n如下图所示：\n\n上图中，L山峰和R山峰是可以达到该水位线要求的最外层的两端山峰，此时这两座山峰之间的每个山峰的储水量就是该水位线最大的储水量。\n而此时边界山峰为L-1，和R+1。\n",
  "examples": [
    {
      "input": "1 8 4 3 6 5 3 7",
      "output": "0 7:19",
      "explanation": "选取山峰0和山峰7作为边界，最大蓄水量19"
    },
    {
      "input": "3 1 2",
      "output": "0 2:1",
      "explanation": "选取s[0]和s[2]作为边界，蓄水量为1"
    },
    {
      "input": "3 2 1",
      "output": "0",
      "explanation": "递减序列无法蓄水"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**接雨水变种**问题（类似LeetCode 42）。\n\n**核心思路：**\n- 从纵向水位线角度思考\n- 计算每个水位线对应的最大蓄水量\n\n**算法步骤：**\n1. 预处理每个位置左右两侧最高山峰\n2. 计算每个位置的水位线高度\n3. 遍历每条水位线，找最外层边界\n4. 计算蓄水量，取最大且距离最短\n\n**时间复杂度**：O(N²)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    Integer[] h =\n        Arrays.stream(sc.nextLine().split(\" \")).map(Integer::parseInt).toArray(Integer[]::new);\n\n    System.out.println(getResult(h));\n  }\n\n  public static String getResult(Integer[] h) {\n    int n = h.length;\n\n    // left[i] 记录 第 i 个山峰左边的最高山峰\n    int[] left = new int[n];\n    for (int i = 1; i < n; i++) left[i] = Math.max(left[i - 1], h[i - 1]);\n\n    // right[i] 记录 第 i 个山峰右边的最高山峰\n    int[] right = new int[n];\n    for (int i = n - 2; i >= 0; i--) right[i] = Math.max(right[i + 1], h[i + 1]);\n\n    // lines[i] 记录 第 i 个山峰的水位线高度\n    int[] lines = new int[n];\n    // lineSet记录有哪些水位线\n    HashSet<Integer> lineSet = new HashSet<>();\n    for (int i = 1; i < n - 1; i++) {\n      int water = Math.max(0, Math.min(left[i], right[i]) - h[i]); // water 记录 第 i 个山峰可以储存多少水\n\n      if (water != 0) {\n        // 第 i 个山峰的水位线高度\n        lines[i] = water + h[i];\n        lineSet.add(lines[i]);\n      }\n    }\n\n    // ans数组含义：[左边界， 右边界， 储水量]\n    int[] ans = {0, 0, 0};\n\n    // 遍历每一个水位线\n    for (int line : lineSet) {\n\n      // 满足该水位线的最左侧山峰位置l\n      int l = 0;\n      while (lines[l] < line || h[l] >= line) {\n        l++;\n      }\n\n      // 满足该水位线的最右侧山峰位置r\n      int r = n - 1;\n      while (lines[r] < line || h[r] >= line) {\n        r--;\n      }\n\n      // 该水位线的总储水量\n      int sum = 0;\n      for (int i = l; i <= r; i++) {\n        sum += Math.max(0, line - h[i]);\n      }\n\n      // 记录最大的储水量\n      if (sum > ans[2]) {\n        ans[0] = l - 1;\n        ans[1] = r + 1;\n        ans[2] = sum;\n      }\n      // 如果有多个最多储水量选择，则选择边界山峰距离最短的\n      else if (sum == ans[2]) {\n        int curDis = r - l + 1;\n        int minDis = ans[1] - ans[0] - 1;\n\n        if (curDis < minDis) {\n          ans[0] = l - 1;\n          ans[1] = r + 1;\n        }\n      }\n    }\n\n    if (ans[2] == 0) return \"0\";\n\n    return ans[0] + \" \" + ans[1] + \":\" + ans[2];\n  }\n}",
    "python": "# 输入获取\nh = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult(h):\n    n = len(h)\n\n    # left[i] 记录 第 i 个山峰左边的最高山峰\n    left = [0] * n\n    for i in range(1, n):\n        left[i] = max(left[i - 1], h[i - 1])\n\n    # right[i] 记录 第 i 个山峰右边的最高山峰\n    right = [0] * n\n    for i in range(n - 2, -1, -1):\n        right[i] = max(right[i + 1], h[i + 1])\n\n    # lines[i] 记录 第 i 个山峰的水位线高度\n    lines = [0] * n\n    # lineSet记录有哪些水位线\n    lineSet = set()\n    for i in range(1, n - 1):\n        # water 记录 第 i 个山峰可以储存多少水\n        water = max(0, min(left[i], right[i]) - h[i])\n\n        # 如果第 i 个山峰可以储存水，则必然有一个水位线，记录到lines中\n        if water != 0:\n            # 第 i 个山峰的水位线高度\n            lines[i] = water + h[i]\n            lineSet.add(lines[i])\n\n    # ans数组含义：[左边界， 右边界， 储水量]\n    ans = [0, 0, 0]\n\n    # 遍历每一个水位线\n    for line in lineSet:\n        # 满足该水位线的最左侧山峰位置l\n        l = 0\n        while lines[l] < line or h[l] >= line:\n            l += 1\n\n        # 满足该水位线的最右侧山峰位置r\n        r = n - 1\n        while lines[r] < line or h[r] >= line:\n            r -= 1\n\n        # 该水位线的总储水量\n        total = 0\n        for i in range(l, r + 1):\n            total += max(0, line - h[i])\n\n        # 记录最大的储水量\n        if total > ans[2]:\n            ans[0] = l - 1\n            ans[1] = r + 1\n            ans[2] = total\n        # 如果有多个最多储水量选择，则选择边界山峰距离最短的\n        elif total == ans[2]:\n            curDis = r - l + 1\n            minDis = ans[1] - ans[0] - 1\n\n            if curDis < minDis:\n                ans[0] = l - 1\n                ans[1] = r + 1\n\n    if ans[2] == 0:\n        return \"0\"\n\n    return str(ans[0]) + \" \" + str(ans[1]) + \":\" + str(ans[2])\n\n\n# 算法调用\nprint(getResult(h))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const h = line.split(\" \").map(Number);\n\n  console.log(getResult(h));\n});\n\nfunction getResult(h) {\n  const n = h.length;\n\n  // left[i] 记录 第 i 个山峰左边的最高山峰\n  const left = new Array(n).fill(0);\n  for (let i = 1; i < n; i++) {\n    left[i] = Math.max(left[i - 1], h[i - 1]);\n  }\n\n  // right[i] 记录 第 i 个山峰右边的最高山峰\n  const right = new Array(n).fill(0);\n  for (let i = n - 2; i >= 0; i--) {\n    right[i] = Math.max(right[i + 1], h[i + 1]);\n  }\n\n  // lines[i] 记录 第 i 个山峰的水位线高度\n  const lines = new Array(n).fill(0);\n  // lineSet记录有哪些水位线\n  const lineSet = new Set();\n  for (let i = 1; i < n - 1; i++) {\n    const water = Math.max(0, Math.min(left[i], right[i]) - h[i]); // water 记录 第 i 个山峰可以储存多少水\n\n    if (water != 0) {\n      // 第 i 个山峰的水位线高度\n      lines[i] = water + h[i];\n      lineSet.add(lines[i]);\n    }\n  }\n\n  // ans数组含义：[左边界， 右边界， 储水量]\n  let ans = [0, 0, 0];\n\n  // 遍历每一个水位线\n  for (let line of lineSet) {\n    // 满足该水位线的最左侧山峰位置l\n    let l = 0;\n    while (lines[l] < line || h[l] >= line) {\n      l++;\n    }\n\n    // 满足该水位线的最右侧山峰位置r\n    let r = n - 1;\n    while (lines[r] < line || h[r] >= line) {\n      r--;\n    }\n\n    // 该水位线的总储水量\n    let sum = 0;\n    for (let i = l; i <= r; i++) {\n      sum += Math.max(0, line - h[i]);\n    }\n\n    // 记录最大的储水量\n    if (sum > ans[2]) {\n      ans[0] = l - 1;\n      ans[1] = r + 1;\n      ans[2] = sum;\n    }\n    // 如果有多个最多储水量选择，则选择边界山峰距离最短的\n    else if (sum == ans[2]) {\n      const curDis = r - l + 1;\n      const minDis = ans[1] - ans[0] - 1;\n\n      if (curDis < minDis) {\n        ans[0] = l - 1;\n        ans[1] = r + 1;\n      }\n    }\n  }\n\n  if (ans[2] == 0) return \"0\";\n\n  return ans[0] + \" \" + ans[1] + \":\" + ans[2];\n}",
    "cpp": "",
    "c": ""
  }
}