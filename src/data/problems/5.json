{
  "id": "5",
  "title": "不等式是否满足约束并输出最大差",
  "examType": "A",
  "score": 100,
  "description": "给定一组不等式，判断是否成立并输出不等式的最大差（输出浮点数的整数部分）。\n\n**要求：**\n1. 不等式系数为 double 类型，是一个二维数组\n2. 不等式的变量为 int 类型，是一维数组\n3. 不等式的目标值为 double 类型，是一维数组\n4. 不等式约束为字符串数组，只能是：`>`, `>=`, `<`, `<=`, `=`\n\n**例如，不等式组：**\n```\na11*x1 + a12*x2 + a13*x3 + a14*x4 + a15*x5 <= b1\na21*x1 + a22*x2 + a23*x3 + a24*x4 + a25*x5 <= b2\na31*x1 + a32*x2 + a33*x3 + a34*x4 + a35*x5 <= b3\n```\n\n**最大差** = max{|左式1-b1|, |左式2-b2|, |左式3-b3|}，输出整数部分",
  "inputDesc": "一行字符串，用分号分隔各部分：\n- 第1-3部分：不等式系数（每行用逗号分隔）\n- 第4部分：变量值（用逗号分隔）\n- 第5部分：目标值（用逗号分隔）\n- 第6部分：约束关系（用逗号分隔）",
  "outputDesc": "`true` 或 `false` 表示所有不等式是否都满足约束，后跟空格和最大差的整数部分",
  "examples": [
    {
      "input": "2.3,3,5.6,7.6;11,3,8.6,25,1;0.3,9,5.3,66,7.8;1,3,2,7,5;340,670,80.6;<=,<=,<=",
      "output": "false 458",
      "explanation": "三个不等式：\n- 2.3×1+3×3+5.6×2+7.6×7=2.3+9+11.2+53.2=75.7（缺少x5项，假设系数数组第一行只有4个元素）\n实际计算：每行系数与变量做点积后减去目标值，判断是否满足约束。最大差的绝对值取整为458。"
    },
    {
      "input": "2.36,3,6,7.1,6;1,30,8.6,2.5,21;0.3,69,5.3,6.6,7.8;1,13,2,17,5;340,67,300.6;<=,>=,<=",
      "output": "false 758",
      "explanation": "计算三个不等式的左式与目标值的差，判断约束是否满足。第二个不等式约束为>=，需要左式>=目标值。最大差的绝对值取整为758。"
    }
  ],
  "solution": "**解题思路：**\n\n1. **解析输入**：将输入按分号分割，分别解析出系数矩阵、变量数组、目标值数组和约束数组\n\n2. **计算差值**：对每个不等式，计算左式（系数与变量的点积）与目标值的差\n   - `diff[i] = sum(coefficients[i] * variables) - target[i]`\n\n3. **判断约束**：\n   - `<=`：差值应 <= 0\n   - `<`：差值应 < 0\n   - `>=`：差值应 >= 0\n   - `>`：差值应 > 0\n   - `=`：差值应 == 0\n\n4. **计算最大差**：取所有差值绝对值的最大值，输出其整数部分\n\n5. **输出结果**：所有约束都满足则输出 `true`，否则输出 `false`，后跟最大差",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        String[] parts = line.split(\";\");\n        \n        // 解析系数矩阵（前3部分）\n        double[][] matrix = new double[3][];\n        for (int i = 0; i < 3; i++) {\n            String[] nums = parts[i].split(\",\");\n            matrix[i] = new double[nums.length];\n            for (int j = 0; j < nums.length; j++) {\n                matrix[i][j] = Double.parseDouble(nums[j]);\n            }\n        }\n        \n        // 解析变量\n        String[] xStrs = parts[3].split(\",\");\n        double[] x = new double[xStrs.length];\n        for (int i = 0; i < xStrs.length; i++) {\n            x[i] = Double.parseDouble(xStrs[i]);\n        }\n        \n        // 解析目标值\n        String[] bStrs = parts[4].split(\",\");\n        double[] b = new double[bStrs.length];\n        for (int i = 0; i < bStrs.length; i++) {\n            b[i] = Double.parseDouble(bStrs[i]);\n        }\n        \n        // 解析约束\n        String[] constraints = parts[5].split(\",\");\n        \n        // 计算差值并判断约束\n        double maxDiff = 0;\n        boolean allSatisfied = true;\n        \n        for (int i = 0; i < 3; i++) {\n            double sum = 0;\n            for (int j = 0; j < matrix[i].length && j < x.length; j++) {\n                sum += matrix[i][j] * x[j];\n            }\n            double diff = sum - b[i];\n            maxDiff = Math.max(maxDiff, Math.abs(diff));\n            \n            if (!satisfies(diff, constraints[i])) {\n                allSatisfied = false;\n            }\n        }\n        \n        System.out.println((allSatisfied ? \"true\" : \"false\") + \" \" + (int) maxDiff);\n    }\n    \n    static boolean satisfies(double diff, String constraint) {\n        switch (constraint) {\n            case \"<=\": return diff <= 0;\n            case \"<\": return diff < 0;\n            case \">=\": return diff >= 0;\n            case \">\": return diff > 0;\n            case \"=\": return diff == 0;\n            default: return false;\n        }\n    }\n}",
    "python": "def satisfies(diff, constraint):\n    if constraint == '<=':\n        return diff <= 0\n    elif constraint == '<':\n        return diff < 0\n    elif constraint == '>=':\n        return diff >= 0\n    elif constraint == '>':\n        return diff > 0\n    elif constraint == '=':\n        return diff == 0\n    return False\n\nline = input().strip()\nparts = line.split(';')\n\n# 解析系数矩阵\nmatrix = []\nfor i in range(3):\n    row = [float(x) for x in parts[i].split(',')]\n    matrix.append(row)\n\n# 解析变量、目标值、约束\nx = [float(v) for v in parts[3].split(',')]\nb = [float(v) for v in parts[4].split(',')]\nconstraints = parts[5].split(',')\n\n# 计算差值并判断\nmax_diff = 0\nall_satisfied = True\n\nfor i in range(3):\n    total = sum(matrix[i][j] * x[j] for j in range(min(len(matrix[i]), len(x))))\n    diff = total - b[i]\n    max_diff = max(max_diff, abs(diff))\n    \n    if not satisfies(diff, constraints[i]):\n        all_satisfied = False\n\nprint(f\"{str(all_satisfied).lower()} {int(max_diff)}\")",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nfunction satisfies(diff, constraint) {\n  switch (constraint) {\n    case '<=': return diff <= 0;\n    case '<': return diff < 0;\n    case '>=': return diff >= 0;\n    case '>': return diff > 0;\n    case '=': return diff === 0;\n    default: return false;\n  }\n}\n\nrl.on('line', (line) => {\n  const parts = line.split(';');\n  \n  // 解析系数矩阵\n  const matrix = [];\n  for (let i = 0; i < 3; i++) {\n    matrix.push(parts[i].split(',').map(parseFloat));\n  }\n  \n  // 解析变量、目标值、约束\n  const x = parts[3].split(',').map(parseFloat);\n  const b = parts[4].split(',').map(parseFloat);\n  const constraints = parts[5].split(',');\n  \n  // 计算差值并判断\n  let maxDiff = 0;\n  let allSatisfied = true;\n  \n  for (let i = 0; i < 3; i++) {\n    let sum = 0;\n    for (let j = 0; j < matrix[i].length && j < x.length; j++) {\n      sum += matrix[i][j] * x[j];\n    }\n    const diff = sum - b[i];\n    maxDiff = Math.max(maxDiff, Math.abs(diff));\n    \n    if (!satisfies(diff, constraints[i])) {\n      allSatisfied = false;\n    }\n  }\n  \n  console.log(`${allSatisfied} ${Math.floor(maxDiff)}`);\n  rl.close();\n});",
    "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nbool satisfies(double diff, const string& constraint) {\n    if (constraint == \"<=\") return diff <= 0;\n    if (constraint == \"<\") return diff < 0;\n    if (constraint == \">=\") return diff >= 0;\n    if (constraint == \">\") return diff > 0;\n    if (constraint == \"=\") return diff == 0;\n    return false;\n}\n\nvector<double> parseDoubles(const string& s) {\n    vector<double> result;\n    stringstream ss(s);\n    string item;\n    while (getline(ss, item, ',')) {\n        result.push_back(stod(item));\n    }\n    return result;\n}\n\nvector<string> parseStrings(const string& s) {\n    vector<string> result;\n    stringstream ss(s);\n    string item;\n    while (getline(ss, item, ',')) {\n        result.push_back(item);\n    }\n    return result;\n}\n\nint main() {\n    string line;\n    getline(cin, line);\n    \n    vector<string> parts;\n    stringstream ss(line);\n    string part;\n    while (getline(ss, part, ';')) {\n        parts.push_back(part);\n    }\n    \n    vector<vector<double>> matrix(3);\n    for (int i = 0; i < 3; i++) {\n        matrix[i] = parseDoubles(parts[i]);\n    }\n    \n    vector<double> x = parseDoubles(parts[3]);\n    vector<double> b = parseDoubles(parts[4]);\n    vector<string> constraints = parseStrings(parts[5]);\n    \n    double maxDiff = 0;\n    bool allSatisfied = true;\n    \n    for (int i = 0; i < 3; i++) {\n        double sum = 0;\n        for (size_t j = 0; j < matrix[i].size() && j < x.size(); j++) {\n            sum += matrix[i][j] * x[j];\n        }\n        double diff = sum - b[i];\n        maxDiff = max(maxDiff, fabs(diff));\n        \n        if (!satisfies(diff, constraints[i])) {\n            allSatisfied = false;\n        }\n    }\n    \n    cout << (allSatisfied ? \"true\" : \"false\") << \" \" << (int)maxDiff << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\nint satisfies(double diff, const char* constraint) {\n    if (strcmp(constraint, \"<=\") == 0) return diff <= 0;\n    if (strcmp(constraint, \"<\") == 0) return diff < 0;\n    if (strcmp(constraint, \">=\") == 0) return diff >= 0;\n    if (strcmp(constraint, \">\") == 0) return diff > 0;\n    if (strcmp(constraint, \"=\") == 0) return diff == 0;\n    return 0;\n}\n\nint main() {\n    char line[10000];\n    fgets(line, sizeof(line), stdin);\n    line[strcspn(line, \"\\n\")] = 0;\n    \n    double matrix[3][10];\n    int matrixCols[3] = {0};\n    double x[10], b[3];\n    char constraints[3][10];\n    int xLen = 0;\n    \n    char* parts[6];\n    char* token = strtok(line, \";\");\n    for (int i = 0; i < 6 && token; i++) {\n        parts[i] = token;\n        token = strtok(NULL, \";\");\n    }\n    \n    // 解析系数矩阵\n    for (int i = 0; i < 3; i++) {\n        char temp[1000];\n        strcpy(temp, parts[i]);\n        char* num = strtok(temp, \",\");\n        int j = 0;\n        while (num) {\n            matrix[i][j++] = atof(num);\n            num = strtok(NULL, \",\");\n        }\n        matrixCols[i] = j;\n    }\n    \n    // 解析变量\n    char temp[1000];\n    strcpy(temp, parts[3]);\n    char* num = strtok(temp, \",\");\n    while (num) {\n        x[xLen++] = atof(num);\n        num = strtok(NULL, \",\");\n    }\n    \n    // 解析目标值\n    strcpy(temp, parts[4]);\n    num = strtok(temp, \",\");\n    for (int i = 0; num; i++) {\n        b[i] = atof(num);\n        num = strtok(NULL, \",\");\n    }\n    \n    // 解析约束\n    strcpy(temp, parts[5]);\n    num = strtok(temp, \",\");\n    for (int i = 0; num; i++) {\n        strcpy(constraints[i], num);\n        num = strtok(NULL, \",\");\n    }\n    \n    double maxDiff = 0;\n    int allSatisfied = 1;\n    \n    for (int i = 0; i < 3; i++) {\n        double sum = 0;\n        int len = matrixCols[i] < xLen ? matrixCols[i] : xLen;\n        for (int j = 0; j < len; j++) {\n            sum += matrix[i][j] * x[j];\n        }\n        double diff = sum - b[i];\n        if (fabs(diff) > maxDiff) maxDiff = fabs(diff);\n        \n        if (!satisfies(diff, constraints[i])) {\n            allSatisfied = 0;\n        }\n    }\n    \n    printf(\"%s %d\\n\", allSatisfied ? \"true\" : \"false\", (int)maxDiff);\n    return 0;\n}"
  }
}
