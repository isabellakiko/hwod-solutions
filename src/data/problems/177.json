{
  "id": "177",
  "title": "组装最大可靠性设备",
  "examType": "",
  "score": 200,
  "description": "一个设备由N种类型元器件组成(每种类型元器件只需要一个，类型type编号从0~N-1)，\n每个元器件均有可靠性属性reliability，可靠性越高的器件其价格price越贵。\n而设备的可靠性由组成设备的所有器件中可靠性最低的器件决定。\n给定预算S，购买N种元器件( 每种类型元器件都需要购买一个)，在不超过预算的情况下，请给出能够组成的设备的最大可靠性。\n",
  "inputDesc": "S N // S总的预算，N元器件的种类\ntotal // 元器件的总数，每种型号的元器件可以有多种;\n此后有total行具体器件的数据\ntype reliability price // type 整数类型，代表元器件的类型编号从0 ~ N-1; reliabilty 整数类型 ，代表元器件的可靠性; price 整数类型 ，代表元器件的价格\n",
  "outputDesc": "符合预算的设备的最大可靠性，如果预算无法买齐N种器件，则返回 -1\n\n\n预算500，设备需要3种元件组成，方案\n类型0的第一个(可靠性80),\n类型1的第二个(可靠性70),\n类型2的第二个(可靠性60),\n可以使设备的可靠性最大 60\n本题很像是分组背包问题，但是细看却不是，因为题目描述中说：\n每种类型元器件都需要购买一个\n\n我的解题思路是二分。\n首先，不分种类，收集所有器件出现过的可靠性到一个Set集合中，收集完后，进行升序排序，升序后可靠性数组设为maybe，即maybe数组里面的可靠性都有可能是题解。\n之后，将所有器件按类型统计，由于题目输入已经给出了种类数n，因此可以定义一个长度为n的数组kinds，即为种类数组，kinds[type]下记录对应类型的所有器件。统计完后，我们需要遍历每一个kinds[type]，然后将它按照器件的可靠性进行升序。\n预备处理如上。\n\n接下来我们需要在maybe中二分取中间值maybe[mid]，作为一个可能的题解，即设备最大可靠性。然后遍历kinds，在每一个种类的器件中，找到一个可靠性>=maybe[mid]，且最接近maybe[mid]的器件，这里需要想清楚两点：\n由于之前，已经对kinds[type]进行了升序，因此这里可以二分查找：可靠性>=maybe[mid]，且最接近maybe[mid]的器件\n这里又涉及到二分查找的目标位置和有序插入位置的知识，具体可以看：\n算法设计 - 二分法和三分法，洛谷P3382_伏城之外的博客-CSDN博客\n\n当找到所有kinds[type]中可靠性>=maybe[mid]，且最接近maybe[mid]的器件后，对这些器件的price进行求和，得到sumPrice：\n按此二分逻辑，将最后一次符合要求的maybe[mid]可能解返回即可，如果没有符合要求的maybe[mid]，则返回-1。\n",
  "examples": [
    {
      "input": "500 3\n6\n0 80 100\n0 90 200\n1 50 100\n1 70 200\n2 50 100\n2 60 200",
      "output": "60",
      "explanation": "预算500，选择类型0可靠性80价格100、类型1可靠性70价格200、类型2可靠性60价格200，总价500，最小可靠性60"
    },
    {
      "input": "100 2\n3\n0 90 200\n1 80 100\n1 70 50",
      "output": "-1",
      "explanation": "预算100无法同时购买类型0和类型1的元器件"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二分答案**问题。\n\n**核心思路：**\n- 二分可靠性值，检验是否能在预算内购齐所有类型\n- 每种类型选可靠性>=目标值且价格最低的器件\n\n**算法步骤：**\n1. 收集所有可靠性值，按类型分组\n2. 对各类型内器件按可靠性排序\n3. 二分搜索可能的最大可靠性\n4. 对于每个候选值，检验能否在预算内选齐\n\n**时间复杂度**：O(N*logN*logR)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n  // 器件类\n  static class Device {\n    int reliability;\n    int price;\n\n    public Device(int reliability, int price) {\n      this.reliability = reliability;\n      this.price = price;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int s = sc.nextInt(); // 总预算\n    int n = sc.nextInt(); // 器件的种类数\n\n    // 收集器件的可靠性\n    TreeSet<Integer> reliabilities = new TreeSet<>();\n\n    // 各种类集合\n    ArrayList<ArrayList<Device>> kinds = new ArrayList<>();\n    // 为每个具体种类创建一个集合，用于装对应种类的器件\n    for (int i = 0; i < n; i++) kinds.add(new ArrayList<>());\n\n    int total = sc.nextInt(); // 之后输入total行具体器件的数据\n\n    for (int i = 0; i < total; i++) {\n      // 器件种类\n      int type = sc.nextInt();\n\n      // 器件可靠性\n      int reliability = sc.nextInt();\n      reliabilities.add(reliability); // 收集器件的可靠性\n\n      // 器件价值\n      int price = sc.nextInt();\n\n      // 将器件加入到对应的种类中\n      kinds.get(type).add(new Device(reliability, price));\n    }\n\n    System.out.println(getResult(s, kinds, reliabilities));\n  }\n\n  /**\n   * @param s 总预算\n   * @param kinds 种类集合\n   * @param reliabilities 可靠性集合\n   * @return 最大可靠性\n   */\n  public static int getResult(\n      int s, ArrayList<ArrayList<Device>> kinds, TreeSet<Integer> reliabilities) {\n\n    // ans记录题解\n    int ans = -1;\n\n    // 将每个种类内的器件按照可靠性升序\n    for (ArrayList<Device> kind : kinds) {\n      kind.sort((a, b) -> a.reliability - b.reliability);\n    }\n\n    // 将所有器件的可靠性集合，变为数组\n    Integer[] maybe = reliabilities.toArray(new Integer[0]);\n\n    // 二分选取可能的最大可靠性maybe\n    int low = 0;\n    int high = maybe.length - 1;\n\n    while (low <= high) {\n      int mid = (low + high) >> 1;\n      // 如果maybe[mid]可靠性可以保证所有种类器件都能选到，且价格之和小于s\n      if (check(kinds, maybe[mid], s)) {\n        // 则maybe[mid]可靠性就是一个可能解\n        ans = maybe[mid];\n        // 继续尝试更优解，即找更大的可靠性\n        low = mid + 1;\n      } else {\n        // 否则，说明可靠性选高了，我们应该继续尝试更低的可靠性\n        high = mid - 1;\n      }\n    }\n\n    return ans;\n  }\n\n  public static boolean check(ArrayList<ArrayList<Device>> kinds, int maxReliability, int s) {\n    int sum = 0;\n    for (ArrayList<Device> kind : kinds) {\n      // 注意kind内的器件已经按照可靠性升序了\n      // 我们需要在该kind种类内找到一个可靠性>=maxReliability的器件\n      int idx = binarySearch(kind, maxReliability);\n\n      // 如果idx<0，则说明idx是一个插入位置\n      if (idx < 0) {\n        idx = -idx - 1;\n      }\n\n      // 如果idx==kind.size()则说明kind内所有器件的可靠性都低于maxReliability，因此此kind器件选取不到，可以直接返回false\n      if (idx == kind.size()) return false;\n\n      // 否则，选取对应idx位置的器件，并计入价格到总价\n      sum += kind.get(idx).price;\n    }\n\n    // 如果最终总价小于总预算s，则此maxReliability可行\n    return sum <= s;\n  }\n\n  public static int binarySearch(ArrayList<Device> kind, int target) {\n    int low = 0;\n    int high = kind.size() - 1;\n\n    while (low <= high) {\n      int mid = (low + high) >> 1;\n      Device device = kind.get(mid);\n\n      if (device.reliability > target) {\n        high = mid - 1;\n      } else if (device.reliability < target) {\n        low = mid + 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -low - 1;\n  }\n}",
    "python": "class Device:\n    def __init__(self, reliability, price):\n        self.reliability = reliability\n        self.price = price\n\n\n# 输入获取\ns, n = map(int, input().split())  # s总预算, n器件的种类数\ntotal = int(input())  # 之后输入total行具体器件的数据\narr = [list(map(int, input().split())) for _ in range(total)]\n\nreliabilities = set()  # 收集器件的可靠性\n\nkinds = [[] for _ in range(n)]  # 各种类集合\nfor ty, reliability, price in arr:\n    kinds[int(ty)].append(Device(reliability, price))\n    reliabilities.add(reliability)\n\n\ndef binarySearch(kind, target):\n    low = 0\n    high = len(kind) - 1\n\n    while low <= high:\n        mid = (low + high) >> 1\n        device = kind[mid]\n\n        if device.reliability > target:\n            high = mid - 1\n        elif device.reliability < target:\n            low = mid + 1\n        else:\n            return mid\n\n    return -low - 1;\n\n\ndef check(reliability):\n    sumPrice = 0\n\n    for kind in kinds:\n        # 注意kind内的器件已经按照可靠性升序了\n        # 我们需要在该kind种类内找到一个可靠性>=maxReliability的器件\n        idx = binarySearch(kind, reliability)\n\n        # 如果idx<0，则说明idx是一个插入位置\n        if idx < 0:\n            idx = -idx - 1\n\n        # 如果idx==kind.size()则说明kind内所有器件的可靠性都低于maxReliability，因此此kind器件选取不到，可以直接返回false\n        if idx == len(kind):\n            return False\n\n        # 否则，选取对应idx位置的器件，并计入价格到总价\n        sumPrice += kind[idx].price\n\n    # 如果最终总价小于总预算s，则此maxReliability可行\n    return sumPrice <= s\n\n\n# 算法入口\ndef getResult():\n    # ans记录题解\n    ans = -1\n\n    # 将每个种类内的器件按照可靠性升序\n    for kind in kinds:\n        kind.sort(key=lambda x: x.reliability)\n\n    # 将所有器件的可靠性集合，变为数组\n    maybe = list(reliabilities)\n    maybe.sort()\n\n    # 二分选取可能的最大可靠性maybe\n    low = 0\n    high = len(maybe) - 1\n    while low <= high:\n        mid = (low + high) >> 1\n\n        # 如果maybe[mid]可靠性可以保证所有种类器件都能选到，且价格之和小于s\n        if check(maybe[mid]):\n            # 则maybe[mid]可靠性就是一个可能解\n            ans = maybe[mid]\n            # 继续尝试更优解，即找更大的可靠性\n            low = mid + 1\n        else:\n            # 否则，说明可靠性选高了，我们应该继续尝试更低的可靠性\n            high = mid - 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}