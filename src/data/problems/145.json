{
  "id": "145",
  "title": "项目排期",
  "examType": "A",
  "score": 200,
  "description": "项目组共有N个开发人员，项目经理接到了M个独立的需求，每个需求的工作量不同，且每个需求只能由一个开发人员独立完成，不能多人合作。假定各个需求直接无任何先后依赖关系，请设计算法帮助项目经理进行工作安排，使整个项目能用最少的时间交付。",
  "inputDesc": "第一行输入为M个需求的工作量，单位为天，用逗号隔开。\n例如：X1 X2 X3 … Xm 。表示共有M个需求，每个需求的工作量分别为X1天，X2天…Xm天。\n其中0<M<30；0<Xm<200\n第二行输入为项目组人员数量N",
  "outputDesc": "最快完成所有工作的天数\n输入：\n输出：\n说明：\n共有两位员工，其中一位分配需求 6 2 7 7 3 2 1共需要28天完成，另一位分配需求 9 3 11 4 共需要27天完成，故完成所有工作至少需要28天。",
  "examples": [
    {
      "input": "6 2 7 7 3 2 1 9 3 11 4\n2",
      "output": "28",
      "explanation": "2人分配任务，一人分配6 2 7 7 3 2 1共28天，另一人9 3 11 4共27天，最少需28天"
    },
    {
      "input": "3 5 2 8\n2",
      "output": "10",
      "explanation": "2人分配，一人3+5+2=10天，另一人8天，最少需10天"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二分答案+回溯验证**问题。\n\n**核心思路：**\n- 二分查找最短完成时间\n- 用回溯法验证能否在限定时间内分配完所有任务\n\n**算法步骤：**\n1. 任务按工作量降序排序（优先分配大任务）\n2. 二分搜索范围[最大单任务, 总工作量]\n3. 对每个mid值，用回溯法尝试分配任务给N个人\n4. 若能在mid天内完成则缩小上界，否则增大下界\n5. 返回最终的最短时间\n\n**时间复杂度**：O(logS × N^M)，S为总工作量，N为人数，M为任务数",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 使用Scanner读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取第一行输入，即需求的工作量，并以空格分隔\n        String[] workloads = scanner.nextLine().split(\" \");\n        // 读取第二行输入，即项目组人员数量\n        int N = Integer.parseInt(scanner.nextLine());\n        // 创建一个数组来存放每个需求的工作量\n        int[] tasks = new int[workloads.length];\n        \n        // 将输入的工作量转换为整数并存入数组\n        for (int i = 0; i < workloads.length; i++) {\n            tasks[i] = Integer.parseInt(workloads[i]);\n        }\n        \n        // 输出最快完成所有工作的天数\n        System.out.println(minimumTimeRequired(tasks, N));\n    }\n    \n    // 计算完成所有任务所需的最少天数\n    public static int minimumTimeRequired(int[] tasks, int k) {\n        // 将任务按工作量升序排序\n        Arrays.sort(tasks);\n        // 将排序后的数组反转，使之成为降序\n        int low = 0, high = tasks.length - 1;\n        while (low < high) {\n            int temp = tasks[low];\n            tasks[low] = tasks[high];\n            tasks[high] = temp;\n            low++;\n            high--;\n        }\n        \n        // 使用二分查找确定完成所有任务的最短时间\n        int l = tasks[0], r = Arrays.stream(tasks).sum();\n        while (l < r) {\n            int mid = (l + r) / 2;\n            // 检查当前时间限制是否足够完成所有任务\n            if (canFinish(tasks, k, mid)) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        \n        // 返回最短完成时间\n        return l;\n    }\n    \n    // 检查是否可以在给定的时间限制内完成所有任务\n    private static boolean canFinish(int[] tasks, int k, int limit) {\n        // 创建一个数组来记录每个员工的工作量\n        int[] workers = new int[k];\n        // 使用回溯法检查是否可以完成\n        return backtrack(tasks, workers, 0, limit);\n    }\n    \n    // 回溯法\n    private static boolean backtrack(int[] tasks, int[] workers, int index, int limit) {\n        // 如果所有任务都已分配，则返回true\n        if (index >= tasks.length) {\n            return true;\n        }\n        \n        // 获取当前任务的工作量\n        int current = tasks[index];\n        // 尝试将当前任务分配给每个员工\n        for (int i = 0; i < workers.length; i++) {\n            // 如果当前员工可以在时间限制内完成这项任务\n            if (workers[i] + current <= limit) {\n                // 分配任务给当前员工\n                workers[i] += current;\n                // 继续尝试分配下一个任务\n                if (backtrack(tasks, workers, index + 1, limit)) {\n                    return true;\n                }\n                // 回溯，取消当前的任务分配\n                workers[i] -= current;\n            }\n            \n            // 如果当前员工没有任务或者加上当前任务刚好达到时间限制，则不需要尝试其他员工\n            if (workers[i] == 0 || workers[i] + current == limit) {\n                break;\n            }\n        }\n        \n        // 如果无法分配当前任务，则返回false\n        return false;\n    }\n}",
    "python": "# Python版本代码\nfrom itertools import combinations\n\ndef minimumTimeRequired(tasks, k):\n    # 将任务按工作量降序排序\n    tasks.sort(reverse=True)\n    \n    # 使用二分查找确定完成所有任务的最短时间\n    l, r = tasks[0], sum(tasks)\n    while l < r:\n        mid = (l + r) // 2\n        # 检查当前时间限制是否足够完成所有任务\n        if canFinish(tasks, k, mid):\n            r = mid\n        else:\n            l = mid + 1\n    \n    # 返回最短完成时间\n    return l\n\ndef canFinish(tasks, k, limit):\n    # 创建一个数组来记录每个员工的工作量\n    workers = [0] * k\n    # 使用回溯法检查是否可以完成\n    return backtrack(tasks, workers, 0, limit)\n\ndef backtrack(tasks, workers, index, limit):\n    # 如果所有任务都已分配，则返回True\n    if index >= len(tasks):\n        return True\n    \n    # 获取当前任务的工作量\n    current = tasks[index]\n    # 尝试将当前任务分配给每个员工\n    for i in range(len(workers)):\n        # 如果当前员工可以在时间限制内完成这项任务\n        if workers[i] + current <= limit:\n            # 分配任务给当前员工\n            workers[i] += current\n            # 继续尝试分配下一个任务\n            if backtrack(tasks, workers, index + 1, limit):\n                return True\n            # 回溯，取消当前的任务分配\n            workers[i] -= current\n        \n        # 如果当前员工没有任务或者加上当前任务刚好达到时间限制，则不需要尝试其他员工\n        if workers[i] == 0 or workers[i] + current == limit:\n            break\n    \n    # 如果无法分配当前任务，则返回False\n    return False\n\nif __name__ == \"__main__\":\n    # 使用input读取输入\n    tasks = list(map(int, input().split()))\n    N = int(input())\n    \n    # 输出最快完成所有工作的天数\n    print(minimumTimeRequired(tasks, N))",
    "javascript": "",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <sstream> \nusing namespace std;\n// 回溯法\nbool backtrack(vector<int>& tasks, vector<int>& workers, int index, int limit) {\n    // 如果所有任务都已分配，则返回true\n    if (index >= tasks.size()) {\n        return true;\n    }\n    \n    // 获取当前任务的工作量\n    int current = tasks[index];\n    // 尝试将当前任务分配给每个员工\n    for (int i = 0; i < workers.size(); i++) {\n        // 如果当前员工可以在时间限制内完成这项任务\n        if (workers[i] + current <= limit) {\n            // 分配任务给当前员工\n            workers[i] += current;\n            // 继续尝试分配下一个任务\n            if (backtrack(tasks, workers, index + 1, limit)) {\n                return true;\n            }\n            // 回溯，取消当前的任务分配\n            workers[i] -= current;\n        }\n        \n        // 如果当前员工没有任务或者加上当前任务刚好达到时间限制，则不需要尝试其他员工\n        if (workers[i] == 0 || workers[i] + current == limit) {\n            break;\n        }\n    }\n    \n    // 如果无法分配当前任务，则返回false\n    return false;\n}\n// 检查是否可以在给定的时间限制内完成所有任务\nbool canFinish(vector<int>& tasks, int k, int limit) {\n    // 创建一个数组来记录每个员工的工作量\n    vector<int> workers(k, 0);\n    // 使用回溯法检查是否可以完成\n    return backtrack(tasks, workers, 0, limit);\n}\n// 计算完成所有任务所需的最少天数\nint minimumTimeRequired(vector<int>& tasks, int k) {\n    // 将任务按工作量降序排序\n    sort(tasks.begin(), tasks.end(), greater<int>());\n    \n    // 使用二分查找确定完成所有任务的最短时间\n    int l = tasks[0], r = accumulate(tasks.begin(), tasks.end(), 0);\n    while (l < r) {\n        int mid = (l + r) / 2;\n        // 检查当前时间限制是否足够完成所有任务\n        if (canFinish(tasks, k, mid)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    \n    // 返回最短完成时间\n    return l;\n}\n\n\n\n\nint main() {\n    // 使用cin读取输入\n    vector<int> tasks;\n    string input;\n    getline(cin, input);\n    istringstream iss(input);\n    int value;\n    while (iss >> value) {\n        tasks.push_back(value);\n    }\n    int N;\n    cin >> N;\n    \n    // 输出最快完成所有工作的天数\n    cout << minimumTimeRequired(tasks, N) << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_TASKS 30 // 定义最大任务数量的常量，用于设置任务数组的最大长度\n\n// 用于qsort函数的比较函数，实现降序排序\nint compare(const void *a, const void *b) {\n    // 将void指针转换为int指针，并解引用获取值进行比较\n    return (*(int*)b - *(int*)a);\n}\n\n// 回溯法分配任务\nint backtrack(int *tasks, int *workers, int index, int limit, int k, int taskSize) {\n    // 检查是否所有任务都已分配\n    if (index >= taskSize) {\n        return 1; // 如果是，返回1表示成功\n    }\n\n    // 获取当前要分配的任务\n    int current = tasks[index];\n    // 遍历所有员工\n    for (int i = 0; i < k; i++) {\n        // 检查当前员工是否可以在时间限制内完成这个任务\n        if (workers[i] + current <= limit) {\n            // 如果可以，分配任务并递归尝试分配下一个任务\n            workers[i] += current;\n            if (backtrack(tasks, workers, index + 1, limit, k, taskSize)) {\n                return 1;\n            }\n            // 如果不成功，回溯，即撤销这次任务分配\n            workers[i] -= current;\n        }\n\n        // 如果当前员工没有任务或者加上当前任务刚好达到时间限制，则不需要尝试其他员工\n        if (workers[i] == 0 || workers[i] + current == limit) {\n            break;\n        }\n    }\n\n    // 如果无法分配当前任务，返回0表示失败\n    return 0;\n}\n\n// 检查是否能在指定时间内完成所有任务\nint canFinish(int *tasks, int k, int limit, int taskSize) {\n    // 初始化一个记录员工当前任务量的数组\n    int workers[MAX_TASKS] = {0};\n    // 调用回溯法尝试分配任务\n    return backtrack(tasks, workers, 0, limit, k, taskSize);\n}\n\n// 计算完成所有任务的最短时间\nint minimumTimeRequired(int *tasks, int k, int taskSize) {\n    // 先对任务进行降序排序\n    qsort(tasks, taskSize, sizeof(int), compare);\n\n    // 二分查找的左右边界，左边界为最大单个任务时间，右边界为所有任务时间总和\n    int l = tasks[0], r = 0;\n    for (int i = 0; i < taskSize; i++) {\n        r += tasks[i];\n    }\n\n    // 二分查找最短完成时间\n    while (l < r) {\n        int mid = l + (r - l) / 2;\n        // 检查是否能在mid时间内完成所有任务\n        if (canFinish(tasks, k, mid, taskSize)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n\n    // 返回最短完成时间\n    return l;\n}\n\nint main() {\n    // 存储任务的数组和任务数量\n    int tasks[MAX_TASKS], taskSize = 0;\n    // 读取一行输入作为任务工作量\n    char input[200];\n    fgets(input, 200, stdin);\n    // 使用strtok分割字符串，将分割后的数字转换为int存入任务数组\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        tasks[taskSize++] = atoi(token);\n        token = strtok(NULL, \" \");\n    }\n\n    // 读取员工数量\n    int N;\n    scanf(\"%d\", &N);\n\n    // 计算并输出完成所有任务的最短时间\n    printf(\"%d\\n\", minimumTimeRequired(tasks, N, taskSize));\n    return 0;\n}"
  }
}