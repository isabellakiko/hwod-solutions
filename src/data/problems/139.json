{
  "id": "139",
  "title": "计算网络信号信号强度",
  "examType": "A",
  "score": 200,
  "description": "网络信号经过传递会逐层衰减，且遇到阻隔物无法直接穿透，在此情况下需要计算某个位置的网络信号值。 注意:网络信号可以绕过阻隔物。\narray[m][n] 的二维数组代表网格地图，array[i][j] = 0代表i行j列是空旷位置;array[i][j] = x(x为正整数)代表i行j列是信号源，信号强度是x;array[i][j] = -1代表i行j列是阻隔物。信号源只有1个，阻隔物可能有0个或多个网络信号衰减是上下左右相邻的网格衰减1\n现要求输出对应位置的网络信号值。",
  "inputDesc": "输入为三行，\n第一行为 m 、n ，代表输入是一个 m × n 的数组。第二行是一串 m × n 个用空格分隔的整数。每连续 n 个数代表一行，再往后 n 个代表下一行，以此类推。对应的值代表对应的网格是空旷位置，还是信号源，还是阻隔物。第三行是 i 、 j，代表需要计算array[i][j]的网络信号值。\n注意：此处 i 和 j 均从 0 开始，即第一行 i 为 0。\n123\n代表如下地图\n\n需要输出第1行第4列的网络信号值，值为2。\n",
  "outputDesc": "输出对应位置的网络信号值，如果网络信号未覆盖到，也输出0。\n一个网格如果可以途径不同的传播衰减路径传达，取较大的值作为其信号值。",
  "examples": [
    {
      "input": "6 5\n0 0 0 -1 0 0 0 0 0 0 0 -1 4 0 0 0 0 0 0 0 0 0 0 -1 0 0 0 0 0 0\n1 4",
      "output": "2",
      "explanation": "信号源在(2,2)位置强度为4，到(1,4)需绕过阻隔物，最短路径衰减后强度为2"
    },
    {
      "input": "3 3\n0 0 0 0 5 0 0 0 0\n0 0",
      "output": "3",
      "explanation": "信号源在(1,1)强度5，到(0,0)距离2，信号强度为5-2=3"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**BFS广度优先搜索**问题。\n\n**核心思路：**\n- 信号从信号源向四周扩散，每传一格衰减1\n- 遇到阻隔物(-1)无法穿透但可绕行\n- BFS保证找到最短路径即最大信号强度\n\n**算法步骤：**\n1. 找到信号源位置，加入BFS队列\n2. 向四个方向扩散，空位置(0)设为当前强度-1\n3. 阻隔物(-1)跳过，已访问位置跳过\n4. 返回目标位置的信号值\n\n**时间复杂度**：O(M×N)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int rows = scanner.nextInt();\n        int cols = scanner.nextInt();\n\n        // 创建一个大小为 rows*cols 的数组，存储矩阵中每个位置的信号强度\n        int[] signalStrength = new int[rows * cols];\n        // 创建一个队列，存储所有信号源的位置\n        Queue<int[]> sourcePositions = new LinkedList<>();\n\n        // 读入矩阵并找到信号源位置\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                signalStrength[i * cols + j] = scanner.nextInt();\n                // 如果该位置的信号强度大于 0，说明这是一个信号源的位置，将其加入队列\n                if (signalStrength[i * cols + j] > 0) {\n                    sourcePositions.offer(new int[]{i, j});\n                }\n            }\n        }\n\n        // 广度优先搜索传播信号\n        while (!sourcePositions.isEmpty()) {\n            // 取出队列头部的位置\n            int[] pos = sourcePositions.poll();\n            int i = pos[0], j = pos[1];\n\n            // 如果信号强度为1，则不需要再传播了，后面肯定都是0\n            if (signalStrength[i * cols + j] == 1) {\n                break;\n            }\n\n            // 信号可以上下左右传播，存储四个方向的偏移量\n            int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n            // 遍历四个方向\n            for (int[] direction : directions) {\n                // 计算新位置的坐标\n                int newI = i + direction[0], newJ = j + direction[1];\n                // 如果新位置在矩阵范围内，且该位置的信号强度为0，说明可以传播到该位置\n                if (newI >= 0 && newI < rows && newJ >= 0 && newJ < cols && signalStrength[newI * cols + newJ] == 0) {\n                    // 将该位置的信号强度设为当前位置的信号强度减1，并将其加入队列\n                    signalStrength[newI * cols + newJ] = signalStrength[i * cols + j] - 1;\n                    sourcePositions.offer(new int[]{newI, newJ});\n                }\n            }\n        }\n\n        // 输出目标位置的信号强度\n        int targetRow = scanner.nextInt(), targetCol = scanner.nextInt();\n        System.out.println(signalStrength[targetRow * cols + targetCol]);\n    }\n}",
    "python": "# 输入获取，读入网格地图大小、地图数据和目标位置\nnum_rows, num_cols = map(int, input().split())\ngrid_map = list(map(int, input().split()))\ntarget_pos = list(map(int, input().split()))\n\n# 算法入口\ndef get_signal_strength(map_array, num_rows, num_cols, target_pos):\n    # 初始化队列，将所有信号源位置加入队列\n    queue = [[i, j] for j in range(num_cols) for i in range(num_rows) if map_array[i*num_cols+j] > 0]\n    # 定义四个方向偏移量\n    directions = ((-1, 0), (1, 0), (0, -1), (0, 1))\n\n    # 广度优先搜索\n    while queue:\n        new_queue = []\n        for i, j in queue:\n            signal_strength = map_array[i*num_cols+j] - 1  # 计算信号强度\n            for dx, dy in directions:\n                new_i, new_j = i+dx, j+dy  # 计算新位置\n                if 0 <= new_i < num_rows and 0 <= new_j < num_cols and map_array[new_i*num_cols+new_j] == 0:\n                    # 如果新位置在地图内且为空旷位置，则更新该位置信号强度并将其加入队列\n                    map_array[new_i*num_cols+new_j] = signal_strength\n                    new_queue.append([new_i, new_j])\n        queue = new_queue\n        \n    # 返回目标位置的信号强度（如果未被覆盖到则返回0）\n    target_row, target_col = target_pos\n    return max(0, map_array[target_row*num_cols+target_col])\n\n# 算法调用，输出结果\nprint(get_signal_strength(grid_map, num_rows, num_cols, target_pos))",
    "javascript": "// 创建 readline 接口\nconst readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet m, n;\nlet matrix = []; // 保存输入的二维数组\nlet posQueue = []; // 保存信号源的位置\n\n// 监听命令行输入\nrl.on('line', (line) => {\n    if (!m) { // 第一行为矩阵行列数\n        [m, n] = line.trim().split(' ').map(Number);\n    } else if (matrix.length < m * n) { // 保存输入的二维数组\n        matrix.push(...line.trim().split(' ').map(Number));\n        if (matrix.length === m * n) { // 找出所有信号源的位置\n            for (let i = 0; i < m; i++) {\n                for (let j = 0; j < n; j++) {\n                    if (matrix[i * n + j] > 0) {\n                        posQueue.push([i, j]);\n                    }\n                }\n            }\n        }\n    } else { // 处理需要计算的位置\n        const [target_i, target_j] = line.trim().split(' ').map(Number);\n        while (posQueue.length > 0) { // 广度优先搜索信号源的传播路径\n            const [i, j] = posQueue.shift();\n            if (matrix[i * n + j] === 1) { // 当前是信号源，不再向外扩散\n                break;\n            }\n            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 四个方向\n            for (const [dx, dy] of directions) { // 向四个方向扩散\n                const new_i = i + dx, new_j = j + dy;\n                if (new_i >= 0 && new_i < m && new_j >= 0 && new_j < n && matrix[new_i * n + new_j] === 0) { // 可以传播到该位置\n                    matrix[new_i * n + new_j] = matrix[i * n + j] - 1; // 计算信号值\n                    posQueue.push([new_i, new_j]); // 将该位置加入队列\n                }\n            }\n        }\n        console.log(matrix[target_i * n + target_j]); // 输出目标位置的信号值\n        rl.close(); // 关闭 readline 接口\n    }\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n\n    // 创建一个大小为 rows*cols 的 vector，存储矩阵中每个位置的信号强度\n    vector<int> signal_strength(rows * cols);\n    // 创建一个队列，存储所有信号源的位置\n    queue<pair<int, int>> source_positions;\n\n    // 读入矩阵并找到信号源位置\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            cin >> signal_strength[i * cols + j];\n            // 如果该位置的信号强度大于 0，说明这是一个信号源的位置，将其加入队列\n            if (signal_strength[i * cols + j] > 0) {\n                source_positions.push({i, j});\n            }\n        }\n    }\n\n    // 广度优先搜索传播信号\n    while (!source_positions.empty()) {\n        // 取出队列头部的位置\n        auto [i, j] = source_positions.front();\n        source_positions.pop();\n\n        // 如果信号强度为1，则不需要再传播了，后面肯定都是0\n        if (signal_strength[i * cols + j] == 1) {\n            break;\n        }\n\n        // 信号可以上下左右传播，存储四个方向的偏移量\n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        // 遍历四个方向\n        for (auto [dx, dy] : directions) {\n            // 计算新位置的坐标\n            int new_i = i + dx, new_j = j + dy;\n            // 如果新位置在矩阵范围内，且该位置的信号强度为0，说明可以传播到该位置\n            if (new_i >= 0 && new_i < rows && new_j >= 0 && new_j < cols && signal_strength[new_i * cols + new_j] == 0) {\n                // 将该位置的信号强度设为当前位置的信号强度减1，并将其加入队列\n                signal_strength[new_i * cols + new_j] = signal_strength[i * cols + j] - 1;\n                source_positions.push({new_i, new_j});\n            }\n        }\n    }\n\n    // 输出目标位置的信号强度\n    int target_row, target_col;\n    cin >> target_row >> target_col;\n    cout << signal_strength[target_row * cols + target_col] << endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int m, n;\n\n    // 读取矩阵的行数和列数\n    scanf(\"%d %d\", &m, &n);\n\n    // 创建一个大小为 m*n 的数组，用于存储矩阵的信号强度\n    int *matrix = (int *)malloc(m * n * sizeof(int));\n    \n    // 创建两个数组来充当队列，分别存储信号源的行坐标和列坐标\n    int *queueX = (int *)malloc(m * n * sizeof(int));\n    int *queueY = (int *)malloc(m * n * sizeof(int));\n    int front = 0, rear = 0;  // 队列的头和尾索引\n\n    // 读入矩阵并找到所有信号源的位置\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &matrix[i * n + j]);\n            // 如果该位置的信号强度大于 0，说明这是一个信号源，将其加入队列\n            if (matrix[i * n + j] > 0) {\n                queueX[rear] = i;  // 存储行坐标\n                queueY[rear] = j;  // 存储列坐标\n                rear++;  // 队尾后移\n            }\n        }\n    }\n\n    // 读取目标位置\n    int target_i, target_j;\n    scanf(\"%d %d\", &target_i, &target_j);\n\n    // 广度优先搜索（BFS）传播信号\n    while (front < rear) {  // 当队列不为空时\n        int i = queueX[front];\n        int j = queueY[front];\n        front++;  // 队头前移\n\n        // 如果当前位置的信号强度为1，则不再向外扩散\n        if (matrix[i * n + j] == 1) {\n            continue;\n        }\n\n        // 信号可以向上下左右传播，定义四个方向的偏移量\n        int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        // 遍历四个方向，检查信号传播的可能性\n        for (int d = 0; d < 4; d++) {\n            int new_i = i + directions[d][0];\n            int new_j = j + directions[d][1];\n\n            // 检查新位置是否在矩阵范围内，并且信号强度为0，说明可以传播到该位置\n            if (new_i >= 0 && new_i < m && new_j >= 0 && new_j < n && matrix[new_i * n + new_j] == 0) {\n                // 将该位置的信号强度设为当前位置的信号强度减1，并将其加入队列\n                matrix[new_i * n + new_j] = matrix[i * n + j] - 1;\n                queueX[rear] = new_i;\n                queueY[rear] = new_j;\n                rear++;  // 队尾后移\n            }\n        }\n    }\n\n    // 输出目标位置的信号强度\n    printf(\"%d\\n\", matrix[target_i * n + target_j]);\n\n    // 释放动态分配的内存\n    free(matrix);\n    free(queueX);\n    free(queueY);\n\n    return 0;\n}"
  }
}