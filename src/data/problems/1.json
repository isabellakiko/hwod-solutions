{
  "id": "1",
  "title": "IPv4地址转换成整数",
  "examType": "A",
  "score": 100,
  "description": "存在一种虚拟IPv4地址，由4小节组成，每节的范围为0~255，以#号间隔，虚拟IPv4地址可以转换为一个32位的整数，例如：\n- 128#0#255#255，转换为32位整数的结果为2147549183（0x8000FFFF）\n- 1#0#0#0，转换为32位整数的结果为16777216（0x01000000）\n\n现以字符串形式给出一个虚拟IPv4地址，限制第1小节的范围为1~128，即每一节范围分别为(1~128)#(0~255)#(0~255)#(0~255)，要求每个IPv4地址只能对应到唯一的整数上。如果是非法IPv4，返回invalid IP",
  "inputDesc": "输入一行，虚拟IPv4地址格式字符串",
  "outputDesc": "输出一行，按照要求输出整型或者特定字符",
  "examples": [
    {
      "input": "100#101#1#5",
      "output": "1684340997",
      "explanation": ""
    },
    {
      "input": "1#2#3",
      "output": "invalid IP",
      "explanation": ""
    }
  ],
  "solution": "虚拟IPv4地址由四个小节组成，每个小节用`#`号分隔。每个小节代表一个整数，范围从0到255，但题目中特别指出第一小节的范围应为1到128。地址的正确形式应该是四部分，例如 `1#2#3#4`。如果格式不正确或数值不在指定范围内，则视为非法IPv4，输出\"invalid IP\"。\n\n**解题注意事项：**\n\n1. **异常处理**：\n   - 确保输入的每一部分（小节）都是数字\n   - 确保没有空的小节，例如`1##3#4`\n   - 处理任何非数字字符，例如`a#b#c#d`\n   - 检查是否每个部分都严格为数字，并且没有前导零（除了单独的0），例如`01#01#01#01`应被视为非法\n\n2. **范围验证**：\n   - 第一小节必须在1到128之间\n   - 其余三小节必须在0到255之间\n   - 任何超出这些范围的值都应该导致输出\"invalid IP\"\n\n3. **格式正确性**：\n   - 确保地址严格由四个数字小节组成，多于或少于四部分都应视为无效",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    String input = sc.nextLine();\n    String[] ipSections = input.split(\"#\"); // 将输入的字符串按照\"#\"分割成4个小节\n    \n    if (ipSections.length != 4) { // 如果分割后的小节数量不等于4，则说明输入的IPv4地址格式不正确\n      System.out.println(\"invalid IP\");\n      return; // 结束程序\n    }\n\n    for (String section : ipSections) {\n      if (!isNumeric(section)) { // 检查是否每部分都是数字\n        System.out.println(\"invalid IP\");\n        return; // 结束程序\n      }\n      if (section.length() == 0) { // 检查是否有空字符\n        System.out.println(\"invalid IP\");\n        return; // 结束程序\n      }\n      // 检查前导零的情况\n      if (section.length() > 1 && section.charAt(0) == '0') {\n        System.out.println(\"invalid IP\");\n        return; // 结束程序\n      }\n    }\n    \n    int firstSection = Integer.parseInt(ipSections[0]); // 将第一个小节转换为整数\n    if (firstSection < 1 || firstSection > 128) { // 如果第一个小节的值不在1~128的范围内\n      System.out.println(\"invalid IP\");\n      return; // 结束程序\n    }\n    \n    for (int i = 1; i < 4; i++) { // 遍历后面的3个小节\n      int sectionValue = Integer.parseInt(ipSections[i]); // 将当前小节转换为整数\n      if (sectionValue < 0 || sectionValue > 255) { // 如果当前小节的值不在0~255的范围内\n        System.out.println(\"invalid IP\");\n        return; // 结束程序\n      }\n    }\n    \n    long ipValue = 0; // 用于计算32位整数值\n    for (int i = 0; i < 4; i++) {\n      ipValue = ipValue * 256 + Integer.parseInt(ipSections[i]); // 每个小节对应一个字节\n    }\n    \n    System.out.println(ipValue); // 输出最终计算得到的32位整数\n  }\n\n  // 判断字符串是否为数字\n  public static boolean isNumeric(String str) {\n    for (int i = 0; i < str.length(); i++) {\n      if (!Character.isDigit(str.charAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n}",
    "python": "def is_numeric(s):\n    return s.isdigit()\n\ninput_str = input()\nip_sections = input_str.split(\"#\")\n\nif len(ip_sections) != 4:\n    print(\"invalid IP\")\nelse:\n    valid = True\n    for section in ip_sections:\n        if len(section) == 0 or not is_numeric(section):\n            valid = False\n            break\n        if len(section) > 1 and section[0] == '0':\n            valid = False\n            break\n    \n    if not valid:\n        print(\"invalid IP\")\n    else:\n        first_section = int(ip_sections[0])\n        if first_section < 1 or first_section > 128:\n            print(\"invalid IP\")\n        else:\n            for i in range(1, 4):\n                section_value = int(ip_sections[i])\n                if section_value < 0 or section_value > 255:\n                    print(\"invalid IP\")\n                    break\n            else:\n                ip_value = 0\n                for i in range(4):\n                    ip_value = ip_value * 256 + int(ip_sections[i])\n                print(ip_value)",
    "javascript": "const readline = require('readline');\n\nfunction isNumeric(str) {\n  for (let i = 0; i < str.length; i++) {\n    if (!/\\d/.test(str[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', function (input) {\n  const ipSections = input.split('#');\n\n  if (ipSections.length !== 4) {\n    console.log(\"invalid IP\");\n    rl.close();\n    return;\n  }\n\n  for (const section of ipSections) {\n    if (section.length === 0 || !isNumeric(section)) {\n      console.log(\"invalid IP\");\n      rl.close();\n      return;\n    }\n    if (section.length > 1 && section[0] === '0') {\n      console.log(\"invalid IP\");\n      rl.close();\n      return;\n    }\n  }\n\n  const firstSection = parseInt(ipSections[0], 10);\n  if (firstSection < 1 || firstSection > 128) {\n    console.log(\"invalid IP\");\n    rl.close();\n    return;\n  }\n\n  for (let i = 1; i < 4; i++) {\n    const sectionValue = parseInt(ipSections[i], 10);\n    if (sectionValue < 0 || sectionValue > 255) {\n      console.log(\"invalid IP\");\n      rl.close();\n      return;\n    }\n  }\n\n  let ipValue = 0;\n  for (let i = 0; i < 4; i++) {\n    ipValue = ipValue * 256 + parseInt(ipSections[i], 10);\n  }\n\n  console.log(ipValue);\n  rl.close();\n});",
    "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nbool isNumeric(const string& str) {\n    for (char c : str) {\n        if (!isdigit(c)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    string input;\n    getline(cin, input);\n\n    stringstream ss(input);\n    vector<string> ipSections;\n    string section;\n    while (getline(ss, section, '#')) {\n        ipSections.push_back(section);\n    }\n\n    if (ipSections.size() != 4) {\n        cout << \"invalid IP\" << endl;\n        return 0;\n    }\n\n    for (const string& section : ipSections) {\n        if (section.empty() || !isNumeric(section)) {\n            cout << \"invalid IP\" << endl;\n            return 0;\n        }\n        if (section.length() > 1 && section[0] == '0') {\n            cout << \"invalid IP\" << endl;\n            return 0;\n        }\n    }\n\n    int firstSection = stoi(ipSections[0]);\n    if (firstSection < 1 || firstSection > 128) {\n        cout << \"invalid IP\" << endl;\n        return 0;\n    }\n\n    for (int i = 1; i < 4; i++) {\n        int sectionValue = stoi(ipSections[i]);\n        if (sectionValue < 0 || sectionValue > 255) {\n            cout << \"invalid IP\" << endl;\n            return 0;\n        }\n    }\n\n    long ipValue = 0;\n    for (int i = 0; i < 4; i++) {\n        ipValue = ipValue * 256 + stoi(ipSections[i]);\n    }\n\n    cout << ipValue << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nint is_numeric(const char* str) {\n    for (int i = 0; str[i] != '\\0'; i++) {\n        if (!isdigit(str[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    char input[256];\n    fgets(input, sizeof(input), stdin);\n\n    char* ipSections[4];\n    char* token = strtok(input, \"#\");\n    int sectionCount = 0;\n\n    while (token != NULL && sectionCount < 4) {\n        ipSections[sectionCount++] = token;\n        token = strtok(NULL, \"#\");\n    }\n\n    if (sectionCount != 4) {\n        printf(\"invalid IP\\n\");\n        return 0;\n    }\n\n    for (int i = 0; i < 4; i++) {\n        char* section = ipSections[i];\n        section[strcspn(section, \"\\n\")] = '\\0';\n\n        if (strlen(section) == 0 || !is_numeric(section)) {\n            printf(\"invalid IP\\n\");\n            return 0;\n        }\n        if (strlen(section) > 1 && section[0] == '0') {\n            printf(\"invalid IP\\n\");\n            return 0;\n        }\n    }\n\n    int firstSection = atoi(ipSections[0]);\n    if (firstSection < 1 || firstSection > 128) {\n        printf(\"invalid IP\\n\");\n        return 0;\n    }\n\n    for (int i = 1; i < 4; i++) {\n        int sectionValue = atoi(ipSections[i]);\n        if (sectionValue < 0 || sectionValue > 255) {\n            printf(\"invalid IP\\n\");\n            return 0;\n        }\n    }\n\n    long ipValue = 0;\n    for (int i = 0; i < 4; i++) {\n        ipValue = ipValue * 256 + atoi(ipSections[i]);\n    }\n\n    printf(\"%ld\\n\", ipValue);\n    return 0;\n}"
  }
}
