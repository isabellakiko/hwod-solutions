{
  "id": "206",
  "title": "几何平均值最大子数组",
  "examType": "B",
  "score": 200,
  "description": "从一个长度为N的正数数组numbers中找出长度至少为L且几何平均值最大子数组，并输出其位置和大小。（K个数的几何平均值为K个数的乘积的K次方根）\n若有多个子数组的几何平均值均为最大值，则输出长度最小的子数组。\n若有多个长度相同的子数组的几何平均值均为最大值，则输出最前面的子数组。\n",
  "inputDesc": "第一行输入为N、L\nN表示numbers的大小（1 ≤ N ≤ 100000）L表示子数组的最小长度（1 ≤ L ≤ N）\n之后N行表示numbers中的N个数，每个一行（10^-9 ≤ numbers[i] ≤ 10^9）\n",
  "outputDesc": "输出子数组的位置（从0开始计数）和大小，中间用一个空格隔开。\n\n用例保证除几何平均值为最大值的子数组外，其他子数组的几何平均值至少比最大值小10^-10倍\n\n本题其实就是 LeetCode - 644 子数组最大平均数 II_伏城之外的博客-CSDN博客\n的变种题。但是本题更难。\n\n建议大家先把leetcode 644 这题做会了，再来看本题。\n本题和leetcode 644的区别在于，leetcode 644求解的长度大于等于k的 最大算术平均值 的连续子序列，而本题求解的是 长度大于等于k的 最大几何平均值 的连续子序列。\n\n一个数组的nums = [a1, a2, a3, ..., aN]的\n\n因此，在求解 长度大于等于k 的子序列时，我们不能在沿用leetcode 644的解法，leetcode 644解法如下\n首先，求出 0~i 子序列的和 sum\n然后，求出 0~0 到 0~i-k 中所有子序列的最小和 min_pre_sum\n最后，sum - min_pre_sum >= 0的话，说明midVal可能取小了\n本题需要换成除法\n首先，求出 0~i 子序列的所有元素乘积 fact\n然后，求出 0~0 到 0~i-k 中所有子序列的最小乘积 min_pre_fact\n最后，fact / min_pre_fact >= 1的话，说明midVal可能取小了\n\n原理如下：有一个数组nums = [a1, a2, a3, ..., aN]，假设其几何平均值为avg，则有等式如下：\nN √ （a1 * a2 * a3 * ... * aN） == avg\n再转换一下，如下：\na1 * a2 * a3 * ... * aN == avg ^ N\n再转换一下，如下：\n(a1 / avg) * (a2 / avg) * (a3 / avg) * ... * (aN / avg) == 1\n如果avg取大了，则 (a1 / avg) * (a2 / avg) * (a3 / avg) * ... * (aN / avg) < 1\n如果avg取小了，则 (a1 / avg) * (a2 / avg) * (a3 / avg) * ... * (aN / avg) > 1\n\n另外，本题需要输出最大几何平均值对应的子数组的起始位置和长度，这个很简单，只需要记录每次被挖去的最小平均值子数组的结尾索引即可，根据结尾索引min_pre_fact_end，即可得出最大平均值数组的起始索引和长度，计算公式如下\n\n\n2023.04.09 根据网友指正，本题之前的解法没有考虑：存在多个最大几何平均值的子数组的情况，比如用例2，就有多个最大几何平均值，下面用JS通过暴力解法，求出所有子数组的几何平均值\n\n如上图所示，最大几何平均值为0.2，而几何平均值到达0.2的子数组有多个，\n比如 [2, 2, '0.200000000000'] 的含义就是：起点索引2，长度2，的子数组的几何平均值就是0.2\n因此，基于上面算法，当我们可以保存最后一轮二分求得的avg对应的：所有子数组的起点和长度（保存进ans），然后进行排序：先按照长度（较短者排前面），再按照起点（靠前者排在前面）、\n",
  "examples": [
    {
      "input": "4 2\n1\n2\n3\n4",
      "output": "2 2",
      "explanation": "长度>=2的子数组中，[3,4]几何平均值最大，起始位置2长度2"
    },
    {
      "input": "5 2\n0.1\n0.2\n0.2\n0.2\n0.1",
      "output": "2 2",
      "explanation": "多个最大几何平均值子数组，选最短的"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二分答案**问题（类似LeetCode 644）。\n\n**核心思路：**\n- 二分搜索可能的几何平均值\n- 转化为判定问题验证是否存在\n\n**算法步骤：**\n1. 二分搜索几何平均值范围\n2. 将数组除以mid转化为乘积判定\n3. 前缀积+最小前缀积判断是否>=1\n4. 记录满足条件的子数组信息\n\n**时间复杂度**：O(N*log(MAX))",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Objects;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int l = sc.nextInt();\n\n    double[] numbers = new double[n];\n    for (int i = 0; i < n; i++) {\n      numbers[i] = sc.nextDouble();\n    }\n\n    System.out.println(getResult(n, l, numbers));\n  }\n\n  public static String getResult(int n, int l, double[] numbers) {\n    double minAvg = Integer.MAX_VALUE;\n    double maxAvg = Integer.MIN_VALUE;\n    for (double num : numbers) {\n      minAvg = Math.min(num, minAvg);\n      maxAvg = Math.max(num, maxAvg);\n    }\n\n    //    double diff = maxAvg / Math.pow(10, 10);\n\n    ArrayList<Integer[]> ans = new ArrayList<>();\n\n    // 其他子数组的几何平均值至少比最大值小10^-10倍\n    while (maxAvg - minAvg >= maxAvg / Math.pow(10, 10)) {\n      // 不保留历史avg对应的ans，只保留最后一个avg，即最大avg的ans\n      ans = new ArrayList<>();\n      double midAvg = (minAvg + maxAvg) / 2;\n\n      if (check(n, l, numbers, midAvg, ans)) {\n        minAvg = midAvg;\n      } else {\n        maxAvg = midAvg;\n      }\n    }\n\n    // 若有多个子数组的几何平均值均为最大值，则输出长度最小的子数组。\n    // 若有多个长度相同的子数组的几何平均值均为最大值，则输出最前面的子数组。\n    ans.sort((a, b) -> !Objects.equals(a[1], b[1]) ? a[1] - b[1] : a[0] - b[0]);\n\n    Integer[] tmp = ans.get(0);\n    return tmp[0] + \" \" + tmp[1];\n  }\n\n  public static boolean check(\n      int n, int l, double[] numbers, double avg, ArrayList<Integer[]> ans) {\n    // 该flag为True表示avg取小了，为False表示avg取大了，默认为False\n    boolean flag = false;\n    double fact = 1;\n\n    for (int i = 0; i < l; i++) {\n      fact *= numbers[i] / avg;\n    }\n\n    if (fact >= 1) {\n      flag = true;\n      // ans的元素含义：[目标子数组起始位置，目标子数组长度]\n      ans.add(new Integer[] {0, l});\n    }\n\n    double pre_fact = 1;\n    double min_pre_fact = Integer.MAX_VALUE;\n    int min_pre_fact_end = 0;\n\n    for (int i = l; i < n; i++) {\n      fact *= numbers[i] / avg; // 对应0~i区间\n      pre_fact *= numbers[i - l] / avg; // 对应0~i-l区间\n\n      if (pre_fact < min_pre_fact) {\n        min_pre_fact = pre_fact; // 对应0~i-l区间内 几何平均值最小的子数列\n        min_pre_fact_end = i - l;\n      }\n\n      if (fact / min_pre_fact >= 1) {\n        flag = true;\n        // ans的元素含义：[目标子数组起始位置，目标子数组长度]\n        ans.add(new Integer[] {min_pre_fact_end + 1, i - min_pre_fact_end});\n      }\n    }\n\n    return flag;\n  }\n}",
    "python": "import sys\n\n# 输入获取\nn, l = map(int, input().split())\nnumbers = [float(input()) for i in range(n)]\n\n\n# 算法入口\ndef getResult(n, l, numbers):\n    minAvg = min(numbers)\n    maxAvg = max(numbers)\n    # diff = maxAvg / 10 ** 10\n\n    ans = []\n\n    # 其他子数组的几何平均值至少比最大值小10^-10倍\n    while maxAvg - minAvg >= maxAvg / 10 ** 10:\n        # 不保留历史avg对应的ans，只保留最后一个avg，即最大avg的ans\n        ans = []\n        midAvg = (minAvg + maxAvg) / 2\n\n        if check(n, l, numbers, midAvg, ans):\n            minAvg = midAvg\n        else:\n            maxAvg = midAvg\n\n    # 若有多个子数组的几何平均值均为最大值，则输出长度最小的子数组。\n    # 若有多个长度相同的子数组的几何平均值均为最大值，则输出最前面的子数组。\n    ans.sort(key=lambda x: (x[1], x[0]))\n    return \" \".join(map(str, ans[0]))\n\n\ndef check(n, l, numbers, avg, ans):\n    # 该flag为True表示avg取小了，为False表示avg取大了，默认为False\n    flag = False\n    fact = 1\n\n    for i in range(l):\n        fact *= numbers[i] / avg\n\n    if fact >= 1:\n        flag = True\n        # ans的元素含义：[目标子数组起始位置，目标子数组长度]\n        ans.append([0, l])\n\n    pre_fact = 1\n    min_pre_fact = sys.maxsize\n    min_pre_fact_end = 0\n\n    for i in range(l, n):\n        fact *= numbers[i] / avg  # 对应0~i区间\n        pre_fact *= numbers[i - l] / avg  # 对应0~i-l区间\n\n        if pre_fact < min_pre_fact:\n            min_pre_fact = pre_fact  # 对应0~i-l区间内 几何平均值最小的子数列\n            min_pre_fact_end = i - l\n\n        if fact / min_pre_fact >= 1:\n            flag = True\n            # ans的元素含义：[目标子数组起始位置，目标子数组长度]\n            ans.append([min_pre_fact_end + 1, i - min_pre_fact_end])\n\n    return flag\n\n\n# 算法调用\nprint(getResult(n, l, numbers))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n, l;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    [n, l] = lines[0].split(\" \").map(Number);\n  }\n\n  if (n && lines.length === n + 1) {\n    const numbers = lines.slice(1).map((line) => Number(line));\n    console.log(getResult(n, l, numbers));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(n, l, numbers) {\n  const sorted_numbers = numbers.slice().sort((a, b) => a - b);\n  let minAvg = sorted_numbers.at(0);\n  let maxAvg = sorted_numbers.at(-1);\n  // const diff = maxAvg / Math.pow(10, 10);\n\n  let ans = [];\n\n  // 其他子数组的几何平均值至少比最大值小10^-10倍\n  while (maxAvg - minAvg >= maxAvg / Math.pow(10, 10)) {\n    // 不保留历史avg对应的ans，只保留最后一个avg，即最大avg的ans\n    ans = [];\n    let midAvg = (minAvg + maxAvg) / 2;\n\n    if (check(n, l, numbers, midAvg, ans)) {\n      minAvg = midAvg;\n    } else {\n      maxAvg = midAvg;\n    }\n  }\n\n  // 若有多个子数组的几何平均值均为最大值，则输出长度最小的子数组。\n  // 若有多个长度相同的子数组的几何平均值均为最大值，则输出最前面的子数组。\n  ans.sort((a, b) => (a[1] != b[1] ? a[1] - b[1] : a[0] - b[0]));\n\n  return ans[0].join(\" \");\n}\n\nfunction check(n, l, numbers, avg, ans) {\n  // 该flag为True表示avg取小了，为False表示avg取大了，默认为False\n  let flag = false;\n  let fact = 1;\n\n  for (let i = 0; i < l; i++) {\n    fact *= numbers[i] / avg;\n  }\n\n  if (fact >= 1) {\n    flag = true;\n    // ans的元素含义：[目标子数组起始位置，目标子数组长度]\n    ans.push([0, l]);\n  }\n\n  let pre_fact = 1;\n  let min_pre_fact = Infinity;\n  let min_pre_fact_end = 0;\n\n  for (let i = l; i < n; i++) {\n    fact *= numbers[i] / avg; // 对应0~i区间\n    pre_fact *= numbers[i - l] / avg; // 对应0~i-l区间\n\n    if (pre_fact < min_pre_fact) {\n      min_pre_fact = pre_fact; // 对应0~i-l区间内 几何平均值最小的子数列\n      min_pre_fact_end = i - l;\n    }\n\n    if (fact / min_pre_fact >= 1) {\n      flag = true;\n      // ans的元素含义：[目标子数组起始位置，目标子数组长度]\n      ans.push([min_pre_fact_end + 1, i - min_pre_fact_end]);\n    }\n  }\n\n  return flag;\n}",
    "cpp": "",
    "c": ""
  }
}