{
  "id": "98",
  "title": "数大雁",
  "examType": "A",
  "score": 100,
  "description": "一群大雁往南飞，给定一个字符串记录地面上的游客听到的大雁叫声，请给出叫声最少由几只大雁发出。\n具体的:\n​ 1.大雁发出的完整叫声为”quack“，因为有多只大雁同一时间嘎嘎作响，所以字符串中可能会混合多个”quack”。\n​ 2.大雁会依次完整发出”quack”，即字符串中’q’ ,‘u’, ‘a’, ‘c’, ‘k’ 这5个字母按顺序完整存在才能计数为一只大雁。如果不完整或者没有按顺序则不予计数。\n​ 3.如果字符串不是由’q’, ‘u’, ‘a’, ‘c’, ‘k’ 字符组合而成，或者没有找到一只大雁，请返回-1。",
  "inputDesc": "一个字符串，包含大雁quack的叫声。1 <= 字符串长度 <= 1000，字符串中的字符只有’q’, ‘u’, ‘a’, ‘c’, ‘k’。",
  "outputDesc": "大雁的数量",
  "examples": [
    {
      "input": "quackquack",
      "output": "1",
      "explanation": "两个完整的quack可以由1只大雁依次发出。"
    },
    {
      "input": "qaauucqcaa",
      "output": "-1",
      "explanation": "无法组成完整的quack序列。"
    },
    {
      "input": "quacqkuack",
      "output": "2",
      "explanation": "两个quack交错出现，需要2只大雁同时发出。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**状态机模拟**问题。\n\n**核心思路：**\n- 用状态数组记录处于q/u/a/c/k各阶段的大雁数量\n- 遇到字符时，从前一状态转移到当前状态\n- 同时活跃的大雁数量即为答案\n\n**算法步骤：**\n1. states[5]记录处于各阶段的大雁数\n2. 遇到q：新大雁开始叫，states[0]++\n3. 遇到其他字符：从前一状态转移\n4. 遇到k：一只大雁完成，可复用\n5. 取同时活跃的最大值\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.Scanner;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class Quack {\n    public static void main(String[] args) {\n        // 创建Scanner对象用于读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取输入的字符串\n        String chars = scanner.nextLine();\n        // 定义大雁叫声的字符串\n        String quack = \"quack\";\n        // 定义一个数组，用于存储每个字符的状态\n        int[] states = new int[quack.length()];\n        // 定义一个ArrayList，用于存储每只大雁的叫声数量\n        ArrayList<Integer> dp = new ArrayList<>();\n        // 初始化最大值为0\n        int max_ = 0;\n\n        // 遍历输入的字符串\n        for (int i = 0; i < chars.length(); i++) {\n            // 获取当前字符在\"quack\"中的索引\n            int index = quack.indexOf(chars.charAt(i));\n            // 如果索引为-1，表示输入的字符串包含非法字符，输出-1并退出程序\n            if (index == -1) {\n                System.out.println(-1);\n                System.exit(0);\n            }\n\n            // 如果索引为0，表示当前字符是'q'，更新状态数组\n            if (index == 0) {\n                states[index] += 1;\n            } else {\n                // 如果当前字符的前一个字符的状态大于0，更新状态数组\n                if (states[index - 1] > 0) {\n                    states[index - 1] -= 1;\n                    states[index] += 1;\n                }\n\n                // 如果当前字符是'k'，表示一个完整的\"quack\"叫声已经结束\n                if (quack.charAt(quack.length() - 1) == chars.charAt(i)) {\n                    // 如果状态数组的最后一个元素不为0，表示有大雁正在叫\n                    if (states[states.length - 1] != 0) {\n                        // 创建一个临时数组，用于计算当前大雁的叫声数量\n                        int[] temp = Arrays.copyOf(states, states.length);\n                        temp[states.length - 1] = 0;\n                        max_ = Math.max(max_, Arrays.stream(temp).sum());\n                        // 遍历剩余的字符，更新临时数组\n                        for (int j = i; j < chars.length(); j++) {\n                            index = quack.indexOf(chars.charAt(j));\n                            if (index > 0 && temp[index - 1] > 0) {\n                                temp[index - 1] -= 1;\n                                temp[index] += 1;\n                            }\n                            if (temp[states.length - 1] == max_) {\n                                break;\n                            }\n                        }\n                        // 将当前大雁的叫声数量添加到ArrayList中\n                        dp.add(temp[states.length - 1] + 1);\n                        // 更新状态数组\n                        states[states.length - 1] -= 1;\n                    }\n                }\n            }\n        }\n\n        // 输出结果，如果dp为空，表示没有找到一只大雁，输出-1；否则输出最大值\n        System.out.println(dp.isEmpty() ? -1 : (int) Collections.max(dp));\n    }\n}",
    "python": "chars = input()  # 输入字符串，包含大雁的叫声\nquack = \"quack\"  # 大雁叫声的顺序\nstates = [0] * len(quack)  # 用于跟踪每个字符当前出现的状态，初始为全0\ndp = []  # 动态规划数组，记录每次完成一个“quack”所需要的最少大雁数量\nmax_ = 0  # 记录当前最大的大雁数量\n\nfor i in range(len(chars)):\n    index = quack.find(chars[i])  # 找到当前字符在“quack”中的位置\n    if index == -1:  # 如果字符不在“quack”中，直接返回-1\n        print(-1)\n        exit()\n\n    if index == 0:  # 如果是“q”，表示一个新的大雁叫声的开始\n        states[index] += 1  # 对应位置状态加1\n    else:\n        if states[index - 1]:  # 如果前一个字符的位置状态存在（即有前置字符）\n            states[index - 1] -= 1  # 前一个字符的状态减1\n            states[index] += 1  # 当前字符的状态加1\n\n        if quack[-1] == chars[i]:  # 如果当前字符是“k”，即完成了一个“quack”\n            if states[-1] != 0:  # 确保有完整的大雁叫声\n                temp = [t for t in states]  # 当前状态\n                temp[-1] = 0  # 将最后一个字符的状态设为0，表示一个大雁叫声结束\n                max_ = max(max_, sum(temp))  # 更新最大的大雁数量\n                for j in range(i, len(chars)):  # 从当前位置向后继续检查是否有完整的“quack”\n                    index = quack.find(chars[j])\n                    if temp[index - 1]:  # 如果前一个字符的位置状态存在\n                        temp[index - 1] -= 1  # 前一个字符的状态减1\n                        temp[index] += 1  # 当前字符的状态加1\n                    if temp[-1] == max_:  # 如果状态达到最大值\n                        break  # 结束当前循环\n                dp.append(temp[-1] + 1)  # 将当前计算的结果记录到动态规划数组\n                states[-1] -= 1  # 减少完成的“quack”计数\n\n# 输出最大的大雁数量，如果没有找到有效的“quack”，则返回-1\nprint(max(dp) if dp else -1)",
    "javascript": "// 引入 readline 模块并创建接口用于读取来自标准输入（stdin）的数据\nconst rl = require(\"readline\").createInterface({ input: process.stdin });\n\n// 创建异步迭代器，用于按行读取输入\nvar iter = rl[Symbol.asyncIterator]();\n\n// 定义一个异步函数用于读取一行输入\nconst readline = async () => (await iter.next()).value;\n\n// 立即执行的异步函数，主逻辑在此执行\nvoid (async function () {\n    const chars = await readline();  // 读取一行输入数据（假设为大雁叫声的字符串）\n    const quack = \"quack\";  // 定义标准的“大雁叫声”顺序\n    const states = new Array(quack.length).fill(0);  // 初始化状态数组，用于跟踪每个字符的出现次数\n    const dp = [];  // 动态规划数组，用于记录完成“quack”时大雁的数量\n    let max_ = 0;  // 记录同时发出叫声的大雁的最大数量\n\n    // 遍历输入的每一个字符\n    for (let i = 0; i < chars.length; i++) {\n        const index = quack.indexOf(chars[i]);  // 查找当前字符在“quack”中的位置\n        if (index === -1) {  // 如果字符不在“quack”中，表示无效输入\n            console.log(-1);  // 输出-1表示错误\n            process.exit();  // 终止程序\n        }\n\n        if (index === 0) {  // 如果是“q”，表示一个新的大雁叫声的开始\n            states[index] += 1;  // 更新状态数组，记录一个新“q”的出现\n        } else {\n            if (states[index - 1]) {  // 如果前一个字符的状态有效\n                states[index - 1] -= 1;  // 前一个字符状态减1\n                states[index] += 1;  // 当前字符状态加1\n            }\n\n            // 如果当前字符是“k”，表示一个完整的“quack”结束\n            if (quack[quack.length - 1] === chars[i]) {\n                if (states[states.length - 1] !== 0) {  // 确保有一个完整的“quack”\n                    const temp = [...states];  // 当前状态数组\n                    temp[states.length - 1] = 0;  // 重置最后一个字符的状态\n                    max_ = Math.max(max_, temp.reduce((a, b) => a + b));  // 更新最大大雁数量\n\n                    // 检查剩余的字符，尝试找到更多的完整“quack”\n                    for (let j = i; j < chars.length; j++) {\n                        const index = quack.indexOf(chars[j]);  // 查找字符位置\n                        if (temp[index - 1]) {  // 如果前一个字符状态有效\n                            temp[index - 1] -= 1;  // 前一个字符状态减1\n                            temp[index] += 1;  // 当前字符状态加1\n                        }\n                        if (temp[temp.length - 1] === max_) {  // 如果达到最大大雁数量\n                            break;  // 停止搜索\n                        }\n                    }\n                    dp.push(temp[temp.length - 1] + 1);  // 记录当前的最大大雁数量\n                    states[states.length - 1] -= 1;  // 减少完成的“quack”计数\n                }\n            }\n        }\n    }\n\n    // 输出最大的大雁数量，如果没有找到有效的“quack”，则返回-1\n    console.log(dp.length ? Math.max(...dp) : -1);\n})();",
    "cpp": "#include <iostream>    \n#include <vector>      \n#include <algorithm>    \n#include <numeric>       \n\nusing namespace std;\n\nint main() {\n    string chars;  // 定义输入字符串，用于存储游客听到的大雁叫声\n    cin >> chars;  // 从标准输入中读取字符串\n    string quack = \"quack\";  // 定义标准的大雁叫声顺序\n    vector<int> states(quack.size(), 0);  // 定义一个状态数组，用于跟踪每个字符的出现次数\n    vector<int> dp;  // 动态规划数组，用于记录完成“quack”时大雁的数量\n    int max_ = 0;  // 用于记录同时发出叫声的大雁的最大数量\n\n    // 遍历输入字符串中的每一个字符\n    for (int i = 0; i < chars.size(); i++) {\n        int index = quack.find(chars[i]);  // 找到当前字符在“quack”中的位置\n        if (index == -1) {  // 如果字符不在“quack”中，输出-1并结束程序\n            cout << -1 << endl;\n            exit(0);\n        }\n\n        if (index == 0) {  // 如果是“q”，表示一个新的大雁叫声的开始\n            states[index] += 1;  // 更新状态数组，表示一个新“q”的开始\n        }\n        else {\n            if (states[index - 1]) {  // 检查前一个字符的状态是否有效\n                states[index - 1] -= 1;  // 前一个字符的状态减1\n                states[index] += 1;  // 当前字符的状态加1\n            }\n\n            if (quack[quack.size() - 1] == chars[i]) {  // 如果当前字符是“k”，表示一个完整的“quack”结束\n                if (states[states.size() - 1] != 0) {  // 确保有一个完整的“quack”存在\n                    vector<int> temp(states);  // 当前状态数组\n                    temp[states.size() - 1] = 0;  // 重置最后一个字符的状态\n                    max_ = max(max_, accumulate(temp.begin(), temp.end(), 0));  // 更新最大大雁数量\n\n                    // 检查剩余的字符，尝试找到更多的完整“quack”\n                    for (int j = i; j < chars.size(); j++) {\n                        index = quack.find(chars[j]);\n                        if (temp[index - 1]) {  // 检查前一个字符的状态是否有效\n                            temp[index - 1] -= 1;  // 前一个字符的状态减1\n                            temp[index] += 1;  // 当前字符的状态加1\n                        }\n                        if (temp[states.size() - 1] == max_) {  // 如果达到最大大雁数量，停止循环\n                            break;\n                        }\n                    }\n                    dp.push_back(temp[states.size() - 1] + 1);  // 记录当前的最大大雁数量\n                    states[states.size() - 1] -= 1;  // 减少完成的“quack”计数\n                }\n            }\n        }\n    }\n\n    // 输出最大的大雁数量，如果没有找到有效的“quack”，则返回-1\n    cout << (dp.empty() ? -1 : *max_element(dp.begin(), dp.end())) << endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>   // 标准输入输出库\n#include <stdlib.h>  // 包含 exit 函数\n#include <string.h>  // 字符串处理库\n\n#define MAX_LEN 1000  // 定义输入字符串的最大长度\n\nint main() {\n    char chars[MAX_LEN];  // 定义输入字符串数组，用于存储游客听到的大雁叫声\n    scanf(\"%s\", chars);  // 从标准输入中读取字符串\n    char quack[] = \"quack\";  // 定义标准的大雁叫声顺序\n    int states[5] = {0};  // 定义一个状态数组，用于跟踪每个字符的出现次数\n    int dp[MAX_LEN] = {0};  // 动态规划数组，用于记录完成“quack”时大雁的数量\n    int max_ = 0;  // 用于记录同时发出叫声的大雁的最大数量\n    int dp_index = 0;  // 动态规划数组的索引\n\n    // 遍历输入字符串中的每一个字符\n    for (int i = 0; i < strlen(chars); i++) {\n        int index = -1;  // 用于存储当前字符在“quack”中的位置\n        for (int k = 0; k < strlen(quack); k++) {  // 手动查找当前字符在“quack”中的位置\n            if (chars[i] == quack[k]) {\n                index = k;\n                break;\n            }\n        }\n        if (index == -1) {  // 如果字符不在“quack”中，输出-1并结束程序\n            printf(\"-1\\n\");\n            exit(0);\n        }\n\n        if (index == 0) {  // 如果是“q”，表示一个新的大雁叫声的开始\n            states[index] += 1;  // 更新状态数组，表示一个新“q”的开始\n        }\n        else {\n            if (states[index - 1]) {  // 检查前一个字符的状态是否有效\n                states[index - 1] -= 1;  // 前一个字符的状态减1\n                states[index] += 1;  // 当前字符的状态加1\n            }\n\n            if (quack[strlen(quack) - 1] == chars[i]) {  // 如果当前字符是“k”，表示一个完整的“quack”结束\n                if (states[strlen(quack) - 1] != 0) {  // 确保有一个完整的“quack”存在\n                    int temp[5];  // 定义临时状态数组\n                    for (int t = 0; t < 5; t++) {\n                        temp[t] = states[t];  // 当前状态数组\n                    }\n                    temp[strlen(quack) - 1] = 0;  // 重置最后一个字符的状态\n                    int temp_sum = 0;  // 计算当前状态数组的和\n                    for (int t = 0; t < 5; t++) {\n                        temp_sum += temp[t];\n                    }\n                    if (temp_sum > max_) {  // 更新最大大雁数量\n                        max_ = temp_sum;\n                    }\n\n                    // 检查剩余的字符，尝试找到更多的完整“quack”\n                    for (int j = i; j < strlen(chars); j++) {\n                        int inner_index = -1;\n                        for (int k = 0; k < strlen(quack); k++) {\n                            if (chars[j] == quack[k]) {\n                                inner_index = k;\n                                break;\n                            }\n                        }\n                        if (temp[inner_index - 1]) {  // 检查前一个字符的状态是否有效\n                            temp[inner_index - 1] -= 1;  // 前一个字符的状态减1\n                            temp[inner_index] += 1;  // 当前字符的状态加1\n                        }\n                        if (temp[strlen(quack) - 1] == max_) {  // 如果达到最大大雁数量，停止循环\n                            break;\n                        }\n                    }\n                    dp[dp_index++] = temp[strlen(quack) - 1] + 1;  // 记录当前的最大大雁数量\n                    states[strlen(quack) - 1] -= 1;  // 减少完成的“quack”计数\n                }\n            }\n        }\n    }\n\n    // 输出最大的大雁数量，如果没有找到有效的“quack”，则返回-1\n    if (dp_index == 0) {\n        printf(\"-1\\n\");\n    } else {\n        int result = dp[0];\n        for (int i = 1; i < dp_index; i++) {\n            if (dp[i] > result) {\n                result = dp[i];\n            }\n        }\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}"
  }
}