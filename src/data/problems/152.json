{
  "id": "152",
  "title": "学生方阵",
  "examType": "A",
  "score": 200,
  "description": "学校组织活动，将学生排成一个矩形方阵。\n请在矩形方阵中找到最大的位置相连的男生数量。\n这个相连位置在一个直线上，方向可以是水平的，垂直的，成对角线的或者呈反对角线的。\n注：学生个数不会超过10000\n",
  "inputDesc": "输入的第一行为矩阵的行数和列数，接下来的n行为矩阵元素，元素间用”,”分隔。\n",
  "outputDesc": "输出一个整数，表示矩阵中最长的位置相连的男生个数。\n\n\n本题的解题思路其实不难，遍历查找矩阵中每一个M点，然后求该M点的水平、垂直、正对角线、反对角线，四个方向的M点个数，然后保留最大的个数，就是题解。\n\n但是这种方法会存在很多重复的查找，比如\n\n红色M是当前遍历到的M，绿色M是以红色M为原点查找到的M，如上图两个红色M点会重复查找同一条M链。\n为了避免这种重复查找，我们可以增加判断：\n如果当前M点的\n\n如上图红色M的左上、上、左点都是M，因此红色M的\n",
  "examples": [
    {
      "input": "3,4\nM,M,F,M\nF,M,M,F\nM,F,F,M",
      "output": "3",
      "explanation": "3行4列矩阵，最长连续M在对角线或水平方向，长度为3"
    },
    {
      "input": "2,3\nM,M,M\nF,F,F",
      "output": "3",
      "explanation": "第一行水平方向连续3个M"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**矩阵遍历**问题。\n\n**核心思路：**\n- 遍历每个M点，检查四个方向的连续M数量\n- 四个方向：水平、垂直、正对角线、反对角线\n- 避免重复计算：检查当前方向的前一个位置是否也是M\n\n**算法步骤：**\n1. 遍历矩阵找到每个M点\n2. 对每个M点检查4个方向\n3. 若该方向前一个位置不是M，则开始计数\n4. 沿该方向统计连续M的数量\n5. 保留最大值\n\n**时间复杂度**：O(R×C×max(R,C))",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n  static int n;\n  static int m;\n  static String[][] matrix;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in).useDelimiter(\"[,\\n]\");\n\n    n = sc.nextInt();\n    m = sc.nextInt();\n\n    matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = sc.next();\n      }\n    }\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    int ans = 0;\n\n    int[][] offsets = {{0, 1}, {1, 0}, {1, 1}, {1, -1}};\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        if (\"M\".equals(matrix[i][j])) {\n          for (int[] offset : offsets) {\n            int oldI = i - offset[0];\n            int oldJ = j - offset[1];\n\n            if (oldI >= 0 && oldI < n && oldJ >= 0 && oldJ < m && \"M\".equals(matrix[oldI][oldJ])) {\n              continue;\n            }\n\n            int len = 1;\n            int newI = i + offset[0];\n            int newJ = j + offset[1];\n\n            while (newI >= 0\n                && newI < n\n                && newJ >= 0\n                && newJ < m\n                && \"M\".equals(matrix[newI][newJ])) {\n              len++;\n              newI += offset[0];\n              newJ += offset[1];\n            }\n\n            ans = Math.max(ans, len);\n          }\n        }\n      }\n    }\n\n    return ans;\n  }\n}",
    "python": "# 输入获取\nn, m = map(int, input().split(\",\"))\nmatrix = [input().split(\",\") for _ in range(n)]\n\n\n# 算法入口\ndef getResult():\n    ans = 0\n\n    offsets = ((0, 1), (1, 0), (1, 1), (1, -1))\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == \"M\":\n                for offset in offsets:\n                    oldI = i - offset[0]\n                    oldJ = j - offset[1]\n\n                    if n > oldI >= 0 and m > oldJ >= 0 and matrix[oldI][oldJ] == \"M\":\n                        continue\n\n                    length = 1\n                    newI = i + offset[0]\n                    newJ = j + offset[1]\n\n                    while n > newI >= 0 and m > newJ >= 0 and matrix[newI][newJ] == \"M\":\n                        length += 1\n                        newI += offset[0]\n                        newJ += offset[1]\n\n                    ans = max(ans, length)\n\n    return ans\n\n\n# 调用算法\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}