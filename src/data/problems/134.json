{
  "id": "134",
  "title": "电脑病毒感染",
  "examType": "A",
  "score": 200,
  "description": "一个局域网内有很多台电脑，分别标注为 0 ~ N-1 的数字。相连接的电脑距离不一样，所以感染时间不一样，感染时间用 t 表示。\n其中网络内一台电脑被病毒感染，求其感染网络内所有的电脑最少需要多长时间。如果最后有电脑不会感染，则返回-1。\n给定一个数组 times 表示一台电脑把相邻电脑感染所用的时间。\n如图：path[i] = {i, j, t} 表示：电脑 i->j，电脑 i 上的病毒感染 j，需要时间 t。",
  "inputDesc": "第一行输入一个整数N ，表示局域网内电脑个数 N ，1 ≤ N ≤ 200 ;\n第二行输入一个整数M ,表示有 M 条网络连接；\n接下来M行 ,每行输入为 i , j , t 。表示电脑 i 感染电脑j 需要时间 t 。（1 ≤ i , j ≤ N）\n最后一行为病毒所在的电脑编号。",
  "outputDesc": "输出最少需要多少时间才能感染全部电脑，如果不存在输出 -1",
  "examples": [
    {
      "input": "4\n4\n1 2 2\n2 3 3\n3 4 1\n1 4 7\n1",
      "output": "6",
      "explanation": "从电脑1开始感染，1->2需2秒，2->3需3秒，3->4需1秒，共6秒感染全部"
    },
    {
      "input": "3\n2\n1 2 5\n2 3 3\n1",
      "output": "8",
      "explanation": "1->2需5秒，2->3需3秒，感染全部需8秒"
    },
    {
      "input": "3\n1\n1 2 5\n1",
      "output": "-1",
      "explanation": "电脑3无法被感染，返回-1"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**单源最短路径(Bellman-Ford)**问题。\n\n**核心思路：**\n- 求从病毒源到所有电脑的最短感染时间\n- 所有电脑都被感染的时间=最大的最短路径\n\n**算法步骤：**\n1. 初始化距离数组，源点为0，其余为无穷大\n2. 进行N-1轮松弛操作，遍历所有边更新最短距离\n3. 找出所有距离中的最大值\n4. 若存在无穷大距离，返回-1\n\n**时间复杂度**：O(V×E)，V为顶点数，E为边数",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt(); // 电脑的数量\n        int connections = sc.nextInt(); // 网络连接的数量\n        int[][] times = new int[connections][3]; // 存储每个连接和对应的感染时间\n        for (int i = 0; i < connections; i++) {\n            // 读取每个连接的信息，将电脑编号减1转换为从0开始的索引\n            times[i][0] = sc.nextInt() - 1; // 感染源电脑编号\n            times[i][1] = sc.nextInt() - 1; // 被感染电脑编号\n            times[i][2] = sc.nextInt(); // 感染所需时间\n        }\n        int initial = sc.nextInt() - 1; // 初始被感染的电脑编号，转换为从0开始的索引\n        sc.close(); // 关闭输入流\n\n        // 输出感染所有电脑所需的最少时间\n        System.out.println(networkDelayTime(times, N, initial));\n    }\n\n    // 计算感染所有电脑所需的最少时间的函数\n    public static int networkDelayTime(int[][] times, int N, int K) {\n        final int INF = Integer.MAX_VALUE / 2; // 定义无穷大的值，用于初始化距离数组\n        int[] dist = new int[N]; // 存储从源电脑到其他所有电脑的最短感染时间\n        Arrays.fill(dist, INF); // 初始化所有感染时间为无穷大\n        dist[K] = 0; // 源电脑的感染时间为0\n\n        // 使用Bellman-Ford算法更新所有电脑的最短感染时间\n        for (int i = 0; i < N; i++) {\n            for (int[] time : times) {\n                int u = time[0], v = time[1], w = time[2];\n                // 如果可以通过电脑u感染到电脑v，并且时间更短，则更新电脑v的感染时间\n                if (dist[u] + w < dist[v]) {\n                    dist[v] = dist[u] + w;\n                }\n            }\n        }\n\n        // 找出所有电脑中最长的感染时间\n        int maxWait = 0;\n        for (int i = 0; i < N; i++) {\n            // 如果有电脑的感染时间仍为无穷大，表示该电脑不可被感染，返回-1\n            if (dist[i] == INF) return -1;\n            // 更新最长的感染时间\n            maxWait = Math.max(maxWait, dist[i]);\n        }\n\n        // 返回感染所有电脑所需的最少时间\n        return maxWait;\n    }\n}",
    "python": "import sys\n\n# 计算感染所有电脑所需的最少时间的函数\ndef network_delay_time(times, N, K):\n    INF = float('inf')  # 定义无穷大的值，用于初始化距离数组\n    dist = [INF] * N  # 存储从源电脑到其他所有电脑的最短感染时间\n    dist[K] = 0  # 源电脑的感染时间为0\n\n    # 使用Bellman-Ford算法更新所有电脑的最短感染时间\n    for _ in range(N):\n        for u, v, w in times:\n            # 如果可以通过电脑u感染到电脑v，并且时间更短，则更新电脑v的感染时间\n            if dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n\n    # 找出所有电脑中最长的感染时间\n    max_wait = max(dist)\n    # 如果有电脑的感染时间仍为无穷大，表示该电脑不可被感染，返回-1\n    return max_wait if max_wait < INF else -1\n\n \nN = int(input())\nconnections = int(input()) # 电脑的数量和网络连接的数量\ntimes = []  # 存储每个连接和对应的感染时间\nfor _ in range(connections):\n    # 读取每个连接的信息，将电脑编号减1转换为从0开始的索引\n    u, v, w = map(int, input().split())\n    times.append((u - 1, v - 1, w))  # 感染源电脑编号，被感染电脑编号，感染所需时间\ninitial = int(input()) - 1  # 初始被感染的电脑编号，转换为从0开始的索引\n\n# 输出感染所有电脑所需的最少时间\nprint(network_delay_time(times, N, initial))",
    "javascript": "",
    "cpp": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n// 计算感染所有电脑所需的最少时间的函数\nint networkDelayTime(vector<vector<int>>& times, int N, int K) {\n    const int INF = INT_MAX / 2; // 定义无穷大的值，用于初始化距离数组\n    vector<int> dist(N, INF); // 存储从源电脑到其他所有电脑的最短感染时间\n    dist[K] = 0; // 源电脑的感染时间为0\n\n    // 使用Bellman-Ford算法更新所有电脑的最短感染时间\n    for (int i = 0; i < N; ++i) {\n        for (const auto& time : times) {\n            int u = time[0], v = time[1], w = time[2];\n            // 如果可以通过电脑u感染到电脑v，并且时间更短，则更新电脑v的感染时间\n            if (dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n\n    // 找出所有电脑中最长的感染时间\n    int maxWait = 0;\n    for (int i = 0; i < N; ++i) {\n        // 如果有电脑的感染时间仍为无穷大，表示该电脑不可被感染，返回-1\n        if (dist[i] == INF) return -1;\n        // 更新最长的感染时间\n        maxWait = max(maxWait, dist[i]);\n    }\n\n    // 返回感染所有电脑所需的最少时间\n    return maxWait;\n}\n\nint main() {\n    int N, connections;\n    cin >> N >> connections; // 电脑的数量和网络连接的数量\n    vector<vector<int>> times(connections, vector<int>(3)); // 存储每个连接和对应的感染时间\n    for (int i = 0; i < connections; ++i) {\n        // 读取每个连接的信息，将电脑编号减1转换为从0开始的索引\n        cin >> times[i][0] >> times[i][1] >> times[i][2];\n        times[i][0]--; // 感染源电脑编号\n        times[i][1]--; // 被感染电脑编号\n    }\n    int initial;\n    cin >> initial; // 初始被感染的电脑编号，转换为从0开始的索引\n    initial--;\n\n    // 输出感染所有电脑所需的最少时间\n    cout << networkDelayTime(times, N, initial) << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h> // 引入INT_MAX\n\n#define INF (INT_MAX / 2) // 定义无穷大的值\n\n// 计算感染所有电脑所需的最少时间\nint networkDelayTime(int times[][3], int connections, int N, int K) {\n    int dist[N]; // 存储从源电脑到其他所有电脑的最短感染时间\n    for (int i = 0; i < N; i++) {\n        dist[i] = INF; // 初始化所有感染时间为无穷大\n    }\n    dist[K] = 0; // 源电脑的感染时间设为0\n\n    // 使用Bellman-Ford算法更新所有电脑的最短感染时间\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < connections; j++) {\n            int u = times[j][0], v = times[j][1], w = times[j][2];\n            // 如果可以通过电脑u感染到电脑v，并且时间更短，则更新电脑v的感染时间\n            if (dist[u] != INF && dist[u] + w < dist[v]) {\n                dist[v] = dist[u] + w;\n            }\n        }\n    }\n\n    // 找出所有电脑中最长的感染时间\n    int maxWait = 0;\n    for (int i = 0; i < N; i++) {\n        // 如果有电脑的感染时间仍为无穷大，表示该电脑不可被感染，返回-1\n        if (dist[i] == INF) return -1;\n        // 更新最长的感染时间\n        if (dist[i] > maxWait) {\n            maxWait = dist[i];\n        }\n    }\n\n    // 返回感染所有电脑所需的最少时间\n    return maxWait;\n}\n\nint main() {\n    int N, connections; // 电脑的数量和网络连接的数量\n    scanf(\"%d\", &N );\n    scanf(\"%d\",  &connections);\n\n    int times[connections][3]; // 存储每个连接和对应的感染时间\n\n    // 读取网络连接信息\n    for (int i = 0; i < connections; i++) {\n        scanf(\"%d %d %d\", &times[i][0], &times[i][1], &times[i][2]);\n        times[i][0]--; // 将电脑编号转换为从0开始的索引\n        times[i][1]--;\n    }\n\n    int initial; // 初始被感染的电脑编号\n    scanf(\"%d\", &initial);\n    initial--; // 转换为从0开始的索引\n\n    // 输出感染所有电脑所需的最少时间\n    printf(\"%d\\n\", networkDelayTime(times, connections, N, initial));\n\n    return 0;\n}"
  }
}