{
  "id": "128",
  "title": "最佳对手实力差距最小总和",
  "examType": "A",
  "score": 200,
  "description": "游戏里面，队伍通过匹配实力相近的对手进行对战。但是如果匹配的队伍实力相差太大，对于双方游戏体验都不会太好。\n给定n个队伍的实力值，对其进行两两实力匹配，两支队伍实例差距在允许的最大差距d内，则可以匹配。 要求在匹配队伍最多的情况下匹配出的各组实力差距的总和最小。",
  "inputDesc": "第一行，n，d。队伍个数n。允许的最大实力差距d。\n2<=n <=500<=d<=100\n第二行，n个队伍的实力值空格分割。\n0<=各队伍实力值<=100",
  "outputDesc": "匹配后，各组对战的实力差值的总和。若没有队伍可以匹配，则输出-1。",
  "examples": [
    {
      "input": "5 30\n87 47 59 81 18",
      "output": "57",
      "explanation": "排序后[18,47,59,81,87]，18与47配对(29)，59与81配对(22)，总差距51。或其他最优配对"
    },
    {
      "input": "6 20\n87 47 59 81 81 18",
      "output": "12",
      "explanation": "最多能匹配3对。47与59配对(12)，81与81配对(0)。总差距12"
    },
    {
      "input": "3 10\n51 62 73",
      "output": "-1",
      "explanation": "实力差距都在10以上，没有队伍可以匹配成功"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**排序+动态规划**问题。\n\n**核心思路：**\n- 先排序，使相邻元素差距最小\n- DP求最多配对数和最小差距和\n- pairs[i]：前i个队伍最多配对数\n- min_sum[i]：前i个队伍最小差距和\n\n**状态转移：**\n- 若nums[i-1]-nums[i-2]≤d，可配对\n- 选择配对或不配对，优先配对数多，其次差距和小\n\n**时间复杂度**：O(NlogN)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // 读取队伍数量 n 和最大允许差距 d\n        int n = scanner.nextInt();  \n        int d = scanner.nextInt();  \n        \n        // 用来存储各队伍的实力值\n        List<Integer> nums = new ArrayList<>();  \n        \n        // 读取每个队伍的实力值并添加到 nums 列表中\n        for (int i = 0; i < n; i++) {  \n            int num = scanner.nextInt();\n            nums.add(num);\n        }\n        \n        // 对队伍实力值进行升序排序，方便后续贪心和动态规划处理\n        Collections.sort(nums);  \n\n        // 初始化 pairs 列表，存储能匹配的对的数量，n+1个元素，初始值为 0\n        List<Integer> pairs = new ArrayList<>(Collections.nCopies(n+1, 0));  \n        \n        // 初始化 min_sum 列表，存储最小的差值总和，n+1个元素，初始值为 0\n        List<Integer> min_sum = new ArrayList<>(Collections.nCopies(n+1, 0));  \n\n        // 从第3个元素开始考虑配对（因为要两两配对，所以从2开始）\n        for (int i = 2; i < n+1; i++) {\n            int tmp = 0;\n            \n            // 如果当前两支队伍的实力差距在允许范围内，tmp置为1，表示可以匹配\n            if (nums.get(i-1) - nums.get(i-2) <= d) {\n                tmp += 1;\n            }\n\n            // 比较是否选择配对前两支队伍能获得更多的匹配数量\n            if (pairs.get(i-2) + tmp > pairs.get(i-1)) {\n                // 如果配对前两支队伍能得到更多的配对数量，更新 pairs 和 min_sum\n                pairs.set(i, pairs.get(i-2) + tmp);  \n                min_sum.set(i, min_sum.get(i-2) + nums.get(i-1) - nums.get(i-2));  \n            }\n            // 如果不配对前两支队伍能保持或增加匹配数量，则选择不配对\n            else if (pairs.get(i-2) + tmp < pairs.get(i-1)) {\n                // 配对数量不增加，保持原有的状态\n                pairs.set(i, pairs.get(i-1));  \n                min_sum.set(i, min_sum.get(i-1));  \n            }\n            // 如果配对数量相同，则选择差距更小的配对策略\n            else {\n                if (tmp == 1) {\n                    // 如果配对，选择较小的差值总和\n                    min_sum.set(i, Math.min(min_sum.get(i-1), min_sum.get(i-2) + nums.get(i-1) - nums.get(i-2)));  \n                }\n                else {\n                    // 如果不配对，选择保持原有的差值总和\n                    min_sum.set(i, Math.min(min_sum.get(i-1), min_sum.get(i-2)));  \n                }\n                pairs.set(i, pairs.get(i-1));  // 匹配数量保持不变\n            }\n        }\n\n        // 最终结果：如果没有任何队伍配对成功，输出 -1，否则输出最小的差值总和\n        if (pairs.get(n) == 0) {\n            System.out.println(-1);  // 无法配对\n        } else {\n            System.out.println(min_sum.get(n));  // 输出最小的差值总和\n        }\n    }\n}",
    "python": "n, d = map(int, input().split())\nnums = list(map(int, input().split()))\nnums.sort()\n\npairs = [0] * (n+1)\nmin_sum = [0] * (n+1)\n\nfor i in range(2, n+1):\n    tmp = 0\n    if nums[i-1] - nums[i-2] <= d:\n        tmp += 1\n    if pairs[i-2] + tmp > pairs[i-1]:\n        pairs[i] = pairs[i-2] + tmp\n        min_sum[i] = min_sum[i-2] + nums[i-1] - nums[i-2]\n    elif pairs[i-2] + tmp < pairs[i-1]:\n        pairs[i] = pairs[i-1]\n        min_sum[i] = min_sum[i-1]\n    else:\n        if tmp == 1:\n            min_sum[i] = min(min_sum[i-1], min_sum[i-2] + nums[i-1] - nums[i-2])\n        else:\n            min_sum[i] = min(min_sum[i-1], min_sum[i-2])\n        pairs[i] = pairs[i-1]\n\nif pairs[n] == 0:\n    print(-1)\nelse:\n    print(min_sum[n])",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet input = [];\nrl.on('line', (line) => {\n  input.push(line);\n  if(input.length === 2){\n    const [n, d] = input[0].split(' ').map(Number);\n    const nums = input[1].split(' ').map(Number).sort((a, b) => a - b);\n\n    //pair个数\n    const pairs = new Array(n+1).fill(0);\n    //最小和\n    const min_sum = new Array(n+1).fill(0);\n\n    // 动态规划求解最小和\n    for (let i = 2; i < n+1; i++){\n        let tmp = 0;\n        // 如果两个队伍之间的实力差距小于等于d，则它们可以匹配\n        if (nums[i-1] - nums[i-2] <= d)\n            tmp += 1;\n\n        // 如果匹配i-1个队伍的最小和小于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-2个队伍的最小和加上i-1和i队伍的实力差距\n        if (pairs[i-2] + tmp > pairs[i-1]){\n            pairs[i] = pairs[i-2] + tmp;\n            min_sum[i] = min_sum[i-2] + nums[i-1] - nums[i-2];\n        }\n        // 如果匹配i-1个队伍的最小和大于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-1个队伍的最小和\n        else if (pairs[i-2] + tmp < pairs[i-1]){\n            pairs[i] = pairs[i-1];\n            min_sum[i] = min_sum[i-1];\n        }\n        // 如果匹配i-1个队伍的最小和等于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-1个队伍的最小和和匹配i-2个队伍的最小和加上i-1和i队伍的实力差距的最小值\n        else{\n            if (tmp == 1)\n                min_sum[i] = Math.min(min_sum[i-1], min_sum[i-2] + nums[i-1] - nums[i-2]);\n            else\n                min_sum[i] = Math.min(min_sum[i-1], min_sum[i-2]);\n            pairs[i] = pairs[i-1];\n        }\n    }\n\n    // 如果没有队伍可以匹配，则输出-1\n    if (pairs[n] == 0)\n        console.log(-1);\n    else\n        console.log(min_sum[n]);\n\n    rl.close();\n  }\n});",
    "cpp": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main() {\n    // 处理输入\n    int n, d; \n    cin >> n >> d;\n    vector<int> nums;\n    for(int i = 0; i < n; i++){\n        int num;\n        cin >> num;\n        nums.push_back(num);\n    }\n    // 按照大小排序\n    sort(nums.begin(), nums.end());\n\n    //pair个数\n    vector<int> pairs (n+1, 0);\n    //最小和\n    vector<int> min_sum (n+1, 0);\n\n    // 动态规划求解最小和\n    for (int i = 2; i < n+1; i++){\n        int tmp = 0;\n        // 如果两个队伍之间的实力差距小于等于d，则它们可以匹配\n        if (nums[i-1] - nums[i-2] <= d)\n            tmp += 1;\n\n        // 如果匹配i-1个队伍的最小和小于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-2个队伍的最小和加上i-1和i队伍的实力差距\n        if (pairs[i-2] + tmp > pairs[i-1]){\n            pairs[i] = pairs[i-2] + tmp;\n            min_sum[i] = min_sum[i-2] + nums[i-1] - nums[i-2];\n        }\n        // 如果匹配i-1个队伍的最小和大于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-1个队伍的最小和\n        else if (pairs[i-2] + tmp < pairs[i-1]){\n            pairs[i] = pairs[i-1];\n            min_sum[i] = min_sum[i-1];\n        }\n        // 如果匹配i-1个队伍的最小和等于匹配i-2个队伍的最小和，那么匹配i个队伍的最小和就是匹配i-1个队伍的最小和和匹配i-2个队伍的最小和加上i-1和i队伍的实力差距的最小值\n        else{\n            if (tmp == 1)\n                min_sum[i] = min(min_sum[i-1], min_sum[i-2] + nums[i-1] - nums[i-2]);\n            else\n                min_sum[i] = min(min_sum[i-1], min_sum[i-2]);\n            pairs[i] = pairs[i-1];\n        }\n    }\n\n    // 如果没有队伍可以匹配，则输出-1\n    if (pairs[n] == 0)\n        cout << -1;\n    else\n        cout << min_sum[n];\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 比较函数，用于升序排序\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint main() {\n    int n, d;\n    \n    // 读取队伍数量 n 和最大允许差距 d\n    scanf(\"%d %d\", &n, &d);\n    \n    // 动态分配数组 nums，用于存储队伍的实力值\n    int *nums = (int *)malloc(n * sizeof(int));\n    \n    // 读取每个队伍的实力值并存储到 nums 数组中\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &nums[i]);\n    }\n    \n    // 对队伍实力值进行升序排序\n    qsort(nums, n, sizeof(int), compare);\n    \n    // 动态分配数组 pairs，用于存储能匹配的对的数量，初始化为 0\n    int *pairs = (int *)calloc(n + 1, sizeof(int));\n    \n    // 动态分配数组 min_sum，用于存储最小的差值总和，初始化为 0\n    int *min_sum = (int *)calloc(n + 1, sizeof(int));\n\n    // 从第3个元素开始考虑配对（因为要两两配对，所以从 i = 2 开始）\n    for (int i = 2; i <= n; i++) {\n        int tmp = 0;\n\n        // 如果当前两支队伍的实力差距在允许范围内，tmp 置为 1，表示可以匹配\n        if (nums[i - 1] - nums[i - 2] <= d) {\n            tmp = 1;\n        }\n\n        // 如果配对前两支队伍的匹配数加上 tmp 比上一支队伍的匹配数更多\n        if (pairs[i - 2] + tmp > pairs[i - 1]) {\n            // 更新 pairs 和 min_sum，记录新的匹配数量和最小差值总和\n            pairs[i] = pairs[i - 2] + tmp;\n            min_sum[i] = min_sum[i - 2] + (nums[i - 1] - nums[i - 2]);\n        }\n        // 如果不配对前两支队伍能保持或增加匹配数量，则选择不配对\n        else if (pairs[i - 2] + tmp < pairs[i - 1]) {\n            pairs[i] = pairs[i - 1];\n            min_sum[i] = min_sum[i - 1];\n        }\n        // 如果配对数量相同，则选择差距更小的配对策略\n        else {\n            if (tmp == 1) {\n                // 如果配对，选择较小的差值总和\n                min_sum[i] = (min_sum[i - 1] < min_sum[i - 2] + (nums[i - 1] - nums[i - 2])) ? min_sum[i - 1] : (min_sum[i - 2] + (nums[i - 1] - nums[i - 2]));\n            } else {\n                // 如果不配对，选择保持原有的差值总和\n                min_sum[i] = (min_sum[i - 1] < min_sum[i - 2]) ? min_sum[i - 1] : min_sum[i - 2];\n            }\n            pairs[i] = pairs[i - 1];\n        }\n    }\n\n    // 最终结果：如果没有任何队伍配对成功，输出 -1，否则输出最小的差值总和\n    if (pairs[n] == 0) {\n        printf(\"-1\\n\");  // 无法配对\n    } else {\n        printf(\"%d\\n\", min_sum[n]);  // 输出最小的差值总和\n    }\n\n    // 释放动态分配的内存\n    free(nums);\n    free(pairs);\n    free(min_sum);\n\n    return 0;\n}"
  }
}