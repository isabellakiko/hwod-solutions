{
  "id": "121",
  "title": "宜居星球改造计划",
  "examType": "A",
  "score": 200,
  "description": "2XXX年，人类通过对火星的大气进行宜居改造分析，使得火星已在理论上具备人类宜居的条件；\n由于技术原因，无法一次性将火星大气全部改造，只能通过局部处理形式；\n假设将火星待改造的区域为row * column的网格，每个网格有3个值，宜居区、可改造区、死亡区，使用YES、NO、NA代替，YES表示该网格已经完成大气改造，NO表示该网格未进行改造，后期可进行改造，NA表示死亡区，不作为判断是否改造完的宜居，无法穿过；\n初始化下，该区域可能存在多个宜居区，并目每个宜居区能同时在每个大阳日单位向上下左右四个方向的相邻格子进行扩散，自动将4个方向相邻的真空区改造成宜居区；\n请计算这个待改造区域的网格中，可改造区是否能全部成宜居区，如果可以，则返回改造的大阳日天教，不可以则返回-1",
  "inputDesc": "输入row * column个网格数据，每个网格值枚举值如下: YES，NO，NA；\n样例:、\n123\ngrid[i][j]只有3种情况，YES、NO、NA\nrow == grid.lengthcolumn == grid[i].length1 ≤ row, column ≤ 8",
  "outputDesc": "可改造区是否能全部变成宜居区，如果可以，则返回改造的太阳日天数，不可以则返回-1。",
  "examples": [
    {
      "input": "YES YES NO\nNO NO NO\nYES NO NO",
      "output": "2",
      "explanation": "经过2个太阳日，所有NO区域被相邻YES扩散改造"
    },
    {
      "input": "NO NA",
      "output": "-1",
      "explanation": "无初始YES区域，无法进行改造"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**多源BFS**问题（类似腐烂的橘子）。\n\n**核心思路：**\n- YES为已改造区，NO为待改造区，NA为死亡区\n- 所有YES同时向四周扩散\n- 计算将所有NO变为YES需要的天数\n\n**算法步骤：**\n1. 将所有YES位置入队，统计NO数量\n2. BFS逐层扩散，每层代表一天\n3. 扩散结束后检查是否还有NO\n4. 有则返回-1，无则返回天数\n\n**时间复杂度**：O(N×M)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<String> lines = new ArrayList<>();\n        \n        // 读取输入，存入列表中\n        while (sc.hasNextLine()) {\n            String line = sc.nextLine();\n            if (line.isEmpty()) break;\n            lines.add(line);\n        }\n        \n        int rows = lines.size();\n        int cols = lines.get(0).split(\" \").length;\n        \n        String[][] grid = new String[rows][cols];\n        Queue<int[]> q = new LinkedList<>();\n        int toConvert = 0;  // 需要改造的区域数量\n        \n        // 初始化网格和队列\n        for (int r = 0; r < rows; r++) {\n            String[] row = lines.get(r).split(\" \");\n            for (int c = 0; c < cols; c++) {\n                grid[r][c] = row[c];\n                if (row[c].equals(\"YES\")) {\n                    q.add(new int[]{r, c});\n                } else if (row[c].equals(\"NO\")) {\n                    toConvert++;\n                }\n            }\n        }\n        \n        // 无初始改造点或全不可改造\n        if (q.isEmpty()) {\n            System.out.println(-1);\n            return;\n        }\n        \n        // 方向数组（上下左右）\n        int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        int days = 0;  // 改造天数\n        \n        // 广度优先搜索\n        while (!q.isEmpty() && toConvert > 0) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int[] pos = q.poll();\n                for (int[] dir : dirs) {\n                    int newRow = pos[0] + dir[0];\n                    int newCol = pos[1] + dir[1];\n                    \n                    if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].equals(\"NO\")) {\n                        grid[newRow][newCol] = \"YES\";\n                        q.add(new int[]{newRow, newCol});\n                        toConvert--;\n                    }\n                }\n            }\n            days++;\n        }\n        \n        System.out.println(toConvert == 0 ? days : -1);\n    }\n}",
    "python": "import sys\n\ngrid = []  # 网格\nfor line in sys.stdin:\n    line = line.strip()\n    if not line:\n        break\n    else:\n        row = line.split()\n        grid.append(row)\n\nrows = len(grid)\ncols = len(grid[0])\n\nq = []  # 存储已经改造的位置\ntoConvert = 0  # 需要改造的位置数\n\nfor r in range(rows):\n    for c in range(cols):\n        val = grid[r][c]\n        if val == \"YES\":\n            q.append([r, c])\n        elif val == \"NO\":\n            toConvert += 1\n\nif not q:  # 如果没有已经改造的位置，则无法继续改造\n    print(-1)\n    sys.exit()\nif len(q) == rows * cols:  # 如果所有位置都已经改造，则不需要继续改造\n    print(0)\n    sys.exit()\n\ndays = 0  # 改造天数\ndirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]  # 上下左右四个方向\n\nwhile q and toConvert > 0:  # 只要还有需要改造的位置，就继续改造\n    new_q = []  # 存储新改造的位置\n\n    for pos in q:\n        x, y = pos\n        for dir in dirs:\n            new_x = x + dir[0]\n            new_y = y + dir[1]\n\n            if 0 <= new_x < rows and 0 <= new_y < cols and grid[new_x][new_y] == \"NO\":  # 如果新位置可以改造，就改造它\n                grid[new_x][new_y] = \"YES\"\n                new_q.append([new_x, new_y])\n                toConvert -= 1\n\n    days += 1  # 改造天数加一\n    q = new_q  # 更新已经改造的位置\n\nif toConvert == 0:\n    print(days)  # 如果所有位置都已经改造，则返回改造的天数\nelse:\n    print(-1)  # 否则返回-1",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet grid = []; // 网格\nrl.on('line', (line) => {\n  if (line === '') {\n    rl.close();\n  } else {\n    let row = [];\n    let start = 0, end = 0;\n    while (end !== -1) {\n      end = line.indexOf(' ', start);\n      row.push(line.substring(start, end !== -1 ? end : undefined));\n      start = end + 1;\n    }\n    grid.push(row);\n  }\n}).on('close', () => {\n  let rows = grid.length;\n  let cols = grid[0].length;\n\n  let q = []; // 存储已经改造的位置\n  let toConvert = 0; // 需要改造的位置数\n\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      let val = grid[r][c];\n      if (val === 'YES') {\n        q.push([r, c]);\n      } else if (val === 'NO') {\n        toConvert++;\n      }\n    }\n  }\n\n  if (q.length === 0) { // 如果没有已经改造的位置，则无法继续改造\n    console.log(-1);\n    process.exit(0);\n  }\n  if (q.length === rows * cols) { // 如果所有位置都已经改造，则不需要继续改造\n    console.log(0);\n    process.exit(0);\n  }\n\n  let days = 0; // 改造天数\n  let dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]]; // 上下左右四个方向\n\n  while (q.length > 0 && toConvert > 0) { // 只要还有需要改造的位置，就继续改造\n    let new_q = []; // 存储新改造的位置\n\n    for (let pos of q) {\n      let x = pos[0], y = pos[1];\n      for (let dir of dirs) {\n        let new_x = x + dir[0];\n        let new_y = y + dir[1];\n\n        if (new_x >= 0 && new_x < rows && new_y >= 0 && new_y < cols && grid[new_x][new_y] === 'NO') { // 如果新位置可以改造，就改造它\n          grid[new_x][new_y] = 'YES';\n          new_q.push([new_x, new_y]);\n          toConvert--;\n        }\n      }\n    }\n\n    days++; // 改造天数加一\n    q = new_q; // 更新已经改造的位置\n  }\n\n  if (toConvert === 0) console.log(days); // 如果所有位置都已经改造，则返回改造的天数\n  else console.log(-1); // 否则返回-1\n});",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    vector<vector<string>> grid; // 网格\n    string line;\n    while (getline(cin, line)) {\n        if (line.empty()) {\n            break;\n        } else {\n            vector<string> row;\n            size_t start = 0, end = 0;\n            while (end != string::npos) {\n                end = line.find(' ', start);\n                row.push_back(line.substr(start, end - start));\n                start = end + 1;\n            }\n            grid.push_back(row);\n        }\n    }\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n \n    vector<vector<int>> q; // 存储已经改造的位置\n    int toConvert = 0; // 需要改造的位置数\n \n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            string val = grid[r][c];\n            if (val == \"YES\") {\n                q.push_back({r, c});\n            } else if (val == \"NO\") {\n                toConvert++;\n            }\n        }\n    }\n \n    if (q.empty()) { // 如果没有已经改造的位置，则无法继续改造\n        cout << -1 << endl;\n        return 0;\n    }\n    if (q.size() == rows * cols) { // 如果所有位置都已经改造，则不需要继续改造\n        cout << 0 << endl;\n        return 0;\n    }\n \n    int days = 0; // 改造天数\n    vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 上下左右四个方向\n \n    while (!q.empty() && toConvert > 0) { // 只要还有需要改造的位置，就继续改造\n        vector<vector<int>> new_q; // 存储新改造的位置\n \n        for (vector<int> pos : q) {\n            int x = pos[0], y = pos[1];\n            for (vector<int> dir : dirs) {\n                int new_x = x + dir[0];\n                int new_y = y + dir[1];\n \n                if (new_x >= 0\n                    && new_x < rows\n                    && new_y >= 0\n                    && new_y < cols\n                    && grid[new_x][new_y] == \"NO\") { // 如果新位置可以改造，就改造它\n                    grid[new_x][new_y] = \"YES\";\n                    new_q.push_back({new_x, new_y});\n                    toConvert--;\n                }\n            }\n        }\n \n        days++; // 改造天数加一\n        q = new_q; // 更新已经改造的位置\n    }\n \n    if (toConvert == 0) cout << days << endl; // 如果所有位置都已经改造，则返回改造的天数\n    else cout << -1 << endl; // 否则返回-1\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n\n// 队列数据结构\nint queue[MAX_ROWS * MAX_COLS][2];\nint front = 0, rear = 0;\n\n// 简单的方向数组（上、下、左、右）\nint dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n// 检查队列是否为空\nint isQueueEmpty() {\n    return front == rear;\n}\n\n// 入队操作\nvoid enqueue(int row, int col) {\n    queue[rear][0] = row;\n    queue[rear][1] = col;\n    rear++;\n}\n\n// 出队操作\nvoid dequeue(int* row, int* col) {\n    *row = queue[front][0];\n    *col = queue[front][1];\n    front++;\n}\n\nint main() {\n    char grid[MAX_ROWS][MAX_COLS][4]; // 网格字符串\n    char line[256];\n    int rows = 0, cols = 0;\n    int toConvert = 0; // 需要改造的区域数量\n    int days = 0;      // 改造天数\n\n    // 读取输入并初始化网格\n    while (fgets(line, sizeof(line), stdin)) {\n        if (line[0] == '\\n') break; // 结束输入\n        char *token = strtok(line, \" \");\n        int col = 0;\n        while (token) {\n            strcpy(grid[rows][col], token);\n            token = strtok(NULL, \" \");\n            col++;\n        }\n        cols = col; // 记录列数\n        rows++;\n    }\n\n    // 初始化网格并查找初始的 \"YES\" 和 \"NO\" 位置\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            if (strcmp(grid[r][c], \"YES\") == 0) {\n                enqueue(r, c); // 将 \"YES\" 位置加入队列\n            } else if (strcmp(grid[r][c], \"NO\") == 0) {\n                toConvert++; // 统计需要改造的 \"NO\" 区域数量\n            }\n        }\n    }\n\n    // 如果没有初始的 \"YES\" 或者没有需要改造的 \"NO\"，则输出 -1\n    if (isQueueEmpty()) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    // 广度优先搜索 (BFS) 开始改造\n    while (!isQueueEmpty() && toConvert > 0) {\n        int size = rear - front; // 当前队列中的元素数量\n        for (int i = 0; i < size; i++) {\n            int row, col;\n            dequeue(&row, &col);\n            for (int j = 0; j < 4; j++) {\n                int newRow = row + dirs[j][0];\n                int newCol = col + dirs[j][1];\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols &&\n                    strcmp(grid[newRow][newCol], \"NO\") == 0) {\n                    strcpy(grid[newRow][newCol], \"YES\"); // 将 \"NO\" 改为 \"YES\"\n                    enqueue(newRow, newCol);             // 将新改造的点加入队列\n                    toConvert--;                        // 剩余待改造的区域减1\n                }\n            }\n        }\n        days++; // 每一轮结束，增加一天\n    }\n\n    // 输出结果\n    printf(\"%d\\n\", toConvert == 0 ? days : -1);\n\n    return 0;\n}"
  }
}