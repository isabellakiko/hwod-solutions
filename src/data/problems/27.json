{
  "id": "27",
  "title": "数字排列",
  "examType": "A",
  "score": 100,
  "description": "小明负责公司年会，想出一个趣味游戏：\n屏幕给出 1 ~ 9 中任意 4 个不重复的数字，大家以最快时间给出这几个数字可拼成的数字从小到大排列位于第 N 位置的数字，其中 N 为给出数字中最大的（如果不到这么多数字则给出最后一个即可）。\n注意：\n2 可以当作 5 来使用，5 也可以当作 2 来使用进行数字拼接，且屏幕不能同时给出 2 和 5；6 可以当作 9 来使用，9 也可以当作 6 来使用进行数字拼接，且屏幕不能同时给出 6 和 9。\n如给出：1，4，8，7，则可以拼接的数字为：\n1，4，7，8，14，17，18，41，47，48，71，74，78，81，84，87，147，148，178 … (省略后面的数字)\n那么第 N （即8）个的数字为 41。",
  "inputDesc": "输入以逗号分隔的 4 个 int 类型整数的字符串。",
  "outputDesc": "输出为这几个数字可拼成的数字从小大大排列位于第 N （N为输入数字中最大的数字）位置的数字，\n如果输入的数字不在范围内或者有重复，则输出-1。",
  "examples": [
    {
      "input": "1,4,8,7",
      "output": "41",
      "explanation": "输入数字：1,4,7,8，最大值N=8。\n可构成的数字排序：1,4,7,8,14,17,18,41,47...\n第8个数字是41。"
    },
    {
      "input": "2,5,1,3",
      "output": "-1",
      "explanation": "2和5不能同时出现，输出-1。"
    },
    {
      "input": "1,0,9,3",
      "output": "-1",
      "explanation": "0不在1到9范围内，输出-1。"
    },
    {
      "input": "3,9,7,8",
      "output": "39",
      "explanation": "输入数字：3,7,8,9，最大值N=9。\n9可以当6使用，所以可用数字为3,6,7,8,9。\n排序：3,6,7,8,9,36,37,38,39,...\n第9个数字是39。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**排列组合 + DFS**问题。\n\n**规则理解：**\n- 输入4个1-9的不重复数字\n- 2和5可以互换使用，但不能同时输入\n- 6和9可以互换使用，但不能同时输入\n- 生成所有可能的数字排列，排序后取第N个（N为最大输入数字）\n\n**算法步骤：**\n\n1. **参数校验**：检查数字范围、重复、2/5和6/9冲突\n2. **DFS生成排列**：对于每个位置，可以放原数字或其替换数字\n3. **排序**：将所有生成的数字升序排列\n4. **取第N个**：如果不够N个，取最后一个\n\n**时间复杂度**：O(4! * 2^k * log)，k为可替换数字的个数",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        // 读取输入的一行字符串，将逗号分隔的数字转换为整数数组\n        int[] nums = Arrays.stream(sc.nextLine().split(\",\"))\n                           .mapToInt(Integer::parseInt)\n                           .toArray();\n\n        // 使用HashSet来记录输入的数字，避免重复，同时用于后续的检查\n        HashSet<Integer> set = new HashSet<>();\n        // 记录输入数字中的最大值，用于后续决定输出的排列结果\n        int n = Integer.MIN_VALUE;\n\n        // 遍历输入的每一个数字，进行合法性检查和找出最大值\n        for (int num : nums) {\n            // 检查数字是否在1到9的范围内，且是否重复\n            if (num < 1 || num > 9 || !set.add(num)) {\n                // 如果数字不在范围内或者重复，则输出-1并结束程序\n                System.out.println(-1);\n                return;\n            }\n            // 更新当前的最大值\n            n = Math.max(n, num);\n        }\n\n        // 检查是否输入了4个数字，并且不允许2和5同时出现，或6和9同时出现\n        if (set.size() != 4 || (set.contains(2) && set.contains(5)) || (set.contains(6) && set.contains(9))) {\n            // 如果条件不满足，输出-1并结束程序\n            System.out.println(-1);\n            return;\n        }\n\n        // 创建一个映射数组，用于定义数字替代规则，例如2替代5，5替代2，6替代9，9替代6\n        int[] map = new int[10];\n        map[2] = 5;\n        map[5] = 2;\n        map[6] = 9;\n        map[9] = 6;\n\n        // 创建一个列表用于存储生成的所有可能的排列结果\n        ArrayList<Integer> resList = new ArrayList<>();\n\n        // 调用递归函数，生成所有排列组合，并将结果存储到resList中\n        dfs(nums, new HashSet<>(), \"\", map, resList);\n\n        // 如果没有生成任何有效的排列结果，输出-1\n        if (resList.isEmpty()) {\n            System.out.println(-1);\n            return;\n        }\n\n        // 对结果列表进行自然顺序排序（升序）\n        resList.sort(Comparator.naturalOrder());\n\n        // 确定要输出的第n个数字，其中n为输入的最大值，如果结果集数量不足，则输出最后一个\n        int nth = Math.min(n, resList.size());\n        // 输出排序后的第nth个数字（因为索引从0开始，所以为nth - 1）\n        System.out.println(resList.get(nth - 1));\n    }\n\n   \n    public static void dfs(int[] nums, Set<Integer> used, String path, int[] map, List<Integer> res) {\n        // 如果当前路径不为空，将路径转换为整数并加入结果集中\n        if (!path.isEmpty()) {\n            res.add(Integer.parseInt(path));\n        }\n\n        // 如果当前路径的长度已经等于输入的数字数量，返回（递归结束条件）\n        if (path.length() == nums.length) {\n            return;\n        }\n\n        // 遍历所有输入的数字，尝试将每个数字放入当前路径中\n        for (int num : nums) {\n            // 如果当前数字已经在路径中使用，跳过此数字\n            if (used.contains(num)) continue;\n\n            // 标记当前数字为使用中\n            used.add(num);\n\n            // 递归调用，将当前数字加入路径中\n            dfs(nums, used, path + num, map, res);\n\n            // 如果当前数字有替代规则，且替代数字未被使用，则尝试使用替代数字\n            if (map[num] != 0 && !used.contains(map[num])) {\n                dfs(nums, used, path + map[num], map, res);\n            }\n\n            // 回溯，取消当前数字的使用标记\n            used.remove(num);\n        }\n    }\n}",
    "python": "# 导入所需模块\nfrom itertools import permutations\n\ndef main():\n    # 读取输入的一行字符串，并将其转换为整数列表\n    nums = list(map(int, input().split(',')))\n\n    # 使用集合来记录输入的数字，避免重复，并进行后续检查\n    num_set = set()\n    # 记录输入数字中的最大值，用于后续输出\n    n = float('-inf')\n\n    # 遍历输入的每一个数字，进行合法性检查并找出最大值\n    for num in nums:\n        # 检查数字是否在1到9的范围内，且是否重复\n        if num < 1 or num > 9 or num in num_set:\n            print(-1)\n            return\n        num_set.add(num)\n        n = max(n, num)\n    \n    # 检查是否输入了4个数字，并且不允许2和5同时出现，或6和9同时出现\n    if len(num_set) != 4 or (2 in num_set and 5 in num_set) or (6 in num_set and 9 in num_set):\n        print(-1)\n        return\n\n    # 定义替换规则\n    replace_map = {2: 5, 5: 2, 6: 9, 9: 6}\n\n    # 初始化结果列表\n    res_list = []\n\n    # 调用递归函数，生成所有排列组合\n    dfs(nums, set(), \"\", replace_map, res_list)\n\n    # 如果没有生成任何有效的排列结果，输出-1\n    if not res_list:\n        print(-1)\n        return\n\n    # 对结果列表进行升序排序\n    res_list.sort()\n\n    # 确定要输出的第n个数字，n为输入的最大值\n    nth = min(n, len(res_list))\n\n    # 输出排序后的第nth个数字\n    print(res_list[nth - 1])\n\ndef dfs(nums, used, path, replace_map, res):\n    # 如果当前路径不为空，将路径转换为整数并加入结果集中\n    if path:\n        res.append(int(path))\n\n    # 如果当前路径的长度已经等于输入的数字数量，返回（递归结束条件）\n    if len(path) == len(nums):\n        return\n\n    # 遍历所有输入的数字，尝试将每个数字放入当前路径中\n    for num in nums:\n        if num in used:\n            continue\n\n        used.add(num)\n\n        # 递归调用，将当前数字加入路径中\n        dfs(nums, used, path + str(num), replace_map, res)\n\n        # 如果当前数字有替代规则且替代数字未被使用，则尝试使用替代数字\n        if num in replace_map and replace_map[num] not in used:\n            dfs(nums, used, path + str(replace_map[num]), replace_map, res)\n\n        # 回溯\n        used.remove(num)\n\nif __name__ == \"__main__\":\n    main()",
    "javascript": "const readline = require('readline');\n \nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n \nrl.on(\"line\", (input) => {\n    // 将输入的字符串转换为整数数组\n    const nums = input.split(',').map(Number);\n\n    // 使用Set来记录输入的数字，避免重复\n    let numSet = new Set();\n    let n = Number.MIN_SAFE_INTEGER;\n\n    // 遍历每个数字，进行合法性检查并找出最大值\n    for (let num of nums) {\n        if (num < 1 || num > 9 || numSet.has(num)) {\n            console.log(-1);\n            rl.close();\n            return;\n        }\n        numSet.add(num);\n        n = Math.max(n, num);\n    }\n\n    // 检查条件\n    if (numSet.size !== 4 || (numSet.has(2) && numSet.has(5)) || (numSet.has(6) && numSet.has(9))) {\n        console.log(-1);\n        rl.close();\n        return;\n    }\n\n    // 定义替换规则\n    const replaceMap = { 2: 5, 5: 2, 6: 9, 9: 6 };\n\n    // 存储结果的数组\n    let resList = [];\n\n    // 调用递归函数\n    dfs(nums, new Set(), \"\", replaceMap, resList);\n\n    // 如果没有结果，输出-1\n    if (resList.length === 0) {\n        console.log(-1);\n        rl.close();\n        return;\n    }\n\n    // 排序\n    resList.sort((a, b) => a - b);\n\n    // 输出第n个结果\n    let nth = Math.min(n, resList.length);\n    console.log(resList[nth - 1]);\n    rl.close();\n});\n \n\n// 递归函数\nfunction dfs(nums, used, path, replaceMap, res) {\n    if (path !== \"\") res.push(parseInt(path));\n\n    if (path.length === nums.length) return;\n\n    for (let num of nums) {\n        if (used.has(num)) continue;\n\n        used.add(num);\n        dfs(nums, used, path + num, replaceMap, res);\n\n        if (replaceMap[num] && !used.has(replaceMap[num])) {\n            dfs(nums, used, path + replaceMap[num], replaceMap, res);\n        }\n\n        used.delete(num);\n    }\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <climits>\nusing namespace std;\n\n// 递归函数，用于生成所有的排列组合\nvoid dfs(const vector<int>& nums, set<int>& used, string path, int map[], vector<int>& res) {\n    // 如果当前路径不为空，将路径转换为整数并加入结果集\n    if (!path.empty()) {\n        res.push_back(stoi(path));\n    }\n\n    // 如果当前路径的长度已经等于输入的数字数量，递归结束\n    if (path.length() == nums.size()) {\n        return;\n    }\n\n    // 遍历所有输入的数字，尝试将每个数字放入当前路径中\n    for (int num : nums) {\n        // 如果当前数字已经在路径中使用，跳过此数字\n        if (used.count(num)) continue;\n\n        // 标记当前数字为使用中\n        used.insert(num);\n        // 递归调用，将当前数字加入路径中\n        dfs(nums, used, path + to_string(num), map, res);\n        // 如果当前数字有替代规则且替代数字未被使用，则尝试使用替代数字\n        if (map[num] != 0 && !used.count(map[num])) {\n            dfs(nums, used, path + to_string(map[num]), map, res);\n        }\n        // 回溯，取消当前数字的使用标记\n        used.erase(num);\n    }\n}\n\nint main() {\n    string input;\n    // 读取输入的一行字符串\n    getline(cin, input);\n\n    vector<int> nums;\n    set<int> numSet;\n    int n = INT_MIN;\n\n    // 将逗号分隔的字符串转换为整数数组\n    size_t pos = 0;\n    while ((pos = input.find(',')) != string::npos) {\n        int num = stoi(input.substr(0, pos));\n        nums.push_back(num);\n        input.erase(0, pos + 1);\n    }\n    nums.push_back(stoi(input));\n\n    // 遍历输入的每一个数字，进行合法性检查和找出最大值\n    for (int num : nums) {\n        // 检查数字是否在1到9的范围内，且是否重复\n        if (num < 1 || num > 9 || !numSet.insert(num).second) {\n            // 如果数字不在范围内或者重复，则输出-1并结束程序\n            cout << -1 << endl;\n            return 0;\n        }\n        // 更新当前的最大值\n        n = max(n, num);\n    }\n\n    // 检查是否输入了4个数字，并且不允许2和5同时出现，或6和9同时出现\n    if (numSet.size() != 4 || (numSet.count(2) && numSet.count(5)) || (numSet.count(6) && numSet.count(9))) {\n        // 如果条件不满足，输出-1并结束程序\n        cout << -1 << endl;\n        return 0;\n    }\n\n    // 创建一个映射数组，用于定义数字替代规则\n    int map[10] = {0};\n    map[2] = 5;\n    map[5] = 2;\n    map[6] = 9;\n    map[9] = 6;\n\n    // 创建一个列表用于存储生成的所有可能的排列结果\n    vector<int> resList;\n\n    // 调用递归函数，生成所有排列组合，并将结果存储到resList中\n    set<int> used;\n    dfs(nums, used, \"\", map, resList);\n\n    // 如果没有生成任何有效的排列结果，输出-1\n    if (resList.empty()) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    // 对结果列表进行自然顺序排序（升序）\n    sort(resList.begin(), resList.end());\n\n    // 确定要输出的第n个数字，其中n为输入的最大值，如果结果集数量不足，则输出最后一个\n    int nth = min(n, (int)resList.size());\n    // 输出排序后的第nth个数字（因为索引从0开始，所以为nth - 1）\n    cout << resList[nth - 1] << endl;\n\n    return 0;\n}",
    "c": ""
  }
}