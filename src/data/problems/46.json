{
  "id": "46",
  "title": "第k个排列",
  "examType": "A",
  "score": 100,
  "description": "给定参数n，从1到n会有n个整数：1,2,3,…,n,这n个数字共有n!种排列。\n按大小顺序升序列出所有排列的情况，并一一标记，\n当n=3时,所有排列如下:\n“123” “132” “213” “231” “312” “321”\n给定n和k，返回第k个排列。",
  "inputDesc": "输入两行，第一行为n，第二行为k，给定n的范围是[1,9],给定k的范围是[1,n!]。",
  "outputDesc": "输出排在第k位置的数字。",
  "examples": [
    {
      "input": "3\n3",
      "output": "213",
      "explanation": "n=3时所有排列按字典序：\n1.\"123\" 2.\"132\" 3.\"213\" 4.\"231\" 5.\"312\" 6.\"321\"\n第3个是\"213\"。"
    },
    {
      "input": "3\n5",
      "output": "312",
      "explanation": "n=3的第5个排列是\"312\"。"
    },
    {
      "input": "4\n9",
      "output": "2314",
      "explanation": "n=4共有24种排列。\n第9个排列是\"2314\"。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**康托展开逆运算**问题。\n\n**核心思想：**\n- n个数的全排列共有n!种\n- 确定第一位后，剩余(n-1)!种排列\n- 利用除法和取模逐位确定\n\n**算法步骤（康托逆展开）：**\n\n1. k = k - 1（转为0索引）\n2. 对于第i位（从左到右）：\n   - index = k / (n-i)!\n   - 从剩余数字中取第index个\n   - k = k % (n-i)!\n3. 重复直到所有位确定\n\n**示例：n=3, k=3**\n- k=2, 剩余[1,2,3]\n- 第1位：2/2!=1 → 取数字2，k=0\n- 第2位：0/1!=0 → 取数字1\n- 第3位：取剩余3\n- 结果：213\n\n**时间复杂度**：O(n²)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int n, k;\n        Vector<String> lines = new Vector<String>();\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取 n 和 k\n        n = scanner.nextInt();\n        k = scanner.nextInt();\n\n        // 如果 n 等于 1，则直接输出 1 并结束程序\n        if (n == 1) {\n            System.out.println(\"1\");\n            return;\n        }\n\n        // 初始化 nums 数组，存储 1 到 n 的整数\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = i + 1;\n        }\n\n        // 初始化结果列表\n        List<String> result = new ArrayList<>();\n\n        // 递归函数，用于生成所有排列\n        generatePermutations(nums, \"\", result, k);\n\n        // 对结果列表进行排序\n        Collections.sort(result);\n\n        // 输出第k个排列\n        System.out.println(result.get(k - 1));\n    }\n\n    public static void generatePermutations(int[] nums, String current, List<String> result, int k) {\n        // 如果数字数组为空，将当前结果添加到结果列表中\n        if (nums.length == 0) {\n            result.add(current);\n            return;\n        }\n\n        // 遍历当前数字数组\n        for (int i = 0; i < nums.length; i++) {\n            // 取出一个数字\n            int num = nums[i];\n\n            // 创建新的数字数组，删除当前数字\n            int[] newNums = new int[nums.length - 1];\n            for (int j = 0; j < i; j++) {\n                newNums[j] = nums[j];\n            }\n            for (int j = i + 1; j < nums.length; j++) {\n                newNums[j - 1] = nums[j];\n            }\n\n            // 递归调用函数，传递更新后的数字数组和结果字符串\n            generatePermutations(newNums, current + num, result, k);\n\n            // 如果结果列表长度等于k，直接返回\n            if (result.size() == k) {\n                return;\n            }\n        }\n    }\n}",
    "python": "n = int(input())\nk = int(input())\n\n\nif n == 1:\n    print(\"1\")\n    exit()\n\nnums = [i+1 for i in range(n)]\nresult = []\n\ndef generatePermutations(nums, current, result, k):\n    if len(nums) == 0:\n        result.append(current)\n        return\n\n    for i in range(len(nums)):\n        num = nums[i]\n        newNums = nums[:i] + nums[i+1:]\n        generatePermutations(newNums, current + str(num), result, k)\n\n        if len(result) == k:\n            return\n\ngeneratePermutations(nums, \"\", result, k)\n\nresult.sort()\nprint(result[k-1])",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (n) => {\n  rl.on('line', (k) => {\n    // 如果 n 等于 1，则直接输出 1 并结束程序\n    if (n == 1) {\n      console.log(\"1\");\n      rl.close();\n      return;\n    }\n\n    // 初始化 nums 数组，存储 1 到 n 的整数\n    let nums = [];\n    for (let i = 0; i < n; i++) {\n      nums.push(i + 1);\n    }\n\n    // 初始化结果列表\n    let result = [];\n\n    // 递归函数，用于生成所有排列\n    generatePermutations(nums, \"\", result, k);\n\n    // 对结果列表进行排序\n    result.sort();\n\n    // 输出第k个排列\n    console.log(result[k - 1]);\n\n    rl.close();\n  });\n});\n\nfunction generatePermutations(nums, current, result, k) {\n  // 如果数字数组为空，将当前结果添加到结果列表中\n  if (nums.length === 0) {\n    result.push(current);\n    return;\n  }\n\n  // 遍历当前数字数组\n  for (let i = 0; i < nums.length; i++) {\n    // 取出一个数字\n    let num = nums[i];\n\n    // 创建新的数字数组，删除当前数字\n    let newNums = nums.slice(0, i).concat(nums.slice(i + 1));\n\n    // 递归调用函数，传递更新后的数字数组和结果字符串\n    generatePermutations(newNums, current + num, result, k);\n\n    // 如果结果列表长度等于k，直接返回\n    if (result.length === k) {\n      return;\n    }\n  }\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvoid generatePermutations(vector<int>& nums, string current, vector<string>& result, int k);\n\nint main() {\n    int n, k;\n    vector<string> lines;\n    cin >> n >> k;\n\n    if (n == 1) {\n        cout << \"1\" << endl;\n        return 0;\n    }\n\n    vector<int> nums(n);\n    for (int i = 0; i < n; i++) {\n        nums[i] = i + 1;\n    }\n\n    vector<string> result;\n    generatePermutations(nums, \"\", result, k);\n\n    sort(result.begin(), result.end());\n\n    cout << result[k - 1] << endl;\n\n    return 0;\n}\n\nvoid generatePermutations(vector<int>& nums, string current, vector<string>& result, int k) {\n    if (nums.empty()) {\n        result.push_back(current);\n        return;\n    }\n\n    for (int i = 0; i < nums.size(); i++) {\n        int num = nums[i];\n        vector<int> newNums(nums.size() - 1);\n        copy(nums.begin(), nums.begin() + i, newNums.begin());\n        copy(nums.begin() + i + 1, nums.end(), newNums.begin() + i);\n\n        generatePermutations(newNums, current + to_string(num), result, k);\n\n        if (result.size() == k) {\n            return;\n        }\n    }\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 生成排列的递归函数\nvoid generatePermutations(int* nums, int numsSize, char* current, char** result, int* resultSize, int k) {\n    // 如果数字数组为空，将当前结果添加到结果列表中\n    if (numsSize == 0) {\n        result[*resultSize] = (char*)malloc(strlen(current) + 1);\n        strcpy(result[*resultSize], current);\n        (*resultSize)++;\n        return;\n    }\n\n    // 遍历当前数字数组\n    for (int i = 0; i < numsSize; i++) {\n        // 取出一个数字\n        int num = nums[i];\n\n        // 创建新的数字数组，删除当前数字\n        int* newNums = (int*)malloc((numsSize - 1) * sizeof(int));\n        for (int j = 0; j < i; j++) {\n            newNums[j] = nums[j];\n        }\n        for (int j = i + 1; j < numsSize; j++) {\n            newNums[j - 1] = nums[j];\n        }\n\n        // 更新结果字符串\n        int newCurrentLen = strlen(current) + 10; // 分配足够大的空间\n        char *newCurrent = (char*)malloc(newCurrentLen * sizeof(char));\n        snprintf(newCurrent, newCurrentLen, \"%s%d\", current, num);\n\n        // 递归调用函数，传递更新后的数字数组和结果字符串\n        generatePermutations(newNums, numsSize - 1, newCurrent, result, resultSize, k);\n\n        // 如果结果列表长度等于k，直接返回\n        if (*resultSize == k) {\n            free(newNums);\n            free(newCurrent); // 避免内存泄漏\n            return;\n        }\n\n        // 释放内存\n        free(newNums);\n        free(newCurrent); // 每次循环后释放newCurrent\n    }\n}\n\nint compareStrings(const void* a, const void* b) {\n    return strcmp(*(const char**)a, *(const char**)b);\n}\n\nint main() {\n    int n, k;\n\n    // 读取 n 和 k\n    scanf(\"%d %d\", &n, &k);\n\n    // 如果 n 等于 1，则直接输出 1 并结束程序\n    if (n == 1) {\n        printf(\"1\\n\");\n        return 0;\n    }\n\n    // 初始化 nums 数组，存储 1 到 n 的整数\n    int* nums = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        nums[i] = i + 1;\n    }\n\n    // 初始化结果列表\n    char** result = (char**)malloc(100000000 * sizeof(char*));   \n    int resultSize = 0;\n\n    // 调用递归函数生成所有排列\n    char current[100] = \"\";  // 初始的结果字符串为空\n    generatePermutations(nums, n, current, result, &resultSize, k);\n\n    // 对结果列表进行排序\n    qsort(result, resultSize, sizeof(char*), compareStrings);\n\n    // 输出第 k 个排列\n    printf(\"%s\\n\", result[k - 1]);\n\n    // 释放内存\n    for (int i = 0; i < resultSize; i++) {\n        free(result[i]);\n    }\n    free(result);\n    free(nums);\n\n    return 0;\n}"
  }
}