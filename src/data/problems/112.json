{
  "id": "112",
  "title": "连续字母长度",
  "examType": "A",
  "score": 100,
  "description": "给定一个字符串，只包含大写字母，求在包含同一字母的子串中，长度第 k 长的子串的长度，相同字母只取最长的那个子串。",
  "inputDesc": "第一行有一个子串(1<长度<=100)，只包含大写字母。",
  "outputDesc": "输出连续出现次数第k多的字母的次数。",
  "examples": [
    {
      "input": "AAAAHHHBBCDHHHH\n3",
      "output": "2",
      "explanation": "各字母最长连续：A=4,H=4,B=2,C=1,D=1。排序后第3长为2(BB)"
    },
    {
      "input": "AABAAA\n2",
      "output": "1",
      "explanation": "各字母最长连续：A=3,B=1。排序后第2长为1(B)"
    },
    {
      "input": "ABC\n4",
      "output": "-1",
      "explanation": "只有3种字母，k=4超出范围，返回-1"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**字符串遍历+排序**问题。\n\n**核心思路：**\n- 统计每个字母的最长连续出现次数\n- 相同字母只取最长的那个\n- 对长度降序排序，取第k个\n\n**算法步骤：**\n1. 遍历字符串，统计每个字母的最长连续次数\n2. 将各字母的最长次数存入数组\n3. 降序排序，返回第k个值\n4. k超出范围返回-1\n\n**时间复杂度**：O(N + 26log26)",
  "codes": {
    "java": "import java.util.Scanner;            \nimport java.util.HashSet;         \nimport java.util.HashMap;            \nimport java.util.regex.Pattern;      \nimport java.util.regex.Matcher;     \nimport java.util.ArrayList;       \nimport java.util.Collections;      \n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);  \n        String str = input.next();              // 读取字符串输入\n        int k = input.nextInt();                // 读取整数k值\n\n        HashSet<Character> charSet = new HashSet<>(); // 创建HashSet，用于存储字符串中不同的字符\n        for (char c : str.toCharArray()) {           // 遍历字符串中的每个字符\n            charSet.add(c);                          // 将字符添加到HashSet中（自动去重）\n        }\n\n        HashMap<Character, Integer> charMap = new HashMap<>(); // 创建HashMap，用于存储每个字符的最长子串长度\n        for (char c : charSet) {                               // 遍历HashSet中的每个字符\n            // 创建一个正则表达式模式，用于匹配当前字符的连续子串\n            Pattern pattern = Pattern.compile(String.valueOf(c) + \"+\");\n            // 使用Matcher在字符串中查找所有匹配的子串\n            Matcher matcher = pattern.matcher(str);\n            while (matcher.find()) {                         // 当找到匹配的子串时\n                int repeatTimes = matcher.group().length();  // 获取匹配子串的长度\n                // 更新HashMap中的最长子串长度\n                if (charMap.containsKey(c)) { \n                    // 如果当前字符已在Map中，比较并存储最大长度\n                    charMap.put(c, Math.max(charMap.get(c), repeatTimes));\n                } else {\n                    // 如果当前字符不在Map中，直接存储当前长度\n                    charMap.put(c, repeatTimes);\n                }\n            }\n        }\n\n        // 将所有字符的最长子串长度存储到ArrayList中\n        ArrayList<Integer> values = new ArrayList<>(charMap.values());\n        // 对ArrayList中的长度值进行降序排序\n        Collections.sort(values, Collections.reverseOrder());\n        // 如果k大于ArrayList中的元素数量，返回-1，否则返回第k大的长度值\n        int rt = k > values.size() ? -1 : values.get(k - 1);\n        System.out.println(rt); // 输出结果\n    }\n}",
    "python": "import re\n\nstr = input()\nk = int(input())\ncharSet = set(str)\ncharMap = {}\nfor c in charSet:\n    reg = re.compile(c + \"+\")\n    it = re.finditer(reg, str)\n    for match in it:\n        repeatTimes = len(match.group())\n        if c in charMap:\n            charMap[c] = max(charMap[c], repeatTimes)\n        else:\n            charMap[c] = repeatTimes\nvalues = list(charMap.values())\nvalues.sort(reverse=True)\nrt = -1 if k > len(values) else values[k-1]\nprint(rt)",
    "javascript": "const { listeners } = require(\"process\"); \nconst readline = require(\"readline\");  \nconst { isNumber } = require(\"util\");  \n\n \nconst rl = readline.createInterface({\n  input: process.stdin,  \n  output: process.stdout  \n});\n\n \nrl.on(\"line\", (str) => {  \n  rl.on(\"line\", (k) => {  \n\n    // 创建一个Set集合，用于存储字符串中的唯一字符\n    let set = new Set(str);\n    // 创建一个空对象，用于存储每个字符的最长连续子串长度\n    let obj = {};\n\n    // 遍历Set集合中的每个字符\n    for (let letter of set) {\n      // 创建一个正则表达式，用于匹配当前字符的连续子串\n      const reg = new RegExp(`${letter}+`, \"g\");\n\n      // 无限循环，直到正则表达式匹配结束\n      while (true) {\n        // 使用正则表达式在字符串中查找匹配的子串\n        let res = reg.exec(str);\n        if (res === null) { // 如果没有更多匹配的子串，则跳出循环\n          break;\n        } else {\n          // 获取匹配子串的长度\n          let repeatTimes = res[0].length;\n          // 更新对象中当前字符的最长子串长度\n          obj[letter] = obj[letter]\n            ? Math.max(obj[letter], repeatTimes) // 如果已存在该字符，则取最大长度\n            : repeatTimes; // 如果不存在，则直接存储当前长度\n        }\n      }\n    }\n\n    // 对对象中所有字符的最长子串长度进行降序排序，并返回第k大的值，如果k超出范围则返回-1\n    let res = Object.values(obj).sort((a, b) => b - a)[k - 1] ?? -1;\n    console.log(res); // 输出结果\n\n  });\n});",
    "cpp": "#include <iostream>       \n#include <string>        \n#include <unordered_map>  \n#include <unordered_set> \n#include <regex>         \nusing namespace std;\n\nint main() {\n    string str; // 定义字符串变量，用于存储输入的字符串\n    int k = 0;  // 定义整数变量，用于存储输入的k值\n    cin >> str; // 从输入中读取字符串\n    cin >> k;   // 从输入中读取k值\n\n    unordered_set<char> charSet; // 定义无序集合，用于存储字符串中出现的不同字符\n    for (char c : str) {\n        charSet.insert(c); // 遍历字符串，将每个字符插入集合中（自动去重）\n    }\n\n    unordered_map<char, int> charMap; // 定义无序映射，用于存储每个字符对应的最长连续子串长度\n    for (char c : charSet) { \n        // 对于集合中的每个字符，构造一个正则表达式，匹配该字符的连续子串\n        const regex reg(string(1, c) + \"+\"); \n        // 使用正则表达式在字符串中查找所有匹配的子串\n        sregex_iterator it(str.begin(), str.end(), reg);\n        while (it != sregex_iterator()) {\n            int repeatTimes = it->str().length(); // 获取匹配子串的长度\n            // 更新映射中的最长子串长度，如果当前长度大于已存储的长度，则更新\n            charMap[c] = charMap.count(c) ? max(charMap[c], repeatTimes) : repeatTimes;\n            ++it; // 继续查找下一个匹配的子串\n        }\n    }\n\n    vector<int> values; // 定义一个向量，用于存储所有字符的最长子串长度\n    for (auto it : charMap) {\n        values.push_back(it.second); // 将映射中的长度值添加到向量中\n    }\n    // 对向量中的长度值进行降序排序\n    sort(values.begin(), values.end(), greater<int>());\n    // 如果k大于向量中的元素数量，则返回-1，否则返回第k大的长度值\n    int rt = k > values.size() ? -1 : values[k - 1];\n    cout << rt << endl; // 输出结果\n    return 0; // 程序正常结束\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char str[101]; // 存储输入的字符串，最大长度100\n    int k, charMaxCount[26] = {0}, count = 0, maxCount = 0;\n    scanf(\"%s\", str); // 读取字符串\n    scanf(\"%d\", &k); // 读取k的值\n\n    // 计算每个字符的最大连续出现次数\n    int len = strlen(str);\n    for (int i = 0; i < len; i++) {\n        if (i == 0 || str[i] != str[i - 1]) {\n            count = 1; // 如果当前字符和前一个字符不同，重置计数器\n        } else {\n            count++; // 如果当前字符和前一个字符相同，增加计数器\n        }\n\n        int index = str[i] - 'A'; // 将字符转换为索引（0-25）\n        if (count > charMaxCount[index]) {\n            charMaxCount[index] = count; // 更新字符的最大连续出现次数\n        }\n    }\n\n    // 将连续出现次数存储在数组中，并排序\n    int counts[26], j = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charMaxCount[i] > 0) {\n            counts[j++] = charMaxCount[i];\n        }\n    }\n\n    // 冒泡排序\n    for (int i = 0; i < j - 1; i++) {\n        for (int p = 0; p < j - i - 1; p++) {\n            if (counts[p] < counts[p + 1]) {\n                int temp = counts[p];\n                counts[p] = counts[p + 1];\n                counts[p + 1] = temp;\n            }\n        }\n    }\n\n    // 输出结果\n    if (k > j) {\n        printf(\"-1\\n\"); // 如果k大于数组长度，输出-1\n    } else {\n        printf(\"%d\\n\", counts[k - 1]); // 输出第k多的字符的次数\n    }\n\n    return 0;\n}"
  }
}