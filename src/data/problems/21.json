{
  "id": "21",
  "title": "悄悄话",
  "examType": "A",
  "score": 100,
  "description": "给定一个二叉树，每个节点上站一个人，节点数字表示父节点到该节点传递悄悄话需要花费的时间。\n初始时，根节点所在位置的人有一个悄悄话想要传递给其他人，求二叉树所有节点上的人都接收到悄悄话花费的时间。",
  "inputDesc": "输入一行，为空格分隔的整数数组，表示二叉树的层序遍历。\n-1表示空节点。数组第一个元素是根节点（值为0表示根节点无传递时间）。",
  "outputDesc": "输出一个整数，表示所有节点都接收到悄悄话花费的最长时间。",
  "examples": [
    {
      "input": "0 9 20 -1 -1 15 7 -1 -1 -1 -1 3 2",
      "output": "38",
      "explanation": "二叉树结构：\n       0\n      / \\\n     9   20\n        /  \\\n       15   7\n      /  \\\n     3    2\n\n路径时间：\n- 根→9：9\n- 根→20：20\n- 根→20→15：35\n- 根→20→7：27\n- 根→20→15→3：38\n- 根→20→15→2：37\n\n最长路径是38。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二叉树BFS层序遍历**问题。\n\n**核心思想：**\n- 二叉树用数组存储（层序），索引 i 的左子节点是 2*i+1，右子节点是 2*i+2\n- 悄悄话同时传递给所有子节点，求所有节点都收到的时间即求最长路径\n\n**算法步骤：**\n\n1. BFS从根节点开始遍历\n2. 对于每个节点，计算子节点的累计时间 = 父节点时间 + 子节点边权\n3. 将子节点加入队列继续遍历\n4. 记录所有节点中的最大累计时间\n\n**时间复杂度**：O(n)，每个节点访问一次",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建扫描器读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取一行输入并将其转换为整数数组，数组中的每个元素代表从父节点到当前节点的时间\n        int[] whisperTimes = Arrays.stream(scanner.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n        // 关闭扫描器\n        scanner.close();\n\n        // 记录最后一个节点接收悄悄话的时间\n        int maxTime = 0;\n\n        // 使用队列来进行二叉树的层次遍历\n        Queue<Integer> nodeQueue = new LinkedList<>();\n        // 将根节点索引0加入队列\n        nodeQueue.add(0);\n\n        // 当队列不为空时，继续遍历\n        while (!nodeQueue.isEmpty()) {\n            // 从队列中取出一个节点索引\n            int parentNodeIndex = nodeQueue.poll();\n\n            // 计算左子节点索引\n            int leftChildIndex = 2 * parentNodeIndex + 1;\n            // 计算右子节点索引\n            int rightChildIndex = 2 * parentNodeIndex + 2;\n\n            // 如果左子节点存在，处理左子节点\n            if (leftChildIndex < whisperTimes.length && whisperTimes[leftChildIndex] != -1) {\n                // 更新左子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n                // 将左子节点加入队列\n                nodeQueue.add(leftChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[leftChildIndex]);\n            }\n\n            // 如果右子节点存在，处理右子节点\n            if (rightChildIndex < whisperTimes.length && whisperTimes[rightChildIndex] != -1) {\n                // 更新右子节点的时间（父节点时间 + 当前节点时间）\n                whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n                // 将右子节点加入队列\n                nodeQueue.add(rightChildIndex);\n                // 更新最大时间\n                maxTime = Math.max(maxTime, whisperTimes[rightChildIndex]);\n            }\n        }\n\n        // 所有节点都接收到悄悄话后，打印最大时间\n        System.out.println(maxTime);\n    }\n}",
    "python": "from collections import deque\n\n# 读取一行输入并将其转换为整数列表\n# 列表中的每个元素代表从父节点到当前节点的时间\nwhisper_times = list(map(int, input().split()))\n\n# 记录最后一个节点接收悄悄话的时间\nmax_time = 0\n\n# 使用队列来进行二叉树的层次遍历\nnode_queue = deque([0])  # 将根节点索引0加入队列\n\n# 当队列不为空时，继续遍历\nwhile node_queue:\n    # 从队列中取出一个节点索引\n    parent_node_index = node_queue.popleft()\n\n    # 计算左子节点索引\n    left_child_index = 2 * parent_node_index + 1\n    # 计算右子节点索引\n    right_child_index = 2 * parent_node_index + 2\n\n    # 如果左子节点存在，处理左子节点\n    if left_child_index < len(whisper_times) and whisper_times[left_child_index] != -1:\n        # 更新左子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[left_child_index] += whisper_times[parent_node_index]\n        # 将左子节点加入队列\n        node_queue.append(left_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[left_child_index])\n\n    # 如果右子节点存在，处理右子节点\n    if right_child_index < len(whisper_times) and whisper_times[right_child_index] != -1:\n        # 更新右子节点的时间（父节点时间 + 当前节点时间）\n        whisper_times[right_child_index] += whisper_times[parent_node_index]\n        # 将右子节点加入队列\n        node_queue.append(right_child_index)\n        # 更新最大时间\n        max_time = max(max_time, whisper_times[right_child_index])\n\n# 所有节点都接收到悄悄话后，打印最大时间\nprint(max_time)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (line) => {\n  // 读取输入并转换为整数数组\n  const whisperTimes = line.split(' ').map(Number);\n  \n  // 记录最大时间\n  let maxTime = 0;\n  \n  // 使用队列进行BFS\n  const queue = [0];\n  \n  while (queue.length > 0) {\n    const parentIndex = queue.shift();\n    \n    // 计算左右子节点索引\n    const leftIndex = 2 * parentIndex + 1;\n    const rightIndex = 2 * parentIndex + 2;\n    \n    // 处理左子节点\n    if (leftIndex < whisperTimes.length && whisperTimes[leftIndex] !== -1) {\n      whisperTimes[leftIndex] += whisperTimes[parentIndex];\n      queue.push(leftIndex);\n      maxTime = Math.max(maxTime, whisperTimes[leftIndex]);\n    }\n    \n    // 处理右子节点\n    if (rightIndex < whisperTimes.length && whisperTimes[rightIndex] !== -1) {\n      whisperTimes[rightIndex] += whisperTimes[parentIndex];\n      queue.push(rightIndex);\n      maxTime = Math.max(maxTime, whisperTimes[rightIndex]);\n    }\n  }\n  \n  console.log(maxTime);\n  rl.close();\n});",
    "cpp": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    // 数组中的每个元素代表从父节点到当前节点的时间\n    string line;\n    getline(cin, line);\n    istringstream iss(line);\n    vector<int> whisperTimes;\n    int time;\n    while (iss >> time) {\n        whisperTimes.push_back(time);\n    }\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用队列来进行二叉树的层次遍历\n    queue<int> nodeQueue;\n    // 将根节点索引0加入队列\n    nodeQueue.push(0);\n\n    // 当队列不为空时，继续遍历\n    while (!nodeQueue.empty()) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = nodeQueue.front();\n        nodeQueue.pop();\n\n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < whisperTimes.size() && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            nodeQueue.push(leftChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[leftChildIndex]);\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < whisperTimes.size() && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            nodeQueue.push(rightChildIndex);\n            // 更新最大时间\n            maxTime = max(maxTime, whisperTimes[rightChildIndex]);\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    cout << maxTime << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 10000 // 假设二叉树节点数不超过10000\n\nint main() {\n    // 读取一行输入并将其转换为整数数组\n    char input[MAX_SIZE];\n    fgets(input, sizeof(input), stdin);\n    \n    int whisperTimes[MAX_SIZE];\n    int i = 0, time;\n    char *token = strtok(input, \" \");\n    while (token != NULL) {\n        sscanf(token, \"%d\", &time);\n        whisperTimes[i++] = time;\n        token = strtok(NULL, \" \");\n    }\n    int length = i; // 数组长度\n\n    // 记录最后一个节点接收悄悄话的时间\n    int maxTime = 0;\n\n    // 使用数组模拟队列进行二叉树的层次遍历\n    int queue[MAX_SIZE];\n    int front = 0, rear = 0; // 队列的头和尾索引\n\n    // 将根节点索引0加入队列\n    queue[rear++] = 0;\n\n    // 当队列不为空时，继续遍历\n    while (front < rear) {\n        // 从队列中取出一个节点索引\n        int parentNodeIndex = queue[front++];\n        \n        // 计算左子节点索引\n        int leftChildIndex = 2 * parentNodeIndex + 1;\n        // 计算右子节点索引\n        int rightChildIndex = 2 * parentNodeIndex + 2;\n\n        // 如果左子节点存在，处理左子节点\n        if (leftChildIndex < length && whisperTimes[leftChildIndex] != -1) {\n            // 更新左子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[leftChildIndex] += whisperTimes[parentNodeIndex];\n            // 将左子节点加入队列\n            queue[rear++] = leftChildIndex;\n            // 更新最大时间\n            if (whisperTimes[leftChildIndex] > maxTime) {\n                maxTime = whisperTimes[leftChildIndex];\n            }\n        }\n\n        // 如果右子节点存在，处理右子节点\n        if (rightChildIndex < length && whisperTimes[rightChildIndex] != -1) {\n            // 更新右子节点的时间（父节点时间 + 当前节点时间）\n            whisperTimes[rightChildIndex] += whisperTimes[parentNodeIndex];\n            // 将右子节点加入队列\n            queue[rear++] = rightChildIndex;\n            // 更新最大时间\n            if (whisperTimes[rightChildIndex] > maxTime) {\n                maxTime = whisperTimes[rightChildIndex];\n            }\n        }\n    }\n\n    // 所有节点都接收到悄悄话后，打印最大时间\n    printf(\"%d\\n\", maxTime);\n    return 0;\n}"
  }
}