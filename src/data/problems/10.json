{
  "id": "10",
  "title": "内存资源分配",
  "examType": "A",
  "score": 100,
  "description": "有一个简易内存池，内存按照大小粒度分类，每个粒度有若干个可用内存资源，用户会进行一系列内存申请，需要按需分配内存池中的资源返回申请结果成功失败列表。\n分配规则如下：\n分配的内存要大于等于内存的申请量，存在满足需求的内存就必须分配，优先分配粒度小的，但内存不能拆分使用；需要按申请顺序分配，先申请的先分配，有可用内存分配则申请结果为true；没有可用则返回false。\n注意：不考虑内存释放",
  "inputDesc": "输入为两行字符串\n第一行为内存池资源列表，包含内存粒度数据信息，粒度数据间用逗号分割\n一个粒度信息内用冒号分割，冒号前为内存粒度大小，冒号后为数量资源列表不大于1024每个粒度的数量不大于4096\n第二行为申请列表，申请的内存大小间用逗号分割\n申请列表不大于100000\n如: 64:2,128:1,32:4,1:128 50,36,64,128,127",
  "outputDesc": "输出为内存池分配结果\n如true,true,true,false,false",
  "examples": [
    {
      "input": "64:2,128:1,32:4,1:128\n50,36,64,128,127",
      "output": "true,true,true,false,false",
      "explanation": "内存池资源包含：64K共2个、128K共1个、32K共4个、1K共128个。\n\n针对 50,36,64,128,127 的内存申请序列：\n- 申请50K：分配64K（最小满足条件的块），剩余64K×1\n- 申请36K：分配64K，剩余无64K\n- 申请64K：分配128K（64K已用完），剩余无128K\n- 申请128K：失败（无>=128K的块）\n- 申请127K：失败（无>=127K的块）\n\n输出：true,true,true,false,false"
    },
    {
      "input": "64:2,128:1,32:4,1:128\n1,1,1,1,1,1",
      "output": "true,true,true,true,true,true",
      "explanation": "申请6个1K内存，内存池有128个1K块，全部成功分配。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心 + 模拟**问题。\n\n**算法步骤：**\n\n1. **解析内存池**：将 `64:2,128:1,32:4` 格式解析为内存块列表\n2. **排序内存池**：按内存块大小升序排列（保证优先分配小的）\n3. **处理每个申请**：\n   - 在排序后的内存池中找第一个 >= 申请大小的块\n   - 找到则分配（移除该块），返回 true\n   - 找不到则返回 false\n4. **输出结果**：用逗号连接所有申请结果\n\n**关键点：**\n- 必须先排序，确保优先分配最小的满足条件的块\n- 内存一旦分配就不能再用（不考虑释放）\n- 不能拆分使用（64K 块不能拆成两个 32K）",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String memoryInfo = sc.next();\n        String applyList = sc.next();\n        \n        // 解析内存池\n        List<Integer> memoryList = new ArrayList<>();\n        for (String info : memoryInfo.split(\",\")) {\n            String[] parts = info.split(\":\");\n            int size = Integer.parseInt(parts[0]);\n            int count = Integer.parseInt(parts[1]);\n            for (int i = 0; i < count; i++) {\n                memoryList.add(size);\n            }\n        }\n        \n        // 排序（优先分配小的）\n        Collections.sort(memoryList);\n        \n        // 处理申请\n        StringBuilder result = new StringBuilder();\n        for (String apply : applyList.split(\",\")) {\n            int need = Integer.parseInt(apply);\n            boolean found = false;\n            for (int i = 0; i < memoryList.size(); i++) {\n                if (memoryList.get(i) >= need) {\n                    memoryList.remove(i);\n                    found = true;\n                    break;\n                }\n            }\n            if (result.length() > 0) result.append(\",\");\n            result.append(found);\n        }\n        \n        System.out.println(result);\n    }\n}",
    "python": "memory_info = input()\napply_list = input()\n\n# 解析内存池\nmemory = []\nfor item in memory_info.split(','):\n    size, count = map(int, item.split(':'))\n    memory.extend([size] * count)\n\n# 排序（优先分配小的）\nmemory.sort()\n\n# 处理申请\nresults = []\nfor need in map(int, apply_list.split(',')):\n    found = False\n    for i, m in enumerate(memory):\n        if m >= need:\n            memory.pop(i)\n            found = True\n            break\n    results.append('true' if found else 'false')\n\nprint(','.join(results))",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n\nlet lines = [];\nrl.on('line', line => lines.push(line));\nrl.on('close', () => {\n  // 解析内存池\n  const memory = [];\n  for (const item of lines[0].split(',')) {\n    const [size, count] = item.split(':').map(Number);\n    for (let i = 0; i < count; i++) memory.push(size);\n  }\n  \n  // 排序（优先分配小的）\n  memory.sort((a, b) => a - b);\n  \n  // 处理申请\n  const results = [];\n  for (const need of lines[1].split(',').map(Number)) {\n    let found = false;\n    for (let i = 0; i < memory.length; i++) {\n      if (memory[i] >= need) {\n        memory.splice(i, 1);\n        found = true;\n        break;\n      }\n    }\n    results.push(found ? 'true' : 'false');\n  }\n  \n  console.log(results.join(','));\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string memoryInfo, applyList;\n    cin >> memoryInfo >> applyList;\n    \n    // 解析内存池\n    vector<int> memory;\n    stringstream ss(memoryInfo);\n    string item;\n    while (getline(ss, item, ',')) {\n        int pos = item.find(':');\n        int size = stoi(item.substr(0, pos));\n        int count = stoi(item.substr(pos + 1));\n        for (int i = 0; i < count; i++) memory.push_back(size);\n    }\n    \n    // 排序（优先分配小的）\n    sort(memory.begin(), memory.end());\n    \n    // 处理申请\n    stringstream ss2(applyList);\n    bool first = true;\n    while (getline(ss2, item, ',')) {\n        int need = stoi(item);\n        bool found = false;\n        for (size_t i = 0; i < memory.size(); i++) {\n            if (memory[i] >= need) {\n                memory.erase(memory.begin() + i);\n                found = true;\n                break;\n            }\n        }\n        if (!first) cout << \",\";\n        cout << (found ? \"true\" : \"false\");\n        first = false;\n    }\n    cout << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint cmp(const void *a, const void *b) {\n    return *(int*)a - *(int*)b;\n}\n\nint main() {\n    char memoryInfo[10000], applyList[10000];\n    int memory[100000], memCount = 0;\n    int results[100000], resCount = 0;\n    \n    scanf(\"%s %s\", memoryInfo, applyList);\n    \n    // 解析内存池\n    char *token = strtok(memoryInfo, \",\");\n    while (token) {\n        char *colon = strchr(token, ':');\n        int size = atoi(token);\n        int count = atoi(colon + 1);\n        for (int i = 0; i < count; i++) memory[memCount++] = size;\n        token = strtok(NULL, \",\");\n    }\n    \n    // 排序（优先分配小的）\n    qsort(memory, memCount, sizeof(int), cmp);\n    \n    // 处理申请\n    token = strtok(applyList, \",\");\n    while (token) {\n        int need = atoi(token);\n        int found = 0;\n        for (int i = 0; i < memCount; i++) {\n            if (memory[i] >= need) {\n                for (int j = i; j < memCount - 1; j++) memory[j] = memory[j + 1];\n                memCount--;\n                found = 1;\n                break;\n            }\n        }\n        results[resCount++] = found;\n        token = strtok(NULL, \",\");\n    }\n    \n    // 输出结果\n    for (int i = 0; i < resCount; i++) {\n        printf(\"%s%s\", results[i] ? \"true\" : \"false\", i < resCount - 1 ? \",\" : \"\\n\");\n    }\n    return 0;\n}"
  }
}