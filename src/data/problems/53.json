{
  "id": "53",
  "title": "补种未成活胡杨",
  "examType": "A",
  "score": 100,
  "description": "近些年来，我国防沙治沙取得显著成果。某沙漠新种植N棵胡杨（编号1-N），排成一排。\n一个月后，有M棵胡杨未能成活。\n现可补种胡杨K棵，请问如何补种（只能补种，不能新种），可以得到最多的连续胡杨树？",
  "inputDesc": "N 总种植数量，1 <= N <= 100000\nM 未成活胡杨数量，M 个空格分隔的数，按编号从小到大排列，1 <= M <= N\nK 最多可以补种的数量，0 <= K <= M",
  "outputDesc": "最多的连续胡杨棵树",
  "examples": [
    {
      "input": "5\n2\n2 4\n1",
      "output": "3",
      "explanation": "5棵树，第2和第4棵未成活。\n树的状态：1 _ 3 _ 5\n补种1棵到位置2或4，最多连续3棵。"
    },
    {
      "input": "10\n2\n4 7\n1",
      "output": "6",
      "explanation": "10棵树，第4和第7棵未成活。\n树的状态：1 2 3 _ 5 6 _ 8 9 10\n补种1棵到第7棵，得到连续6棵(5,6,7,8,9,10)。"
    },
    {
      "input": "8\n3\n2 5 7\n2",
      "output": "6",
      "explanation": "8棵树，第2、5、7棵未成活。\n树的状态：1 _ 3 4 _ 6 _ 8\n补种2棵到位置2和5，得到连续6棵(1,2,3,4,5,6)。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**滑动窗口**问题，类似LeetCode 1004「最大连续1的个数 III」。\n\n**算法步骤：**\n\n1. 将胡杨树状态转为0/1数组，成活为0，未成活为1\n2. 使用滑动窗口，维护窗口内未成活树的数量\n3. 当窗口内未成活数量超过K时，左边界右移\n4. 每次更新最大窗口长度\n\n**核心思想：**\n- 窗口内最多允许K棵未成活的树（可以补种）\n- 滑动窗口找最长的满足条件的连续区间\n\n**时间复杂度**：O(N)\n**空间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个扫描器对象，用于读取输入\n        Scanner scanner = new Scanner(System.in);\n        \n        // 读取总共的胡杨树数量\n        int total = scanner.nextInt();\n        \n        // 读取未成活的胡杨树数量\n        int deadCount = scanner.nextInt();\n        \n        // 创建一个数组来表示每棵树是否成活，0表示成活，1表示未成活\n        int[] nums = new int[total];\n        \n        // 初始化数组，所有元素设为0，表示所有树最初都是成活的\n        Arrays.fill(nums, 0);\n \n        // 根据输入，将未成活的树的位置标记为1\n        for (int i = 0; i < deadCount; i++) {\n            int num = scanner.nextInt();\n            nums[num - 1] = 1; // 树的编号从1开始，因此需要减1\n        }\n        \n        // 读取可以补种的树的数量\n        int supplementCount = scanner.nextInt();\n        \n        // 初始化滑动窗口的左右边界\n        int left = 0;\n        int maxLen = 0; // 用于存储最大连续成活区域的长度\n        int sumLeft = 0; // 滑动窗口左边界的未成活树数量\n        int sumRight = 0; // 滑动窗口右边界的未成活树数量\n        \n        // 遍历所有的树，right代表滑动窗口的右边界\n        for (int right = 0; right < total; right++) {\n            sumRight += nums[right]; // 更新右边界的未成活树数量\n            \n            // 如果窗口内的未成活树数量大于可以补种的数量\n            while (sumRight - sumLeft > supplementCount) {\n                sumLeft += nums[left]; // 缩小窗口，左边界右移\n                left++;\n            }\n            \n            // 更新最大成活区域的长度\n            maxLen = Math.max(maxLen, right - left + 1);\n        }\n        \n        // 输出最大连续成活区域的长度\n        System.out.println(maxLen);\n    }\n}",
    "python": "# 读取胡杨树的总数N\ntotal = int(input())\n\n# 读取未成活胡杨树的数量M\ndead_count = int(input())\n\n# 读取未成活胡杨树的编号列表\ndead_list = list(map(int, input().split()))\n\n# 读取可以补种的胡杨树数量K\nsupplement_count = int(input())\n\n# 初始化数组，所有树最初都是成活的，0表示成活，1表示未成活\nnums = [0] * total\n\n# 根据输入，将未成活的树的位置标记为1\nfor num in dead_list:\n    nums[num - 1] = 1  # 树的编号从1开始，因此需要减1\n\n# 初始化滑动窗口的左右边界\nleft = 0\nmax_len = 0  # 用于存储最大连续成活区域的长度\nsum_left = 0  # 滑动窗口左边界的未成活树数量\nsum_right = 0  # 滑动窗口右边界的未成活树数量\n\n# 遍历所有的树，right代表滑动窗口的右边界\nfor right in range(total):\n    sum_right += nums[right]  # 更新右边界的未成活树数量\n    \n    # 如果窗口内的未成活树数量大于可以补种的数量\n    while sum_right - sum_left > supplement_count:\n        sum_left += nums[left]  # 缩小窗口，左边界右移\n        left += 1\n    \n    # 更新最大成活区域的长度\n    max_len = max(max_len, right - left + 1)\n\n# 输出最大连续成活区域的长度\nprint(max_len)",
    "javascript": "const readline = require('readline');\n\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst inputLines = [];\nrl.on('line', (input) => {\n    inputLines.push(input);\n});\n\nrl.on('close', () => {\n    // 读取胡杨树的总数N\n    const total = parseInt(inputLines[0]);\n\n    // 读取未成活胡杨树的数量M\n    const deadCount = parseInt(inputLines[1]);\n\n    // 读取未成活胡杨树的编号列表\n    const deadList = inputLines[2].split(' ').map(Number);\n\n    // 读取可以补种的胡杨树数量K\n    const supplementCount = parseInt(inputLines[3]);\n\n    // 初始化数组，所有树最初都是成活的，0表示成活，1表示未成活\n    const nums = new Array(total).fill(0);\n\n    // 根据输入，将未成活的树的位置标记为1\n    deadList.forEach(num => {\n        nums[num - 1] = 1; // 树的编号从1开始，因此需要减1\n    });\n\n    // 初始化滑动窗口的左右边界\n    let left = 0;\n    let maxLen = 0; // 用于存储最大连续成活区域的长度\n    let sumLeft = 0; // 滑动窗口左边界的未成活树数量\n    let sumRight = 0; // 滑动窗口右边界的未成活树数量\n\n    // 遍历所有的树，right代表滑动窗口的右边界\n    for (let right = 0; right < total; right++) {\n        sumRight += nums[right]; // 更新右边界的未成活树数量\n        \n        // 如果窗口内的未成活树数量大于可以补种的数量\n        while (sumRight - sumLeft > supplementCount) {\n            sumLeft += nums[left]; // 缩小窗口，左边界右移\n            left++;\n        }\n        \n        // 更新最大成活区域的长度\n        maxLen = Math.max(maxLen, right - left + 1);\n    }\n\n    // 输出最大连续成活区域的长度\n    console.log(maxLen);\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm> \n\nusing namespace std;\n\nint main() {\n    int total, deadCount;\n    cin >> total >> deadCount;\n\n    // 初始化数组，所有树最初都是成活的，0表示成活，1表示未成活\n    vector<int> nums(total, 0);\n\n    // 根据输入，将未成活的树的位置标记为1\n    for (int i = 0; i < deadCount; i++) {\n        int num;\n        cin >> num;\n        nums[num - 1] = 1; // 树的编号从1开始，因此需要减1\n    }\n\n    // 读取可以补种的树的数量\n    int supplementCount;\n    cin >> supplementCount;\n\n    // 初始化滑动窗口的左右边界\n    int left = 0, maxLen = 0, sumLeft = 0, sumRight = 0;\n\n    // 遍历所有的树，right代表滑动窗口的右边界\n    for (int right = 0; right < total; right++) {\n        sumRight += nums[right]; // 更新右边界的未成活树数量\n\n        // 如果窗口内的未成活树数量大于可以补种的数量\n        while (sumRight - sumLeft > supplementCount) {\n            sumLeft += nums[left]; // 缩小窗口，左边界右移\n            left++;\n        }\n\n        // 更新最大成活区域的长度\n        maxLen = max(maxLen, right - left + 1);\n    }\n\n    // 输出最大连续成活区域的长度\n    cout << maxLen << endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 定义一个max函数，用于求两个数中的最大值\nint max(int a, int b) {\n    return (a > b) ? a : b;\n}\n\nint main() {\n    int total, deadCount;\n\n    scanf(\"%d %d\", &total, &deadCount);\n\n    // 初始化数组，所有树最初都是成活的，0表示成活，1表示未成活\n    int *nums = (int *)calloc(total, sizeof(int));\n\n    // 根据输入，将未成活的树的位置标记为1\n    for (int i = 0; i < deadCount; i++) {\n        int num;\n        scanf(\"%d\", &num);\n        nums[num - 1] = 1; // 树的编号从1开始，因此需要减1\n    }\n\n    // 读取可以补种的树的数量\n    int supplementCount;\n    scanf(\"%d\", &supplementCount);\n\n    // 初始化滑动窗口的左右边界\n    int left = 0, maxLen = 0, sumLeft = 0, sumRight = 0;\n\n    // 遍历所有的树，right代表滑动窗口的右边界\n    for (int right = 0; right < total; right++) {\n        sumRight += nums[right]; // 更新右边界的未成活树数量\n\n        // 如果窗口内的未成活树数量大于可以补种的数量\n        while (sumRight - sumLeft > supplementCount) {\n            sumLeft += nums[left]; // 缩小窗口，左边界右移\n            left++;\n        }\n\n        // 更新最大成活区域的长度\n        maxLen = max(maxLen, right - left + 1);\n    }\n\n    // 输出最大连续成活区域的长度\n    printf(\"%d\\n\", maxLen);\n\n    // 释放动态分配的内存\n    free(nums);\n\n    return 0;\n}"
  }
}