{
  "id": "140",
  "title": "跳房子I",
  "examType": "A",
  "score": 200,
  "description": "跳房子，也叫跳飞机，是一种世界性的儿童游戏。\n游戏参与者需要分多个回合按顺序跳到第1格直到房子的最后一格。\n跳房子的过程中，可以向前跳，也可以向后跳。\n假设房子的总格数是count，小红每回合可能连续跳的步教都放在数组steps中，请问数组中是否有一种步数的组合，可以让小红两个回合跳到量后一格?\n如果有，请输出索引和最小的步数组合。\n注意：\n数组中的步数可以重复，但数组中的元素不能重复使用。提供的数据保证存在满足题目要求的组合，且索引和最小的步数组合是唯一的。",
  "inputDesc": "第一行输入为每回合可能连续跳的步数，它是int整数数组类型。\n第二行输入为房子总格数count，它是int整数类型。\ncount ≤ 10000 ≤ steps.length ≤ 5000-100000000 ≤ steps ≤ 100000000",
  "outputDesc": "返回索引和最小的满足要求的步数组合（顺序保持steps中原有顺序）",
  "examples": [
    {
      "input": "[1,4,5,2,2]\n7",
      "output": "[5, 2]",
      "explanation": "5+2=7，索引为2+3=5，是索引和最小的组合"
    },
    {
      "input": "[-1,2,4,9,6]\n8",
      "output": "[-1, 9]",
      "explanation": "-1+9=8索引和0+3=3，2+6=8索引和1+4=5，选择索引和最小的[-1,9]"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**两数之和变体**问题。\n\n**核心思路：**\n- 找两个数之和等于count\n- 多个解时选择索引和最小的\n\n**算法步骤：**\n1. 双重循环遍历所有数对组合\n2. 若两数之和等于count，计算索引和\n3. 更新索引和最小的答案\n4. 由于从小索引开始遍历，找到第一个解即可break内层循环\n\n**时间复杂度**：O(N²)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建Scanner对象用于读取输入\n        Scanner sc = new Scanner(System.in);\n\n        // 读取一行输入，将其转换为int数组steps\n        String tmp = sc.nextLine();\n        int[] steps =\n                Arrays.stream(tmp.substring(1, tmp.length() - 1).split(\",\"))\n                        .mapToInt(Integer::parseInt)\n                        .toArray();\n\n        // 读取房子总格数count\n        int count = Integer.parseInt(sc.nextLine());\n\n        // 初始化最小索引和为最大整数值\n        int minIdxSum = Integer.MAX_VALUE;\n        // 初始化答案为空字符串\n        String ans = \"\";\n\n        // 使用两层循环遍历数组中的所有可能的组合\n        for (int idx1 = 0; idx1 < steps.length; idx1++) {\n            for (int idx2 = idx1 + 1; idx2 < steps.length; idx2++) {\n                // 获取两个步数\n                int step1 = steps[idx1];\n                int step2 = steps[idx2];\n\n                // 如果两个步数之和等于count\n                if (step1 + step2 == count) {\n                    // 计算当前组合的索引和\n                    int idxSum = idx1 + idx2;\n                    // 如果当前组合的索引和小于已找到的最小索引和\n                    if (idxSum < minIdxSum) {\n                        // 更新最小索引和\n                        minIdxSum = idxSum;\n                        // 更新答案\n                        ans = \"[\" + step1 + \", \" + step2 + \"]\";\n                    }\n                    // 找到满足条件的组合后，跳出内层循环\n                    break;\n                }\n            }\n        }\n\n        // 输出结果\n        System.out.println(ans);\n    }\n}",
    "python": "def main():\n    # 读取一行输入，将其转换为 int 列表 steps\n    steps = list(map(int, input()[1:-1].split(',')))\n\n    # 读取房子总格数 count\n    count = int(input())\n\n    # 初始化最小索引和为最大整数值\n    min_idx_sum = float('inf')\n    # 初始化答案为空字符串\n    ans = \"\"\n\n    # 使用两层循环遍历数组中的所有可能的组合\n    for idx1 in range(len(steps)):\n        for idx2 in range(idx1 + 1, len(steps)):\n            # 获取两个步数\n            step1 = steps[idx1]\n            step2 = steps[idx2]\n\n            # 如果两个步数之和等于 count\n            if step1 + step2 == count:\n                # 计算当前组合的索引和\n                idx_sum = idx1 + idx2\n                # 如果当前组合的索引和小于已找到的最小索引和\n                if idx_sum < min_idx_sum:\n                    # 更新最小索引和\n                    min_idx_sum = idx_sum\n                    # 更新答案\n                    ans = [step1, step2]\n                # 找到满足条件的组合后，跳出内层循环\n                break\n\n    # 输出结果\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst inputLines = [];\n\n// 读取输入行\nrl.on('line', (line) => {\n  inputLines.push(line);\n  if (inputLines.length === 2) {\n    rl.close();\n  }\n});\n\nrl.on('close', () => {\n  // 解析输入的步数数组和房子总格数\n  const steps = JSON.parse(inputLines[0]);\n  const count = parseInt(inputLines[1], 10);\n\n  let minIdxSum = Number.MAX_VALUE;\n  let ans = '';\n\n  // 遍历数组中的所有可能的组合\n  for (let idx1 = 0; idx1 < steps.length; idx1++) {\n    for (let idx2 = idx1 + 1; idx2 < steps.length; idx2++) {\n      const step1 = steps[idx1];\n      const step2 = steps[idx2];\n\n      // 如果两个步数之和等于房子总格数\n      if (step1 + step2 === count) {\n        const idxSum = idx1 + idx2;\n        // 如果当前组合的索引和小于已找到的最小索引和\n        if (idxSum < minIdxSum) {\n          // 更新最小索引和\n          minIdxSum = idxSum;\n          // 更新答案\n          ans = `[${step1}, ${step2}]`;\n        }\n        // 找到满足条件的组合后，跳出内层循环\n        break;\n      }\n    }\n  }\n\n  // 输出结果\n  console.log(ans);\n});",
    "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <limits>\n#include <algorithm>\nusing namespace std;\nint main() {\n    // 读取一行输入，将其转换为 int 数组 steps\n    string tmp;\n    getline(cin, tmp);\n    tmp = tmp.substr(1, tmp.length() - 2);\n    istringstream iss(tmp);\n    vector<int> steps;\n    string token;\n    while (getline(iss, token, ',')) {\n        steps.push_back(stoi(token));\n    }\n\n    // 读取房子总格数 count\n    int count;\n    cin >> count;\n\n    // 初始化最小索引和为最大整数值\n    int minIdxSum = numeric_limits<int>::max();\n    // 初始化答案为空字符串\n    string ans = \"\";\n\n    // 使用两层循环遍历数组中的所有可能的组合\n    for (size_t idx1 = 0; idx1 < steps.size(); idx1++) {\n        for (size_t idx2 = idx1 + 1; idx2 < steps.size(); idx2++) {\n            // 获取两个步数\n            int step1 = steps[idx1];\n            int step2 = steps[idx2];\n\n            // 如果两个步数之和等于 count\n            if (step1 + step2 == count) {\n                // 计算当前组合的索引和\n                int idxSum = static_cast<int>(idx1 + idx2);\n                // 如果当前组合的索引和小于已找到的最小索引和\n                if (idxSum < minIdxSum) {\n                    // 更新最小索引和\n                    minIdxSum = idxSum;\n                    // 更新答案\n                    ans = \"[\" + to_string(step1) + \", \" + to_string(step2) + \"]\";\n                }\n                // 找到满足条件的组合后，跳出内层循环\n                break;\n            }\n        }\n    }\n\n    // 输出结果\n    cout << ans << endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\nint main() {\n    // 定义一个字符数组用于存储输入的步数\n    char tmp[10000];\n    \n    // 读取一行输入，将其存储在tmp中\n    fgets(tmp, 10000, stdin);\n\n    // 去掉首尾的方括号，并通过逗号分隔输入，转换为整数数组steps\n    int steps[5000];  // 假设步数的最大长度不会超过5000\n    int stepCount = 0; // 实际步数的数量\n    char *token = strtok(tmp + 1, \",\"); // 从第二个字符开始（跳过左方括号）\n    while (token != NULL && *token != ']') {\n        steps[stepCount++] = atoi(token); // 将分割出的每个字符串转换为整数并存入steps数组\n        token = strtok(NULL, \",\");\n    }\n\n    // 读取房子总格数count\n    int count;\n    scanf(\"%d\", &count);\n\n    // 初始化最小索引和为最大整数值\n    int minIdxSum = INT_MAX;\n    // 初始化答案为两个步数的值\n    int ans1 = 0, ans2 = 0;\n\n    // 使用两层循环遍历数组中的所有可能的组合\n    for (int idx1 = 0; idx1 < stepCount; idx1++) {\n        for (int idx2 = idx1 + 1; idx2 < stepCount; idx2++) {\n            // 获取两个步数\n            int step1 = steps[idx1];\n            int step2 = steps[idx2];\n\n            // 如果两个步数之和等于count\n            if (step1 + step2 == count) {\n                // 计算当前组合的索引和\n                int idxSum = idx1 + idx2;\n                // 如果当前组合的索引和小于已找到的最小索引和\n                if (idxSum < minIdxSum) {\n                    // 更新最小索引和\n                    minIdxSum = idxSum;\n                    // 更新答案步数\n                    ans1 = step1;\n                    ans2 = step2;\n                }\n                // 找到满足条件的组合后，跳出内层循环\n                break;\n            }\n        }\n    }\n\n    // 输出结果，格式为\"[step1, step2]\"\n    printf(\"[%d, %d]\\n\", ans1, ans2);\n\n    return 0;\n}"
  }
}