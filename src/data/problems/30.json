{
  "id": "30",
  "title": "整数对最小和",
  "examType": "A",
  "score": 100,
  "description": "给定两个整数数组array1、array2，数组元素按升序排列。\n假设从array1、array2中分别取出一个元素可构成一对元素，现在需要取出k对元素，\n并对取出的所有元素求和，计算和的最小值。\n注意：\n两对元素如果对应于array1、array2中的两个下标均相同，则视为同一对元素。",
  "inputDesc": "输入两行数组array1、array2，每行首个数字为数组大小size(0 < size <= 100);\n0 < array1[i] <= 1000\n0 < array2[i] <= 1000\n接下来一行为正整数k\n0 < k <= array1.size() * array2.size()",
  "outputDesc": "满足要求的最小和",
  "examples": [
    {
      "input": "2 1 1\n3 1 2 3\n2",
      "output": "4",
      "explanation": "array1=[1,1]，array2=[1,2,3]，需要取k=2对元素。\n所有可能的和：1+1=2, 1+2=3, 1+3=4, 1+1=2, 1+2=3, 1+3=4\n排序后取前2个最小的：2+2=4"
    },
    {
      "input": "3 1 2 3\n3 1 2 3\n3",
      "output": "8",
      "explanation": "array1=[1,2,3]，array2=[1,2,3]，需要取k=3对元素。\n最小的3对：(1,1)=2, (1,2)=3, (2,1)=3\n最小和：2+3+3=8"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**暴力枚举 + 排序**问题。\n\n**算法步骤：**\n\n1. 读取两个升序数组array1和array2\n2. 枚举所有可能的元素对，计算每对的和\n3. 将所有和排序\n4. 取前k个最小的和相加\n\n**优化思路：**\n可以使用最小堆优化，但由于数组较小(size≤100)，暴力也能通过。\n\n**时间复杂度**：O(n*m*log(n*m))，其中n、m为数组大小",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 输入第一个数组\n        int size1 = scanner.nextInt();\n        List<Integer> array1 = new ArrayList<>();\n        for (int i = 0; i < size1; i++) {\n            array1.add(scanner.nextInt());\n        }\n\n        // 输入第二个数组\n        int size2 = scanner.nextInt();\n        List<Integer> array2 = new ArrayList<>();\n        for (int i = 0; i < size2; i++) {\n            array2.add(scanner.nextInt());\n        }\n\n        // 输入需要取出的元素对数\n        int k = scanner.nextInt();\n\n        // 存储所有可能的元素对的和\n        List<Integer> pairsSum = new ArrayList<>();\n        for (int value1 : array1) {\n            for (int value2 : array2) {\n                pairsSum.add(value1 + value2);\n            }\n        }\n\n        // 对和进行排序\n        Collections.sort(pairsSum);\n\n        // 取前k个元素进行求和\n        int minSum = 0;\n        for (int i = 0; i < k; i++) {\n            minSum += pairsSum.get(i);\n        }\n\n        System.out.println(minSum);\n    }\n}",
    "python": "# 从输入中获取数组array1，使用map函数将输入的字符串转换为整数，并使用列表切片[1:]去除第一个元素\narray1 = list(map(int, input().split()))[1:]\n\n# 从输入中获取数组array2，使用map函数将输入的字符串转换为整数，并使用列表切片[1:]去除第一个元素\narray2 = list(map(int, input().split()))[1:]\n\n# 从输入中获取k的值，将其转换为整数\nk = int(input())\n\n# 存储所有可能的元素对的和\npairsSum = []\nfor value1 in array1:\n    for value2 in array2:\n        pairsSum.append(value1 + value2)\n\n# 对和进行排序\npairsSum.sort()\n\n# 取前k个元素进行求和\nminSum = sum(pairsSum[:k])\n\n# 输出最小和\nprint(minSum)",
    "javascript": "const readline = require('readline');\n\n// 创建readline接口实例\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n rl.on('line', (array1Input) => {\n  // 将输入的字符串按空格分割为数组，并将每个元素转换为数字，然后去除第一个元素\n  const array1 = array1Input.split(' ').map(Number).slice(1);\n\n   rl.on('line', (array2Input) => {\n    // 将输入的字符串按空格分割为数组，并将每个元素转换为数字，然后去除第一个元素\n    const array2 = array2Input.split(' ').map(Number).slice(1);\n\n     rl.on('line', (kInput) => {\n      // 将输入的字符串转换为整数\n      const k = parseInt(kInput);\n\n      // 创建一个空数组pairsSum\n      const pairsSum = [];\n\n      // 嵌套循环，将array1和array2中的元素两两相加，并将结果存储到pairsSum中\n      for (const value1 of array1) {\n        for (const value2 of array2) {\n          pairsSum.push(value1 + value2);\n        }\n      }\n\n      // 对pairsSum中的元素进行排序\n      pairsSum.sort();\n\n      // 取出pairsSum中前k个元素，并使用reduce方法计算它们的和\n      const minSum = pairsSum.slice(0, k).reduce((sum, value) => sum + value, 0);\n\n      // 输出最小和\n      console.log(minSum);\n\n      // 关闭readline接口，结束程序的执行\n      rl.close();\n    });\n  });\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // 输入数组array1的大小\n    int size1;\n    std::cin >> size1;\n\n    // 创建大小为size1的vector来存储array1的元素\n    std::vector<int> array1(size1);\n    for (int i = 0; i < size1; i++) {\n        // 逐个读取array1的元素并存储到vector中\n        std::cin >> array1[i];\n    }\n\n    // 输入数组array2的大小\n    int size2;\n    std::cin >> size2;\n\n    // 创建大小为size2的vector来存储array2的元素\n    std::vector<int> array2(size2);\n    for (int i = 0; i < size2; i++) {\n        // 逐个读取array2的元素并存储到vector中\n        std::cin >> array2[i];\n    }\n\n    // 输入k的值\n    int k;\n    std::cin >> k;\n\n    // 创建一个vector来存储所有可能的元素对的和\n    std::vector<int> pairsSum;\n    for (int value1 : array1) {\n        for (int value2 : array2) {\n            // 将array1和array2中的元素两两相加，并将结果存储到pairsSum中\n            pairsSum.push_back(value1 + value2);\n        }\n    }\n\n    // 对pairsSum中的元素进行排序\n    std::sort(pairsSum.begin(), pairsSum.end());\n\n    // 计算前k个元素的和\n    int minSum = 0;\n    for (int i = 0; i < k; i++) {\n        minSum += pairsSum[i];\n    }\n\n    // 输出最小和\n    std::cout << minSum << std::endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\n// 比较函数，用于qsort\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int size1, size2, k;\n    // 输入数组array1和array2的大小\n    scanf(\"%d\", &size1);\n    int array1[size1];\n    for (int i = 0; i < size1; i++) {\n        scanf(\"%d\", &array1[i]);\n    }\n\n    scanf(\"%d\", &size2);\n    int array2[size2];\n    for (int i = 0; i < size2; i++) {\n        scanf(\"%d\", &array2[i]);\n    }\n\n    // 输入k的值\n    scanf(\"%d\", &k);\n\n    // 创建数组来存储所有可能的元素对的和\n    int pairsSum[size1 * size2];\n    int count = 0;\n    for (int i = 0; i < size1; i++) {\n        for (int j = 0; j < size2; j++) {\n            // 将array1和array2中的元素两两相加，并将结果存储到pairsSum中\n            pairsSum[count++] = array1[i] + array2[j];\n        }\n    }\n\n    // 对pairsSum中的元素进行排序\n    qsort(pairsSum, count, sizeof(int), compare);\n\n    // 计算前k个元素的和\n    int minSum = 0;\n    for (int i = 0; i < k; i++) {\n        minSum += pairsSum[i];\n    }\n\n    // 输出最小和\n    printf(\"%d\\n\", minSum);\n\n    return 0;\n}"
  }
}