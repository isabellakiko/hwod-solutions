{
  "id": "78",
  "title": "最长的指定瑕疵度的元音子串",
  "examType": "A",
  "score": 100,
  "description": "开头和结尾都是元音字母（aeiouAEIOU）的字符串为元音字符串，其中混杂的非元音字母数量为其瑕疵度。比如:\n“a” 、 “aa”是元音字符串，其瑕疵度都为0“aiur”不是元音字符串（结尾不是元音字符） “abira”是元音字符串，其瑕疵度为2\n给定一个字符串，请找出指定瑕疵度的最长元音字符子串，并输出其长度，如果找不到满足条件的元音字符子串，输出0。\n子串：字符串中任意个连续的字符组成的子序列称为该字符串的子串。\n",
  "inputDesc": "首行输入是一个整数，表示预期的瑕疵度flaw，取值范围[0, 65535]。\n接下来一行是一个仅由字符a-z和A-Z组成的字符串，字符串长度(0, 65535]。\n",
  "outputDesc": "输出为一个整数，代表满足条件的元音字符子串的长度。",
  "examples": [
    {
      "input": "0\nasdbuiodevauufgh",
      "output": "3",
      "explanation": "瑕疵度为0的元音子串有a、uio、e、auu，最长是auu或uio，长度3。"
    },
    {
      "input": "2\nasdbuiodevauufgh",
      "output": "9",
      "explanation": "瑕疵度为2的最长元音子串是uiodevau，长度9（d、v两个非元音）。"
    },
    {
      "input": "1\nabira",
      "output": "0",
      "explanation": "abira瑕疵度为2，没有瑕疵度为1的元音子串。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**双指针**问题。\n\n**算法步骤：**\n1. 记录所有元音字母的下标到数组idxs\n2. 用双指针l、r指向idxs的元素，代表元音子串的首尾\n3. 瑕疵度 = idxs[r] - idxs[l] - (r - l)\n4. 若瑕疵度>flaw，l右移；若<flaw，r右移\n5. 若等于flaw，记录长度并r右移\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int flaw = sc.nextInt();\n    String s = sc.next();\n\n    System.out.println(getResult(flaw, s));\n  }\n\n  public static int getResult(int flaw, String s) {\n    char[] yuan = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n    HashSet<Character> set = new HashSet<>();\n    for (char c : yuan) set.add(c);\n\n    ArrayList<Integer> idxs = new ArrayList<>();\n    for (int i = 0; i < s.length(); i++) {\n      if (set.contains(s.charAt(i))) idxs.add(i);\n    }\n\n    int ans = 0;\n    int n = idxs.size();\n\n    int l = 0;\n    int r = 0;\n\n    while (r < n) {\n      // 瑕疵度计算\n      int diff = idxs.get(r) - idxs.get(l) - (r - l);\n\n      if (diff > flaw) {\n        l++;\n      } else if (diff < flaw) {\n        r++;\n      } else {\n        ans = Math.max(ans, idxs.get(r) - idxs.get(l) + 1);\n        r++;\n      }\n    }\n\n    return ans;\n  }\n}",
    "python": "# 输入获取\nflaw = int(input())\ns = input()\n\n\n# 算法入口\ndef getResult():\n    yuanSet = set(list(\"aeiouAEIOU\"))\n\n    idxs = []\n    for i in range(len(s)):\n        if s[i] in yuanSet:\n            idxs.append(i)\n\n    ans = 0\n\n    l = 0\n    r = 0\n\n    while r < len(idxs):\n        # 瑕疵度计算\n        diff = idxs[r] - idxs[l] - (r - l)\n\n        if diff > flaw:\n            l += 1\n        elif diff < flaw:\n            r += 1\n        else:\n            ans = max(ans, idxs[r] - idxs[l] + 1)\n            r += 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst lines = [];\nrl.on('line', (line) => {\n    lines.push(line);\n    if (lines.length === 2) {\n        const flaw = parseInt(lines[0]);\n        const s = lines[1];\n        \n        const yuanSet = new Set('aeiouAEIOU'.split(''));\n        const idxs = [];\n        for (let i = 0; i < s.length; i++) {\n            if (yuanSet.has(s[i])) idxs.push(i);\n        }\n        \n        let ans = 0;\n        let l = 0, r = 0;\n        \n        while (r < idxs.length) {\n            const diff = idxs[r] - idxs[l] - (r - l);\n            \n            if (diff > flaw) {\n                l++;\n            } else if (diff < flaw) {\n                r++;\n            } else {\n                ans = Math.max(ans, idxs[r] - idxs[l] + 1);\n                r++;\n            }\n        }\n        \n        console.log(ans);\n        rl.close();\n    }\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int flaw;\n    string s;\n    cin >> flaw >> s;\n    \n    set<char> yuanSet({'a','e','i','o','u','A','E','I','O','U'});\n    vector<int> idxs;\n    \n    for (int i = 0; i < s.length(); i++) {\n        if (yuanSet.count(s[i])) idxs.push_back(i);\n    }\n    \n    int ans = 0;\n    int l = 0, r = 0;\n    int n = idxs.size();\n    \n    while (r < n) {\n        int diff = idxs[r] - idxs[l] - (r - l);\n        \n        if (diff > flaw) {\n            l++;\n        } else if (diff < flaw) {\n            r++;\n        } else {\n            ans = max(ans, idxs[r] - idxs[l] + 1);\n            r++;\n        }\n    }\n    \n    cout << ans << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n\nint isVowel(char c) {\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n           c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\n\nint main() {\n    int flaw;\n    char s[65536];\n    scanf(\"%d %s\", &flaw, s);\n    \n    int idxs[65536];\n    int n = 0;\n    int len = strlen(s);\n    \n    for (int i = 0; i < len; i++) {\n        if (isVowel(s[i])) idxs[n++] = i;\n    }\n    \n    int ans = 0;\n    int l = 0, r = 0;\n    \n    while (r < n) {\n        int diff = idxs[r] - idxs[l] - (r - l);\n        \n        if (diff > flaw) {\n            l++;\n        } else if (diff < flaw) {\n            r++;\n        } else {\n            int curLen = idxs[r] - idxs[l] + 1;\n            if (curLen > ans) ans = curLen;\n            r++;\n        }\n    }\n    \n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  }
}