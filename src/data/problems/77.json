{
  "id": "77",
  "title": "最短木板长度",
  "examType": "A",
  "score": 100,
  "description": "小明有 n 块木板，第 i ( 1 ≤ i ≤ n ) 块木板长度为 ai。 小明买了一块长度为 m 的木料，这块木料可以切割成任意块，拼接到已有的木板上，用来加长木板。 小明想让最短的模板尽量长。请问小明加长木板后，最短木板的长度可以为多少？\n",
  "inputDesc": "输入的第一行包含两个正整数， n ( 1 ≤ n ≤ 10^3 ), m ( 1 ≤ m ≤ 10^6 )，n 表示木板数， m 表示木板长度。 输入的第二行包含 n 个正整数， a1, a2,…an ( 1 ≤ ai ≤ 10^6 )。\n",
  "outputDesc": "输出加长木板后，最短木板的长度最大可以为多少。",
  "examples": [
    {
      "input": "5 3\n4 5 3 5 5",
      "output": "5",
      "explanation": "先将长度3的板补到4（消耗1），再将两块4的板补到5（消耗2），最终所有板都是5。"
    },
    {
      "input": "3 10\n1 1 1",
      "output": "4",
      "explanation": "三块板都是1，材料10可以平均分给3块板，每块分到10/3=3，最短板长度1+3=4。"
    },
    {
      "input": "4 5\n2 3 4 5",
      "output": "4",
      "explanation": "补足最短板2到3（消耗1），补足两块3到4（消耗2），剩余2不够补3块4到5，每块分2/3=0，最短板4。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心+优先队列**问题。\n\n**算法步骤：**\n1. 统计每种长度木板的数量\n2. 用优先队列按长度升序排列\n3. 每次将最短板补足到第二短板的长度\n4. 计算补足所需材料，判断是否足够\n5. 若只剩一种长度，平均分配剩余材料\n\n**时间复杂度**：O(N log N)",
  "codes": {
    "java": "import java.util.HashMap;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n    int m = sc.nextInt();\n\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++) {\n      a[i] = sc.nextInt();\n    }\n\n    System.out.println(getResult(m, a));\n  }\n\n  public static int getResult(int m, int[] a) {\n    // 统计每种长度板的数量，记录到woods中，key是板长度，val是板数量\n    HashMap<Integer, Integer> woods = new HashMap<>();\n    for (Integer ai : a) {\n      if (woods.containsKey(ai)) {\n        Integer val = woods.get(ai);\n        woods.put(ai, ++val);\n      } else {\n        woods.put(ai, 1);\n      }\n    }\n\n    // 将统计到的板，按板长度排优先级，长度越短优先级越高，这里使用优先队列来实现优先级\n    PriorityQueue<Integer[]> pq = new PriorityQueue<>((b, c) -> b[0] - c[0]);\n    for (Integer wood : woods.keySet()) {\n      pq.offer(new Integer[] {wood, woods.get(wood)});\n    }\n\n    // 只要还有剩余的m长度，就将他补到最短板上\n    while (m > 0) {\n      // 如果只有一种板长度，那么就尝试将m平均分配到各个板上\n      if (pq.size() == 1) {\n        Integer[] info = pq.poll();\n        int len = info[0];\n        int count = info[1];\n        return len + m / count;\n      }\n\n      // 如果有多种板长度\n      // min1是最短板\n      Integer[] min1 = pq.poll();\n      // min2是第二最短板\n      Integer[] min2 = pq.peek();\n\n      // diff是最短板和第二最短板的差距\n      int diff = min2[0] - min1[0];\n      // 将所有最短板补足到第二短板的长度，所需要总长度total\n      int total = diff * min1[1];\n\n      // 如果m的长度不够补足所有最短板，那么说明此时最短板的长度就是题解\n      if (total > m) {\n        return min1[0] + m / min1[1];\n      }\n      // 如果m的长度刚好可以补足所有最短板，那么说明最短板可以全部升级到第二短板，且刚好用完m，因此第二短板的长度就是题解\n      else if (total == m) {\n        return min2[0];\n      }\n      // 如果m的长度足够长，能补足所有最短板到第二短板，还能有剩余，则将最短的数量加到第二短板的数量上，继续下轮循环\n      else {\n        m -= total;\n        min2[1] += min1[1];\n      }\n    }\n\n    return pq.peek()[0];\n  }\n}",
    "python": "# 输入获取\nimport math\n\nn, m = map(int, input().split())\na = list(map(int, input().split()))\n\n\n# 算法入口\ndef getResult(m, a):\n    # 统计每种长度板的数量，记录到count中，属性是板长度，属性值是板数量\n    count = {}\n    for ai in a:\n        if count.get(ai) is None:\n            count[ai] = 1\n        else:\n            count[ai] += 1\n\n    # 将统计到的板，按板长度升序\n    arr = []\n    for ai in count.keys():\n        arr.append([int(ai), count[ai]])\n\n    arr.sort(key=lambda x: x[0])\n\n    # 只要还有剩余的m长度，就将他补到最短板上\n    while m > 0:\n        # 如果只有一种板长度，那么就尝试将m平均分配到各个板上\n        if len(arr) == 1:\n            lenV, count = arr[0]\n            return lenV + math.floor(m / count)\n\n        # 如果有多种板长度\n        min1 = arr.pop(0) # min1是最短板\n        min2 = arr[0] # min2是第二最短板\n\n        # diff是最短板和第二最短板的差距\n        diff = min2[0] - min1[0]\n\n        # 将所有最短板补足到第二短板的长度，所需要总长度total\n        total = diff * min1[1]\n\n        # 如果m的长度不够补足所有最短板，那么说明此时最短板的长度就是题解\n        if total > m:\n            return min1[0] + math.floor(m / min1[1])\n        # 如果m的长度刚好可以补足所有最短板，那么说明最短板可以全部升级到第二短板，且刚好用完m，因此第二短板的长度就是题解\n        elif total == m:\n            return min2[0]\n        # 如果m的长度足够长，能补足所有最短板到第二短板，还能有剩余，则将最短的数量加到第二短板的数量上，继续下轮循环\n        else:\n            m -= total\n            min2[1] += min1[1]\n\n    return arr[0][0]\n\n\n# 算法调用\nprint(getResult(m, a))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const [n, m] = lines[0].split(\" \").map(Number);\n    const a = lines[1].split(\" \").map(Number);\n    console.log(getResult(m, a));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(m, a) {\n  // 统计每种长度板的数量，记录到count中，属性是板长度，属性值是板数量\n  const count = {};\n  for (let ai of a) {\n    count[ai] ? count[ai]++ : (count[ai] = 1);\n  }\n\n  // 将统计到的板，按板长度升序\n  const arr = [];\n  for (let ai in count) {\n    arr.push([ai - 0, count[ai]]);\n  }\n  arr.sort((a, b) => a[0] - b[0]);\n\n  // 只要还有剩余的m长度，就将他补到最短板上\n  while (m > 0) {\n    // 如果只有一种板长度，那么就尝试将m平均分配到各个板上\n    if (arr.length === 1) {\n      const [len, count] = arr[0];\n      return len + Math.floor(m / count);\n    }\n\n    // 如果有多种板长度\n    // min1是最短板\n    let min1 = arr.shift();\n    // min2是第二最短板\n    let min2 = arr[0];\n\n    // diff是最短板和第二最短板的差距\n    let diff = min2[0] - min1[0];\n\n    // 将所有最短板补足到第二短板的长度，所需要总长度total\n    let total = diff * min1[1];\n\n    // 如果m的长度不够补足所有最短板，那么说明此时最短板的长度就是题解\n    if (total > m) {\n      return min1[0] + Math.floor(m / min1[1]);\n    }\n    // 如果m的长度刚好可以补足所有最短板，那么说明最短板可以全部升级到第二短板，且刚好用完m，因此第二短板的长度就是题解\n    else if (total === m) {\n      return min2[0];\n    }\n    // 如果m的长度足够长，能补足所有最短板到第二短板，还能有剩余，则将最短的数量加到第二短板的数量上，继续下轮循环\n    else {\n      m -= total;\n      min2[1] += min1[1];\n    }\n  }\n\n  return arr[0][0];\n}",
    "cpp": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    map<int, int> count;\n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        count[x]++;\n    }\n    \n    vector<pair<int, int>> arr(count.begin(), count.end());\n    \n    while (m > 0) {\n        if (arr.size() == 1) {\n            cout << arr[0].first + m / arr[0].second << endl;\n            return 0;\n        }\n        \n        auto min1 = arr[0];\n        arr.erase(arr.begin());\n        auto& min2 = arr[0];\n        \n        int diff = min2.first - min1.first;\n        int total = diff * min1.second;\n        \n        if (total > m) {\n            cout << min1.first + m / min1.second << endl;\n            return 0;\n        } else if (total == m) {\n            cout << min2.first << endl;\n            return 0;\n        } else {\n            m -= total;\n            min2.second += min1.second;\n        }\n    }\n    \n    cout << arr[0].first << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int len;\n    int count;\n} Wood;\n\nint cmp(const void* a, const void* b) {\n    return ((Wood*)a)->len - ((Wood*)b)->len;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    int a[1000];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    \n    // 排序后统计\n    qsort(a, n, sizeof(int), cmp);\n    \n    Wood arr[1000];\n    int arrLen = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (arrLen == 0 || arr[arrLen-1].len != a[i]) {\n            arr[arrLen].len = a[i];\n            arr[arrLen].count = 1;\n            arrLen++;\n        } else {\n            arr[arrLen-1].count++;\n        }\n    }\n    \n    int idx = 0;\n    while (m > 0 && idx < arrLen) {\n        if (idx == arrLen - 1) {\n            printf(\"%d\\n\", arr[idx].len + m / arr[idx].count);\n            return 0;\n        }\n        \n        int diff = arr[idx+1].len - arr[idx].len;\n        int total = diff * arr[idx].count;\n        \n        if (total > m) {\n            printf(\"%d\\n\", arr[idx].len + m / arr[idx].count);\n            return 0;\n        } else if (total == m) {\n            printf(\"%d\\n\", arr[idx+1].len);\n            return 0;\n        } else {\n            m -= total;\n            arr[idx+1].count += arr[idx].count;\n            idx++;\n        }\n    }\n    \n    printf(\"%d\\n\", arr[idx].len);\n    return 0;\n}"
  }
}