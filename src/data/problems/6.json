{
  "id": "6",
  "title": "优秀学员统计",
  "examType": "A",
  "score": 100,
  "description": "公司某部门软件教导团正在组织新员工每日打卡学习活动，他们开展这项学习活动已经一个月了，所以想统计下这个月优秀的打卡员工。每个员工会对应一个id，每天的打卡记录记录当天打卡员工的id集合，一共30天。\n\n请你实现代码帮助统计出打卡次数 **top5** 的员工。如果打卡次数相同，将较早参与打卡的员工排在前面，如果开始参与打卡的时间还是一样，将id较小的员工排在前面。\n\n**注意**：不考虑并列的情况，按规则返回前5名员工的id即可，如果当月打卡的员工少于5个，按规则排序返回所有有打卡记录的员工id。",
  "inputDesc": "- 第一行：新员工数量 N，表示新员工编号id为 0 到 N-1，N 的范围为 [1, 100]\n- 第二行：30个整数，表示每天打卡的员工数量，每天至少有1名员工打卡\n- 之后30行：每天打卡的员工id集合（id不会重复）",
  "outputDesc": "按顺序输出打卡 top5 员工的id，用空格隔开",
  "examples": [
    {
      "input": "11\n4 4 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2\n0 1 7 10\n0 1 6 10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n10\n6 10\n7 10",
      "output": "10 0 1 7 6",
      "explanation": "员工编号范围为0~10。id为10的员工连续打卡30天，排第一。id为0,1,6,7的员工都打卡2天。其中0,1,7在第一天就打卡，比id为6的员工早，排在前面。0,1,7按id升序排列，所以最终输出 10 0 1 7 6。"
    },
    {
      "input": "7\n6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5\n0 1 2 3 4 5",
      "output": "0 1 2 3 4",
      "explanation": "员工编号范围为0~6。id为0,1,2,3,4,5的员工打卡次数相同（都是30次），最早开始打卡的时间也一样（都是第1天），所以按id升序返回前5个id：0 1 2 3 4。"
    },
    {
      "input": "2\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n1\n0 1\n0 1",
      "output": "1 0",
      "explanation": "只有两名员工参与打卡。id为1的员工打卡30次，id为0的员工打卡2次。按打卡次数排序，输出 1 0。"
    }
  ],
  "solution": "**解题思路：**\n\n这是一道排序问题，关键在于设计正确的排序规则。\n\n**算法步骤：**\n\n1. **统计打卡信息**：遍历30天的打卡记录，对每个员工记录：\n   - 打卡次数\n   - 首次打卡的日期（用于排序）\n\n2. **设计排序规则**（优先级从高到低）：\n   - 打卡次数多的排前面\n   - 次数相同时，首次打卡日期早的排前面\n   - 日期也相同时，id小的排前面\n\n3. **输出结果**：取排序后的前5名（或全部，如果不足5人）\n\n**关键点：**\n- 使用 HashMap 或数组存储每个员工的统计信息\n- 自定义比较器实现多级排序",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        int[] dayCount = new int[30];\n        for (int i = 0; i < 30; i++) {\n            dayCount[i] = sc.nextInt();\n        }\n        \n        // 记录每个员工的 [打卡次数, 首次打卡日期]\n        Map<Integer, int[]> info = new HashMap<>();\n        \n        for (int day = 0; day < 30; day++) {\n            for (int j = 0; j < dayCount[day]; j++) {\n                int id = sc.nextInt();\n                if (info.containsKey(id)) {\n                    info.get(id)[0]++;\n                } else {\n                    info.put(id, new int[]{1, day});\n                }\n            }\n        }\n        \n        // 转为列表并排序\n        List<int[]> list = new ArrayList<>();\n        for (int id : info.keySet()) {\n            int[] data = info.get(id);\n            list.add(new int[]{id, data[0], data[1]});\n        }\n        \n        // 排序：打卡次数降序 -> 首次打卡日期升序 -> id升序\n        list.sort((a, b) -> {\n            if (a[1] != b[1]) return b[1] - a[1];\n            if (a[2] != b[2]) return a[2] - b[2];\n            return a[0] - b[0];\n        });\n        \n        // 输出前5名\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < Math.min(5, list.size()); i++) {\n            if (i > 0) sb.append(\" \");\n            sb.append(list.get(i)[0]);\n        }\n        System.out.println(sb);\n    }\n}",
    "python": "from functools import cmp_to_key\n\nn = int(input())\nday_count = list(map(int, input().split()))\n\n# 记录每个员工的 {id: [打卡次数, 首次打卡日期]}\ninfo = {}\n\nfor day in range(30):\n    ids = list(map(int, input().split()))\n    for emp_id in ids:\n        if emp_id in info:\n            info[emp_id][0] += 1\n        else:\n            info[emp_id] = [1, day]\n\n# 转为列表 [[id, 次数, 首次日期], ...]\nemp_list = [[emp_id, data[0], data[1]] for emp_id, data in info.items()]\n\n# 排序：打卡次数降序 -> 首次打卡日期升序 -> id升序\ndef compare(a, b):\n    if a[1] != b[1]:\n        return b[1] - a[1]  # 次数降序\n    if a[2] != b[2]:\n        return a[2] - b[2]  # 日期升序\n    return a[0] - b[0]      # id升序\n\nemp_list.sort(key=cmp_to_key(compare))\n\n# 输出前5名\nresult = [str(emp[0]) for emp in emp_list[:5]]\nprint(' '.join(result))",
    "javascript": "const readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet lines = [];\nrl.on('line', (line) => {\n  lines.push(line);\n  \n  if (lines.length >= 32) {\n    const n = parseInt(lines[0]);\n    const dayCount = lines[1].split(' ').map(Number);\n    \n    // 记录每个员工的信息\n    const info = new Map();\n    \n    for (let day = 0; day < 30; day++) {\n      const ids = lines[day + 2].split(' ').map(Number);\n      for (const id of ids) {\n        if (info.has(id)) {\n          info.get(id).count++;\n        } else {\n          info.set(id, { count: 1, firstDay: day });\n        }\n      }\n    }\n    \n    // 转为数组并排序\n    const arr = [];\n    for (const [id, data] of info) {\n      arr.push([parseInt(id), data.count, data.firstDay]);\n    }\n    \n    arr.sort((a, b) => {\n      if (a[1] !== b[1]) return b[1] - a[1];\n      if (a[2] !== b[2]) return a[2] - b[2];\n      return a[0] - b[0];\n    });\n    \n    // 输出前5名\n    const result = arr.slice(0, 5).map(item => item[0]);\n    console.log(result.join(' '));\n    rl.close();\n  }\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    int dayCount[30];\n    for (int i = 0; i < 30; i++) {\n        cin >> dayCount[i];\n    }\n    \n    // 记录每个员工的 [打卡次数, 首次打卡日期]\n    map<int, pair<int, int>> info;\n    \n    for (int day = 0; day < 30; day++) {\n        for (int j = 0; j < dayCount[day]; j++) {\n            int id;\n            cin >> id;\n            if (info.count(id)) {\n                info[id].first++;\n            } else {\n                info[id] = {1, day};\n            }\n        }\n    }\n    \n    // 转为vector并排序\n    vector<tuple<int, int, int>> arr;  // {id, count, firstDay}\n    for (auto& p : info) {\n        arr.push_back({p.first, p.second.first, p.second.second});\n    }\n    \n    sort(arr.begin(), arr.end(), [](auto& a, auto& b) {\n        if (get<1>(a) != get<1>(b)) return get<1>(a) > get<1>(b);\n        if (get<2>(a) != get<2>(b)) return get<2>(a) < get<2>(b);\n        return get<0>(a) < get<0>(b);\n    });\n    \n    // 输出前5名\n    for (int i = 0; i < min(5, (int)arr.size()); i++) {\n        if (i > 0) cout << \" \";\n        cout << get<0>(arr[i]);\n    }\n    cout << endl;\n    \n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id;\n    int count;\n    int firstDay;\n} Employee;\n\nint compare(const void* a, const void* b) {\n    Employee* ea = (Employee*)a;\n    Employee* eb = (Employee*)b;\n    if (ea->count != eb->count) return eb->count - ea->count;\n    if (ea->firstDay != eb->firstDay) return ea->firstDay - eb->firstDay;\n    return ea->id - eb->id;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int dayCount[30];\n    for (int i = 0; i < 30; i++) {\n        scanf(\"%d\", &dayCount[i]);\n    }\n    \n    Employee employees[100];\n    int exists[100] = {0};\n    int empCount = 0;\n    \n    for (int day = 0; day < 30; day++) {\n        for (int j = 0; j < dayCount[day]; j++) {\n            int id;\n            scanf(\"%d\", &id);\n            \n            if (exists[id]) {\n                for (int k = 0; k < empCount; k++) {\n                    if (employees[k].id == id) {\n                        employees[k].count++;\n                        break;\n                    }\n                }\n            } else {\n                employees[empCount].id = id;\n                employees[empCount].count = 1;\n                employees[empCount].firstDay = day;\n                exists[id] = 1;\n                empCount++;\n            }\n        }\n    }\n    \n    qsort(employees, empCount, sizeof(Employee), compare);\n    \n    for (int i = 0; i < empCount && i < 5; i++) {\n        if (i > 0) printf(\" \");\n        printf(\"%d\", employees[i].id);\n    }\n    printf(\"\\n\");\n    \n    return 0;\n}"
  }
}
