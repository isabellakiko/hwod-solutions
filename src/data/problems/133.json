{
  "id": "133",
  "title": "特殊的加密算法",
  "examType": "A",
  "score": 200,
  "description": "有一种特殊的加密算法，明文为一段数字串，经过密码本查找转换，生成另一段密文数字串。\n规则如下：\n明文为一段数字串由 0~9 组成 密码本为数字 0~9 组成的二维数组 需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成，上下和左右是相邻的，注意：对角线不相邻，同一个单元格的数字不能重复使用。 每一位明文对应密文即为密码本中找到的单元格所在的行和列序号（序号从0开始）组成的两个数宇。 如明文第 i 位 Data[i] 对应密码本单元格为 Book[x][y]，则明文第 i 位对应的密文为X Y，X和Y之间用空格隔开。\n明文为一段数字串由 0~9 组成\n密码本为数字 0~9 组成的二维数组\n需要按明文串的数字顺序在密码本里找到同样的数字串，密码本里的数字串是由相邻的单元格数字组成，上下和左右是相邻的，注意：对角线不相邻，同一个单元格的数字不能重复使用。\n每一位明文对应密文即为密码本中找到的单元格所在的行和列序号（序号从0开始）组成的两个数宇。\n如明文第 i 位 Data[i] 对应密码本单元格为 Book[x][y]，则明文第 i 位对应的密文为X Y，X和Y之间用空格隔开。\n如果有多条密文，返回字符序最小的密文。\n如果密码本无法匹配，返回\"error\"。\n请你设计这个加密程序。\n示例1：\n密码本：\n0 0 2\n1 3 4\n6 6 4\n明文：“3”，密文：“1 1”\n示例2：\n密码本：\n0 0 2\n1 3 4\n6 6 4\n明文：“0 3”，密文：“0 1 1 1”\n示例3：\n密码本：\n0 0 2 4\n1 3 4 6\n3 4 1 5\n6 6 6 5\n明文：“0 0 2 4”，密文：“0 0 0 1 0 2 0 3” 和 “0 0 0 1 0 2 1 2”，返回字典序最小的\"0 0 0 1 0 2 0 3\"\n明文：“8 2 2 3”，密文：“error”，密码本中无法匹配",
  "inputDesc": "第一行输入 1 个正整数 N，代表明文的长度（1 ≤ N ≤ 200）\n第二行输入 N 个明文组成的序列 Data[i]（0 ≤ Data[i] ≤ 9）\n第三行输入 1 个正整数 M，代表密文的长度\n接下来 M 行，每行 M 个数，代表密文矩阵",
  "outputDesc": "输出字典序最小密文，如果无法匹配，输出\"error\"\n输入\n输出\n输入\n输出\n说明\n找不到 0 5 的序列，返回error",
  "examples": [
    {
      "input": "1\n3\n3\n0 0 2\n1 3 4\n6 6 4",
      "output": "1 1",
      "explanation": "明文为3，在密码本中位置(1,1)找到3"
    },
    {
      "input": "2\n0 3\n3\n0 0 2\n1 3 4\n6 6 4",
      "output": "0 1 1 1",
      "explanation": "明文0 3，找到相邻路径(0,1)->(1,1)，密文为0 1 1 1"
    },
    {
      "input": "2\n0 5\n3\n0 0 2\n1 3 4\n6 6 4",
      "output": "error",
      "explanation": "密码本中找不到0和5相邻的路径"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**DFS回溯+路径搜索**问题。\n\n**核心思路：**\n- 在密码本中找相邻路径匹配明文序列\n- DFS遍历所有可能路径\n- 返回字典序最小的密文\n\n**算法步骤：**\n1. 遍历密码本找明文首字符位置作为起点\n2. DFS向四个方向搜索，匹配明文下一字符\n3. 用visited数组避免重复访问同一格\n4. 记录路径坐标，找到完整匹配时更新最小字典序结果\n5. 回溯尝试所有路径\n\n**时间复杂度**：O(M²×4^N)，M为密码本大小，N为明文长度",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    static int n, m; // 分别用于存储明文的长度和密码本的尺寸\n    static int[][] book; // 用于存储密码本，是一个二维数组\n    static int[][] directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 表示四个搜索方向：右、下、左、上\n    static String minPath = \"\"; // 用于存储找到的字典序最小的密文路径\n    static boolean found = false; // 标记是否找到了至少一种加密方式\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt(); // 读取明文的长度\n        int[] data = new int[n]; // 创建数组存储明文数字\n        for (int i = 0; i < n; i++) {\n            data[i] = scanner.nextInt(); // 读取每个明文数字\n        }\n\n        m = scanner.nextInt(); // 读取密码本的尺寸\n        book = new int[m][m]; // 初始化密码本数组\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                book[i][j] = scanner.nextInt(); // 填充密码本内容\n            }\n        }\n\n        boolean[][] visited = new boolean[m][m]; // 标记密码本中的数字是否已经被访问过\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                if (book[i][j] == data[0]) { // 从找到的第一个数字开始搜索\n                    dfs(data, 0, i, j, visited, \"\"); // 使用深度优先搜索找到所有可能的加密路径\n                }\n            }\n        }\n\n        System.out.println(found ? minPath.trim() : \"error\"); // 如果找到至少一种加密方式，输出最小字典序的密文；否则，输出\"error\"\n    }\n\n    public static void dfs(int[] data, int index, int x, int y, boolean[][] visited, String path) {\n        if (index == n) { // 如果已经处理完所有明文数字\n            if (!found || path.compareTo(minPath) < 0) { // 如果找到的是第一种加密方式，或者字典序比之前的小\n                minPath = path; // 更新最小字典序密文路径\n            }\n            found = true; // 标记找到了加密方式\n            return;\n        }\n\n        if (x < 0 || y < 0 || x >= m || y >= m || visited[x][y] || book[x][y] != data[index]) {\n            // 如果坐标越界，或该位置已访问，或该位置数字与明文不匹配，则返回\n            return;\n        }\n\n        visited[x][y] = true; // 标记当前位置已访问\n        String newPath = path + x + \" \" + y + \" \"; // 更新路径字符串\n\n        if (index == n - 1 || book[x][y] == data[index]) {\n            dfs(data, index + 1, x, y, visited, newPath); // 继续搜索下一个明文数字\n        }\n\n        for (int[] dir : directions) { // 遍历四个方向\n            int newX = x + dir[0];\n            int newY = y + dir[1];\n            dfs(data, index + 1, newX, newY, visited, newPath); // 在新方向上搜索下一个明文数字\n        }\n\n        visited[x][y] = false; // 回溯，撤销当前位置的访问标记\n    }\n}",
    "python": "import sys\n\n# 读取输入\nn = int(input())\ndata = list(map(int, input().split()))\nm = int(input())\nbook = [list(map(int, input().split())) for _ in range(m)]\n\ndirections = [(0, 1), (1, 0), (-1, 0), (0, -1)]  # 四个搜索方向：右、下、左、上\nmin_path = None  # 存储找到的字典序最小的密文路径\nfound = False  # 标记是否找到至少一种加密方式\n\ndef dfs(data, index, x, y, visited, path):\n    global min_path, found\n    if index == len(data):  # 如果已经处理完所有明文数字\n        if not found or path < min_path:  # 如果找到的是第一种加密方式，或者字典序比之前的小\n            min_path = path  # 更新最小字典序密文路径\n        found = True\n        return\n\n    if x < 0 or y < 0 or x >= m or y >= m or visited[x][y] or book[x][y] != data[index]:\n        # 如果坐标越界，或该位置已访问，或该位置数字与明文不匹配，则返回\n        return\n\n    visited[x][y] = True  # 标记当前位置已访问\n    new_path = path + f\"{x} {y} \"  # 更新路径字符串\n\n    for dir in directions:  # 遍历四个方向\n        newX, newY = x + dir[0], y + dir[1]\n        dfs(data, index + 1, newX, newY, visited, new_path)  # 在新方向上搜索下一个明文数字\n\n    visited[x][y] = False  # 回溯，撤销当前位置的访问标记\n\nvisited = [[False for _ in range(m)] for _ in range(m)]  # 标记密码本中的数字是否已经被访问过\nfor i in range(m):\n    for j in range(m):\n        if book[i][j] == data[0]:  # 从找到的第一个数字开始搜索\n            dfs(data, 0, i, j, visited, \"\")  # 使用深度优先搜索找到所有可能的加密路径\n\nprint(min_path.strip() if found else \"error\")  # 如果找到至少一种加密方式，输出最小字典序的密文；否则，输出\"error\"",
    "javascript": "",
    "cpp": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// 全局变量定义\nstatic int n, m; // 分别用于存储明文的长度和密码本的尺寸\nvector<vector<int>> book; // 用于存储密码本，是一个二维向量\nvector<vector<int>> directions = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 表示四个搜索方向：右、下、左、上\nstring minPath = \"\"; // 用于存储找到的字典序最小的密文路径\nbool found = false; // 标记是否找到了至少一种加密方式\n\n// 深度优先搜索函数声明\nvoid dfs(const vector<int>& data, int index, int x, int y, vector<vector<bool>>& visited, string path);\n\nint main() {\n    cin >> n; // 读取明文的长度\n    vector<int> data(n); // 创建向量存储明文数字\n    for (int i = 0; i < n; ++i) {\n        cin >> data[i]; // 读取每个明文数字\n    }\n\n    cin >> m; // 读取密码本的尺寸\n    book.resize(m, vector<int>(m)); // 初始化密码本向量\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < m; ++j) {\n            cin >> book[i][j]; // 填充密码本内容\n        }\n    }\n\n    vector<vector<bool>> visited(m, vector<bool>(m, false)); // 标记密码本中的数字是否已经被访问过\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (book[i][j] == data[0]) { // 从找到的第一个数字开始搜索\n                dfs(data, 0, i, j, visited, \"\"); // 使用深度优先搜索找到所有可能的加密路径\n            }\n        }\n    }\n\n    cout << (found ? minPath : \"error\") << endl; // 如果找到至少一种加密方式，输出最小字典序的密文；否则，输出\"error\"\n    return 0;\n}\n\nvoid dfs(const vector<int>& data, int index, int x, int y, vector<vector<bool>>& visited, string path) {\n    if (index == n) { // 如果已经处理完所有明文数字\n        if (!found || path < minPath) { // 如果找到的是第一种加密方式，或者字典序比之前的小\n            minPath = path; // 更新最小字典序密文路径\n        }\n        found = true; // 标记找到了加密方式\n        return;\n    }\n\n    if (x < 0 || y < 0 || x >= m || y >= m || visited[x][y] || book[x][y] != data[index]) {\n        // 如果坐标越界，或该位置已访问，或该位置数字与明文不匹配，则返回\n        return;\n    }\n\n    visited[x][y] = true; // 标记当前位置已访问\n    string newPath = path + to_string(x) + \" \" + to_string(y) + \" \"; // 更新路径字符串\n\n    // 遍历四个方向\n    for (const auto& dir : directions) {\n        int newX = x + dir[0];\n        int newY = y + dir[1];\n        dfs(data, index + 1, newX, newY, visited, newPath); // 在新方向上搜索下一个明文数字\n    }\n\n    visited[x][y] = false; // 回溯，撤销当前位置的访问标记\n}",
    "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100 //  密码本的最大尺寸\n#define PATH_LEN 1000 //  路径字符串的最大长度\n\nint n, m; // 明文长度和密码本尺寸\nint book[MAX_SIZE][MAX_SIZE]; // 密码本\nint directions[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}}; // 搜索方向：右、下、左、上\nchar minPath[PATH_LEN] = \"\"; // 最小字典序密文路径\nbool found = false; // 是否找到至少一种加密方式\n\nvoid dfs(int data[], int index, int x, int y, bool visited[MAX_SIZE][MAX_SIZE], char path[PATH_LEN]) {\n    if (index == n) { // 处理完所有明文数字\n        if (!found || strcmp(path, minPath) < 0) {\n            strcpy(minPath, path); // 更新最小字典序密文路径\n        }\n        found = true;\n        return;\n    }\n\n    if (x < 0 || y < 0 || x >= m || y >= m || visited[x][y] || book[x][y] != data[index]) {\n        return; // 坐标越界或位置已访问或数字不匹配\n    }\n\n    visited[x][y] = true;\n    char newPath[PATH_LEN];\n    strcpy(newPath, path); // 当前路径\n    char temp[20]; // 临时字符串存储当前位置\n    sprintf(temp, \"%d %d \", x, y);\n    strcat(newPath, temp); // 更新路径\n\n    for (int i = 0; i < 4; i++) { // 遍历四个方向\n        int newX = x + directions[i][0];\n        int newY = y + directions[i][1];\n        dfs(data, index + 1, newX, newY, visited, newPath);\n    }\n\n    visited[x][y] = false; // 回溯\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    int data[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &data[i]);\n    }\n\n    scanf(\"%d\", &m);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            scanf(\"%d\", &book[i][j]);\n        }\n    }\n\n    bool visited[MAX_SIZE][MAX_SIZE] = {false};\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (book[i][j] == data[0]) {\n                char path[PATH_LEN] = \"\";\n                dfs(data, 0, i, j, visited, path);\n            }\n        }\n    }\n\n    if (found) {\n        printf(\"%s\\n\", minPath);\n    } else {\n        printf(\"error\\n\");\n    }\n\n    return 0;\n}"
  }
}