{
  "id": "65",
  "title": "判断一组不等式是否满足约束并输出最大差",
  "examType": "A",
  "score": 100,
  "description": "给定一组不等式，判断是否成立并输出不等式的最大差(输出浮点数的整数部分)\n要求:\n不等式系数为 double类型，是一个二维数组不等式的变量为 int类型，是一维数组;不等式的目标值为 double类型，是一维数组不等式约束为字符串数组，只能是:“>”,“>=”,“<”,“<=”,“=”，\n例如，不等式组:\na11x1+a12x2+a13x3+a14x4+a15x5<=b1;\na21x1+a22x2+a23x3+a24x4+a25x5<=b2;\na31x1+a32x2+a33x3+a34x4+a35x5<=b3;\n最大差 = max{(a11x1+a12x2+a13x3+a14x4+a15x5-b1),(a21x1+a22x2+a23x3+a24x4+ a25x5-b2),(a31x1+a32x2+a33x3+a34x4+a35x5-b3)},\n类型为整数(输出浮点数的整数部分)\n",
  "inputDesc": "a11,a12,a13,a14,a15,a21,a22,a23,a24,a25, a31,a32,a33,a34,a35,x1,x2,x3,x4,x5,b1,b2,b3,<=,<=,<=\n1)不等式组系数(double类型):\na11,a12,a13,a14,a15\na21,a22,a23,a24,a25\na31,a32,a33,a34,a35\n2)不等式变量(int类型):x1,x2,x3,x4,x5\n3)不等式目标值(double类型):b1,b2,b3\n4)不等式约束(字符串类型):<=,<=,<=\n",
  "outputDesc": "true或者false，最大差（取浮点数的整数部分，不是向下取整）",
  "examples": [
    {
      "input": "2.3,3,5.6,7,6;11,3,8.6,25,1;0.3,9,5.3,66,7.8;1,2,3,4,5;340,670,80.6;<=,<=,<=",
      "output": "false 458",
      "explanation": "计算三个不等式左边-右边的差值，判断是否满足<=约束，输出最大差的整数部分。"
    },
    {
      "input": "1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;1,1,1,1,1;5,5,5;<=,<=,<=",
      "output": "true 0",
      "explanation": "三个差值都是1+1+1+1+1-5=0，满足<=0，输出true和最大差0。"
    },
    {
      "input": "1,0,0,0,0;0,1,0,0,0;0,0,1,0,0;10,20,30,0,0;5,15,25;>,>,>",
      "output": "true 5",
      "explanation": "差值分别为5,5,5，都>0成立，最大差为5。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟计算**问题。\n\n**算法步骤：**\n1. 解析输入，提取系数矩阵、变量、目标值、约束条件\n2. 计算每个不等式的差值：左边表达式-目标值\n3. 根据约束条件判断每个差值是否满足\n4. 输出所有约束是否满足，以及最大差值的整数部分\n\n**注意事项：**\n- 最大差取整数部分，不是向下取整\n- 需要正确处理各种比较运算符\n\n**时间复杂度**：O(N×M)，N为不等式数，M为变量数",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String[][] arr =\n        Arrays.stream(sc.nextLine().split(\";\")).map(s -> s.split(\",\")).toArray(String[][]::new);\n\n    double[] a1 = Arrays.stream(arr[0]).mapToDouble(Double::parseDouble).toArray();\n    double[] a2 = Arrays.stream(arr[1]).mapToDouble(Double::parseDouble).toArray();\n    double[] a3 = Arrays.stream(arr[2]).mapToDouble(Double::parseDouble).toArray();\n    double[] x = Arrays.stream(arr[3]).mapToDouble(Double::parseDouble).toArray();\n    double[] b = Arrays.stream(arr[4]).mapToDouble(Double::parseDouble).toArray();\n\n    String[] y = arr[5];\n\n    double diff1 = a1[0] * x[0] + a1[1] * x[1] + a1[2] * x[2] + a1[3] * x[3] + a1[4] * x[4] - b[0];\n    double diff2 = a2[0] * x[0] + a2[1] * x[1] + a2[2] * x[2] + a2[3] * x[3] + a2[4] * x[4] - b[1];\n    double diff3 = a3[0] * x[0] + a3[1] * x[1] + a3[2] * x[2] + a3[3] * x[3] + a3[4] * x[4] - b[2];\n\n    boolean flag =\n        compareWithZero(diff1, y[0])\n            && compareWithZero(diff2, y[1])\n            && compareWithZero(diff3, y[2]);\n\n    double maxDiff = Math.max(Math.max(diff1, diff2), diff3);\n\n    System.out.println(flag + \" \" + (int) maxDiff);\n  }\n\n  public static boolean compareWithZero(double val, String constraint) {\n    boolean flag = false;\n\n    switch (constraint) {\n      case \">\":\n        flag = val > 0;\n        break;\n      case \">=\":\n        flag = val >= 0;\n        break;\n      case \"<\":\n        flag = val < 0;\n        break;\n      case \"<=\":\n        flag = val <= 0;\n        break;\n      case \"=\":\n        flag = val == 0;\n        break;\n    }\n\n    return flag;\n  }\n}",
    "python": "# 输入获取\narr = list(map(lambda s: s.split(\",\"), input().split(\";\")))\n\n\ndef compareWithZero(val, constraint):\n    if constraint == \">\":\n        return val > 0\n    elif constraint == \">=\":\n        return val >= 0\n    elif constraint == \"<\":\n        return val < 0\n    elif constraint == \"<=\":\n        return val <= 0\n    elif constraint == \"=\":\n        return val == 0\n    else:\n        return False\n\n\n# 算法入口\ndef getResult(arr):\n    a11, a12, a13, a14, a15 = map(float, arr[0])\n    a21, a22, a23, a24, a25 = map(float, arr[1])\n    a31, a32, a33, a34, a35 = map(float, arr[2])\n    x1, x2, x3, x4, x5 = map(float, arr[3])\n    b1, b2, b3 = map(float, arr[4])\n    y1, y2, y3 = arr[5]\n\n    diff1 = a11 * x1 + a12 * x2 + a13 * x3 + a14 * x4 + a15 * x5 - b1\n    diff2 = a21 * x1 + a22 * x2 + a23 * x3 + a24 * x4 + a25 * x5 - b2\n    diff3 = a31 * x1 + a32 * x2 + a33 * x3 + a34 * x4 + a35 * x5 - b3\n\n    flag = compareWithZero(diff1, y1) and compareWithZero(diff2, y2) and compareWithZero(diff3, y3)\n\n    maxDiff = max(diff1, diff2, diff3)\n\n    print(f\"{flag} {int(maxDiff)}\".lower())\n\n\n# 算法调用\ngetResult(arr)",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nrl.on(\"line\", (line) => {\n  const arr = line.split(\";\").map((str) => str.split(\",\"));\n\n  const [a11, a12, a13, a14, a15] = arr[0].map(Number);\n  const [a21, a22, a23, a24, a25] = arr[1].map(Number);\n  const [a31, a32, a33, a34, a35] = arr[2].map(Number);\n  const [x1, x2, x3, x4, x5] = arr[3].map(Number);\n  const [b1, b2, b3] = arr[4].map(Number);\n  const [y1, y2, y3] = arr[5];\n\n  let diff1 = a11 * x1 + a12 * x2 + a13 * x3 + a14 * x4 + a15 * x5 - b1;\n  let diff2 = a21 * x1 + a22 * x2 + a23 * x3 + a24 * x4 + a25 * x5 - b2;\n  let diff3 = a31 * x1 + a32 * x2 + a33 * x3 + a34 * x4 + a35 * x5 - b3;\n\n  const flag =\n    compareWithZero(diff1, y1) &&\n    compareWithZero(diff2, y2) &&\n    compareWithZero(diff3, y3);\n\n  const maxDiff = Math.max(diff1, diff2, diff3);\n\n  console.log(`${flag} ${parseInt(maxDiff)}`);\n});\n\nfunction compareWithZero(val, constraint) {\n  let flag;\n  switch (constraint) {\n    case \">\":\n      flag = val > 0;\n      break;\n    case \">=\":\n      flag = val >= 0;\n      break;\n    case \"<\":\n      flag = val < 0;\n      break;\n    case \"<=\":\n      flag = val <= 0;\n      break;\n    case \"=\":\n      flag = val === 0;\n      break;\n  }\n  return flag;\n}",
    "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nbool compareWithZero(double val, const string& constraint) {\n    if (constraint == \">\") return val > 0;\n    if (constraint == \">=\") return val >= 0;\n    if (constraint == \"<\") return val < 0;\n    if (constraint == \"<=\") return val <= 0;\n    if (constraint == \"=\") return val == 0;\n    return false;\n}\n\nvector<string> split(const string& s, char delim) {\n    vector<string> result;\n    stringstream ss(s);\n    string item;\n    while (getline(ss, item, delim)) {\n        result.push_back(item);\n    }\n    return result;\n}\n\nint main() {\n    string line;\n    getline(cin, line);\n    \n    vector<string> parts = split(line, ';');\n    vector<double> a1, a2, a3, x, b;\n    vector<string> y;\n    \n    for (auto& s : split(parts[0], ',')) a1.push_back(stod(s));\n    for (auto& s : split(parts[1], ',')) a2.push_back(stod(s));\n    for (auto& s : split(parts[2], ',')) a3.push_back(stod(s));\n    for (auto& s : split(parts[3], ',')) x.push_back(stod(s));\n    for (auto& s : split(parts[4], ',')) b.push_back(stod(s));\n    y = split(parts[5], ',');\n    \n    double diff1 = a1[0]*x[0] + a1[1]*x[1] + a1[2]*x[2] + a1[3]*x[3] + a1[4]*x[4] - b[0];\n    double diff2 = a2[0]*x[0] + a2[1]*x[1] + a2[2]*x[2] + a2[3]*x[3] + a2[4]*x[4] - b[1];\n    double diff3 = a3[0]*x[0] + a3[1]*x[1] + a3[2]*x[2] + a3[3]*x[3] + a3[4]*x[4] - b[2];\n    \n    bool flag = compareWithZero(diff1, y[0]) && compareWithZero(diff2, y[1]) && compareWithZero(diff3, y[2]);\n    double maxDiff = max({diff1, diff2, diff3});\n    \n    cout << (flag ? \"true\" : \"false\") << \" \" << (int)maxDiff << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compareWithZero(double val, const char* constraint) {\n    if (strcmp(constraint, \">\") == 0) return val > 0;\n    if (strcmp(constraint, \">=\") == 0) return val >= 0;\n    if (strcmp(constraint, \"<\") == 0) return val < 0;\n    if (strcmp(constraint, \"<=\") == 0) return val <= 0;\n    if (strcmp(constraint, \"=\") == 0) return val == 0;\n    return 0;\n}\n\nint main() {\n    char line[1024];\n    fgets(line, sizeof(line), stdin);\n    \n    double a1[5], a2[5], a3[5], x[5], b[3];\n    char y[3][10];\n    \n    char* parts[6];\n    int idx = 0;\n    char* token = strtok(line, \";\");\n    while (token && idx < 6) {\n        parts[idx++] = token;\n        token = strtok(NULL, \";\");\n    }\n    \n    sscanf(parts[0], \"%lf,%lf,%lf,%lf,%lf\", &a1[0], &a1[1], &a1[2], &a1[3], &a1[4]);\n    sscanf(parts[1], \"%lf,%lf,%lf,%lf,%lf\", &a2[0], &a2[1], &a2[2], &a2[3], &a2[4]);\n    sscanf(parts[2], \"%lf,%lf,%lf,%lf,%lf\", &a3[0], &a3[1], &a3[2], &a3[3], &a3[4]);\n    sscanf(parts[3], \"%lf,%lf,%lf,%lf,%lf\", &x[0], &x[1], &x[2], &x[3], &x[4]);\n    sscanf(parts[4], \"%lf,%lf,%lf\", &b[0], &b[1], &b[2]);\n    sscanf(parts[5], \"%[^,],%[^,],%s\", y[0], y[1], y[2]);\n    \n    double diff1 = a1[0]*x[0] + a1[1]*x[1] + a1[2]*x[2] + a1[3]*x[3] + a1[4]*x[4] - b[0];\n    double diff2 = a2[0]*x[0] + a2[1]*x[1] + a2[2]*x[2] + a2[3]*x[3] + a2[4]*x[4] - b[1];\n    double diff3 = a3[0]*x[0] + a3[1]*x[1] + a3[2]*x[2] + a3[3]*x[3] + a3[4]*x[4] - b[2];\n    \n    int flag = compareWithZero(diff1, y[0]) && compareWithZero(diff2, y[1]) && compareWithZero(diff3, y[2]);\n    double maxDiff = diff1;\n    if (diff2 > maxDiff) maxDiff = diff2;\n    if (diff3 > maxDiff) maxDiff = diff3;\n    \n    printf(\"%s %d\\n\", flag ? \"true\" : \"false\", (int)maxDiff);\n    return 0;\n}"
  }
}