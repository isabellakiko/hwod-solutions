{
  "id": "126",
  "title": "数字游戏",
  "examType": "A",
  "score": 200,
  "description": "小明玩一个游戏。\n系统发1+n张牌，每张牌上有一个整数。\n第一张给小明，后n张按照发牌顺序排成连续的一行。\n需要小明判断，后n张牌中，是否存在连续的若干张牌，其和可以整除小明手中牌上的数字。",
  "inputDesc": "输入数据有多组，每组输入数据有两行，输入到文件结尾结束。\n第一行有两个整数n和m，空格隔开。m代表发给小明牌上的数字。\n第二行有n个数，代表后续发的n张牌上的数字，以空格隔开。\n1 ≤ n ≤ 10001 ≤ 牌上的整数 ≤ 400000输入的组数，不多于1000用例确保输入都正确，不需要考虑非法情况。",
  "outputDesc": "对每组输入，如果存在满足条件的连续若干张牌，则输出1;否则，输出0",
  "examples": [
    {
      "input": "6 7\n12 6 3 5 5 1",
      "output": "1",
      "explanation": "小明牌的数字为7，再发了6张牌。第1、2两张牌数字和为12+6=18，再加第3张=21，可以整除7，输出1"
    },
    {
      "input": "10 11\n1 1 1 1 1 1 1 1 1 1",
      "output": "0",
      "explanation": "小明牌的数字为11，再发了10张牌，这10张牌数字和为10，无法整除11，输出0"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**前缀和+取余**问题。\n\n**核心思路：**\n- 利用前缀和的余数判断连续子数组和是否能被m整除\n- 若prefix[j] % m == prefix[i] % m，则sum(i+1, j)能被m整除\n- 用哈希表记录已出现的余数\n\n**算法步骤：**\n1. 计算前缀和的余数\n2. 若余数为0或余数重复出现，返回1\n3. 遍历完未找到则返回0\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        while (scanner.hasNextLine()) {\n            // 读取输入的n和m，n代表牌的数量，m代表小明手中牌上的数字\n            String[] input = scanner.nextLine().split(\" \");\n            int n = Integer.parseInt(input[0]);\n            int m = Integer.parseInt(input[1]);\n\n            // 读取后续发的n张牌的数字\n            int[] cardNumbers = new int[n];\n            String[] numStrings = scanner.nextLine().split(\" \");\n            for (int i = 0; i < n; i++) {\n                cardNumbers[i] = Integer.parseInt(numStrings[i]);\n            }\n\n            // 使用boolean数组来记录余数的出现情况\n            boolean[] remainderExists = new boolean[m];\n\n            int sum = 0;\n            boolean found = false;\n            for (int cardNumber : cardNumbers) {\n                sum += cardNumber; // 将当前牌的数字累加到sum中\n                int remainder = sum % m; // 计算当前和的余数\n                if (remainderExists[remainder]) { // 如果之前已经存在相同的余数，说明存在连续的若干张牌和可以整除m\n                    found = true;\n                    break;\n                } else {\n                    remainderExists[remainder] = true; // 将当前余数标记为已存在\n                }\n            }\n            System.out.println(found ? 1 : 0);\n        }\n    }\n}",
    "python": "import sys\n\nfor line in sys.stdin:\n    # 读取输入的n和m，n代表牌的数量，m代表小明手中牌上的数字\n    n, m = map(int, line.split())\n\n    # 读取后续发的n张牌的数字\n    cardNumbers = list(map(int, input().split()))\n\n    # 使用列表来记录余数的出现情况\n    remainderExists = [False] * m\n\n    sum = 0\n    found = False\n    for cardNumber in cardNumbers:\n        sum += cardNumber  # 将当前牌的数字累加到sum中\n        remainder = sum % m  # 计算当前和的余数\n        if remainderExists[remainder]:  # 如果之前已经存在相同的余数，说明存在连续的若干张牌和可以整除m\n            found = True\n            break\n        else:\n            remainderExists[remainder] = True  # 将当前余数标记为已存在\n\n    print(1 if found else 0)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet isFirstLine = true;\nlet n, m, cardNumbers;\n\nrl.on('line', (line) => {\n  if (isFirstLine) {\n    // 读取输入的n和m，n代表牌的数量，m代表小明手中牌上的数字\n    [n, m] = line.split(' ').map(Number);\n    isFirstLine = false;\n  } else {\n    // 读取后续发的n张牌的数字\n    cardNumbers = line.split(' ').map(Number);\n\n    // 使用数组来记录余数的出现情况\n    const remainderExists = new Array(m).fill(false);\n\n    let sum = 0;\n    let found = false;\n    for (let i = 0; i < n; i++) {\n      const cardNumber = cardNumbers[i];\n      sum += cardNumber;  // 将当前牌的数字累加到sum中\n      const remainder = sum % m;  // 计算当前和的余数\n      if (remainderExists[remainder]) {  // 如果之前已经存在相同的余数，说明存在连续的若干张牌和可以整除m\n        found = true;\n        break;\n      } else {\n        remainderExists[remainder] = true;  // 将当前余数标记为已存在\n      }\n    }\n\n    console.log(found ? 1 : 0);\n\n    isFirstLine = true;\n  }\n});",
    "cpp": "#include <iostream>\n#include <sstream>\n#include <vector>\n\nint main() {\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        std::istringstream iss(line);\n\n        // 读取输入的n和m，n代表牌的数量，m代表小明手中牌上的数字\n        int n, m;\n        iss >> n >> m;\n\n        // 读取后续发的n张牌的数字\n        std::vector<int> cardNumbers(n);\n        std::getline(std::cin, line);\n        iss.str(line);\n        iss.clear();\n        for (int i = 0; i < n; i++) {\n            iss >> cardNumbers[i];\n        }\n\n        // 使用bool数组来记录余数的出现情况\n        std::vector<bool> remainderExists(m, false);\n\n        int sum = 0;\n        bool found = false;\n        for (int cardNumber : cardNumbers) {\n            sum += cardNumber; // 将当前牌的数字累加到sum中\n            int remainder = sum % m; // 计算当前和的余数\n            if (remainderExists[remainder]) { // 如果之前已经存在相同的余数，说明存在连续的若干张牌和可以整除m\n                found = true;\n                break;\n            } else {\n                remainderExists[remainder] = true; // 将当前余数标记为已存在\n            }\n        }\n\n        std::cout << (found ? 1 : 0) << std::endl;\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint main() {\n    int n, m; // 定义两个整数变量n和m，n代表牌的数量，m代表小明手中牌上的数字\n\n    // 使用while循环读取输入，当输入不是文件结束符EOF时继续执行\n    while (scanf(\"%d %d\", &n, &m) != EOF) {\n        int cardNumbers[n]; // 定义一个数组来存储n张牌的数字\n\n        // 读取n个牌的数字\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &cardNumbers[i]); // 从输入中读取每个牌的数字并存入数组\n        }\n\n        // 定义一个布尔数组用于记录余数的出现情况，初始值全部为false\n        bool remainderExists[m]; \n        for (int i = 0; i < m; i++) {\n            remainderExists[i] = false; // 初始化布尔数组\n        }\n\n        int sum = 0; // 用于存储牌数字的累加和\n        bool found = false; // 标记是否找到满足条件的连续牌\n\n        // 遍历每张牌的数字，计算累加和并求余数\n        for (int i = 0; i < n; i++) {\n            sum += cardNumbers[i]; // 将当前牌的数字累加到sum中\n            int remainder = sum % m; // 计算当前和的余数\n\n            // 如果当前余数为0，或者之前已经存在相同的余数，说明存在满足条件的连续牌\n            if (remainder == 0 || remainderExists[remainder]) {\n                found = true; // 设置found为true表示找到满足条件的连续牌\n                break; // 跳出循环\n            } else {\n                remainderExists[remainder] = true; // 将当前余数标记为已存在\n            }\n        }\n\n        // 输出结果，1表示找到满足条件的连续牌，0表示没有找到\n        printf(\"%d\\n\", found ? 1 : 0);\n    }\n\n    return 0; // 返回0表示程序正常结束\n}"
  }
}