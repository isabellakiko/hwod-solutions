{
  "id": "63",
  "title": "Linux发行版的数量",
  "examType": "A",
  "score": 100,
  "description": "Linux操作系统有多个发行版，distrowatch.com提供了各个发行版的资料。这些发行版互相存在关联，例如Ubuntu基于Debian开发，而Mint又基于Ubuntu开发，那么我们认为Mint同Debian也存在关联。\n发行版集是一个或多个相关存在关联的操作系统发行版，集合内不包含没有关联的发行版。\n给你一个 n * n 的矩阵 isConnected，其中 isConnected[i][j] = 1 表示第 i 个发行版和第 j 个发行版直接关联，而 isConnected[i][j] = 0 表示二者不直接相连。\n返回最大的发行版集中发行版的数量。\n",
  "inputDesc": "第一行输入发行版的总数量N，\n之后每行表示各发行版间是否直接相关\n",
  "outputDesc": "输出最大的发行版集中发行版的数量",
  "examples": [
    {
      "input": "4\n1 1 0 0\n1 1 1 0\n0 1 1 0\n0 0 0 1",
      "output": "3",
      "explanation": "0-1相连，1-2相连，形成连通分量{0,1,2}；3单独形成{3}。最大连通分量有3个节点。"
    },
    {
      "input": "3\n1 0 0\n0 1 0\n0 0 1",
      "output": "1",
      "explanation": "三个发行版互不相连，每个都是独立的发行版集，最大为1。"
    },
    {
      "input": "3\n1 1 1\n1 1 1\n1 1 1",
      "output": "3",
      "explanation": "三个发行版全部互相关联，形成一个发行版集，包含3个发行版。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**并查集**问题，求最大连通分量的节点数。\n\n**算法步骤：**\n1. 初始化并查集，每个节点的父节点指向自己\n2. 遍历矩阵，若isConnected[i][j]=1则合并i和j\n3. 统计每个连通分量的节点数\n4. 返回最大的节点数\n\n**并查集核心操作：**\n- find：路径压缩查找根节点\n- union：合并两个集合\n\n**时间复杂度**：O(N²α(N))，α为反阿克曼函数",
  "codes": {
    "java": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    int[][] matrix = new int[n][n];\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        matrix[i][j] = sc.nextInt();\n      }\n    }\n\n    System.out.println(getResult(matrix, n));\n  }\n\n  public static int getResult(int[][] matrix, int n) {\n    UnionFindSet ufs = new UnionFindSet(n);\n\n    for (int i = 0; i < n; i++) {\n      for (int j = i + 1; j < n; j++) { // j从i+1开始，是因为矩阵是对称的\n        if (matrix[i][j] == 1) {\n          ufs.union(i, j);\n        }\n      }\n    }\n\n    // connected的key代表某个连通分量的顶级父节点，value代表该连通分量下的节点个数\n    HashMap<Integer, Integer> connected = new HashMap<>();\n\n    for (int i = 0; i < n; i++) {\n      Integer fa = ufs.find(ufs.fa[i]);\n      connected.put(fa, connected.getOrDefault(fa, 0) + 1);\n    }\n\n    // 返回最大节点数\n    return connected.values().stream().max((a, b) -> a - b).get();\n  }\n}\n\n// 并查集实现\nclass UnionFindSet {\n  int[] fa;\n  int count;\n\n  public UnionFindSet(int n) {\n    this.count = n;\n    this.fa = new int[n];\n    for (int i = 0; i < n; i++) this.fa[i] = i;\n  }\n\n  public int find(int x) {\n    if (x != this.fa[x]) {\n      return (this.fa[x] = this.find(this.fa[x]));\n    }\n    return x;\n  }\n\n  public void union(int x, int y) {\n    int x_fa = this.find(x);\n    int y_fa = this.find(y);\n\n    if (x_fa != y_fa) {\n      this.fa[y_fa] = x_fa;\n      this.count--;\n    }\n  }\n}",
    "python": "# 并查集\nclass UnionFindSet:\n    def __init__(self, n):\n        self.fa = [idx for idx in range(n)]\n        self.count = n\n\n    def find(self, x):\n        if x != self.fa[x]:\n            self.fa[x] = self.find(self.fa[x])\n            return self.fa[x]\n        return x\n\n    def union(self, x, y):\n        x_fa = self.find(x)\n        y_fa = self.find(y)\n\n        if x_fa != y_fa:\n            self.fa[y_fa] = x_fa\n            self.count -= 1\n\n\nn = int(input())\n\nmatrix = []\nfor i in range(n):\n    matrix.append(list(map(int, input().split())))\n\nufs = UnionFindSet(n)\n\nfor i in range(n):\n    for j in range(i + 1, n):  # 这里j从i+1开始，是因为矩阵是对称的\n        if matrix[i][j] == 1:\n            ufs.union(i, j)\n\n# connected字典的属性代表某个连通分量的顶级父节点，属性值代表该连通分量下的节点个数\nconnected = {}\n\nfor i in range(n):\n    fa = ufs.find(ufs.fa[i])\n    connected[fa] = connected.get(fa, 0) + 1\n\n# 返回最大节点数\nprint(max(connected.values()))",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = lines[0] - 0;\n  }\n\n  if (n && lines.length === n + 1) {\n    lines.shift();\n    const matrix = lines.map((line) => line.split(\" \").map(Number));\n    console.log(getResult(matrix, n));\n    lines.length = 0;\n  }\n});\n\nfunction getResult(matrix, n) {\n  const ufs = new UnionFindSet(n);\n\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) { // 这里j从i+1开始，是因为矩阵是对称的\n      if (matrix[i][j] === 1) {\n        ufs.union(i, j);\n      }\n    }\n  }\n\n  // connected对象的属性代表某个连通分量的顶级父节点，属性值代表该连通分量下的节点个数\n  const connected = {};\n\n  for (let i = 0; i < n; i++) {\n    const fa = ufs.find(ufs.fa[i]);\n    connected[fa] ? connected[fa]++ : (connected[fa] = 1);\n  }\n\n  // 返回最大节点数\n  return Math.max.apply(null, Object.values(connected));\n}\n\n// 并查集实现\nclass UnionFindSet {\n  constructor(n) {\n    this.fa = new Array(n).fill(0).map((_, i) => i);\n    this.count = n;\n  }\n\n  find(x) {\n    if (x !== this.fa[x]) {\n      return (this.fa[x] = this.find(this.fa[x]));\n    }\n    return x;\n  }\n\n  union(x, y) {\n    const x_fa = this.find(x);\n    const y_fa = this.find(y);\n\n    if (x_fa !== y_fa) {\n      this.fa[y_fa] = x_fa;\n      this.count--;\n    }\n  }\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass UnionFindSet {\npublic:\n    vector<int> fa;\n    int count;\n    \n    UnionFindSet(int n) {\n        count = n;\n        fa.resize(n);\n        for (int i = 0; i < n; i++) fa[i] = i;\n    }\n    \n    int find(int x) {\n        if (x != fa[x]) {\n            fa[x] = find(fa[x]);\n        }\n        return fa[x];\n    }\n    \n    void unite(int x, int y) {\n        int xFa = find(x);\n        int yFa = find(y);\n        if (xFa != yFa) {\n            fa[yFa] = xFa;\n            count--;\n        }\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<vector<int>> matrix(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n    \n    UnionFindSet ufs(n);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (matrix[i][j] == 1) {\n                ufs.unite(i, j);\n            }\n        }\n    }\n    \n    unordered_map<int, int> connected;\n    for (int i = 0; i < n; i++) {\n        int fa = ufs.find(ufs.fa[i]);\n        connected[fa]++;\n    }\n    \n    int maxCount = 0;\n    for (auto& p : connected) {\n        maxCount = max(maxCount, p.second);\n    }\n    \n    cout << maxCount << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint fa[200];\n\nint find(int x) {\n    if (x != fa[x]) {\n        fa[x] = find(fa[x]);\n    }\n    return fa[x];\n}\n\nvoid unite(int x, int y) {\n    int xFa = find(x);\n    int yFa = find(y);\n    if (xFa != yFa) {\n        fa[yFa] = xFa;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    int matrix[200][200];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n    \n    // 初始化并查集\n    for (int i = 0; i < n; i++) fa[i] = i;\n    \n    // 合并\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (matrix[i][j] == 1) {\n                unite(i, j);\n            }\n        }\n    }\n    \n    // 统计每个连通分量的节点数\n    int count[200] = {0};\n    for (int i = 0; i < n; i++) {\n        int root = find(fa[i]);\n        count[root]++;\n    }\n    \n    // 找最大值\n    int maxCount = 0;\n    for (int i = 0; i < n; i++) {\n        if (count[i] > maxCount) maxCount = count[i];\n    }\n    \n    printf(\"%d\\n\", maxCount);\n    return 0;\n}"
  }
}