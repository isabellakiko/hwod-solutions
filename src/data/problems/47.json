{
  "id": "47",
  "title": "简单的自动曝光平均像素值",
  "examType": "A",
  "score": 100,
  "description": "一个图像有n个像素点，存储在一个长度为n的数组img里，每个像素点的取值范围[0,255]的正整数。\n请你给图像每个像素点值加上一个整数k（可以是负数），得到新图newImg，使得新图newImg的所有像素平均值最接近中位值128。\n请输出这个整数k。",
  "inputDesc": "n个整数，中间用空格分开\n• 1 <= n <= 100 • 如有多个整数k都满足，输出小的那个k； • 新图的像素值会自动截取到[0,255]范围。当新像素值<0，其值会更改为0；当新像素值>255，其值会更改为255；\n例如newImg=”-1 -2 256″,会自动更改为”0 0 255″",
  "outputDesc": "一个整数k",
  "examples": [
    {
      "input": "130 129 130",
      "output": "-2",
      "explanation": "原均值=(130+129+130)/3=129.67\nk=-1时：新值129,128,129，均值=128.67，差0.67\nk=-2时：新值128,127,128，均值=127.67，差0.33\n两者距离128相同(0.67和0.33)...实际-2更接近。输出较小的-2。"
    },
    {
      "input": "0 0 0",
      "output": "128",
      "explanation": "三个像素值都为0。\nk=128时：新值都是128，均值=128，完美匹配中位值。"
    },
    {
      "input": "255 255 255",
      "output": "-127",
      "explanation": "三个像素值都为255。\nk=-127时：新值都是128，均值=128。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**枚举+模拟**问题。\n\n**目标：**\n- 找整数k，使新图像平均值最接近128\n- 新像素值需截取到[0,255]范围\n\n**算法步骤：**\n\n1. 枚举k从-127到128（或更大范围）\n2. 对每个k，计算所有新像素值：\n   - new_val = max(0, min(img[i]+k, 255))\n3. 计算新图像平均值\n4. 计算与128的差值绝对值\n5. 记录使差值最小的k\n6. 若多个k差值相同，输出较小的k\n\n**时间复杂度**：O(256×n)",
  "codes": {
    "java": "import java.util.Scanner; // 导入Scanner类\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in); // 创建Scanner对象\n        String input_str = sc.nextLine(); // 读取一行输入\n        Scanner ss = new Scanner(input_str); // 将输入转换为Scanner对象\n        int val, len = 0;\n        int[] img = new int[110];\n        while (ss.hasNextInt()) { // 判断Scanner对象中是否还有整数\n            val = ss.nextInt(); // 读取下一个整数\n            img[len++] = val;\n        }\n        double min_diff = Integer.MAX_VALUE; // 定义双精度浮点型变量min_diff，并初始化为整型最大值\n        int k_ans = 0; // 定义整型变量k_ans，并初始化为0\n\n        for (int k = -127; k <= 128; k++) { // 循环k的值从-127到128\n            double sum = 0; // 定义双精度浮点型变量sum，并初始化为0\n            for (int i = 0; i < len; i++) { // 循环i的值从0到len-1\n                int new_val = img[i] + k; // 定义整型变量new_val，值为img[i]+k\n                new_val = Math.max(0, Math.min(new_val, 255)); // 将new_val的值限制在0到255之间\n                sum += new_val; // 将new_val的值加入sum中\n            }\n\n            double diff = Math.abs(sum / len - 128); // 计算sum/len-128的绝对值\n\n            if (diff < min_diff) { // 如果diff小于min_diff\n                min_diff = diff; // 将min_diff的值更新为diff\n                k_ans = k; // 将k_ans的值更新为k\n            } else if (diff == min_diff && k_ans != 0) { // 如果diff等于min_diff且k_ans不等于0\n                k_ans = Math.min(k_ans, k); // 将k_ans的值更新为k和k_ans中的最小值\n            }\n        }\n\n        System.out.println(k_ans); // 输出k_ans的值，并换行\n    }\n}",
    "python": "import sys\ninput_str = sys.stdin.readline().strip()\nimg = list(map(int, input_str.split()))\nlen = len(img)\nmin_diff = sys.maxsize\nk_ans = 0\n\nfor k in range(-127, 129):\n    sum = 0\n    for i in range(len):\n        new_val = img[i] + k\n        new_val = max(0, min(new_val, 255))\n        sum += new_val\n    diff = abs(sum / len - 128)\n    if diff < min_diff:\n        min_diff = diff\n        k_ans = k\n    elif diff == min_diff and k_ans != 0:\n        k_ans = min(k_ans, k)\n\nprint(k_ans)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet input_str = '';\n\n// 监听输入，将输入存入input_str中\nrl.on('line', (line) => {\n  input_str += line + ' ';\n}).on('close', () => {\n  const img = [];\n  const input_arr = input_str.trim().split(' ');\n  const len = input_arr.length;\n\n  // 将输入的字符串转为数字并存入数组img中\n  for (let i = 0; i < len; i++) {\n    img.push(parseInt(input_arr[i]));\n  }\n\n  // 初始化最小差值和答案k\n  let min_diff = Number.MAX_SAFE_INTEGER;\n  let k_ans = 0;\n\n  // 枚举k的取值范围\n  for (let k = -127; k <= 128; k++) {\n    let sum = 0;\n\n    // 计算新图的所有像素点的值之和\n    for (let i = 0; i < len; i++) {\n      let new_val = img[i] + k;\n      // 将新像素值截取到[0,255]范围\n      new_val = Math.max(0, Math.min(new_val, 255));\n      sum += new_val;\n    }\n\n    // 计算新图的所有像素点的平均值与中位值128的差值\n    const diff = Math.abs(sum / len - 128);\n\n    // 更新最小差值和答案k\n    if (diff < min_diff) {\n      min_diff = diff;\n      k_ans = k;\n    } else if (diff === min_diff && k_ans !== 0) {\n      k_ans = Math.min(k_ans, k);\n    }\n  }\n\n  // 输出答案k\n  console.log(k_ans);\n});",
    "cpp": "#include <iostream> // 标准输入输出流\n#include <algorithm> \n#include <string> \n#include <sstream> \n#include <cmath> \n#include <climits> \n\nusing namespace std;\n\nint main() {\n    string input_str; \n    getline(cin, input_str); \n    stringstream ss(input_str); \n    int val, len = 0; \n    int img[110]; \n    while (ss >> val) {\n        img[len++] = val; \n    }\n    double min_diff = INT_MAX; // 定义双精度浮点型变量min_diff，并初始化为整型最大值\n    int k_ans = 0; // 定义整型变量k_ans，并初始化为0\n\n    for (int k = -127; k <= 128; k++) { // 循环k的值从-127到128\n        double sum = 0; // 定义双精度浮点型变量sum，并初始化为0\n        for (int i = 0; i < len; i++) { // 循环i的值从0到len-1\n            int new_val = img[i] + k; // 定义整型变量new_val，值为img[i]+k\n            new_val = max(0, min(new_val, 255)); // 将new_val的值限制在0到255之间\n            sum += new_val; // 将new_val的值加入sum中\n        }\n\n        double diff = abs(sum / len - 128); // 计算sum/len-128的绝对值\n\n        if (diff < min_diff) { // 如果diff小于min_diff\n            min_diff = diff; // 将min_diff的值更新为diff\n            k_ans = k; // 将k_ans的值更新为k\n        }\n        else if (diff == min_diff && k_ans != 0) { // 如果diff等于min_diff且k_ans不等于0\n            k_ans = min(k_ans, k); // 将k_ans的值更新为k和k_ans中的最小值\n        }\n    }\n\n    cout << k_ans << endl; // 输出k_ans的值，并换行\n\n    return 0; // 返回0，表示程序正常结束\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <math.h>\n\nint main() {\n    char input_str[1000]; // 定义字符数组用于存储输入的字符串\n    fgets(input_str, 1000, stdin); // 读取一行输入并存储在input_str中\n\n    int val, len = 0; // 定义整型变量val和len，len用于记录数组长度\n    int img[110]; // 定义整型数组img，用于存储输入的像素值\n\n    // 用于解析输入字符串中的整数\n    char *token = strtok(input_str, \" \");\n    while (token != NULL) { // 当token不为NULL时继续循环\n        val = atoi(token); // 将token转换为整数\n        img[len++] = val; // 将整数存入数组img中，并增加数组长度len\n        token = strtok(NULL, \" \"); // 获取下一个token\n    }\n\n    double min_diff = INT_MAX; // 定义双精度浮点型变量min_diff，并初始化为整型最大值\n    int k_ans = 0; // 定义整型变量k_ans，并初始化为0\n\n    // 枚举k值从-127到128\n    for (int k = -127; k <= 128; k++) {\n        double sum = 0; // 定义双精度浮点型变量sum，并初始化为0\n\n        // 遍历img数组中的每一个像素值\n        for (int i = 0; i < len; i++) {\n            int new_val = img[i] + k; // 定义整型变量new_val，值为img[i]+k\n\n            // 将new_val的值限制在0到255之间\n            if (new_val < 0) {\n                new_val = 0; // 如果new_val小于0，则将new_val设为0\n            } else if (new_val > 255) {\n                new_val = 255; // 如果new_val大于255，则将new_val设为255\n            }\n\n            sum += new_val; // 将new_val的值加入sum中\n        }\n\n        // 计算新图像的平均值与中位值128的差的绝对值\n        double diff = fabs(sum / len - 128);\n\n        // 如果当前diff小于min_diff，更新min_diff和k_ans\n        if (diff < min_diff) {\n            min_diff = diff;\n            k_ans = k;\n        } \n        // 如果当前diff等于min_diff且k_ans不等于0，更新k_ans为k和k_ans中的较小值\n        else if (diff == min_diff && k_ans != 0) {\n            k_ans = (k_ans < k) ? k_ans : k;\n        }\n    }\n\n    // 输出最终的k_ans值\n    printf(\"%d\\n\", k_ans);\n\n    return 0;\n}"
  }
}