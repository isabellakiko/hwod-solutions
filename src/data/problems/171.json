{
  "id": "171",
  "title": "模拟目录管理",
  "examType": "A",
  "score": 200,
  "description": "实现一个模拟目录管理功能的软件，输入一个命令序列，输出最后一条命令运行结果。\n支持命令：\n创建目录命令：mkdir 目录名称，如 mkdir abc 为在当前目录创建abc目录，如果已存在同名目录则不执行任何操作。此命令无输出。进入目录命令：cd 目录名称，如 cd abc 为进入abc目录，特别地，cd … 为返回上级目录，如果目录不存在则不执行任何操作。此命令无输出。查看当前所在路径命令：pwd，输出当前路径字符串。\n约束：\n目录名称仅支持小写字母；mkdir 和 cd 命令的参数仅支持单个目录，如：mkdir abc 和 cd abc；不支持嵌套路径和绝对路径，如 mkdir abc/efg，cd abc/efg，mkdir /abc/efg，cd /abc/efg 是不支持的。目录符号为/，根目录/作为初始目录。任何不符合上述定义的无效命令不做任何处理并且无输出。",
  "inputDesc": "输入 N 行字符串，每一行字符串是一条命令。\n命令行数限制100行以内，目录名称限制10个字符以内。",
  "outputDesc": "输出最后一条命令运行结果字符串。",
  "examples": [
    {
      "input": "mkdir abc\ncd abc\npwd",
      "output": "/abc/",
      "explanation": "在根目录创建一个abc的目录并进入abc目录中查看当前目录路径，输出当前路径/abc/。"
    }
  ],
  "solution": "定义一个节点类（Node），用于表示文件系统中的每个目录。该类包含路径信息和一个映射，映射存储子目录和对应的节点对象。 创建一个根节点实例，代表文件系统的根目录。根目录没有父目录。 读取用户输入，根据输入的命令和参数执行相应的操作。 如果输入的是创建目录的命令（例如，“mkdir”），检查目录名是否有效，然后在当前节点下创建新的子目录节点。如果输入的是切换目录的命令（例如，“cd”），检查目标目录是否存在，如果存在，则更新当前节点为目标节点。如果输入的是打印当前目录路径的命令（例如，“pwd”），则输出当前节点的路径信息。 循环读取输入直到结束，并在结束时输出最后的路径信息。\n定义一个节点类（Node），用于表示文件系统中的每个目录。该类包含路径信息和一个映射，映射存储子目录和对应的节点对象。\n创建一个根节点实例，代表文件系统的根目录。根目录没有父目录。\n读取用户输入，根据输入的命令和参数执行相应的操作。\n如果输入的是创建目录的命令（例如，“mkdir”），检查目录名是否有效，然后在当前节点下创建新的子目录节点。如果输入的是切换目录的命令（例如，“cd”），检查目标目录是否存在，如果存在，则更新当前节点为目标节点。如果输入的是打印当前目录路径的命令（例如，“pwd”），则输出当前节点的路径信息。\n循环读取输入直到结束，并在结束时输出最后的路径信息。",
  "codes": {
    "java": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n    // 定义一个内部类Node，用于表示文件系统中的每个目录\n    static class Node {\n        String path; // 目录的路径\n        Map<String, Node> next = new HashMap<>(); // 存储当前目录下的子目录，键为目录名，值为对应的Node对象\n\n        // Node类的构造方法ac\n        Node(String path, Node parent) {\n            this.path = path; // 设置当前节点的路径\n            // 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n            if (parent != null) {\n                this.next.put(\"..\", parent);\n            }\n        }\n    }\n\n    // 程序的主入口点\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in); // 创建Scanner对象来读取用户的输入\n        Node root = new Node(\"/\", null); // 创建根目录节点，根目录没有父目录，所以第二个参数为null\n        Node currentNode = root; // 初始化当前目录为根目录\n        String lastOutput = \"\"; // 用于存储最后输出的路径\n\n        // 循环读取用户输入的命令\n        while (scanner.hasNextLine()) {\n            String input = scanner.nextLine().trim(); // 读取一行输入并去除前后空格\n            if (input.isEmpty()) break; // 如果输入为空，则退出循环\n\n            String[] parts = input.split(\" \"); // 将输入的命令按空格分割为命令和参数\n            String command = parts[0]; // 获取命令部分\n\n            // 处理mkdir命令，用于创建新的子目录\n            if (\"mkdir\".equals(command) && parts.length == 2 && isValidDirectoryName(parts[1])) {\n                // 如果目录名有效并且不存在，则创建一个新的目录节点，并将其添加到当前目录的子目录映射中\n                currentNode.next.putIfAbsent(parts[1], new Node(currentNode.path + parts[1] + \"/\", currentNode));\n            } else if (\"cd\".equals(command) && parts.length == 2 && isValidChangeDirectory(parts[1])) {\n                // 处理cd命令，用于改变当前目录\n                Node nextNode = currentNode.next.get(parts[1]); // 从子目录映射中获取要切换的目录节点\n                if (nextNode != null) {\n                    currentNode = nextNode; // 如果目录存在，则将当前目录切换为该目录\n                }\n            } else if (\"pwd\".equals(command) && parts.length == 1) {\n                // 处理pwd命令，用于打印当前目录的路径\n                lastOutput = currentNode.path; // 将当前目录的路径保存到lastOutput变量中\n            }\n        }\n\n        System.out.println(lastOutput); // 循环结束后，打印最后保存的路径\n    }\n\n    // 检查目录名是否有效的方法，目录名只能包含小写字母\n    private static boolean isValidDirectoryName(String name) {\n        for (char c : name.toCharArray()) {\n            if (c < 'a' || c > 'z') {\n                return false; // 如果目录名中包含非小写字母的字符，则返回false\n            }\n        }\n        return true; // 如果目录名全部由小写字母组成，则返回true\n    }\n\n    // 检查是否可以切换到指定的目录的方法，目录名要么是有效的，要么是\"..\"表示上级目录\n    private static boolean isValidChangeDirectory(String name) {\n        return \"..\".equals(name) || isValidDirectoryName(name); // 如果是\"..\"或者是有效的目录名，则返回true\n    }\n}",
    "python": "# 定义一个类Node，用于表示文件系统中的每个目录\nclass Node:\n    def __init__(self, path, parent):\n        self.path = path  # 目录的路径\n        self.next = {}  # 存储当前目录下的子目录，键为目录名，值为对应的Node对象\n        if parent:\n            self.next['..'] = parent  # 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n\n# 检查目录名是否有效的函数，目录名只能包含小写字母\ndef is_valid_directory_name(name):\n    return name.islower() and name.isalpha()  # 如果目录名全部由小写字母组成，则返回true\n\n# 检查是否可以切换到指定的目录的函数，目录名要么是有效的，要么是\"..\"表示上级目录\ndef is_valid_change_directory(name):\n    return name == '..' or is_valid_directory_name(name)  # 如果是\"..\"或者是有效的目录名，则返回true\n\nroot = Node('/', None)  # 创建根目录节点，根目录没有父目录，所以第二个参数为None\ncurrent_node = root  # 初始化当前目录为根目录\nlast_output = ''  # 用于存储最后输出的路径\n\n# 循环读取用户输入的命令\ntry:\n    while True:\n        input_command = input().strip()  # 读取一行输入并去除前后空格\n        if not input_command:\n            break\n        parts = input_command.split(' ')  # 将输入的命令按空格分割为命令和参数\n        command = parts[0]  # 获取命令部分\n\n        if command == 'mkdir' and len(parts) == 2 and is_valid_directory_name(parts[1]):\n            # 处理mkdir命令，用于创建新的子目录\n            if parts[1] not in current_node.next:\n                current_node.next[parts[1]] = Node(current_node.path + parts[1] + '/', current_node)\n        elif command == 'cd' and len(parts) == 2 and is_valid_change_directory(parts[1]):\n            # 处理cd命令，用于改变当前目录\n            next_node = current_node.next.get(parts[1])\n            if next_node:\n                current_node = next_node  # 如果目录存在，则将当前目录切换为该目录\n        elif command == 'pwd' and len(parts) == 1:\n            # 处理pwd命令，用于打印当前目录的路径\n            last_output = current_node.path  # 将当前目录的路径保存到last_output变量中\nexcept EOFError:\n    pass\n\nprint(last_output)  # 打印最后保存的路径",
    "javascript": "const readline = require('readline');\n\n// 定义一个类Node，用于表示文件系统中的每个目录\nclass Node {\n    constructor(path, parent) {\n        this.path = path; // 目录的路径\n        this.next = {}; // 存储当前目录下的子目录，键为目录名，值为对应的Node对象\n        if (parent) {\n            this.next['..'] = parent; // 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n        }\n    }\n}\n\n// 检查目录名是否有效的函数，目录名只能包含小写字母\nfunction isValidDirectoryName(name) {\n    return /^[a-z]+$/.test(name); // 如果目录名全部由小写字母组成，则返回true\n}\n\n// 检查是否可以切换到指定的目录的函数，目录名要么是有效的，要么是\"..\"表示上级目录\nfunction isValidChangeDirectory(name) {\n    return name === '..' || isValidDirectoryName(name); // 如果是\"..\"或者是有效的目录名，则返回true\n}\n\n// 创建readline接口实例\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst root = new Node('/', null); // 创建根目录节点，根目录没有父目录，所以第二个参数为null\nlet currentNode = root; // 初始化当前目录为根目录\nlet lastOutput = ''; // 用于存储最后输出的路径\n\n// 逐行读取输入\nrl.on('line', (input) => {\n    const parts = input.trim().split(' '); // 将输入的命令按空格分割为命令和参数\n    const command = parts[0]; // 获取命令部分\n\n    if (command === 'mkdir' && parts.length === 2 && isValidDirectoryName(parts[1])) {\n        // 处理mkdir命令，用于创建新的子目录\n        if (!currentNode.next[parts[1]]) {\n            currentNode.next[parts[1]] = new Node(currentNode.path + parts[1] + '/', currentNode);\n        }\n    } else if (command === 'cd' && parts.length === 2 && isValidChangeDirectory(parts[1])) {\n        // 处理cd命令，用于改变当前目录\n        const nextNode = currentNode.next[parts[1]];\n        if (nextNode) {\n            currentNode = nextNode; // 如果目录存在，则将当前目录切换为该目录\n        }\n    } else if (command === 'pwd' && parts.length === 1) {\n        // 处理pwd命令，用于打印当前目录的路径\n        lastOutput = currentNode.path; // 将当前目录的路径保存到lastOutput变量中\n    }\n}).on('close', () => {\n    console.log(lastOutput); // 当输入流关闭时，打印最后保存的路径\n});",
    "cpp": "#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <sstream>\n\nusing namespace std;\n// 定义一个类Node，用于表示文件系统中的每个目录\nclass Node {\npublic:\n    string path; // 目录的路径\n    unordered_map<string, Node*> next; // 存储当前目录下的子目录，键为目录名，值为对应的Node指针\n\n    // Node类的构造方法\n    Node(string path, Node* parent) : path(path) {\n        // 如果存在父目录，则在子目录映射中添加一个指向父目录的条目\n        if (parent != nullptr) {\n            this->next[\"..\"] = parent;\n        }\n    }\n};\n\n// 检查目录名是否有效的函数，目录名只能包含小写字母\nbool isValidDirectoryName(const string& name) {\n    for (char c : name) {\n        if (c < 'a' || c > 'z') {\n            return false; // 如果目录名中包含非小写字母的字符，则返回false\n        }\n    }\n    return true; // 如果目录名全部由小写字母组成，则返回true\n}\n\n// 检查是否可以切换到指定的目录的函数，目录名要么是有效的，要么是\"..\"表示上级目录\nbool isValidChangeDirectory(const string& name) {\n    return name == \"..\" || isValidDirectoryName(name); // 如果是\"..\"或者是有效的目录名，则返回true\n}\n\nint main() {\n    Node* root = new Node(\"/\", nullptr); // 创建根目录节点，根目录没有父目录，所以第二个参数为nullptr\n    Node* currentNode = root; // 初始化当前目录为根目录\n    string lastOutput; // 用于存储最后输出的路径\n\n    // 循环读取用户输入的命令\n    string input;\n    while (getline(cin, input)) {\n        istringstream iss(input);\n        string command, arg;\n        iss >> command;\n\n        if (command == \"mkdir\") {\n            iss >> arg;\n            if (isValidDirectoryName(arg)) {\n                // 如果目录名有效并且不存在，则创建一个新的目录节点，并将其添加到当前目录的子目录映射中\n                if (currentNode->next.find(arg) == currentNode->next.end()) {\n                    currentNode->next[arg] = new Node(currentNode->path + arg + \"/\", currentNode);\n                }\n            }\n        } else if (command == \"cd\") {\n            iss >> arg;\n            if (isValidChangeDirectory(arg)) {\n                // 处理cd命令，用于改变当前目录\n                auto it = currentNode->next.find(arg);\n                if (it != currentNode->next.end()) {\n                    currentNode = it->second; // 如果目录存在，则将当前目录切换为该目录\n                }\n            }\n        } else if (command == \"pwd\") {\n            // 处理pwd命令，用于打印当前目录的路径\n            lastOutput = currentNode->path; // 将当前目录的路径保存到lastOutput变量中\n        }\n    }\n\n    cout << lastOutput << endl; // 循环结束后，打印最后保存的路径\n\n  \n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_CHILDREN 128  // 假设每个目录最多可以有128个子目录\n\n// 定义一个结构体Node，用于表示文件系统中的每个目录\ntypedef struct Node {\n    char path[1024]; // 目录的完整路径\n    struct Node* children[MAX_CHILDREN]; // 存储指向子目录的指针数组\n    char* childNames[MAX_CHILDREN]; // 存储子目录名的数组\n    int childCount; // 实际子目录的数量\n    struct Node* parent; // 指向父目录的指针\n} Node;\n\n// 创建新目录节点的函数，接受目录路径和父节点作为参数\nNode* createNode(const char* path, Node* parent) {\n    Node* newNode = (Node*)malloc(sizeof(Node)); // 分配内存\n    strcpy(newNode->path, path); // 设置目录路径\n    memset(newNode->children, 0, sizeof(newNode->children)); // 初始化子目录指针数组\n    memset(newNode->childNames, 0, sizeof(newNode->childNames)); // 初始化子目录名数组\n    newNode->childCount = 0; // 初始化子目录计数\n    newNode->parent = parent; // 设置父目录\n    return newNode; // 返回新创建的节点\n}\n\n// 检查目录名是否仅包含小写字母\nint isValidDirectoryName(const char* name) {\n    for (int i = 0; name[i] != '\\0'; i++) {\n        if (!islower(name[i])) {\n            return 0; // 如果含有非小写字母，则返回0\n        }\n    }\n    return 1; // 全部是小写字母，则返回1\n}\n\n// 向特定父目录添加一个新的子目录\nvoid addDirectory(Node* parent, const char* name, Node* child) {\n    if (parent->childCount < MAX_CHILDREN) { // 检查是否还有空间添加子目录\n        parent->children[parent->childCount] = child; // 添加子目录指针\n        parent->childNames[parent->childCount] = strdup(name); // 并存储子目录名\n        parent->childCount++; // 子目录计数增加\n    }\n}\n\n// 根据目录名在父目录中查找子目录\nNode* findDirectory(Node* parent, const char* name) {\n    for (int i = 0; i < parent->childCount; i++) {\n        if (strcmp(parent->childNames[i], name) == 0) {\n            return parent->children[i]; // 找到匹配的子目录后返回其指针\n        }\n    }\n    return NULL; // 未找到返回NULL\n}\n\nint main() {\n    Node* root = createNode(\"/\", NULL); // 创建根目录节点\n    Node* currentNode = root; // 初始当前目录为根目录\n    char input[1024], lastOutput[1024] = \"/\"; // 输入缓冲区和最终输出缓冲区\n\n    while (fgets(input, sizeof(input), stdin)) { // 读取命令行输入\n        char* command = strtok(input, \" \\n\"); // 分割出命令\n        char* arg = strtok(NULL, \" \\n\"); // 分割出参数\n\n        if (strcmp(command, \"mkdir\") == 0 && arg && isValidDirectoryName(arg)) {\n            if (findDirectory(currentNode, arg) == NULL) { // 检查目录是否已存在\n                char newPath[1024];\n                sprintf(newPath, \"%s%s/\", currentNode->path, arg); // 构建新目录的完整路径\n                Node* newNode = createNode(newPath, currentNode); // 创建新目录节点\n                addDirectory(currentNode, arg, newNode); // 将新目录添加到当前节点的子目录中\n            }\n        } else if (strcmp(command, \"cd\") == 0 && arg) {\n            if (strcmp(arg, \"..\") == 0 && currentNode->parent) { // 返回上一级目录\n                currentNode = currentNode->parent;\n            } else if (isValidDirectoryName(arg)) { // 改变当前目录到指定的子目录\n                Node* foundNode = findDirectory(currentNode, arg);\n                if (foundNode) {\n                    currentNode = foundNode;\n                }\n            }\n        } else if (strcmp(command, \"pwd\") == 0) { // 输出当前目录的路径\n            strcpy(lastOutput, currentNode->path);\n        }\n    }\n\n    printf(\"%s\\n\", lastOutput); // 打印最后记录的路径\n \n    return 0;\n}"
  }
}