{
  "id": "109",
  "title": "猜字谜",
  "examType": "A",
  "score": 100,
  "description": "小王设计了一个简单的猜字谜游戏，游戏的谜面是一个错误的单词，比如nesw，玩家需要猜出谜底库中正确的单词。猜中的要求如下： 对于某个谜面和谜底单词，满足下面任一条件都表示猜中：\n变换顺序以后一样的，比如通过变换w和e的顺序，“nwes”跟“news”是可以完全对应的；字母去重以后是一样的，比如“woood”和“wood”是一样的，它们去重后都是“wod”\n请你写一个程序帮忙在谜底库中找到正确的谜底。谜面是多个单词，都需要找到对应的谜底，如果找不到的话，返回”not found”",
  "inputDesc": "谜面单词列表，以“,”分隔谜底库单词列表，以\",\"分隔",
  "outputDesc": "输出匹配到的谜底单词，以逗号分隔。找不到的输出not found",
  "examples": [
    {
      "input": "bdni,wooood\nbind,wrong,wood",
      "output": "bind,wood",
      "explanation": "bdni排序去重后=bdni，bind排序去重后=bdni，匹配成功。wooood去重排序=dow，wood去重排序=dow，匹配成功"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**字符串处理**问题。\n\n**核心思路：**\n- 猜中条件：变换顺序或去重后一样\n- 对谜面和谜底进行去重+排序后比较\n\n**算法步骤：**\n1. 对谜面单词去重并排序\n2. 对谜底库每个单词去重并排序\n3. 比较处理后的字符串是否相等\n4. 找不到匹配则输出not found\n\n**时间复杂度**：O(M×N×L)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        // 读取谜面单词列表，以逗号分隔\n        String[] puzzleWords = scanner.nextLine().split(\",\");\n        // 读取谜底库单词列表，以逗号分隔\n        String[] answerBank = scanner.nextLine().split(\",\");\n        // 创建一个列表，用于存储匹配到的正确单词\n        List<String> matchedAnswers = new ArrayList<>();\n\n        // 遍历谜面单词列表\n        for (String puzzleWord : puzzleWords) {\n            // 去除谜面单词中的重复字母，TreeSet自动升序排序\n            String puzzleWordNoDuplicate = String.join(\"\", new TreeSet<>(Arrays.asList(puzzleWord.split(\"\"))));\n            // 标记是否匹配到对应的谜底\n            boolean isFound = false;\n\n            // 遍历谜底库单词列表\n            for (String answer : answerBank) {\n                // 去除谜底单词中的重复字母，TreeSet自动升序排序\n                String answerNoDuplicate = String.join(\"\", new TreeSet<>(Arrays.asList(answer.split(\"\"))));\n\n                // 如果去重后的谜面单词与谜底单词相同，则将谜底单词添加到结果列表中，并将 isFound 标记为 true\n                if (puzzleWordNoDuplicate.equals(answerNoDuplicate)) {\n                    matchedAnswers.add(answer);\n                    isFound = true;\n                }\n            }\n\n            // 如果没有找到匹配的单词，则将 \"not found\" 添加到结果列表中\n            if (!isFound) {\n                matchedAnswers.add(\"not found\");\n            }\n        }\n\n        // 输出匹配到的正确单词列表，以逗号分隔\n        System.out.println(String.join(\",\", matchedAnswers));\n    }\n}",
    "python": "puzzle_words = input().split(\",\")\nword_bank = input().split(\",\")\n\n# 用于存储匹配到的正确单词列表\nmatched_words = []\n\n# 遍历每个谜面\nfor puzzle_word in puzzle_words:\n    # 将谜面中的字符去重并排序\n    sorted_puzzle_word = \"\".join(sorted(set(puzzle_word)))\n    # 标记是否找到匹配的谜底\n    found = False\n\n    # 遍历每个谜底\n    for word in word_bank:\n        # 将谜底中的字符去重并排序\n        sorted_word = \"\".join(sorted(set(word)))\n\n        # 判断谜底是否与谜面匹配\n        if sorted_puzzle_word == sorted_word:\n            # 将匹配到的谜底添加到结果列表中\n            matched_words.append(word)\n            # 标记为已找到匹配的谜底\n            found = True\n\n    # 如果没有找到匹配的谜底，将\"not found\"添加到结果列表中\n    if not found:\n        matched_words.append(\"not found\")\n\n# 输出匹配到的正确单词列表，以\",\"分隔\nprint(\",\".join(matched_words))",
    "javascript": "// 导入 readline 模块，用于从标准输入读取数据\nconst readline = require('readline');\n\n// 创建 readline 接口实例，用于处理输入输出\nconst rl = readline.createInterface({\n  input: process.stdin, // 指定标准输入流\n  output: process.stdout // 指定标准输出流\n});\n\n// 监听第一个输入行，即谜面单词列表\nrl.on('line', (puzzleInput) => {\n  // 监听第二个输入行，即谜底库单词列表\n  rl.on('line', (answerBankInput) => {\n    // 将谜面单词列表按照逗号分隔成数组\n    const puzzles = puzzleInput.split(',');\n    // 将谜底库单词列表按照逗号分隔成数组\n    const answerBank = answerBankInput.split(',');\n    // 用于存储匹配到的正确单词\n    const matchedAnswers = [];\n\n    // 遍历每一个谜面单词\n    for (let puzzleIndex = 0; puzzleIndex < puzzles.length; puzzleIndex++) {\n      // 对谜面单词进行排序并去重\n      const sortedPuzzle = puzzles[puzzleIndex].split('') // 将单词分割成字符数组\n        .sort() // 对字符数组进行排序\n        .filter((char, index, array) => {\n          // 通过过滤函数去重，保留第一次出现的字符\n          return index === 0 || char !== array[index - 1];\n        })\n        .join(''); // 将处理后的字符数组重新组合成字符串\n\n      let found = false; // 用于标记当前谜面是否找到匹配的正确单词\n\n      // 遍历谜底库中的每一个单词\n      for (let answerIndex = 0; answerIndex < answerBank.length; answerIndex++) {\n        // 对谜底单词进行排序并去重，方法同上\n        const sortedAnswer = answerBank[answerIndex].split('')\n          .sort()\n          .filter((char, index, array) => {\n            return index === 0 || char !== array[index - 1];\n          })\n          .join('');\n\n        // 如果处理后的谜面单词和谜底单词相同，则表示匹配成功\n        if (sortedPuzzle === sortedAnswer) {\n          // 将匹配到的谜底单词加入结果数组\n          matchedAnswers.push(answerBank[answerIndex]);\n          found = true; // 标记为已找到匹配\n          break; // 一旦找到匹配的正确单词，跳出当前循环\n        }\n      }\n\n      // 如果没有找到匹配的正确单词，加入\"not found\"标记\n      if (!found) {\n        matchedAnswers.push(\"not found\");\n      }\n    }\n\n    // 将匹配到的正确单词以逗号分隔的形式输出\n    console.log(matchedAnswers.join(', '));\n    rl.close(); // 关闭 readline 接口\n  });\n});",
    "cpp": "#include <iostream>\n#include <algorithm>  \n#include <vector>  \n#include <string> \n\nusing namespace std;\n\nint main() {\n    string input_puzzles, input_solutions;\n    \n \n    getline(cin, input_puzzles); // 读取第一行谜面单词列表\n    getline(cin, input_solutions); // 读取第二行谜底单词列表\n\n    vector<string> puzzles, solutions;\n    string temp = \"\";\n    \n    // 将输入的谜面单词列表以“,”分隔并存储在puzzles向量中\n    for (char c : input_puzzles) {\n        if (c == ',') {\n            puzzles.push_back(temp); // 遇到逗号，将temp中的单词加入puzzles\n            temp = \"\"; // 重置temp\n        } else {\n            temp += c; // 将字符加入temp\n        }\n    }\n    puzzles.push_back(temp); // 将最后一个单词加入puzzles\n\n    temp = \"\";\n    // 将输入的谜底库单词列表以“,”分隔并存储在solutions向量中\n    for (char c : input_solutions) {\n        if (c == ',') {\n            solutions.push_back(temp); // 遇到逗号，将temp中的单词加入solutions\n            temp = \"\"; // 重置temp\n        } else {\n            temp += c; // 将字符加入temp\n        }\n    }\n    solutions.push_back(temp); // 将最后一个单词加入solutions\n\n    vector<string> matched_solutions; // 用于存储匹配到的谜底单词\n    // 遍历每个谜面单词\n    for (string puzzle : puzzles) {\n        string sorted_puzzle = puzzle;\n        sort(sorted_puzzle.begin(), sorted_puzzle.end()); // 对谜面单词排序\n        sorted_puzzle.erase(unique(sorted_puzzle.begin(), sorted_puzzle.end()), sorted_puzzle.end()); // 去重\n\n        bool found = false; // 标记是否找到匹配的谜底单词\n\n        // 遍历谜底库中的每个单词\n        for (string solution : solutions) {\n            string sorted_solution = solution;\n            sort(sorted_solution.begin(), sorted_solution.end()); // 对谜底单词排序\n            sorted_solution.erase(unique(sorted_solution.begin(), sorted_solution.end()), sorted_solution.end()); // 去重\n\n            if (sorted_puzzle == sorted_solution) { // 如果排序去重后的结果相同\n                matched_solutions.push_back(solution); // 将该谜底单词加入匹配结果中\n                found = true; // 标记为找到匹配\n                break; // 跳出当前循环\n            }\n        }\n\n        if (!found) { // 如果未找到匹配的谜底单词\n            matched_solutions.push_back(\"not found\"); // 加入\"not found\"\n        }\n    }\n\n    // 输出第一个匹配结果\n    cout << matched_solutions[0];\n    // 输出剩余的匹配结果，中间以逗号分隔\n    for (int i = 1; i < matched_solutions.size(); i++) {\n        cout << \",\" << matched_solutions[i];\n    }\n\n    return 0; // 程序结束\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// 自定义比较函数，用于qsort中的字符排序\nint compare(const void *a, const void *b) {\n    return *(char *)a - *(char *)b;\n}\n\n// 去重函数，将字符串中的重复字符移除\nvoid remove_duplicates(char *str) {\n    int length = strlen(str);\n    if (length < 2) return;\n\n    int j = 0;\n    for (int i = 1; i < length; i++) {\n        if (str[i] != str[j]) {\n            j++;\n            str[j] = str[i];\n        }\n    }\n    str[j + 1] = '\\0';\n}\n\nint main() {\n    char input_puzzles[1000], input_solutions[1000];\n\n    // 从标准输入读取谜面和谜底列表\n    fgets(input_puzzles, sizeof(input_puzzles), stdin); // 读取第一行谜面单词列表\n    fgets(input_solutions, sizeof(input_solutions), stdin); // 读取第二行谜底单词列表\n\n    // 移除字符串末尾的换行符\n    input_puzzles[strcspn(input_puzzles, \"\\n\")] = '\\0';\n    input_solutions[strcspn(input_solutions, \"\\n\")] = '\\0';\n\n    char *puzzles[1000];\n    char *solutions[1000];\n    int puzzle_count = 0, solution_count = 0;\n\n    // 将谜面单词列表以“,”分隔并存储在puzzles数组中\n    char *token = strtok(input_puzzles, \",\");\n    while (token != NULL) {\n        puzzles[puzzle_count++] = strdup(token); // 将分隔出的单词到puzzles中\n        token = strtok(NULL, \",\");\n    }\n\n    // 将谜底库单词列表以“,”分隔并存储在solutions数组中\n    token = strtok(input_solutions, \",\");\n    while (token != NULL) {\n        solutions[solution_count++] = strdup(token); // 将分隔出的单词到solutions中\n        token = strtok(NULL, \",\");\n    }\n\n    char *matched_solutions[1000];\n    int match_count = 0;\n\n    // 遍历每个谜面单词\n    for (int i = 0; i < puzzle_count; i++) {\n        char sorted_puzzle[1000];\n        strcpy(sorted_puzzle, puzzles[i]);\n        qsort(sorted_puzzle, strlen(sorted_puzzle), sizeof(char), compare); // 对谜面单词排序\n        remove_duplicates(sorted_puzzle); // 去重\n\n        int found = 0; // 标记是否找到匹配的谜底单词\n\n        // 遍历谜底库中的每个单词\n        for (int j = 0; j < solution_count; j++) {\n            char sorted_solution[1000];\n            strcpy(sorted_solution, solutions[j]);\n            qsort(sorted_solution, strlen(sorted_solution), sizeof(char), compare); // 对谜底单词排序\n            remove_duplicates(sorted_solution); // 去重\n\n            if (strcmp(sorted_puzzle, sorted_solution) == 0) { // 如果排序去重后的结果相同\n                matched_solutions[match_count++] = solutions[j]; // 将该谜底单词加入匹配结果中\n                found = 1; // 标记为找到匹配\n                break; // 跳出当前循环\n            }\n        }\n\n        if (!found) { // 如果未找到匹配的谜底单词\n            matched_solutions[match_count++] = \"not found\"; // 加入\"not found\"\n        }\n    }\n\n    // 输出第一个匹配结果\n    printf(\"%s\", matched_solutions[0]);\n    // 输出剩余的匹配结果，中间以逗号分隔\n    for (int i = 1; i < match_count; i++) {\n        printf(\",%s\", matched_solutions[i]);\n    }\n\n    // 释放动态分配的内存\n    for (int i = 0; i < puzzle_count; i++) {\n        free(puzzles[i]);\n    }\n    for (int i = 0; i < solution_count; i++) {\n        free(solutions[i]);\n    }\n\n    return 0;  \n}"
  }
}