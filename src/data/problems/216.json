{
  "id": "216",
  "title": "服务中心选址",
  "examType": "B",
  "score": 200,
  "description": "一个快递公司希望在一条街道建立新的服务中心。公司统计了该街道中所有区域在地图上的位置，并希望能够以此为依据为新的服务中心选址：使服务中心到所有区域的距离的总和最小。\n给你一个数组positions，其中positions[i] = [left, right] 表示第 i 个区域在街道上的位置，其中left代表区域的左侧的起点，right代表区域的右侧终点，假设服务中心的位置为location：\n如果第 i 个区域的右侧终点right满足 right < location，则第 i 个区域到服务中心的距离为 location - right；如果第 i 个区域的左侧起点left 满足 left > location，则第 i 个区域到服务中心的距离为left - location；如果第 i 个区域的两侧left，right满足left <= location <= right，则第 i 个区域到服务中心的距离为0\n选择最佳的服务中心位置为location，请返回最佳的服务中心位置到所有区域的距离总和的最小值。\n",
  "inputDesc": "先输入区域数组positions的长度n（1 ≤ n ≤ 10^5）\n接下来 n 行每行输入成对的left和right值，以空格隔开\n-10^9 ＜left ≤ 10^9-10^9 ＜right ≤ 10^9\n",
  "outputDesc": "输出为location\n\n\n根据网友反馈进行分析得出，本题中各区域应该是有交集的。\n我想了很久，如何求解某个点到有交集区域的最小距离和，但是没有什么好的办法，直到我死心准备用暴力法求解时，发现了一丝丝生机。下面是暴力法测试过程：\n测试用例：含区域交集情况\n11 -10 10 1 2 3 4 5 10 6 8 7 12 9 13 15 20 31 41 22 35 34 50\n\nJavaScript暴力实现\n\n可以发现，当服务中心选址10位置时，到各区间距离之和最小为78\n\nJava暴力实现\n\n可以发现，当服务中心选址10位置时，到各区间距离之和最小为78\n\nPython暴力实现\n\n可以发现，当服务中心选址10位置时，到各区间距离之和最小为78\n\n上面暴力法过程中，我首先获得了所有区间中最左边的点min，和最右边的点max，并遍历这两个点之间每一个点作为服务中心地址 i ，并求每个服务中心地址到各区域的距离之和 dis，然后将它们成对打印出来，结果发现一个现象：\n\n随着 服务中心位置 i 的变化，服务中心到各区域的距离之和 dis 呈现上图U型曲线。\n即，一定存在一个 i ，其左边点 i-0.5 的，和其右边点 i+0.5 到各区域的距离和大于它。\n\n因此，我想是否可以用二分法求解，即取min点和max点的中间点mid作为服务中心位置，：\n这样一搞，我们最终就可以找到最低dis的mid点。\n\n2023.04.12 上面的二分策略存在问题，本题要求解凹函数的极值，应该使用三分法求解。\n关于三分法请看：https://blog.csdn.net/qfc_128220/article/details/130097676\n\n2023.04.19 今天又有考友考到这题了，上面解法还是27%通过率。我已经emo了。\n然后我又读了一遍题目，发现：\n难道实际机试系统要求输出的是：服务中心的位置？\n",
  "examples": [],
  "solution": "",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n  static double[][] positions;\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    positions = new double[n][2];\n    for (int i = 0; i < n; i++) {\n      positions[i][0] = sc.nextDouble();\n      positions[i][1] = sc.nextDouble();\n    }\n\n    System.out.println(getResult());\n  }\n\n  public static int getResult() {\n    ArrayList<Double> tmp = new ArrayList<>();\n    for (double[] pos : positions) {\n      tmp.add(pos[0]);\n      tmp.add(pos[1]);\n    }\n    tmp.sort(Double::compareTo);\n\n    double l = tmp.get(0);\n    double r = tmp.get(tmp.size() - 1);\n    double eps = 1e-5;\n\n    while (r - l >= eps) {\n      double k = (r - l) / 3;\n      double ml = l + k;\n      double mr = r - k;\n\n      if (getDistance(ml) < getDistance(mr)) {\n        r = mr;\n      } else {\n        l = ml;\n      }\n    }\n\n    return (int) getDistance(l);\n  }\n\n  public static double getDistance(double t) {\n    double dis = 0;\n    for (double[] pos : positions) {\n      double l = pos[0];\n      double r = pos[1];\n      if (r < t) dis += t - r;\n      else if (t < l) dis += l - t;\n    }\n    return dis;\n  }\n}",
    "python": "import math\n\n# 输入获取\nn = int(input())\npositions = [list(map(float, input().split())) for _ in range(n)]\n\n\n# 算法入口\ndef getResult():\n    tmp = []\n    for pos in positions:\n        tmp.extend(pos)\n    tmp.sort()\n\n    l = tmp[0]\n    r = tmp[-1]\n    eps = 1e-5\n\n    while r - l >= eps:\n        k = (r - l) / 3\n        ml = l + k\n        mr = r - k\n\n        if getDistance(ml) < getDistance(mr):\n            r = mr\n        else:\n            l = ml\n\n    return int(getDistance(l))\n\n\ndef getDistance(t):\n    dis = 0\n    for l, r in positions:\n        if r < t:\n            dis += t - r\n        elif t < l:\n            dis += l - t\n    return dis\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nlet n, positions;\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 1) {\n    n = lines[0] - 0;\n  }\n\n  if (n && lines.length === n + 1) {\n    positions = lines.slice(1).map((line) => line.split(\" \").map(Number));\n    console.log(getResult(n, positions));\n    lines.length = 0;\n  }\n});\n\nfunction getResult() {\n  const tmp = positions.flat(2).sort((a, b) => a - b);\n\n  let l = tmp.at(0);\n  let r = tmp.at(-1);\n  const eps = 1e-5;\n\n  while (r - l >= eps) {\n    const k = (r - l) / 3;\n    const ml = l + k;\n    const mr = r - k;\n\n    if (getDistance(ml) < getDistance(mr)) {\n      r = mr;\n    } else {\n      l = ml;\n    }\n  }\n\n  return Math.floor(getDistance(l));\n}\n\nfunction getDistance(t) {\n  let dis = 0;\n  for (let [l, r] of positions) {\n    if (r < t) dis += t - r;\n    else if (t < l) dis += l - t;\n  }\n  return dis;\n}",
    "cpp": "",
    "c": ""
  }
}