{
  "id": "52",
  "title": "螺旋数字矩阵",
  "examType": "A",
  "score": 100,
  "description": "疫情期间，小明隔离在家，百无聊赖，在纸上写数字玩。他发明了一种写法： 给出数字个数n和行数m（0 < n ≤ 999，0 < m ≤ 999），从左上角的1开始，按照顺时针螺旋向内写方式，依次写出2,3…n，最终形成一个m行矩阵。 小明对这个矩阵有些要求：\n每行数字的个数一样多列的数量尽可能少填充数字时优先填充外部数字不够时，使用单个*号占位",
  "inputDesc": "输入一行，两个整数，空格隔开，依次表示n、m",
  "outputDesc": "符合要求的唯一矩阵\n输入：\n输出：\n说明：\n9个数字写成4行，最少需要3列\n输入：\n3 5 输出：\n说明：\n3个数字写5行，只有一列，数字不够用*号填充\n输入：\n输出：",
  "examples": [
    {
      "input": "9 4",
      "output": "1 2 3\n8 9 4\n7 * 5\n6 * *",
      "explanation": "9个数字写成4行，最少需要3列。\n按顺时针螺旋填充：1→2→3→4→5→6→7→8→9。\n剩余位置用*填充。"
    },
    {
      "input": "3 5",
      "output": "1\n2\n3\n*\n*",
      "explanation": "3个数字写5行，只有1列。\n数字不够用*号填充。"
    },
    {
      "input": "12 3",
      "output": "1 2 3 4\n10 11 12 5\n9 8 7 6",
      "explanation": "12个数字写3行，需要4列。\n按顺时针螺旋填充正好填满。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**螺旋矩阵模拟**问题。\n\n**算法步骤：**\n\n1. 计算列数：cols = ceil(n / m)\n2. 创建m×cols的矩阵，初始化为0\n3. 定义四个边界：top, bottom, left, right\n4. 按顺时针螺旋顺序填充1到n：\n   - 从左到右填充top行，top++\n   - 从上到下填充right列，right--\n   - 从右到左填充bottom行，bottom--\n   - 从下到上填充left列，left++\n5. 输出矩阵，0的位置输出*\n\n**时间复杂度**：O(m × cols)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt(); // 读取要填充的数字个数n\n        int m = scanner.nextInt(); // 读取矩阵的行数m\n        scanner.close(); // 输入完毕后关闭scanner\n\n        int cols = (int) Math.ceil(n / (double) m); // 计算矩阵的列数\n        int[][] matrix = new int[m][cols]; // 创建一个整型矩阵，默认初始化为0\n\n        int num = 1; // 用于填充的数字从1开始\n        int top = 0, bottom = m - 1, left = 0, right = cols - 1;\n        while (num <= n) {\n            for (int i = left; i <= right && num <= n; i++) { // 从左到右填充上边界\n                matrix[top][i] = num++;\n            }\n            top++; // 上边界下移\n            for (int i = top; i <= bottom && num <= n; i++) { // 从上到下填充右边界\n                matrix[i][right] = num++;\n            }\n            right--; // 右边界左移\n            for (int i = right; i >= left && num <= n; i--) { // 从右到左填充下边界\n                matrix[bottom][i] = num++;\n            }\n            bottom--; // 下边界上移\n            for (int i = bottom; i >= top && num <= n; i--) { // 从下到上填充左边界\n                matrix[i][left] = num++;\n            }\n            left++; // 左边界右移\n        }\n\n        for (int i = 0; i < m; i++) { // 遍历矩阵的每一行\n            for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n                if (matrix[i][j] == 0) { // 如果当前位置是0，则输出'*'\n                    System.out.print('*');\n                } else { // 否则输出当前位置的数字\n                    System.out.print(matrix[i][j]);\n                }\n                if (j < cols - 1) { // 在同一行的数字之间打印空格\n                    System.out.print(\" \");\n                }\n            }\n            System.out.println(); // 每打印完一行后换行\n        }\n    }\n}",
    "python": "import math\n\nn, m = map(int, input().split()) # 读取要填充的数字个数n和矩阵的行数m\ncols = math.ceil(n / m) # 计算矩阵的列数\nmatrix = [[0 for _ in range(cols)] for _ in range(m)] # 创建一个整型矩阵，默认初始化为0\n\nnum = 1 # 用于填充的数字从1开始\ntop, bottom, left, right = 0, m - 1, 0, cols - 1\nwhile num <= n:\n    for i in range(left, right + 1): # 从左到右填充上边界\n        if num <= n:\n            matrix[top][i] = num\n            num += 1\n    top += 1 # 上边界下移\n    for i in range(top, bottom + 1): # 从上到下填充右边界\n        if num <= n:\n            matrix[i][right] = num\n            num += 1\n    right -= 1 # 右边界左移\n    for i in range(right, left - 1, -1): # 从右到左填充下边界\n        if num <= n:\n            matrix[bottom][i] = num\n            num += 1\n    bottom -= 1 # 下边界上移\n    for i in range(bottom, top - 1, -1): # 从下到上填充左边界\n        if num <= n:\n            matrix[i][left] = num\n            num += 1\n    left += 1 # 左边界右移\n\nfor row in matrix: # 遍历矩阵的每一行\n    print(' '.join('*' if val == 0 else str(val) for val in row)) # 如果当前位置是0，则输出'*'，否则输出当前位置的数字",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', (line) => {\n    const [n, m] = line.split(' ').map(Number); // 读取数字个数n和行数m\n    const cols = Math.ceil(n / m); // 计算列数\n    const matrix = Array.from({ length: m }, () => Array(cols).fill(0)); // 创建矩阵\n\n    let num = 1; // 从1开始填充\n    let top = 0, bottom = m - 1, left = 0, right = cols - 1;\n    \n    while (num <= n) {\n        for (let i = left; i <= right && num <= n; i++) { // 从左到右填充上边界\n            matrix[top][i] = num++;\n        }\n        top++;\n        for (let i = top; i <= bottom && num <= n; i++) { // 从上到下填充右边界\n            matrix[i][right] = num++;\n        }\n        right--;\n        for (let i = right; i >= left && num <= n; i--) { // 从右到左填充下边界\n            matrix[bottom][i] = num++;\n        }\n        bottom--;\n        for (let i = bottom; i >= top && num <= n; i--) { // 从下到上填充左边界\n            matrix[i][left] = num++;\n        }\n        left++;\n    }\n\n    // 输出矩阵\n    for (let i = 0; i < m; i++) {\n        const row = matrix[i].map(val => val === 0 ? '*' : val.toString());\n        console.log(row.join(' '));\n    }\n    rl.close();\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nint main() {\n    int n, m;\n    std::cin >> n >> m; // 读取要填充的数字个数n和矩阵的行数m\n\n    int cols = std::ceil(static_cast<double>(n) / m); // 计算矩阵的列数\n    std::vector<std::vector<int>> matrix(m, std::vector<int>(cols, 0)); // 创建一个整型矩阵，默认初始化为0\n\n    int num = 1; // 用于填充的数字从1开始\n    int top = 0, bottom = m - 1, left = 0, right = cols - 1;\n    while (num <= n) {\n        for (int i = left; i <= right && num <= n; i++) { // 从左到右填充上边界\n            matrix[top][i] = num++;\n        }\n        top++; // 上边界下移\n        for (int i = top; i <= bottom && num <= n; i++) { // 从上到下填充右边界\n            matrix[i][right] = num++;\n        }\n        right--; // 右边界左移\n        for (int i = right; i >= left && num <= n; i--) { // 从右到左填充下边界\n            matrix[bottom][i] = num++;\n        }\n        bottom--; // 下边界上移\n        for (int i = bottom; i >= top && num <= n; i--) { // 从下到上填充左边界\n            matrix[i][left] = num++;\n        }\n        left++; // 左边界右移\n    }\n\n    for (int i = 0; i < m; i++) { // 遍历矩阵的每一行\n        for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n            if (matrix[i][j] == 0) { // 如果当前位置是0，则输出'*'\n                std::cout << '*';\n            } else { // 否则输出当前位置的数字\n                std::cout << matrix[i][j];\n            }\n            if (j < cols - 1) { // 在同一行的数字之间打印空格\n                std::cout << \" \";\n            }\n        }\n        std::cout << std::endl; // 每打印完一行后换行\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <math.h>\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m); // 读取要填充的数字个数n和矩阵的行数m\n\n    int cols = (int)ceil((double)n / m); // 计算矩阵的列数\n    int matrix[m][cols]; // 创建一个整型矩阵，默认初始化为0\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < cols; j++) {\n            matrix[i][j] = 0;\n        }\n    }\n\n    int num = 1; // 用于填充的数字从1开始\n    int top = 0, bottom = m - 1, left = 0, right = cols - 1;\n    while (num <= n) {\n        for (int i = left; i <= right && num <= n; i++) { // 从左到右填充上边界\n            matrix[top][i] = num++;\n        }\n        top++; // 上边界下移\n        for (int i = top; i <= bottom && num <= n; i++) { // 从上到下填充右边界\n            matrix[i][right] = num++;\n        }\n        right--; // 右边界左移\n        for (int i = right; i >= left && num <= n; i--) { // 从右到左填充下边界\n            matrix[bottom][i] = num++;\n        }\n        bottom--; // 下边界上移\n        for (int i = bottom; i >= top && num <= n; i--) { // 从下到上填充左边界\n            matrix[i][left] = num++;\n        }\n        left++; // 左边界右移\n    }\n\n    for (int i = 0; i < m; i++) { // 遍历矩阵的每一行\n        for (int j = 0; j < cols; j++) { // 遍历矩阵的每一列\n            if (matrix[i][j] == 0) { // 如果当前位置是0，则输出'*'\n                printf(\"* \");\n            } else { // 否则输出当前位置的数字\n                printf(\"%d \", matrix[i][j]);\n            }\n        }\n        printf(\"\\n\"); // 每打印完一行后换行\n    }\n\n    return 0;\n}"
  }
}