{
  "id": "62",
  "title": "AI面板识别",
  "examType": "A",
  "score": 100,
  "description": "AI识别到面板上有N（1 ≤ N ≤ 100）个指示灯，灯大小一样，任意两个之间无重叠。\n由于AI识别误差，每次别到的指示灯位置可能有差异，以4个坐标值描述AI识别的指示灯的大小和位置(左上角x1,y1，右下角x2,y2)，\n请输出先行后列排序的指示灯的编号，排序规则：\n每次在尚未排序的灯中挑选最高的灯作为的基准灯，找出和基准灯属于同一行所有的灯进行排序。两个灯高低偏差不超过灯半径算同一行（即两个灯坐标的差 ≤ 灯高度的一半）。\n",
  "inputDesc": "第一行为N，表示灯的个数 接下来N行，每行为1个灯的坐标信息，格式为：\n编号 x1 y1 x2 y2\n编号全局唯一1 ≤ 编号 ≤ 1000 ≤ x1 < x2 ≤ 10000 ≤ y1 < y2 ≤ 1000\n",
  "outputDesc": "排序后的编号列表，编号之间以空格分隔",
  "examples": [
    {
      "input": "5\n1 0 0 10 10\n2 20 5 30 15\n3 50 2 60 12\n4 25 30 35 40\n5 60 35 70 45",
      "output": "1 2 3 4 5",
      "explanation": "灯1圆心(5,5)、灯2圆心(25,10)、灯3圆心(55,7)，y坐标差<=半径5，同一行按x排；灯4、5为第二行。"
    },
    {
      "input": "3\n2 10 0 20 10\n1 0 0 10 10\n3 30 5 40 15",
      "output": "1 2 3",
      "explanation": "三个灯y坐标相近(5,5,10)，差值都<=半径5，视为同一行，按x坐标升序。"
    },
    {
      "input": "4\n1 0 0 10 10\n2 0 20 10 30\n3 0 40 10 50\n4 0 60 10 70",
      "output": "1 2 3 4",
      "explanation": "四个灯y坐标分别为5,25,45,65，各自独立成行，每行只有一个灯。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**排序+分组**问题。\n\n**关键点：**\n- 将矩形灯转换为圆心坐标和半径\n- y坐标差不超过半径视为同一行\n\n**算法步骤：**\n1. 计算每个灯的圆心(x,y)和半径r\n2. 按y坐标升序排列所有灯\n3. 从最高灯开始，找出所有y坐标差<=半径的灯作为同一行\n4. 同一行内按x坐标升序排列\n5. 继续处理剩余未分组的灯\n\n**时间复杂度**：O(N log N)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringJoiner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = sc.nextInt();\n\n    Light[] lights = new Light[n];\n    for (int i = 0; i < n; i++) {\n      int id = sc.nextInt();\n      int x1 = sc.nextInt();\n      int y1 = sc.nextInt();\n      int x2 = sc.nextInt();\n      int y2 = sc.nextInt();\n      lights[i] = new Light(id, (x1 + x2) / 2, (y1 + y2) / 2, (x2 - x1) / 2);\n    }\n\n    System.out.println(getResult(lights));\n  }\n\n  public static String getResult(Light[] lights) {\n    // 按照圆心y坐标升序\n    Arrays.sort(lights, (a, b) -> a.y - b.y);\n\n    // ans记录题解\n    StringJoiner ans = new StringJoiner(\" \");\n\n    // sameRowLights记录同一行的灯\n    ArrayList<Light> sameRowLights = new ArrayList<>();\n    Light base = lights[0];\n    sameRowLights.add(base);\n\n    for (int i = 1; i < lights.length; i++) {\n      Light light = lights[i];\n\n      // 如果lights[i]的纵坐标和base的纵坐标相差不超过半径，则视为同一行\n      if (light.y - base.y <= base.r) {\n        sameRowLights.add(light);\n      } else {\n        // 否则，不是同一行\n        // 针对同一行的灯，再按照横坐标升序\n        sameRowLights.sort((a, b) -> a.x - b.x);\n        sameRowLights.forEach(a -> ans.add(a.id + \"\"));\n        sameRowLights.clear();\n\n        // 开始新的一行记录\n        base = light;\n        sameRowLights.add(base);\n      }\n    }\n\n    // 注意不要漏了最后一行\n    if (sameRowLights.size() > 0) {\n      sameRowLights.sort((a, b) -> a.x - b.x);\n      sameRowLights.forEach(a -> ans.add(a.id + \"\"));\n    }\n\n    return ans.toString();\n  }\n}\n\nclass Light {\n  int id; // 编号\n  int x; // 圆心横坐标\n  int y; // 圆心纵坐标\n  int r; // 圆半径\n\n  public Light(int id, int x, int y, int r) {\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.r = r;\n  }\n}",
    "python": "class Light:\n    def __init__(self, id, x, y, r):\n        self.id = id  # 编号\n        self.x = x  # 圆心横坐标\n        self.y = y  # 圆心纵坐标\n        self.r = r  # 圆半径\n\n\n# 输入获取\nn = int(input())\narr = [list(map(int, input().split())) for _ in range(n)]\nlights = list(map(lambda ele: Light(ele[0], (ele[1] + ele[3]) // 2, (ele[2] + ele[4]) // 2, (ele[3] - ele[1]) // 2), arr))\n\n\n# 算法入口\ndef getResult():\n    # 按照圆心y坐标升序\n    lights.sort(key=lambda l: l.y)\n\n    # ans记录题解\n    ans = []\n\n    # sameRowLights记录同一行的灯\n    sameRowLights = []\n    base = lights[0]\n    sameRowLights.append(base)\n\n    for i in range(1, len(lights)):\n        light = lights[i]\n\n        # 如果lights[i]的纵坐标和base的纵坐标相差不超过半径，则视为同一行\n        if light.y - base.y <= base.r:\n            sameRowLights.append(light)\n        else:\n            # 否则，不是同一行\n            # 针对同一行的灯，再按照横坐标升序\n            sameRowLights.sort(key=lambda l: l.x)\n            for l in sameRowLights:\n                ans.append(l.id)\n            sameRowLights.clear()\n\n            # 开始新的一行记录\n            base = light\n            sameRowLights.append(base)\n\n    # 注意不要漏了最后一行\n    if len(sameRowLights) > 0:\n        sameRowLights.sort(key=lambda l: l.x)\n        for l in sameRowLights:\n            ans.append(l.id)\n\n    return \" \".join(map(str, ans))\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nconst lines = [];\nrl.on('line', (line) => {\n    lines.push(line);\n}).on('close', () => {\n    const n = parseInt(lines[0]);\n    const lights = [];\n    \n    for (let i = 1; i <= n; i++) {\n        const [id, x1, y1, x2, y2] = lines[i].split(' ').map(Number);\n        lights.push({\n            id,\n            x: Math.floor((x1 + x2) / 2),\n            y: Math.floor((y1 + y2) / 2),\n            r: Math.floor((x2 - x1) / 2)\n        });\n    }\n    \n    // 按y坐标升序排序\n    lights.sort((a, b) => a.y - b.y);\n    \n    const ans = [];\n    let sameRowLights = [];\n    let base = lights[0];\n    sameRowLights.push(base);\n    \n    for (let i = 1; i < lights.length; i++) {\n        const light = lights[i];\n        if (light.y - base.y <= base.r) {\n            sameRowLights.push(light);\n        } else {\n            sameRowLights.sort((a, b) => a.x - b.x);\n            sameRowLights.forEach(l => ans.push(l.id));\n            sameRowLights = [];\n            base = light;\n            sameRowLights.push(base);\n        }\n    }\n    \n    if (sameRowLights.length > 0) {\n        sameRowLights.sort((a, b) => a.x - b.x);\n        sameRowLights.forEach(l => ans.push(l.id));\n    }\n    \n    console.log(ans.join(' '));\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Light {\n    int id, x, y, r;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Light> lights(n);\n    for (int i = 0; i < n; i++) {\n        int id, x1, y1, x2, y2;\n        cin >> id >> x1 >> y1 >> x2 >> y2;\n        lights[i] = {id, (x1 + x2) / 2, (y1 + y2) / 2, (x2 - x1) / 2};\n    }\n    \n    // 按y坐标升序\n    sort(lights.begin(), lights.end(), [](const Light& a, const Light& b) {\n        return a.y < b.y;\n    });\n    \n    vector<int> ans;\n    vector<Light> sameRowLights;\n    Light base = lights[0];\n    sameRowLights.push_back(base);\n    \n    for (int i = 1; i < n; i++) {\n        Light& light = lights[i];\n        if (light.y - base.y <= base.r) {\n            sameRowLights.push_back(light);\n        } else {\n            sort(sameRowLights.begin(), sameRowLights.end(), [](const Light& a, const Light& b) {\n                return a.x < b.x;\n            });\n            for (const auto& l : sameRowLights) ans.push_back(l.id);\n            sameRowLights.clear();\n            base = light;\n            sameRowLights.push_back(base);\n        }\n    }\n    \n    if (!sameRowLights.empty()) {\n        sort(sameRowLights.begin(), sameRowLights.end(), [](const Light& a, const Light& b) {\n            return a.x < b.x;\n        });\n        for (const auto& l : sameRowLights) ans.push_back(l.id);\n    }\n    \n    for (int i = 0; i < ans.size(); i++) {\n        cout << ans[i];\n        if (i < ans.size() - 1) cout << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int id, x, y, r;\n} Light;\n\nint cmpByY(const void* a, const void* b) {\n    return ((Light*)a)->y - ((Light*)b)->y;\n}\n\nint cmpByX(const void* a, const void* b) {\n    return ((Light*)a)->x - ((Light*)b)->x;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Light* lights = (Light*)malloc(n * sizeof(Light));\n    for (int i = 0; i < n; i++) {\n        int id, x1, y1, x2, y2;\n        scanf(\"%d %d %d %d %d\", &id, &x1, &y1, &x2, &y2);\n        lights[i].id = id;\n        lights[i].x = (x1 + x2) / 2;\n        lights[i].y = (y1 + y2) / 2;\n        lights[i].r = (x2 - x1) / 2;\n    }\n    \n    qsort(lights, n, sizeof(Light), cmpByY);\n    \n    int* ans = (int*)malloc(n * sizeof(int));\n    int ansLen = 0;\n    \n    Light* sameRow = (Light*)malloc(n * sizeof(Light));\n    int rowLen = 0;\n    Light base = lights[0];\n    sameRow[rowLen++] = base;\n    \n    for (int i = 1; i < n; i++) {\n        if (lights[i].y - base.y <= base.r) {\n            sameRow[rowLen++] = lights[i];\n        } else {\n            qsort(sameRow, rowLen, sizeof(Light), cmpByX);\n            for (int j = 0; j < rowLen; j++) ans[ansLen++] = sameRow[j].id;\n            rowLen = 0;\n            base = lights[i];\n            sameRow[rowLen++] = base;\n        }\n    }\n    \n    if (rowLen > 0) {\n        qsort(sameRow, rowLen, sizeof(Light), cmpByX);\n        for (int j = 0; j < rowLen; j++) ans[ansLen++] = sameRow[j].id;\n    }\n    \n    for (int i = 0; i < ansLen; i++) {\n        printf(\"%d\", ans[i]);\n        if (i < ansLen - 1) printf(\" \");\n    }\n    printf(\"\\n\");\n    \n    free(lights);\n    free(ans);\n    free(sameRow);\n    return 0;\n}"
  }
}