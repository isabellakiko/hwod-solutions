{
  "id": "100",
  "title": "日志采集系统",
  "examType": "A",
  "score": 100,
  "description": "日志采集是运维系统的的核心组件。日志是按行生成，每行记做一条，由采集系统分批上报。\n如果上报太频繁，会对服务端造成压力;如果上报太晚，会降低用户的体验；如果一次上报的条数太多，会导致超时失败。\n为此，项目组设计了如下的上报策略：\n每成功上报一条日志，奖励1分每条日志每延迟上报1秒，扣1分积累日志达到100条，必须立即上报\n给出日志序列，根据该规则，计算首次上报能获得的最多积分数。",
  "inputDesc": "按时序产生的日志条数 T1,T2…Tn，其中 1<=n<=1000，0<=Ti<=100",
  "outputDesc": "首次上报最多能获得的积分数",
  "examples": [
    {
      "input": "1 98 1",
      "output": "98",
      "explanation": "T2时刻上报99条，第1条延迟1秒扣1分，得99-1=98分，为最大。"
    },
    {
      "input": "50 60 1",
      "output": "50",
      "explanation": "T1上报50条得50分；T2强制上报100条，前50条延迟扣50分，得50分。"
    },
    {
      "input": "3 7 40 10 60",
      "output": "37",
      "explanation": "T3上报50条，T1的3条延迟2秒扣6分，T2的7条延迟1秒扣7分，得50-6-7=37分。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟+贪心**问题。\n\n**核心规则：**\n- 每上报1条日志得1分\n- 每条日志延迟1秒扣1分\n- 累计>=100条必须立即上报\n\n**算法步骤：**\n1. 枚举每个时刻作为上报时间点\n2. 计算该时刻上报的得分：累计条数 - 延迟扣分\n3. 若累计>=100，只能上报100条\n4. 取所有时刻得分的最大值\n\n**时间复杂度**：O(N²)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class LogCollection {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        // 读取输入的日志序列\n        String input = in.nextLine();\n        // 将日志序列按空格分割成数组\n        String[] logs = input.split(\" \");\n\n        int totalCount = 0; // 总日志条数\n        int maxScore = 0; // 最大积分数\n        for (int i = 0; i < logs.length; i++) {\n            int logCount = Integer.valueOf(logs[i]); // 当前时间点的日志条数\n            if (logCount == 0) {\n                continue; // 如果当前时间点没有日志条数，则跳过\n            }\n\n            totalCount += logCount; // 更新总日志条数\n\n            int score = 0; // 当前时间点的积分数\n            for (int j = 0; j <= i; j++) {\n                if (totalCount > 100 && i == j) {\n                    // 如果总日志条数超过100，并且当前时间点是最后一个时间点\n                    score += logCount - (totalCount - 100); // 计算得分\n                } else {\n                    score += Integer.valueOf(logs[j]) - (i - j) * Integer.valueOf(logs[j]); // 计算得分\n                }\n            }\n\n            if (score > maxScore) {\n                maxScore = score; // 更新最大积分数\n            }\n\n            if (totalCount >= 100) {\n                break; // 如果总日志条数达到100条以上，则退出循环\n            }\n        }\n\n        System.out.println(maxScore); // 输出最大积分数\n    }\n}",
    "python": "import sys\n\n# 读取输入的日志序列\ninput = sys.stdin.readline().strip()\n# 将日志序列按空格分割成数组\nlogs = input.split(\" \")\n\ntotalCount = 0  # 总日志条数\nmaxScore = 0  # 最大积分数\nfor i in range(len(logs)):\n    logCount = int(logs[i])  # 当前时间点的日志条数\n    if logCount == 0:\n        continue  # 如果当前时间点没有日志条数，则跳过\n\n    totalCount += logCount  # 更新总日志条数\n\n    score = 0  # 当前时间点的积分数\n    for j in range(i+1):\n        if totalCount > 100 and i == j:\n            # 如果总日志条数超过100，并且当前时间点是最后一个时间点\n            score += logCount - (totalCount - 100)  # 计算得分\n        else:\n            score += int(logs[j]) - (i - j) * int(logs[j])  # 计算得分\n\n    if score > maxScore:\n        maxScore = score  # 更新最大积分数\n\n    if totalCount >= 100:\n        break  # 如果总日志条数达到100条以上，则退出循环\n\nprint(maxScore)  # 输出最大积分数",
    "javascript": "var readline = require('readline');\n\nvar rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', function (input) {\n    var logs = input.split(\" \");\n\n    var totalCount = 0; // 总日志条数\n    var maxScore = 0; // 最大积分数\n    for (var i = 0; i < logs.length; i++) {\n        var logCount = parseInt(logs[i]); // 当前时间点的日志条数\n        if (logCount === 0) {\n            continue; // 如果当前时间点没有日志条数，则跳过\n        }\n\n        totalCount += logCount; // 更新总日志条数\n\n        var score = 0; // 当前时间点的积分数\n        for (var j = 0; j <= i; j++) {\n            if (totalCount > 100 && i === j) {\n                // 如果总日志条数超过100，并且当前时间点是最后一个时间点\n                score += logCount - (totalCount - 100); // 计算得分\n            } else {\n                score += parseInt(logs[j]) - (i - j) * parseInt(logs[j]); // 计算得分\n            }\n        }\n\n        if (score > maxScore) {\n            maxScore = score; // 更新最大积分数\n        }\n\n        if (totalCount >= 100) {\n            break; // 如果总日志条数达到100条以上，则退出循环\n        }\n    }\n\n    console.log(maxScore); // 输出最大积分数\n\n    rl.close();\n});",
    "cpp": "#include <iostream>  // 包含输入输出流库\n#include <vector>    // 包含向量容器库\nusing namespace std;\n\nint main() {\n    string input;\n    getline(cin, input);  // 从标准输入读取整行数据\n    vector<string> logs;  // 用于存储日志条数的字符串向量\n    string temp = \"\";     // 临时字符串变量，用于逐字符拼接日志条数\n    for (int i = 0; i < input.length(); i++) {  // 遍历输入的每一个字符\n        if (input[i] == ' ') {  // 遇到空格时，表示一个日志条数的结束\n            logs.push_back(temp);  // 将当前拼接的字符串加入日志向量\n            temp = \"\";  // 重置临时字符串变量\n        } else {\n            temp += input[i];  // 拼接字符\n        }\n    }\n    logs.push_back(temp);  // 将最后一个日志条数加入日志向量\n\n    int totalCount = 0;  // 累计日志总条数\n    int maxScore = 0;    // 记录最大积分数\n    for (int i = 0; i < logs.size(); i++) {  // 遍历每个时间点的日志\n        int logCount = stoi(logs[i]);  // 将当前日志条数从字符串转换为整数\n        if (logCount == 0) {  // 如果当前时间点日志条数为0，跳过该时间点\n            continue;\n        }\n\n        totalCount += logCount;  // 累加日志总条数\n\n        int score = 0;  // 当前时间点的积分\n        for (int j = 0; j <= i; j++) {  // 计算当前时间点的积分\n            if (totalCount > 100 && i == j) {  // 如果总日志条数超过100且当前为最后一个时间点\n                score += logCount - (totalCount - 100);  // 计算积分，考虑超出100条的部分\n            } else {\n                score += stoi(logs[j]) - (i - j) * stoi(logs[j]);  // 正常积分计算，考虑延迟扣分\n            }\n        }\n\n        if (score > maxScore) {  // 更新最大积分数\n            maxScore = score;\n        }\n\n        if (totalCount >= 100) {  // 如果总日志条数达到或超过100，提前结束循环\n            break;\n        }\n    }\n\n    cout << maxScore << endl;  // 输出最大积分数\n\n    return 0;\n}",
    "c": "#include <stdio.h>    \n#include <string.h>  \n#include <stdlib.h> \n\nint main() {\n    char input[1000];  // 定义一个字符数组用于存储输入\n    fgets(input, 1000, stdin);  // 从标准输入读取一行数据\n\n    char logs[100][10];  // 定义一个二维字符数组存储日志条数，每条日志最长为10个字符\n    int logCount = 0;    // 日志条数计数器\n    char *token = strtok(input, \" \");  // 使用空格分割输入字符串，获取第一个日志条数\n\n    while (token != NULL) {  // 逐个分割字符串，直到没有更多的分割部分\n        strcpy(logs[logCount], token);  // 将当前日志条数到日志数组中\n        logCount++;  // 增加日志条数计数\n        token = strtok(NULL, \" \");  // 获取下一个日志条数\n    }\n\n    int totalCount = 0;  // 累积日志总条数\n    int maxScore = 0;    // 记录最大积分数\n    for (int i = 0; i < logCount; i++) {  // 遍历每个时间点的日志\n        int logNum = atoi(logs[i]);  // 将当前日志条数从字符串转换为整数\n        if (logNum == 0) {  // 如果当前时间点日志条数为0，跳过该时间点\n            continue;\n        }\n\n        totalCount += logNum;  // 累加日志总条数\n\n        int score = 0;  // 当前时间点的积分\n        for (int j = 0; j <= i; j++) {  // 计算当前时间点的积分\n            int logAtJ = atoi(logs[j]);  // 将日志条数从字符串转换为整数\n            if (totalCount > 100 && i == j) {  // 如果总日志条数超过100且当前为最后一个时间点\n                score += logNum - (totalCount - 100);  // 计算积分，考虑超出100条的部分\n            } else {\n                score += logAtJ - (i - j) * logAtJ;  // 正常积分计算，考虑延迟扣分\n            }\n        }\n\n        if (score > maxScore) {  // 更新最大积分数\n            maxScore = score;\n        }\n\n        if (totalCount >= 100) {  // 如果总日志条数达到或超过100，提前结束循环\n            break;\n        }\n    }\n\n    printf(\"%d\\n\", maxScore);  // 输出最大积分数\n\n    return 0;\n}"
  }
}