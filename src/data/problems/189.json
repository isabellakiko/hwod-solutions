{
  "id": "189",
  "title": "提取字符串中的最长合法简单数学表达式",
  "examType": "B",
  "score": 100,
  "description": "提取字符串中的最长合法简单数学表达式，字符串长度最长的，并计算表达式的值。如果没有，则返回 0 。\n简单数学表达式只能包含以下内容：\n0-9数字，符号+-*\n说明：\n所有数字，计算结果都不超过long如果有多个长度一样的，请返回第一个表达式的结果数学表达式，必须是最长的，合法的操作符不能连续出现，如 +--+1 是不合法的\n",
  "inputDesc": "字符串\n",
  "outputDesc": "表达式值\n\n\n注意！！！本题原题描述中没有 / 除号\n\n因此，本题的合法表达式不需要考虑 '/' 号，也就不用考虑除0，以及除法是整除还是小数除的问题。\n另外，本题的 +、-号仅作为运算符号，不作为正负号。因此 \"+1\"，\"-1\" 这种不能理解为合法的表达式。\n本题可以分为两步求解：\n关于1的求解，有两种思路：\n其中正则匹配实现起来比较简单，用于匹配合法表达式的正则也不是很难写，对应正则解析如下：\n\n对于python而言，为了更好地适配findall方法，我们可以对上面正则表达式中内层括号使用到非捕获组\n\n\n关于2的求解\n对于JS和Python而言，可以使用内置的eval函数计算字符串表达式的结果。\n更常规的思路是利用栈结构：\n找出最长合法表达式子串后，比如 \"1-2*3+10+2\"，我们需要注意表达式运算符优先级问题，即先乘，后加减，相同优先级的运算从左到右进行。\n\n这里我的思路是将 合法表达式串 进行分块，比如上面表达式可以分为：\n我们可以发现：\n分块之后，我们只需要求各块结果之和即可。\n\n具体逻辑实现如下：\n扫描合法表达式串，如果当前扫描的字符c是：\n这块实现的更详细解析，可以参考：\n华为OD机试 - 符号运算（Java & JS & Python & C）_java 华为od机试,符号运算-CSDN博客\n\n",
  "examples": [
    {
      "input": "1-2*3+10+2",
      "output": "7",
      "explanation": "整个字符串就是最长合法表达式，1-2*3+10+2=1-6+10+2=7"
    },
    {
      "input": "abc1+2*3def",
      "output": "7",
      "explanation": "最长合法表达式为1+2*3，结果为7"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**正则匹配+表达式求值**问题。\n\n**核心思路：**\n- 用正则提取所有合法表达式\n- 找最长的计算其值\n\n**算法步骤：**\n1. 使用正则(\\d+[+*-])*\\d+匹配合法表达式\n2. 找出最长的表达式串\n3. 使用栈计算表达式值（处理运算符优先级）\n4. 返回计算结果\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.LinkedList;\nimport java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    System.out.println(getResult(sc.nextLine()));\n  }\n\n  public static long getResult(String s) {\n    String maxLenExp = getMaxLenExp(s);\n\n    if (maxLenExp.length() == 0) {\n      return 0;\n    } else {\n      return calcExpStr(maxLenExp);\n    }\n  }\n\n  public static String getMaxLenExp(String s) {\n    Matcher matcher = Pattern.compile(\"((\\\\d+[+*-])*\\\\d+)\").matcher(s);\n\n    String maxLenExp = \"\";\n\n    while (matcher.find()) {\n      String exp = matcher.group(0);\n\n      if (exp.length() > maxLenExp.length()) {\n        maxLenExp = exp;\n      }\n    }\n\n    return maxLenExp;\n  }\n\n  public static long calcExpStr(String exp) {\n    // 这里在表达式结尾追加\"+0\"是为了避免后面收尾操作，不理解的话，可以去掉此步，测试下\"1-2\"\n    exp += \"+0\";\n\n    // 记录表达式中各块的操作数\n    LinkedList<Long> stack = new LinkedList<>();\n    // 各块操作数的\"值\"部分的缓存容器\n    StringBuilder numStr = new StringBuilder();\n    // 各块操作数的\"系数\"部分，默认为1\n    long num_coef = 1;\n\n    for (int i = 0; i < exp.length(); i++) {\n      char c = exp.charAt(i);\n\n      if (c >= '0' && c <= '9') {\n        numStr.append(c);\n        continue;\n      }\n\n      // 如果扫描到的字符c是运算符，那么该运算符打断了前面操作数的扫描，前面操作数 = 系数 * 值\n      long num = num_coef * Long.parseLong(numStr.toString());\n      stack.add(num);\n\n      // 清空缓存容器，用于下一个操作数的”值“记录\n      numStr = new StringBuilder();\n\n      switch (c) {\n        case '+':\n          // 如果运算符是加法，则后一个操作数的系数为1\n          num_coef = 1;\n          break;\n        case '-':\n          // 如果运算符是减法，则后一个操作数的系数为-1\n          num_coef = -1;\n          break;\n        case '*':\n          // 如果运算符是乘法，则后一个操作数的系数为栈顶值，比如2*3，其中2可以当作3的系数\n          num_coef = stack.removeLast();\n          break;\n      }\n    }\n\n    // 表达式分块后，每一块独立计算，所有块的和就是表达式的结果\n    long res = 0;\n    for (long num : stack) {\n      res += num;\n    }\n\n    return res;\n  }\n}",
    "python": "# 输入获取\nimport re\n\ns = input()\n\n\n# 计算合法表达式的结果\ndef calcExpStr(exp):\n    # 这里在表达式结尾追加\"+0\"是为了避免后面收尾操作，不理解的话，可以去掉此步，测试下\"1-2\"\n    exp += '+0'\n\n    # 记录表达式中各块的操作数\n    stack = []\n    # 各块操作数的\"值\"部分的缓存容器\n    numStr = []\n    # 各块操作数的\"系数\"部分，默认为1\n    num_coef = 1\n\n    for c in exp:\n        if '9' >= c >= '0':\n            numStr.append(c)\n            continue\n\n        # 如果扫描到的字符c是运算符，那么该运算符打断了前面操作数的扫描，前面操作数 = 系数 * 值\n        num = num_coef * int(\"\".join(numStr))\n        stack.append(num)\n\n        # 清空缓存容器，用于下一个操作数的”值“记录\n        numStr.clear()\n\n        if c == '+':\n            # 如果运算符是加法，则后一个操作数的系数为1\n            num_coef = 1\n        elif c == '-':\n            # 如果运算符是减法，则后一个操作数的系数为-1\n            num_coef = -1\n        elif c == '*':\n            # 如果运算符是乘法，则后一个操作数的系数为栈顶值，比如2*3，其中2可以当作3的系数\n            num_coef = stack.pop()\n\n    # 表达式分块后，每一块独立计算，所有块的和就是表达式的结果\n    return sum(stack)\n\n\n# 获取最长合法表达式\ndef getMaxLenExp():\n    lst = re.compile(r\"((?:\\d+[+*-])*\\d+)\").findall(s)\n\n    maxLenExp = \"\"\n\n    for exp in lst:\n        if len(exp) > len(maxLenExp):\n            maxLenExp = exp\n\n    return maxLenExp\n\n\n# 算法入口\ndef getResult():\n    maxLenExp = getMaxLenExp()\n\n    if len(maxLenExp) == 0:\n        return 0\n    else:\n        return calcExpStr(maxLenExp)\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}