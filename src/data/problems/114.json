{
  "id": "114",
  "title": "MELON的难题",
  "examType": "A",
  "score": 200,
  "description": "MELON有一堆精美的雨花石（数量为n，重量各异），准备送给S和W。MELON希望送给俩人的雨花石重量一致，请你设计一个程序，帮MELON确认是否能将雨花石平均分配。",
  "inputDesc": "第1行输入为雨花石个数: n，0 < n < 31. 第2行输入为空格分割的各雨花石重量: m[0] m[1] … m[n - 1]， 0 < m[k] < 1001\n不需要考虑异常输入的情况。",
  "outputDesc": "如果可以均分，从当前雨花石中最少拿出几块，可以使两堆的重量相等:如果不能均分，则输出-1。\n输入\n输出\n说明\n输入第一行代表共4颗雨花石，第二行代表4颗雨花石重量分别为1、1、2、2。均分时只能分别为1,2，需要拿出重量为1和2的两块雨花石，所以输出2。\n输入\n输出\n说明\n输入第一行代表共10颗雨花石，第二行代表4颗雨花石重量分别为1、1、1、1、1、9、8、3、7、10 。\n均分时可以1,1,1,1,1,9,7和10,8,3，也可以1,1,1,1,9.8和10,7,3,1，或者其他均分方式，但第一种只需要拿出重量为10.8,3的3块雨花石，第二种需要拿出4块，所以输出3(块数最少)。",
  "examples": [
    {
      "input": "4\n1 1 2 2",
      "output": "2",
      "explanation": "总重6，目标重量3。分成(1,2)和(1,2)，需拿出2块"
    },
    {
      "input": "10\n1 1 1 1 1 9 8 3 7 10",
      "output": "3",
      "explanation": "总重42，目标21。最优：拿出10,8,3共3块组成一堆"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**01背包变形**问题。\n\n**核心思路：**\n- 总重为奇数则无法均分\n- 目标：选最少数量的石头，使重量=总重/2\n- dp[j]表示凑成重量j所需的最少石头数\n\n**状态转移：**\n- dp[j] = min(dp[j], dp[j-w]+1)\n- 初始dp[0]=0，其他为n\n\n**时间复杂度**：O(N×Sum/2)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();  // 输入雨花石个数\n        int[] stones = new int[n];\n        for (int i = 0; i < n; i++) {\n            stones[i] = scanner.nextInt();  // 输入雨花石重量\n        }\n\n        int totalWeight = 0;\n        for (int stone : stones) {\n            totalWeight += stone;  // 计算雨花石总重量\n        }\n\n        if (totalWeight % 2 != 0) {  // 如果总重量为奇数，无法均分\n            System.out.println(-1);\n        } else {\n            int targetWeight = totalWeight / 2;  // 目标重量为总重量的一半\n\n            // 创建动态规划数组，dp[i]表示前i块雨花石中是否能够取出一些雨花石使得重量和为j\n            int[] dp = new int[targetWeight + 1];\n\n            // 初始化dp数组，将除了dp[0]之外的其他元素设置为n，表示最坏情况下需要拿出所有雨花石\n            for (int i = 1; i <= targetWeight; i++) {\n                dp[i] = n;\n            }\n\n            // 遍历每一块雨花石\n            for (int i = 1; i <= n; i++) {\n                int weight = stones[i - 1];  // 当前雨花石的重量\n                // 从目标重量开始递减，更新dp数组\n                for (int j = targetWeight; j >= weight; j--) {\n                    // 如果当前重量可以由前面的雨花石组成，更新dp[j]为最小需要拿出的雨花石数量\n                    dp[j] = Math.min(dp[j], dp[j - weight] + 1);\n                }\n            }\n\n            // 如果dp[targetWeight]仍然等于n，表示无法找到满足条件的雨花石组合\n            if (dp[targetWeight] == n) {\n                System.out.println(-1);\n            } else {\n                // 输出最少需要拿出的雨花石数量\n                System.out.println(dp[targetWeight]);\n            }\n        }\n    }\n}",
    "python": "# 输入雨花石个数\nn = int(input())\n\n# 输入雨花石重量，将输入的字符串转换为整数列表\nstones = list(map(int, input().split()))\n\n# 计算所有雨花石的总重量\ntotalWeight = 0\nfor stone in stones:\n    totalWeight += stone\n\n# 如果总重量为奇数，则无法平均分配，输出 -1\nif totalWeight % 2 != 0:\n    print(-1)\nelse:\n    # 计算目标重量，即总重量的一半\n    targetWeight = totalWeight // 2\n\n    # 初始化动态规划数组 dp，长度为目标重量加 1\n    dp = [0] * (targetWeight + 1)\n\n    # 将 dp 数组的值从索引 1 开始设置为 n\n    for i in range(1, targetWeight + 1):\n        dp[i] = n\n\n    # 遍历所有雨花石\n    for i in range(1, n + 1):\n        weight = stones[i - 1]\n        # 更新 dp 数组的值\n        for j in range(targetWeight, weight - 1, -1):\n            # 如果当前重量可以由前面的雨花石组成，更新dp[j]为最小需要拿出的雨花石数量\n            dp[j] = min(dp[j], dp[j - weight] + 1)\n\n    # 如果 dp[targetWeight] 等于 n，说明无法平均分配，输出 -1\n    if dp[targetWeight] == n:\n        print(-1)\n    else:\n        # 输出最少需要拿出的雨花石数量，使两堆的重量相等\n        print(dp[targetWeight])",
    "javascript": "const readline = require('readline');\n\n// 创建readline接口，用于读取输入\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nconst inputLines = [];\n// 当接收到一行输入时，将其添加到inputLines数组\nrl.on('line', (line) => {\n  inputLines.push(line);\n  // 当接收到两行输入时，处理输入并关闭readline接口\n  if (inputLines.length === 2) {\n    processInput();\n    rl.close();\n  }\n});\n\nfunction processInput() {\n  // 解析输入的雨花石数量和重量\n  const n = parseInt(inputLines[0]);\n  const stones = inputLines[1].split(' ').map(Number);\n\n  // 计算雨花石总重量\n  let totalWeight = 0;\n  for (const stone of stones) {\n    totalWeight += stone;\n  }\n\n  // 如果总重量不能被2整除，则无法平分\n  if (totalWeight % 2 !== 0) {\n    console.log(-1);\n  } else {\n    // 目标重量为总重量的一半\n    const targetWeight = totalWeight / 2;\n\n    // 初始化动态规划数组\n    const dp = new Array(targetWeight + 1).fill(0);\n\n    // 将除第一个元素外的其他元素设置为n\n    for (let i = 1; i <= targetWeight; i++) {\n      dp[i] = n;\n    }\n\n    // 遍历每个雨花石\n    for (let i = 1; i <= n; i++) {\n      const weight = stones[i - 1];\n      // 更新动态规划数组\n      for (let j = targetWeight; j >= weight; j--) {\n        // 如果当前重量可以由前面的雨花石组成，更新dp[j]为最小需要拿出的雨花石数量\n        dp[j] = Math.min(dp[j], dp[j - weight] + 1);\n      }\n    }\n\n    // 如果dp[targetWeight]等于n，说明无法平分\n    if (dp[targetWeight] === n) {\n      console.log(-1);\n    } else {\n      // 输出最少需要拿出的雨花石数量\n      console.log(dp[targetWeight]);\n    }\n  }\n}",
    "cpp": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;  // 输入雨花石个数\n    vector<int> stones(n);\n    for (int i = 0; i < n; i++) {\n        cin >> stones[i];  // 输入雨花石重量\n    }\n\n    int totalWeight = 0;\n    for (int stone : stones) {\n        totalWeight += stone;  // 计算雨花石总重量\n    }\n\n    if (totalWeight % 2 != 0) {  // 如果总重量为奇数，无法均分\n        cout << -1 << endl;\n    } else {\n        int targetWeight = totalWeight / 2;  // 目标重量为总重量的一半\n\n        // 创建动态规划数组，dp[i]表示前i块雨花石中是否能够取出一些雨花石使得重量和为j\n        vector<int> dp(targetWeight + 1, 0);\n\n        // 初始化dp数组，将除了dp[0]之外的所有值设为n，表示最大需要拿出n块雨花石\n        for (int i = 1; i <= targetWeight; i++) {\n            dp[i] = n;\n        }\n\n        // 遍历每一块雨花石\n        for (int i = 1; i <= n; i++) {\n            int weight = stones[i - 1];\n            // 更新dp数组，从后往前更新，避免重复使用同一块雨花石\n            for (int j = targetWeight; j >= weight; j--) {\n                // 如果当前重量可以由前面的雨花石组成，更新dp[j]为最小需要拿出的雨花石数量\n                dp[j] = min(dp[j], dp[j - weight] + 1);\n            }\n        }\n\n        // 如果dp[targetWeight]仍然等于n，表示无法均分雨花石\n        if (dp[targetWeight] == n) {\n            cout << -1 << endl;\n        } else {\n            // 输出最少需要拿出的雨花石数量\n            cout << dp[targetWeight] << endl;\n        }\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 31\n#define MAX_WEIGHT 1001\n\nint stones[MAX_N]; // 存储每块雨花石的重量\nint dp[MAX_WEIGHT]; // 动态规划数组，用于记录达到某个重量的最小雨花石数量\n\n// 求两个数中的较小值\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n); // 输入雨花石个数\n\n    int totalWeight = 0; // 雨花石总重量\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &stones[i]); // 输入每块雨花石的重量\n        totalWeight += stones[i]; // 累加总重量\n    }\n\n    // 如果总重量为奇数，无法均分\n    if (totalWeight % 2 != 0) {\n        printf(\"-1\\n\");\n        return 0;\n    }\n\n    int targetWeight = totalWeight / 2; // 目标重量为总重量的一半\n\n    // 初始化动态规划数组，dp[0]为0，其余为最大值n\n    dp[0] = 0;\n    for (int i = 1; i <= targetWeight; i++) {\n        dp[i] = n;\n    }\n\n    // 动态规划求解\n    for (int i = 0; i < n; i++) {\n        for (int j = targetWeight; j >= stones[i]; j--) {\n            // 更新dp数组，求取最小需要拿出的雨花石数量\n            dp[j] = min(dp[j], dp[j - stones[i]] + 1);\n        }\n    }\n\n    // 如果dp[targetWeight]仍然等于n，表示无法均分雨花石\n    if (dp[targetWeight] == n) {\n        printf(\"-1\\n\");\n    } else {\n        // 输出最少需要拿出的雨花石数量\n        printf(\"%d\\n\", dp[targetWeight]);\n    }\n\n    return 0;\n}"
  }
}