{
  "id": "66",
  "title": "勾股数元组",
  "examType": "A",
  "score": 100,
  "description": "如果3个正整数(a,b,c)满足a^2 + b^2 = c^2的关系，则称(a,b,c)为勾股数（著名的勾三股四弦五），\n为了探索勾股数的规律，我们定义如果勾股数(a,b,c)之间两两互质（即a与b，a与c，b与c之间均互质，没有公约数），则其为勾股数元组（例如(3,4,5)是勾股数元组，(6,8,10)则不是勾股数元组）。\n请求出给定范围[N,M]内，所有的勾股数元组。\n",
  "inputDesc": "起始范围N，1 <= N <= 10000\n结束范围M，N < M <= 10000\n",
  "outputDesc": "1. a,b,c请保证a < b < c，输出格式：a b c\n2. 多组勾股数元组按a、b、c升序排序输出\n3. 找不到时输出NA",
  "examples": [
    {
      "input": "1\n20",
      "output": "3 4 5\n5 12 13\n8 15 17",
      "explanation": "[1,20]范围内勾股数元组(两两互质)有：(3,4,5)、(5,12,13)、(8,15,17)。"
    },
    {
      "input": "5\n10",
      "output": "NA",
      "explanation": "[5,10]范围内勾股数有(6,8,10)，但6和8不互质(公因数2)，所以没有勾股数元组。"
    },
    {
      "input": "1\n5",
      "output": "3 4 5",
      "explanation": "[1,5]范围内只有(3,4,5)是勾股数且两两互质。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**枚举+数论**问题。\n\n**算法步骤：**\n1. 枚举范围[N,M]内所有可能的(a,b,c)组合\n2. 检查是否满足a²+b²=c²\n3. 使用辗转相除法(GCD)判断两两是否互质\n4. 按a,b,c升序排序输出\n\n**互质判断：**\n使用辗转相除法求最大公约数，若GCD=1则互质\n\n**时间复杂度**：O((M-N)³)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    int n = sc.nextInt();\n    int m = sc.nextInt();\n\n    getResult(n, m);\n  }\n\n  public static void getResult(int n, int m) {\n    ArrayList<Integer> arr = new ArrayList<>();\n\n    for (int i = n; i <= m; i++) {\n      arr.add(i * i);\n    }\n\n    HashSet<Integer> set = new HashSet<>(arr);\n    ArrayList<Integer[]> res = new ArrayList<>();\n\n    for (int i = 0; i < arr.size(); i++) {\n      for (int j = i + 1; j < arr.size(); j++) {\n        // 判断勾股数 a^2 + b^2 = c^2\n        int sum = arr.get(i) + arr.get(j);\n        if (set.contains(sum)) {\n          res.add(\n              new Integer[] {\n                (int) Math.sqrt(arr.get(i)), (int) Math.sqrt(arr.get(j)), (int) Math.sqrt(sum)\n              });\n        }\n      }\n    }\n\n    List<Integer[]> collect =\n        res.stream()\n            .filter(\n                g ->\n                    isRelativePrime(g[0], g[1])\n                        && isRelativePrime(g[0], g[2])\n                        && isRelativePrime(g[1], g[2]))\n            .collect(Collectors.toList());\n\n    if (collect.size() == 0) {\n      System.out.println(\"NA\");\n    } else {\n      for (Integer[] g : collect) {\n        System.out.println(g[0] + \" \" + g[1] + \" \" + g[2]);\n      }\n    }\n  }\n\n  // 判断两个数是否互质，辗转相除\n  public static boolean isRelativePrime(int x, int y) {\n    while (y > 0) {\n      int mod = x % y;\n      x = y;\n      y = mod;\n    }\n\n    return x == 1;\n  }\n}",
    "python": "import math\n\n# 输入获取\nn = int(input())\nm = int(input())\n\n\n# 判断两个数是否互质，辗转相除\ndef isRelativePrime(x, y):\n    while y > 0:\n        mod = x % y\n        x = y\n        y = mod\n\n    return x == 1\n\n\n# 算法入口\ndef getResult():\n    arr = []\n\n    for i in range(n, m + 1):\n        arr.append(i * i)\n\n    setArr = set(arr)\n\n    res = []\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            # 判断勾股数 a^2 + b^2 = c^2\n            sumV = arr[i] + arr[j]\n            if sumV in setArr:\n                res.append([int(math.sqrt(arr[i])), int(math.sqrt(arr[j])), int(math.sqrt(sumV))])\n\n    ans = list(\n        filter(lambda x: isRelativePrime(x[0], x[1]) and isRelativePrime(x[0], x[2]) and isRelativePrime(x[1], x[2]),\n               res))\n\n    if len(ans) == 0:\n        print(\"NA\")\n    else:\n        for g in ans:\n            print(\" \".join(map(str, g)))\n\n\n# 算法调用\ngetResult()",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const [n, m] = lines.map(Number);\n\n    getResult(n, m);\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(n, m) {\n  const arr = [];\n\n  for (let i = n; i <= m; i++) {\n    arr.push(i * i);\n  }\n\n  const set = new Set(arr);\n\n  const res = [];\n  for (let i = 0; i < arr.length; i++) {\n    for (let j = i + 1; j < arr.length; j++) {\n      /* 判断勾股数 a^2 + b^2 = c^2 */\n      const sum = arr[i] + arr[j];\n      if (set.has(sum)) {\n        res.push([Math.sqrt(arr[i]), Math.sqrt(arr[j]), Math.sqrt(sum)]);\n      }\n    }\n  }\n\n  const ans = res.filter((group) => {\n    const [a, b, c] = group;\n    return (\n      isRelativePrime(a, b) && isRelativePrime(a, c) && isRelativePrime(b, c)\n    );\n  });\n\n  if (!ans.length) return console.log(\"NA\");\n\n  ans.forEach((g) => console.log(g.join(\" \")));\n}\n\n/* 判断两个数是否互质，辗转相除 */\nfunction isRelativePrime(x, y) {\n  while (y > 0) {\n    let mod = x % y;\n    x = y;\n    y = mod;\n  }\n\n  return x === 1;\n}",
    "cpp": "#include <iostream>\n#include <vector>\n#include <set>\n#include <cmath>\nusing namespace std;\n\nbool isRelativePrime(int x, int y) {\n    while (y > 0) {\n        int mod = x % y;\n        x = y;\n        y = mod;\n    }\n    return x == 1;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<int> arr;\n    for (int i = n; i <= m; i++) {\n        arr.push_back(i * i);\n    }\n    \n    set<int> s(arr.begin(), arr.end());\n    vector<vector<int>> res;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        for (int j = i + 1; j < arr.size(); j++) {\n            int sum = arr[i] + arr[j];\n            if (s.count(sum)) {\n                res.push_back({(int)sqrt(arr[i]), (int)sqrt(arr[j]), (int)sqrt(sum)});\n            }\n        }\n    }\n    \n    vector<vector<int>> ans;\n    for (auto& g : res) {\n        if (isRelativePrime(g[0], g[1]) && isRelativePrime(g[0], g[2]) && isRelativePrime(g[1], g[2])) {\n            ans.push_back(g);\n        }\n    }\n    \n    if (ans.empty()) {\n        cout << \"NA\" << endl;\n    } else {\n        for (auto& g : ans) {\n            cout << g[0] << \" \" << g[1] << \" \" << g[2] << endl;\n        }\n    }\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint isRelativePrime(int x, int y) {\n    while (y > 0) {\n        int mod = x % y;\n        x = y;\n        y = mod;\n    }\n    return x == 1;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    int len = m - n + 1;\n    int* arr = (int*)malloc(len * sizeof(int));\n    for (int i = 0; i < len; i++) {\n        arr[i] = (n + i) * (n + i);\n    }\n    \n    int res[1000][3];\n    int resLen = 0;\n    \n    for (int i = 0; i < len; i++) {\n        for (int j = i + 1; j < len; j++) {\n            int sum = arr[i] + arr[j];\n            // 检查sum是否在arr中\n            for (int k = j + 1; k < len; k++) {\n                if (arr[k] == sum) {\n                    res[resLen][0] = (int)sqrt(arr[i]);\n                    res[resLen][1] = (int)sqrt(arr[j]);\n                    res[resLen][2] = (int)sqrt(sum);\n                    resLen++;\n                    break;\n                }\n            }\n        }\n    }\n    \n    int found = 0;\n    for (int i = 0; i < resLen; i++) {\n        if (isRelativePrime(res[i][0], res[i][1]) && \n            isRelativePrime(res[i][0], res[i][2]) && \n            isRelativePrime(res[i][1], res[i][2])) {\n            printf(\"%d %d %d\\n\", res[i][0], res[i][1], res[i][2]);\n            found = 1;\n        }\n    }\n    \n    if (!found) {\n        printf(\"NA\\n\");\n    }\n    \n    free(arr);\n    return 0;\n}"
  }
}