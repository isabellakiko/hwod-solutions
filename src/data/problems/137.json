{
  "id": "137",
  "title": "观看文艺汇演问题",
  "examType": "A",
  "score": 200,
  "description": "为了庆祝中国共产党成立100周年，某公园将举行多场文艺表演，很多演出都是同时进行，一个人只能同时观看一场演出，且不能迟到早退，由于演出分布在不同的演出场地，所以连续观看的演出最少有15分钟的时间间隔，\n小明是一个狂热的文艺迷，想观看尽可能多的演出， 现给出演出时间表，请帮小明计算他最多能观看几场演出。",
  "inputDesc": "第一行为一个数 N，表示演出场数\n1 ≤ N ≤ 1000\n接下来 N 行，每行有被空格分割的整数，第一个整数 T 表示演出的开始时间，第二个整数 L 表示演出的持续时间\nT 和 L 的单位为分钟0 ≤ T ≤ 14400 < L ≤ 180",
  "outputDesc": "输出最多能观看的演出场数。",
  "examples": [
    {
      "input": "2\n720 120\n840 120",
      "output": "2",
      "explanation": "演出1从720分钟开始持续120分钟到840，演出2从840开始，间隔0分钟<15，但刚好衔接可以都看"
    },
    {
      "input": "3\n720 60\n800 60\n900 60",
      "output": "3",
      "explanation": "三场演出间隔都>=15分钟，可以全部观看"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心+区间调度**问题。\n\n**核心思路：**\n- 按结束时间排序，优先选择结束早的演出\n- 下一场演出开始时间与上一场结束时间间隔>=15分钟才能观看\n\n**算法步骤：**\n1. 读取所有演出，计算结束时间=开始时间+持续时间\n2. 按结束时间升序排序\n3. 贪心选择：若当前演出开始时间-上次结束时间>=15，则观看\n4. 统计可观看的演出数量\n\n**时间复杂度**：O(NlogN)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        \n        // 输入演出场数\n        int n = in.nextInt();\n\n        // 创建一个列表来存储演出时间表\n        List<List<Integer>> schedule = new ArrayList<>();\n        \n        // 循环读取每个演出的开始时间和持续时间，并将其添加到演出时间表中\n        for (int i = 0; i < n; i++) {\n            int startTime = in.nextInt();\n            int endTime = startTime + in.nextInt();\n            schedule.add(List.of(startTime, endTime));\n        }\n        \n        // 将演出时间表按照结束时间进行排序\n        schedule.sort(Comparator.comparingInt(a -> a.get(1)));\n\n        // 获取第一个演出的结束时间和初始化观看的演出场数\n        int firstEndTime = schedule.get(0).get(1);\n        int numShows = 1;\n\n        // 遍历演出时间表中的每个演出时间段\n        for (List<Integer> interval : schedule) {\n            int startTime = interval.get(0);\n            int endTime = interval.get(1);\n\n            // 如果当前演出的开始时间与前一个演出的结束时间间隔大于等于15分钟，则可以观看该演出\n            if (startTime - firstEndTime >= 15) {\n                numShows++;\n                firstEndTime = endTime;\n            }\n        }\n\n        // 输出最多能观看的演出场数\n        System.out.println(numShows);\n    }\n}",
    "python": "import sys\n\n# 输入演出场数\nn = int(input())\n\n# 创建一个列表来存储演出时间表\nschedule = []\n\n# 循环读取每个演出的开始时间和持续时间，并将其添加到演出时间表中\nfor i in range(n):\n    time = input()\n    startTime = int(time.split()[0])\n    endTime = startTime + int(time.split()[1])\n    schedule.append([startTime, endTime])\n\n# 将演出时间表按照结束时间进行排序\nschedule.sort(key=lambda x: x[1])\n\n# 获取第一个演出的结束时间和初始化观看的演出场数\nfirstEndTime = schedule[0][1]\nnumShows = 1\n\n# 遍历演出时间表中的每个演出时间段\nfor interval in schedule:\n    startTime = interval[0]\n    endTime = interval[1]\n\n    # 如果当前演出的开始时间与前一个演出的结束时间间隔大于等于15分钟，则可以观看该演出\n    if startTime - firstEndTime >= 15:\n        numShows += 1\n        firstEndTime = endTime\n\n# 输出最多能观看的演出场数\nprint(numShows)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\nlet n;\n  let schedule = [];\n \n\nrl.on('line', (input) => {\n  if (!n) {\n    n = parseInt(input);\n  } else {\n    let [start, end] = input.split(' ').map(Number);\n    schedule.push([start, start + end]);\n    if (schedule.length === n) {\n          // 将演出时间表按照结束时间进行排序\n      schedule.sort((a, b) => a[1] - b[1]);\n\n      // 获取第一个演出的结束时间和初始化观看的演出场数\n      let firstEndTime = schedule[0][1];\n      let numShows = 1;\n\n      // 遍历演出时间表中的每个演出时间段\n      for (let i = 1; i < n; i++) {\n        const [startTime, endTime] = schedule[i];\n\n        // 如果当前演出的开始时间与前一个演出的结束时间间隔大于等于15分钟，则可以观看该演出\n        if (startTime - firstEndTime >= 15) {\n          numShows++;\n          firstEndTime = endTime;\n        }\n      }\n    console.log(numShows);\n    }\n  }\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n;\n    // 读取演出场次的数量\n    cin >> n;\n\n    // 定义一个二维向量，用于存储每场演出的开始时间和结束时间\n    vector<vector<int>> schedule;\n\n    // 读取每场演出的开始时间和持续时间，并计算结束时间\n    for (int i = 0; i < n; i++) {\n        int startTime, duration;\n        // 读取每场演出的开始时间和持续时间\n        cin >> startTime >> duration;\n        // 计算演出的结束时间\n        int endTime = startTime + duration;\n        // 将开始时间和结束时间存入schedule向量中\n        schedule.push_back({startTime, endTime});\n    }\n\n    // 对所有演出按照结束时间进行排序，确保优先选择结束时间较早的演出\n    sort(schedule.begin(), schedule.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[1] < b[1];\n    });\n\n    // 记录第一场选择的演出的结束时间\n    int firstEndTime = schedule[0][1];\n    // 记录小明可以观看的演出场次，初始为1（选择了第一场）\n    int numShows = 1;\n\n    // 遍历每一场演出，判断能否在当前时间后观看\n    for (const vector<int>& interval : schedule) {\n        int startTime = interval[0];  // 当前演出的开始时间\n        int endTime = interval[1];    // 当前演出的结束时间\n\n        // 如果当前演出的开始时间与上一个观看的演出结束时间之间有至少15分钟的间隔\n        if (startTime - firstEndTime >= 15) {\n            numShows++;  // 小明可以观看这场演出，增加计数\n            firstEndTime = endTime;  // 更新为当前演出的结束时间，作为下次判断的依据\n        }\n    }\n\n    // 输出小明最多可以观看的演出场次\n    cout << numShows << endl;\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 1000\n\n// 定义一个结构体，用于存储每场演出的开始时间和结束时间\ntypedef struct {\n    int startTime;  // 演出的开始时间\n    int endTime;    // 演出的结束时间\n} Show;\n\n// 比较函数，用于qsort对演出按结束时间进行排序\nint compare(const void *a, const void *b) {\n    Show *showA = (Show *)a;\n    Show *showB = (Show *)b;\n    return showA->endTime - showB->endTime;  // 按结束时间升序排列\n}\n\nint main() {\n    int n;\n    // 读取演出场次的数量\n    scanf(\"%d\", &n);\n\n    // 定义一个数组，用于存储每场演出的开始时间和结束时间\n    Show schedule[MAX_N];\n\n    // 读取每场演出的开始时间和持续时间，并计算结束时间\n    for (int i = 0; i < n; i++) {\n        int startTime, duration;\n        // 读取每场演出的开始时间和持续时间\n        scanf(\"%d %d\", &startTime, &duration);\n        // 计算演出的结束时间，并存储在结构体数组中\n        schedule[i].startTime = startTime;\n        schedule[i].endTime = startTime + duration;\n    }\n\n    // 使用qsort函数对所有演出按照结束时间进行排序\n    qsort(schedule, n, sizeof(Show), compare);\n\n    // 记录第一场选择的演出的结束时间\n    int firstEndTime = schedule[0].endTime;\n    // 记录小明可以观看的演出场次，初始为1（选择了第一场）\n    int numShows = 1;\n\n    // 遍历剩下的每一场演出，判断能否在当前时间后观看\n    for (int i = 1; i < n; i++) {\n        int startTime = schedule[i].startTime;  // 当前演出的开始时间\n        int endTime = schedule[i].endTime;      // 当前演出的结束时间\n\n        // 如果当前演出的开始时间与上一个观看的演出结束时间之间有至少15分钟的间隔\n        if (startTime - firstEndTime >= 15) {\n            numShows++;  // 小明可以观看这场演出，增加计数\n            firstEndTime = endTime;  // 更新为当前演出的结束时间，作为下次判断的依据\n        }\n    }\n\n    // 输出小明最多可以观看的演出场次\n    printf(\"%d\\n\", numShows);\n\n    return 0;\n}"
  }
}