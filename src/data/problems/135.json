{
  "id": "135",
  "title": "矩阵匹配",
  "examType": "A",
  "score": 200,
  "description": "从一个 N * M（N ≤ M）的矩阵中选出 N 个数，任意两个数字不能在同一行或同一列，求选出来的 N 个数中第 K 大的数字的最小值是多少。",
  "inputDesc": "输入矩阵要求：1 ≤ K ≤ N ≤ M ≤ 150\n输入格式：\nN M K\nN*M矩阵",
  "outputDesc": "N*M 的矩阵中可以选出 M! / N! 种组合数组，每个组合数组种第 K 大的数中的最小值。无需考虑重复数字，直接取字典排序结果即可。\n注意：结果是第 K 大的数字的最小值\n输入\n输出\nN*M的矩阵中可以选出 M！/ N！种组合数组，每个组合数组种第 K 大的数中的最小值； 上述输入中选出数组组合为： 1,3,6; 1,3,3; 1,4,8; 1,4,3; … 上述输入样例中选出的组合数组有24种，最小数组为1,3,3，则第2大的最小值为3",
  "examples": [
    {
      "input": "3 4 2\n1 5 6 6\n8 3 4 3\n6 8 6 3",
      "output": "3",
      "explanation": "选出3个数不同行不同列，如1,3,3组合，第2大的数最小为3"
    },
    {
      "input": "2 3 1\n1 2 3\n4 5 6",
      "output": "4",
      "explanation": "选2个数，第1大的数最小组合如1,4或2,4或3,4，最小值为4"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**二分答案+二分图匹配**问题。\n\n**核心思路：**\n- 二分答案：枚举第K大数的可能值\n- 验证：能否选出N个数使得至少N-K+1个数≤mid\n- 用二分图匹配验证可行性\n\n**算法步骤：**\n1. 二分枚举第K大数的值mid\n2. 将≤mid的格子作为可选边建立二分图\n3. 求最大匹配数，若≥N-K+1则可行\n4. 找到满足条件的最小mid\n\n**时间复杂度**：O(NM×log(max)×NM)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    static int n, m, k;  // n、m、k 分别表示矩阵的行数、列数和要求的第K大数\n    static int[][] matrix;  // matrix 用于存储输入的矩阵\n    static int[] match;  // match 数组用于存储匹配信息，match[j] = i 表示第j列与第i行匹配\n    static boolean[] vis;  // vis 数组用于标记每一列在当前增广路中是否被访问过\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        n = sc.nextInt();  // 读取行数\n        m = sc.nextInt();  // 读取列数\n        k = sc.nextInt();  // 读取k值\n\n        int min = 1, max = Integer.MIN_VALUE;  // 初始化二分查找的上下界\n        matrix = new int[n][m];  // 初始化矩阵\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                matrix[i][j] = sc.nextInt();  // 读取矩阵元素\n                max = Math.max(max, matrix[i][j]);  // 更新矩阵元素的最大值，作为二分查找的上界\n            }\n        }\n\n        // 二分查找确定第K大的数的最小可能值\n        while (min <= max) {\n            int mid = (min + max) / 2;  // 取中间值\n            if (check(mid)) {\n                max = mid - 1;  // 如果当前中间值满足条件，则尝试寻找更小的值\n            } else {\n                min = mid + 1;  // 如果不满足条件，则尝试寻找更大的值\n            }\n        }\n        System.out.println(min);  // 输出最终结果\n    }\n\n    // 检查当前值是否满足条件\n    public static boolean check(int currentVal) {\n        match = new int[m];  // 初始化匹配数组\n        Arrays.fill(match, -1);  // 将所有列初始化为未匹配状态\n        vis = new boolean[m];  // 初始化访问标记数组\n        int smallerCount = 0;  // 统计满足条件的数量\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(vis, false);  // 每次搜索前重置访问标记\n            if (dfs(i, currentVal)) {\n                smallerCount++;  // 如果找到增广路径，则计数增加\n            }\n        }\n        return smallerCount >= n - k + 1;  // 检查是否有足够的小于等于currentVal的数\n    }\n\n    // 深度优先搜索寻找增广路径\n    public static boolean dfs(int i, int currentVal) {\n        for (int j = 0; j < m; j++) {\n            // 检查列j是否未被访问过且第i行第j列的值小于等于currentVal\n            if (!vis[j] && matrix[i][j] <= currentVal) {\n                vis[j] = true;  // 标记列j为已访问\n                // 如果列j未匹配或者列j的匹配行可以匹配到其他列\n                if (match[j] == -1 || dfs(match[j], currentVal)) {\n                    match[j] = i;  // 将列j与行i匹配\n                    return true;  // 找到增广路径\n                }\n            }\n        }\n        return false;  // 没有找到增广路径\n    }\n}",
    "python": "import sys\n\ndef dfs(i, current_val):\n    \"\"\"\n    深度优先搜索寻找增广路径\n    :param i: 当前正在处理的行索引\n    :param current_val: 当前考虑的值\n    :return: 如果找到增广路径，返回True；否则返回False\n    \"\"\"\n    for j in range(m):\n        # 检查第j列是否未被访问过且第i行第j列的值小于等于current_val\n        if not vis[j] and matrix[i][j] <= current_val:\n            vis[j] = True  # 标记第j列为已访问\n            # 如果第j列未匹配或其匹配的行可以找到其他匹配列\n            if match[j] == -1 or dfs(match[j], current_val):\n                match[j] = i  # 将第j列与第i行匹配\n                return True\n    return False\n\ndef check(current_val):\n    \"\"\"\n    检查当前值是否满足条件\n    :param current_val: 当前考虑的值\n    :return: 如果满足条件，返回True；否则返回False\n    \"\"\"\n    global match, vis\n    match = [-1] * m  # 初始化匹配数组，所有列都标记为未匹配\n    vis = [False] * m  # 初始化访问标记数组\n    smaller_count = 0  # 统计满足条件的数量\n\n    for i in range(n):\n        vis = [False] * m  # 每次搜索前重置访问标记\n        if dfs(i, current_val):\n            smaller_count += 1  # 如果找到增广路径，则计数增加\n\n    return smaller_count >= n - k + 1  # 检查是否有足够的小于等于current_val的数\n\n# 读取输入\nn, m, k = map(int, input().split())  # 读取行数、列数和k值\n\n# 初始化矩阵\nmatrix = []\nfor _ in range(n):\n    matrix.append(list(map(int, input().split())))\n\n# 初始化二分查找的上下界\nmin_val, max_val = 1, -sys.maxsize\n\n# 更新矩阵元素的最大值，作为二分查找的上界\nfor row in matrix:\n    max_val = max(max_val, max(row))\n\n# 二分查找确定第K大的数的最小可能值\nwhile min_val <= max_val:\n    mid = (min_val + max_val) // 2\n    if check(mid):\n        max_val = mid - 1\n    else:\n        min_val = mid + 1\n\n# 输出最终结果\nprint(min_val)",
    "javascript": "",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\nusing namespace std;\n\nint n, m, k;  // n、m、k 分别表示矩阵的行数、列数和要求的第K大数\nvector<vector<int>> matrix;  // matrix 用于存储输入的矩阵\nvector<int> match;  // match 数组用于存储匹配信息，match[j] = i 表示第j列与第i行匹配\nvector<bool> vis;  // vis 数组用于标记每一列在当前增广路中是否被访问过\n\n// 深度优先搜索寻找增广路径\nbool dfs(int i, int currentVal) {\n    for (int j = 0; j < m; j++) {\n        // 检查列j是否未被访问过且第i行第j列的值小于等于currentVal\n        if (!vis[j] && matrix[i][j] <= currentVal) {\n            vis[j] = true;  // 标记列j为已访问\n            // 如果列j未匹配或者列j的匹配行可以匹配到其他列\n            if (match[j] == -1 || dfs(match[j], currentVal)) {\n                match[j] = i;  // 将列j与行i匹配\n                return true;  // 找到增广路径\n            }\n        }\n    }\n    return false;  // 没有找到增广路径\n}\n\n// 检查当前值是否满足条件\nbool check(int currentVal) {\n    match.assign(m, -1);  // 初始化匹配数组\n    vis.assign(m, false);  // 初始化访问标记数组\n    int smallerCount = 0;  // 统计满足条件的数量\n    for (int i = 0; i < n; i++) {\n        fill(vis.begin(), vis.end(), false);  // 每次搜索前重置访问标记\n        if (dfs(i, currentVal)) {\n            smallerCount++;  // 如果找到增广路径，则计数增加\n        }\n    }\n    return smallerCount >= n - k + 1;  // 检查是否有足够的小于等于currentVal的数\n}\n\nint main() {\n    cin >> n >> m >> k;  // 读取行数、列数和k值\n\n    int min = 1, maxT = INT_MIN;  // 初始化二分查找的上下界\n    matrix.assign(n, vector<int>(m));  // 初始化矩阵\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> matrix[i][j];  // 读取矩阵元素\n            maxT = max(maxT, matrix[i][j]);  // 更新矩阵元素的最大值，作为二分查找的上界\n        }\n    }\n\n    // 二分查找确定第K大的数的最小可能值\n    while (min <= maxT) {\n        int mid = (min + maxT) / 2;  // 取中间值\n        if (check(mid)) {\n            maxT = mid - 1;  // 如果当前中间值满足条件，则尝试寻找更小的值\n        } else {\n            min = mid + 1;  // 如果不满足条件，则尝试寻找更大的值\n        }\n    }\n    cout << min << endl;  // 输出最终结果\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_N 200  \n#define MAX_M 200  \n\nint n, m, k;  // n、m、k 分别表示矩阵的行数、列数和要求的第K大数\nint matrix[MAX_N][MAX_M];  // matrix 用于存储输入的矩阵\nint match[MAX_M];  // match 数组用于存储匹配信息\nbool vis[MAX_M];  // vis 数组用于标记每一列在当前增广路中是否被访问过\n\nbool dfs(int i, int current_val) {\n    for (int j = 0; j < m; j++) {\n        if (!vis[j] && matrix[i][j] <= current_val) {\n            vis[j] = true;\n            if (match[j] == -1 || dfs(match[j], current_val)) {\n                match[j] = i;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool check(int current_val) {\n    for (int j = 0; j < m; j++) {\n        match[j] = -1;  // 初始化匹配数组\n    }\n\n    int smaller_count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            vis[j] = false;  // 初始化访问标记数组\n        }\n        if (dfs(i, current_val)) {\n            smaller_count++;\n        }\n    }\n    return smaller_count >= n - k + 1;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &k);  // 读取行数、列数和k值\n\n    // 初始化矩阵\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n\n    // 初始化二分查找的上下界\n    int min_val = 1, max_val = INT_MIN;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (matrix[i][j] > max_val) {\n                max_val = matrix[i][j];  // 更新矩阵元素的最大值\n            }\n        }\n    }\n\n    // 二分查找确定第K大的数的最小可能值\n    while (min_val <= max_val) {\n        int mid = (min_val + max_val) / 2;\n        if (check(mid)) {\n            max_val = mid - 1;\n        } else {\n            min_val = mid + 1;\n        }\n    }\n\n    // 输出最终结果\n    printf(\"%d\\n\", min_val);\n\n    return 0;\n}"
  }
}