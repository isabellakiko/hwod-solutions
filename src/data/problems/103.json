{
  "id": "103",
  "title": "最左侧冗余覆盖子串",
  "examType": "A",
  "score": 100,
  "description": "给定两个字符串s1和s2和正整数K，其中s1长度为n1，s2长度为n2，在s2中选一个子串，满足:\n该子串长度为n1+k该子串中包含s1中全部字母，该子串每个字母出现次数不小于s1中对应的字母，\n我们称s2以长度k冗余覆盖s1，给定s1，s2，k，求最左侧的s2以长度k冗余覆盖s1的子串的首个元素的下标，如果没有返回**-1**。",
  "inputDesc": "输入三行，第一行为s1，第二行为s2，第三行为k，s1和s2只包含小写字母\n0 ≤ len(s1) ≤ 10000000 ≤ len(s2) ≤ 200000000 ≤ k ≤ 1000",
  "outputDesc": "最左侧的s2以长度k冗余覆盖s1的子串首个元素下标，如果没有返回-1",
  "examples": [
    {
      "input": "ab\naabcd\n1",
      "output": "0",
      "explanation": "子串长度=2+1=3，aab和abc都符合条件，aab在左侧，返回下标0"
    },
    {
      "input": "abc\ndfs\n10",
      "output": "-1",
      "explanation": "s2长度不足n1+k=13，无法覆盖s1，返回-1"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**滑动窗口**问题。\n\n**核心思路：**\n- 窗口大小固定为 n1 + k\n- 窗口内字符频次需覆盖s1的所有字符\n- 找最左侧满足条件的窗口起始位置\n\n**算法步骤：**\n1. 统计s1中每个字符的出现次数\n2. 维护固定大小为n1+k的滑动窗口\n3. 窗口内字符计数，判断是否覆盖s1\n4. 返回第一个满足条件的左边界\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s1 = scanner.nextLine();\n        String s2 = scanner.nextLine();\n        int k = Integer.parseInt(scanner.nextLine().trim());\n\n        // 调用查找函数并输出结果\n        System.out.println(findRedundantCover(s1, s2, k));\n    }\n\n    /**\n     * 查找满足条件的子串起始位置\n     * @param s1 字符串 s1\n     * @param s2 字符串 s2\n     * @param k  冗余长度 k\n     * @return 返回满足条件的子串的最左侧起始位置，如果没有返回 -1\n     */\n    public static int findRedundantCover(String s1, String s2, int k) {\n        // 计算 s1 中每个字符的出现次数\n        int[] s1Count = new int[26];\n        for (char c : s1.toCharArray()) {\n            s1Count[c - 'a']++;\n        }\n\n        // 初始化滑动窗口的左右边界、剩余需要匹配的 s1 字符数和窗口内字符计数数组\n        int left = 0, right = 0;\n        int s1CharsLeft = s1.length();\n        int[] windowCount = new int[26];\n\n        // 遍历 s2 字符串\n        while (right < s2.length()) {\n            // 将右边界字符加入窗口计数\n            char rightChar = s2.charAt(right);\n            windowCount[rightChar - 'a']++;\n\n            // 如果窗口中的字符在 s1 中出现过，减少剩余需要匹配的字符数\n            if (windowCount[rightChar - 'a'] <= s1Count[rightChar - 'a']) {\n                s1CharsLeft--;\n            }\n\n            // 如果窗口长度大于 s1 长度 + k，需要移动左边界\n            if (right - left + 1 > s1.length() + k) {\n                char leftChar = s2.charAt(left);\n                // 如果左边界字符在 s1 中出现过，增加剩余需要匹配的字符数\n                if (windowCount[leftChar - 'a'] <= s1Count[leftChar - 'a']) {\n                    s1CharsLeft++;\n                }\n                // 将左边界字符从窗口计数中移除\n                windowCount[leftChar - 'a']--;\n                left++;\n            }\n\n            // 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n            if (s1CharsLeft == 0) {\n                return left;\n            }\n\n            // 移动右边界\n            right++;\n        }\n\n        // 如果遍历完 s2 仍未找到满足条件的子串，返回 -1\n        return -1;\n    }\n}",
    "python": "def find_redundant_cover(s1, s2, k):\n    \"\"\"\n    查找满足条件的子串起始位置\n    :param s1: 字符串 s1\n    :param s2: 字符串 s2\n    :param k: 冗余长度 k\n    :return: 返回满足条件的子串的最左侧起始位置，如果没有返回 -1\n    \"\"\"\n    # 计算 s1 中每个字符的出现次数\n    s1_count = [0] * 26  # 创建一个长度为26的数组，用于记录每个字母的出现次数\n    for c in s1:\n        s1_count[ord(c) - ord('a')] += 1  # 通过字符的ASCII码计算其在数组中的位置并递增计数\n\n    # 初始化滑动窗口的左右边界、剩余需要匹配的 s1 字符数和窗口内字符计数数组\n    left, right = 0, 0  # 滑动窗口的左右边界初始都为0\n    s1_chars_left = len(s1)  # 剩余需要匹配的字符数为 s1 的长度\n    window_count = [0] * 26  # 初始化滑动窗口中每个字母的出现次数数组\n\n    # 开始遍历 s2 字符串\n    while right < len(s2):\n        # 将右边界字符加入窗口计数\n        right_char = s2[right]  # 获取当前右边界字符\n        window_count[ord(right_char) - ord('a')] += 1  # 增加该字符在窗口中的计数\n\n        # 如果该字符在 s1 中存在且匹配的数量不超过 s1 中的数量，减少剩余需要匹配的字符数\n        if window_count[ord(right_char) - ord('a')] <= s1_count[ord(right_char) - ord('a')]:\n            s1_chars_left -= 1\n\n        # 如果窗口的长度大于 s1 长度 + k，移动左边界\n        if right - left + 1 > len(s1) + k:\n            left_char = s2[left]  # 获取当前左边界字符\n            # 如果左边界字符在 s1 中存在且数量不超过 s1 中的数量，增加剩余需要匹配的字符数\n            if window_count[ord(left_char) - ord('a')] <= s1_count[ord(left_char) - ord('a')]:\n                s1_chars_left += 1\n            # 将左边界字符从窗口计数中移除\n            window_count[ord(left_char) - ord('a')] -= 1\n            left += 1  # 左边界右移\n\n        # 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n        if s1_chars_left == 0:\n            return left\n\n        # 移动右边界\n        right += 1\n\n    # 如果遍历完 s2 仍未找到满足条件的子串，返回 -1\n    return -1\n\n   \ns1 = input()   # 读取字符串 s1\ns2 = input()   # 读取字符串 s2\nk = int(input().strip())  # 读取并将字符串转换为整数的 k\n\n# 调用查找函数并输出结果\nprint(find_redundant_cover(s1, s2, k))",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nlet s1, s2, k;\nrl.on('line', (input) => {\n  if (!s1) {\n    s1 = input.trim();\n  } else if (!s2) {\n    s2 = input.trim();\n  } else {\n    k = parseInt(input.trim());\n    console.log(findRedundantCover(s1, s2, k));\n    rl.close();\n  }\n});\n\n/**\n * 查找满足条件的子串起始位置\n * @param {string} s1\n * @param {string} s2\n * @param {number} k\n * @returns {number}\n */\nfunction findRedundantCover(s1, s2, k) {\n  // 计算s1中每个字符的出现次数\n  const s1Count = new Array(26).fill(0);\n  for (const c of s1) {\n    s1Count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n  }\n\n  // 初始化滑动窗口的左右边界、剩余需要匹配的s1字符数和窗口内字符计数数组\n  let left = 0, right = 0, s1CharsLeft = s1.length;\n  const windowCount = new Array(26).fill(0);\n\n  // 遍历s2字符串\n  while (right < s2.length) {\n    // 将右边界字符加入窗口计数\n    const rightChar = s2.charAt(right);\n    windowCount[rightChar.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    // 如果窗口中的字符在s1中出现过，减少剩余需要匹配的字符数\n    if (windowCount[rightChar.charCodeAt(0) - 'a'.charCodeAt(0)] <= s1Count[rightChar.charCodeAt(0) - 'a'.charCodeAt(0)]) {\n      s1CharsLeft--;\n    }\n\n    // 如果窗口长度大于s1长度+k，需要移动左边界\n    if (right - left + 1 > s1.length + k) {\n      const leftChar = s2.charAt(left);\n      // 如果左边界字符在s1中出现过，增加剩余需要匹配的字符数\n      if (windowCount[leftChar.charCodeAt(0) - 'a'.charCodeAt(0)] <= s1Count[leftChar.charCodeAt(0) - 'a'.charCodeAt(0)]) {\n        s1CharsLeft++;\n      }\n      // 将左边界字符从窗口计数中移除\n      windowCount[leftChar.charCodeAt(0) - 'a'.charCodeAt(0)]--;\n      left++;\n    }\n\n    // 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n    if (s1CharsLeft === 0) {\n      return left;\n    }\n\n    // 移动右边界\n    right++;\n  }\n\n  // 如果遍历完s2仍未找到满足条件的子串，返回-1\n  return -1;\n}",
    "cpp": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint findRedundantCover(const string &s1, const string &s2, int k);\n\nint main() {\n    \n    string s1, s2;\n    getline(cin, s1);  // 读取整行字符串 s1\n    getline(cin, s2);  // 读取整行字符串 s2\n    int k;\n    cin >> k;  // 读取整数 k\n\n    // 调用查找函数并输出结果\n    cout << findRedundantCover(s1, s2, k) << endl;\n\n    return 0;\n}\n\nint findRedundantCover(const string &s1, const string &s2, int k) {\n    // 计算 s1 中每个字符的出现次数\n    vector<int> s1Count(26, 0);  // 创建一个长度为26的数组，用于记录每个字母的出现次数\n    for (char c : s1) {\n        s1Count[c - 'a']++;  // 计算每个字符在 s1 中的出现次数\n    }\n\n    // 初始化滑动窗口的左右边界、剩余需要匹配的 s1 字符数和窗口内字符计数数组\n    int left = 0, right = 0;\n    int s1CharsLeft = s1.length();  // 剩余需要匹配的字符数\n    vector<int> windowCount(26, 0);  // 初始化滑动窗口中每个字母的出现次数数组\n\n    // 遍历 s2 字符串\n    while (right < s2.length()) {\n        // 将右边界字符加入窗口计数\n        char rightChar = s2[right];\n        windowCount[rightChar - 'a']++;\n\n        // 如果该字符在 s1 中存在且匹配的数量不超过 s1 中的数量，减少剩余需要匹配的字符数\n        if (windowCount[rightChar - 'a'] <= s1Count[rightChar - 'a']) {\n            s1CharsLeft--;\n        }\n\n        // 如果窗口的长度大于 s1 长度 + k，移动左边界\n        if (right - left + 1 > s1.length() + k) {\n            char leftChar = s2[left];\n            // 如果左边界字符在 s1 中存在且数量不超过 s1 中的数量，增加剩余需要匹配的字符数\n            if (windowCount[leftChar - 'a'] <= s1Count[leftChar - 'a']) {\n                s1CharsLeft++;\n            }\n            // 将左边界字符从窗口计数中移除\n            windowCount[leftChar - 'a']--;\n            left++;\n        }\n\n        // 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n        if (s1CharsLeft == 0) {\n            return left;\n        }\n\n        // 移动右边界\n        right++;\n    }\n\n    // 如果遍历完 s2 仍未找到满足条件的子串，返回 -1\n    return -1;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n\nint findRedundantCover(const char *s1, const char *s2, int k);\n\nint main() {\n     \n    char s1[1000], s2[1000];\n    fgets(s1, 1000, stdin);  // 读取整行字符串 s1\n    fgets(s2, 1000, stdin);  // 读取整行字符串 s2\n    int k;\n    scanf(\"%d\", &k);  // 读取整数 k\n\n    // 去除换行符\n    s1[strcspn(s1, \"\\n\")] = '\\0';\n    s2[strcspn(s2, \"\\n\")] = '\\0';\n\n    // 调用查找函数并输出结果\n    printf(\"%d\\n\", findRedundantCover(s1, s2, k));\n\n    return 0;\n}\n\nint findRedundantCover(const char *s1, const char *s2, int k) {\n    // 计算 s1 中每个字符的出现次数\n    int s1Count[26] = {0};  // 创建一个长度为26的数组，用于记录每个字母的出现次数\n    for (int i = 0; s1[i] != '\\0'; i++) {\n        s1Count[s1[i] - 'a']++;  // 计算每个字符在 s1 中的出现次数\n    }\n\n    // 初始化滑动窗口的左右边界、剩余需要匹配的 s1 字符数和窗口内字符计数数组\n    int left = 0, right = 0;\n    int s1CharsLeft = strlen(s1);  // 剩余需要匹配的字符数\n    int windowCount[26] = {0};  // 初始化滑动窗口中每个字母的出现次数数组\n\n    // 遍历 s2 字符串\n    while (s2[right] != '\\0') {\n        // 将右边界字符加入窗口计数\n        char rightChar = s2[right];\n        windowCount[rightChar - 'a']++;\n\n        // 如果该字符在 s1 中存在且匹配的数量不超过 s1 中的数量，减少剩余需要匹配的字符数\n        if (windowCount[rightChar - 'a'] <= s1Count[rightChar - 'a']) {\n            s1CharsLeft--;\n        }\n\n        // 如果窗口的长度大于 s1 长度 + k，移动左边界\n        if (right - left + 1 > strlen(s1) + k) {\n            char leftChar = s2[left];\n            // 如果左边界字符在 s1 中存在且数量不超过 s1 中的数量，增加剩余需要匹配的字符数\n            if (windowCount[leftChar - 'a'] <= s1Count[leftChar - 'a']) {\n                s1CharsLeft++;\n            }\n            // 将左边界字符从窗口计数中移除\n            windowCount[leftChar - 'a']--;\n            left++;\n        }\n\n        // 如果剩余需要匹配的字符数为0，返回满足条件的子串起始位置\n        if (s1CharsLeft == 0) {\n            return left;\n        }\n\n        // 移动右边界\n        right++;\n    }\n\n    // 如果遍历完 s2 仍未找到满足条件的子串，返回 -1\n    return -1;\n}"
  }
}