{
  "id": "154",
  "title": "数字序列比大小",
  "examType": "A",
  "score": 200,
  "description": "A，B两个人玩一个数字比大小的游戏，在游戏前，两个人会拿到相同长度的两个数字序列，两个数字序列不相同的，且其中的数字是随机的。\nA，B各自从数字序列中挑选出一个数字进行大小比较，赢的人得1分，输的人扣1分，相等则各自的分数不变。 用过的数字需要丢弃。\n求A可能赢B的最大分数。\n",
  "inputDesc": "输入数据的第1个数字表示数字序列的长度N，后面紧跟着两个长度为N的数字序列。\n",
  "outputDesc": "A可能赢B的最大分数\n\n\n输入数据第1个数字表示数字序列长度为3，后面紧跟着两个长度为3的数字序列。\n序列A：4 8 10\n序列B：3 6 4\nA可以赢的最大分数是3。获得该分数的比大小过程可以是：\n1）A：4 B：3\n2）A：8 B：6\n3）A：10 B：4\n\n本题其实就是田忌赛马问题，解析可以参考我的这篇博客：\nPOJ - 2287 Tian Ji -- The Horse Racing_伏城之外的博客-CSDN博客\n",
  "examples": [
    {
      "input": "3\n4 8 10\n3 6 4",
      "output": "3",
      "explanation": "A用4赢3，8赢6，10赢4，全胜得3分"
    },
    {
      "input": "4\n1 3 5 7\n2 4 6 8",
      "output": "-2",
      "explanation": "A每个数都比B对应位置小，最优策略仍输2分"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心算法**问题（田忌赛马）。\n\n**核心思路：**\n- 双指针指向两队的最大最小值\n- 能赢就赢，必输则用最小消耗对方最大\n- 相等时优先用最小对最小或消耗对方最大\n\n**算法步骤：**\n1. 两数组排序\n2. 双指针la,ra指向A的最小最大，lb,rb指向B的最小最大\n3. 若A最大>B最大：A赢，ra--,rb--,得1分\n4. 若A最大<B最大：用A最小消耗B最大，la++,rb--,扣1分\n5. 相等时比较最小值决定策略\n\n**时间复杂度**：O(NlogN)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int n = Integer.parseInt(sc.nextLine());\n    int[] a = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    int[] b = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n    System.out.println(getResult(n, a, b));\n  }\n\n  public static int getResult(int n, int[] a, int[] b) {\n    Arrays.sort(a);\n    Arrays.sort(b);\n\n    int la = 0; // 指向田忌最慢的马\n    int ra = n - 1; // 指向田忌最快的马\n\n    int lb = 0; // 指向齐王最慢的马\n    int rb = n - 1; // 指向齐王最快的马\n\n    int ans = 0; // 记录田忌获得银币数\n\n    while (la <= ra) {\n      if (a[ra] > b[rb]) {\n        // 田忌最快的马 比 齐王最快的马要快, 则直接比\n        ans += 1;\n        ra--;\n        rb--;\n      } else if (a[ra] < b[rb]) {\n        // 田忌最快的马 比 齐王最快的马要慢, 则结果肯定输, 为了保留田忌最快的马, 我们应该用田忌最慢的马去消耗掉齐王最快的马\n        ans -= 1;\n        la++;\n        rb--;\n      } else {\n        // 田忌最快的马 和 齐王最快的 速度相同, 此时如果平局的话，则会让田忌损失最快的马，因此我们应该找到田忌最慢的马, 即田忌必输的马来消耗掉齐王最快的马\n        if (a[la] > b[lb]) {\n          // 如果田忌最慢的马 比 齐王最慢的马 快, 则此时田忌最慢的马不是必输的马\n          ans += 1;\n          la++;\n          lb++;\n        } else {\n          // 如果田忌最慢的马速度 <= 齐王最慢的马速度, 此时应该让田忌最慢的马 去消耗  齐王最快的马\n\n          // 如果齐王最快的马速度 > 田忌最慢的马速度，则田忌失去银币\n          // 如果齐王最快的马速度 == 田忌最慢的马速度，则田忌不失去银币\n          if (b[rb] > a[la]) ans -= 1;\n          la++;\n          rb--;\n        }\n      }\n    }\n\n    return ans;\n  }\n}",
    "python": "# 输入获取\nn = int(input())\na = list(map(int, input().split()))  # 田忌的马速度数组\nb = list(map(int, input().split()))  # 齐王的马速度数组\n\n\n# 算法入口\ndef getResult():\n    a.sort()\n    b.sort()\n\n    la = 0  # 指向田忌最慢的马\n    ra = n - 1  # 指向田忌最快的马\n\n    lb = 0  # 指向齐王最慢的马\n    rb = n - 1  # 指向齐王最快的马\n\n    ans = 0  # 记录田忌获得银币数\n\n    while la <= ra:\n        if a[ra] > b[rb]:\n            #  田忌最快的马 比 齐王最快的马要快, 则直接比\n            ans += 1\n            ra -= 1\n            rb -= 1\n        elif a[ra] < b[rb]:\n            # 田忌最快的马 比 齐王最快的马要慢, 则结果肯定输, 为了保留田忌最快的马, 我们应该用田忌最慢的马去消耗掉齐王最快的马\n            ans -= 1\n            la += 1\n            rb -= 1\n        else:\n            # 田忌最快的马 和 齐王最快的 速度相同, 此时如果平局的话，则会让田忌损失最快的马，因此我们应该找到田忌最慢的马, 即田忌必输的马来消耗掉齐王最快的马\n            if a[la] > b[lb]:\n                # 如果田忌最慢的马 比 齐王最慢的马 快, 则此时田忌最慢的马不是必输的马\n                ans += 1\n                la += 1\n                lb += 1\n            else:\n                # 如果田忌最慢的马速度 <= 齐王最慢的马速度, 此时应该让田忌最慢的马 去消耗  齐王最快的马\n                # 如果齐王最快的马速度 > 田忌最慢的马速度，则田忌失去银币\n                # 如果齐王最快的马速度 == 田忌最慢的马速度，则田忌不失去银币\n                if b[rb] > a[la]:\n                    ans -= 1\n                la += 1\n                rb -= 1\n\n    return ans\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}