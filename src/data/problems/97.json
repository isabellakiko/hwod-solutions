{
  "id": "97",
  "title": "敏感字段加密",
  "examType": "A",
  "score": 100,
  "description": "给定一个由多个命令字组成的命令字符串：\n1、字符串长度小于等于127字节，只包含大小写字母，数字，下划线和偶数个双引号； 2、命令字之间以一个或多个下划线_进行分割； 3、可以通过两个双引号””来标识包含下划线_的命令字或空命令字（仅包含两个双引号的命令字），双引号不会在命令字内部出现；\n请对指定索引的敏感字段进行加密，替换为******（6个*），并删除命令字前后多余的下划线_。\n如果无法找到指定索引的命令字，输出字符串ERROR。",
  "inputDesc": "输入为两行，第一行为命令字索引K（从0开始），第二行为命令字符串S。",
  "outputDesc": "输出处理后的命令字符串，如果无法找到指定索引的命令字，输出字符串ERROR",
  "examples": [
    {
      "input": "1\npassword__a12345678_timeout_100",
      "output": "password_******_timeout_100",
      "explanation": "索引1的命令字是a12345678，替换为******，删除多余下划线。"
    },
    {
      "input": "2\naaa_password_\"a12_45678\"_timeout__100_\"\"_",
      "output": "aaa_password_******_timeout_100_\"\"",
      "explanation": "索引2是双引号包裹的命令字，替换后删除多余下划线。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**字符串解析**问题。\n\n**核心思路：**\n- 解析命令字：下划线分隔，双引号内的下划线不分隔\n- 找到索引K的命令字替换为******\n- 重新用单个下划线连接\n\n**算法步骤：**\n1. 遍历字符串，遇到双引号进入引号模式\n2. 引号模式下遇到第二个双引号结束当前命令字\n3. 非引号模式下遇到下划线分隔命令字\n4. 替换索引K的命令字并重组\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int index = Integer.parseInt(scanner.nextLine()); // 输入命令字索引K\n        String input = scanner.nextLine(); // 输入命令字符串S\n        char[] charArray = input.toCharArray(); // 将命令字符串转换为字符数组\n        String command = \"\"; // 当前正在解析的命令字\n        List<String> commandList = new ArrayList<>(); // 存储解析后的命令字列表\n\n        for (int i = 0; i < charArray.length; i++) {\n            char ch = charArray[i];\n\n            if (ch == '\"' && command.contains(ch + \"\")) { // 如果当前字符为双引号且命令字中已经包含了一个双引号\n                command += '\"'; // 将双引号添加到命令字中\n                commandList.add(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            } else if (!command.contains(\"\\\"\") && ch == '_') { // 如果命令字不包含双引号且当前字符为下划线\n                if (!command.isEmpty()) { // 如果命令字不为空\n                    commandList.add(command); // 将解析完毕的命令字添加到命令字列表中\n                    command = \"\"; // 重置命令字\n                }\n            } else if (i == charArray.length - 1) { // 如果已经到达字符串末尾\n                command += ch; // 将当前字符添加到命令字中\n                commandList.add(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            } else {\n                command += ch; // 将当前字符添加到命令字中\n            }\n        }\n\n        if (index < 0 || index > commandList.size() - 1) { // 如果命令字索引超出范围\n            System.out.println(\"ERROR\");\n        } else {\n            commandList.set(index, \"******\"); // 将指定索引的命令字替换为******\n            StringBuilder result = new StringBuilder();\n\n            for (String item : commandList) {\n                result.append(\"_\").append(item); // 在命令字之前添加下划线\n            }\n\n            result.deleteCharAt(0); // 删除第一个下划线\n            System.out.println(result.toString());\n        }\n    }\n}",
    "python": "import sys\n\nindex = int(input()) # 输入命令字索引K\ninput = input() # 输入命令字符串S\ncharArray = list(input) # 将命令字符串转换为字符数组\ncommand = \"\" # 当前正在解析的命令字\ncommandList = [] # 存储解析后的命令字列表\n\nfor i in range(len(charArray)):\n    ch = charArray[i]\n\n    if ch == '\"' and ch in command: # 如果当前字符为双引号且命令字中已经包含了一个双引号\n        command += '\"' # 将双引号添加到命令字中\n        commandList.append(command) # 将解析完毕的命令字添加到命令字列表中\n        command = \"\" # 重置命令字\n    elif '\"' not in command and ch == '_': # 如果命令字不包含双引号且当前字符为下划线\n        if command: # 如果命令字不为空\n            commandList.append(command) # 将解析完毕的命令字添加到命令字列表中\n            command = \"\" # 重置命令字\n    elif i == len(charArray) - 1: # 如果已经到达字符串末尾\n        command += ch # 将当前字符添加到命令字中\n        commandList.append(command) # 将解析完毕的命令字添加到命令字列表中\n        command = \"\" # 重置命令字\n    else:\n        command += ch # 将当前字符添加到命令字中\n\nif index < 0 or index > len(commandList) - 1: # 如果命令字索引超出范围\n    print(\"ERROR\")\nelse:\n    commandList[index] = \"******\" # 将指定索引的命令字替换为******\n    result = []\n\n    for item in commandList:\n        result.append(\"_\" + item) # 在命令字之前添加下划线\n\n    result = \"\".join(result)\n    result = result[1:] # 删除第一个下划线\n    print(result)",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (index) => {\n    rl.on('line', (input) => {\n        const charArray = input.split(''); // 将命令字符串转换为字符数组\n        let command = \"\"; // 当前正在解析的命令字\n        let commandList = []; // 存储解析后的命令字列表\n\n        for (let i = 0; i < charArray.length; i++) {\n            const ch = charArray[i];\n\n            if (ch === '\"' && command.includes(ch)) { // 如果当前字符为双引号且命令字中已经包含了一个双引号\n                command += '\"'; // 将双引号添加到命令字中\n                commandList.push(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            } else if (!command.includes('\"') && ch === '_') { // 如果命令字不包含双引号且当前字符为下划线\n                if (command !== \"\") { // 如果命令字不为空\n                    commandList.push(command); // 将解析完毕的命令字添加到命令字列表中\n                    command = \"\"; // 重置命令字\n                }\n            } else if (i === charArray.length - 1) { // 如果已经到达字符串末尾\n                command += ch; // 将当前字符添加到命令字中\n                commandList.push(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            } else {\n                command += ch; // 将当前字符添加到命令字中\n            }\n        }\n\n        if (index < 0 || index > commandList.length - 1) { // 如果命令字索引超出范围\n            console.log(\"ERROR\");\n        } else {\n            commandList[index] = \"******\"; // 将指定索引的命令字替换为******\n            let result = \"\";\n\n            for (let i = 0; i < commandList.length; i++) {\n                result += \"_\" + commandList[i]; // 在命令字之前添加下划线\n            }\n\n            result = result.substring(1); // 删除第一个下划线\n            console.log(result);\n        }\n\n        rl.close();\n    });\n});",
    "cpp": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main() {\n    int index;\n    cin >> index; // 输入命令字索引K\n    string input;\n    cin >> input; // 输入命令字符串S\n    vector<char> charArray(input.begin(), input.end()); // 将命令字符串转换为字符数组\n    string command = \"\"; // 当前正在解析的命令字\n    vector<string> commandList; // 存储解析后的命令字列表\n\n    for (int i = 0; i < charArray.size(); i++) {\n        char ch = charArray[i];\n\n        if (ch == '\"' && command.find(ch) != string::npos) { // 如果当前字符为双引号且命令字中已经包含了一个双引号\n            command += '\"'; // 将双引号添加到命令字中\n            commandList.push_back(command); // 将解析完毕的命令字添加到命令字列表中\n            command = \"\"; // 重置命令字\n        } else if (command.find('\"') == string::npos && ch == '_') { // 如果命令字不包含双引号且当前字符为下划线\n            if (!command.empty()) { // 如果命令字不为空\n                commandList.push_back(command); // 将解析完毕的命令字添加到命令字列表中\n                command = \"\"; // 重置命令字\n            }\n        } else if (i == charArray.size() - 1) { // 如果已经到达字符串末尾\n            command += ch; // 将当前字符添加到命令字中\n            commandList.push_back(command); // 将解析完毕的命令字添加到命令字列表中\n            command = \"\"; // 重置命令字\n        } else {\n            command += ch; // 将当前字符添加到命令字中\n        }\n    }\n\n    if (index < 0 || index > commandList.size() - 1) { // 如果命令字索引超出范围\n        cout << \"ERROR\" << endl;\n    } else {\n        commandList[index] = \"******\"; // 将指定索引的命令字替换为******\n        string result = \"\";\n\n        for (string item : commandList) {\n            result += \"_\" + item; // 在命令字之前添加下划线\n        }\n\n        result = result.substr(1); // 删除第一个下划线\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 定义一个宏，用于最大字符串长度\n#define MAX_LEN 128\n\n// 定义一个函数来分割命令字符串\nvoid split_command(char *input, char commandList[][MAX_LEN], int *commandCount) {\n    char command[MAX_LEN] = \"\"; // 当前正在解析的命令字\n    int j = 0; // 用于记录命令字的字符位置\n\n    for (int i = 0; i < strlen(input); i++) {\n        char ch = input[i];\n\n        // 如果当前字符为双引号且命令字中已经包含了一个双引号\n        if (ch == '\"' && strchr(command, '\"') != NULL) {\n            command[j++] = '\"'; // 将双引号添加到命令字中\n            command[j] = '\\0'; // 结束当前命令字字符串\n            strcpy(commandList[*commandCount], command); // 将命令字存储到命令列表中\n            (*commandCount)++; // 增加命令字计数\n            j = 0; // 重置命令字的字符位置\n            command[0] = '\\0'; // 重置命令字\n        }\n        // 如果命令字不包含双引号且当前字符为下划线\n        else if (strchr(command, '\"') == NULL && ch == '_') {\n            if (j > 0) { // 如果命令字不为空\n                command[j] = '\\0'; // 结束当前命令字字符串\n                strcpy(commandList[*commandCount], command); // 将命令字存储到命令列表中\n                (*commandCount)++; // 增加命令字计数\n                j = 0; // 重置命令字的字符位置\n                command[0] = '\\0'; // 重置命令字\n            }\n        }\n        // 如果已经到达字符串末尾\n        else if (i == strlen(input) - 1) {\n            command[j++] = ch; // 将当前字符添加到命令字中\n            command[j] = '\\0'; // 结束当前命令字字符串\n            strcpy(commandList[*commandCount], command); // 将命令字存储到命令列表中\n            (*commandCount)++; // 增加命令字计数\n        }\n        // 其他情况下，将当前字符添加到命令字中\n        else {\n            command[j++] = ch;\n        }\n    }\n}\n\nint main() {\n    int index;\n    char input[MAX_LEN];\n    char commandList[MAX_LEN][MAX_LEN]; // 存储解析后的命令字列表\n    int commandCount = 0; // 记录解析到的命令字数\n\n    // 输入命令字索引K\n    scanf(\"%d\", &index);\n    // 输入命令字符串S\n    scanf(\"%s\", input);\n\n    // 将命令字符串转换为命令列表\n    split_command(input, commandList, &commandCount);\n\n    // 如果命令字索引超出范围\n    if (index < 0 || index >= commandCount) {\n        printf(\"ERROR\\n\");\n    } else {\n        // 将指定索引的命令字替换为******\n        strcpy(commandList[index], \"******\");\n        \n        // 构建结果字符串\n        for (int i = 0; i < commandCount; i++) {\n            if (i > 0) {\n                printf(\"_\"); // 在命令字之间添加下划线\n            }\n            printf(\"%s\", commandList[i]); // 输出命令字\n        }\n        printf(\"\\n\");\n    }\n\n    return 0;\n}"
  }
}