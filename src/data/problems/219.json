{
  "id": "219",
  "title": "竖直四子棋",
  "examType": "B",
  "score": 200,
  "description": "竖直四子棋的棋盘是竖立起来的，双方轮流选择棋盘的一列下子，棋子因重力落到棋盘底部或者其他棋子之上，当一列的棋子放满时，无法再在这列上下子。\n一方的4个棋子横、竖或者斜方向连成一线时获胜。\n现给定一个棋盘和红蓝对弈双方的下子步骤，判断红方或蓝方是否在某一步获胜。\n下面以一个6×5的棋盘图示说明落子过程：\n\n下面给出横、竖和斜方向四子连线的图示：\n\n",
  "inputDesc": "输入为2行，第一行指定棋盘的宽和高，为空格分隔的两个数字；\n第二行依次间隔指定红蓝双方的落子步骤，第1步为红方的落子，第2步为蓝方的落子，第3步为红方的落子，以此类推。\n步骤由空格分隔的一组数字表示，每个数字为落子的列的编号（最左边的列编号为1，往右递增）。用例保证数字均为32位有符号数。\n",
  "outputDesc": "如果落子过程中红方获胜，输出 N,red ；\n如果落子过程中蓝方获胜，输出 N,blue ；\n如果出现非法的落子步骤，输出 N,error。\nN为落子步骤的序号，从1开始。如果双方都没有获胜，输出 0,draw 。\n非法落子步骤有两种，一是列的编号超过棋盘范围，二是在一个已经落满子的列上落子。\nN和单词red、blue、draw、error之间是英文逗号连接。\n\n\n纯逻辑题，我们只需要构造一个矩阵，并按照第二行输入来落子，需要注意的是，当第7个及以后的落子，才可能会产生四连击，因此四连击判断放在step>=7中判断。\n另外，关于四连击的判断，要检查四个方向：\n同时，需要以落子位置为中心，向当前方向两端发散检查。\n\n自测用例\n5 5\n1 2 1 3 1 1 2 4 5 3 3 4 4 2 5 1\n输出：14,blue\n2023.07.31\n考虑到可能存在超过四子连珠的情况，因此isFour函数判断中，对应连续数量判断应该改为>=4更稳妥。\n",
  "examples": [],
  "solution": "",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int[] tmp = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n    int n = tmp[0];\n    int m = tmp[1];\n\n    int[] cols = Arrays.stream(sc.nextLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\n    System.out.println(getResult(n, m, cols));\n  }\n\n  /**\n   * @param n 宽 ，矩阵列数\n   * @param m 高，矩阵行数\n   * @param cols 落子的列的编号\n   */\n  public static String getResult(int n, int m, int[] cols) {\n    int r = m;\n    int c = n;\n\n    // 构造棋盘，注意棋盘长宽都+1了，方便后面棋子获取\n    int[][] matrix = new int[r + 1][c + 1];\n\n    // 这里i对应第几步，由于题目是从第1步开始算，而这里 i 从0开始算，因此最终返回要i+1\n    for (int i = 0; i < cols.length; i++) {\n      // cols[i]代表第 i 步下在第几列\n      if (cols[i] < 1 || cols[i] > c) return i + 1 + \",error\";\n\n      // player落子颜色：1代表红色，2代表蓝色\n      int player = i % 2 == 0 ? 1 : 2;\n\n      // 落子逻辑\n      int x = m;\n      int y = cols[i];\n      while (matrix[x][y] > 0) {\n        x--; // 如果当前列底部有棋子，则需要往上查找\n        if (x < 1) return i + 1 + \",error\"; // 如果当前列已经放满棋子，则报错\n      }\n      matrix[x][y] = player; // 如果当前列底部没有棋子，则可以放入\n\n      // i >= 6，即第七步及之后落子时，才可能产生四连击\n      if (i >= 6 && isFour(x, y, player, matrix, r, c)) {\n        return i + 1 + \",\" + (player == 1 ? \"red\" : \"blue\");\n      }\n    }\n\n    // 双方都没有获胜\n    return \"0,draw\";\n  }\n\n  // 上，左，左上，左下\n  static int[][] offsets = {{-1, 0}, {0, -1}, {-1, -1}, {-1, 1}};\n\n  public static boolean isFour(int x, int y, int player, int[][] matrix, int r, int c) {\n    for (int[] offset : offsets) {\n      int len = 1;\n\n      // 向着某个方向延申判断是否存在相同子\n      int x1 = x, y1 = y;\n      while (true) {\n        x1 += offset[0];\n        y1 += offset[1];\n\n        if (x1 >= 1 && x1 <= r && y1 >= 1 && y1 <= c && matrix[x1][y1] == player) {\n          len++;\n        } else {\n          break;\n        }\n      }\n\n      // 向着上面方向的反方向延申判断是否存在相同子（两个相反方向其实处于一条线上）\n      int x2 = x, y2 = y;\n      while (true) {\n        x2 -= offset[0];\n        y2 -= offset[1];\n\n        if (x2 >= 1 && x2 <= r && y2 >= 1 && y2 <= c && matrix[x2][y2] == player) {\n          len++;\n        } else {\n          break;\n        }\n      }\n\n      // 如果此线可以形成四子连击，则直接返回true\n      if (len >= 4) return true;\n    }\n\n    return false;\n  }\n}",
    "python": "# 输入获取\nc, r = map(int, input().split())\ncols = list(map(int, input().split()))\n\n# 构造棋盘，注意棋盘长宽都+1了，方便后面棋子获取\nmatrix = [[0] * (c + 1) for _ in range(r + 1)]\n# 上，左，左上，左下 偏移量\noffsets = ((-1, 0), (0, -1), (-1, -1), (-1, 1))\n\n\ndef isFour(x, y, player):\n    for offsetX, offsetY in offsets:\n        long = 1\n\n        # 向着某个方向延申判断是否存在相同子\n        x1, y1 = x, y\n        while True:\n            x1 += offsetX\n            y1 += offsetY\n            if r >= x1 >= 1 and c >= y1 >= 1 and matrix[x1][y1] == player:\n                long += 1\n            else:\n                break\n\n        # 向着上面方向的反方向延申判断是否存在相同子（两个相反方向其实处于一条线上）\n        x2, y2 = x, y\n        while True:\n            x2 -= offsetX\n            y2 -= offsetY\n            if r >= x2 >= 1 and c >= y2 >= 1 and matrix[x2][y2] == player:\n                long += 1\n            else:\n                break\n\n        # 如果此线可以形成四子连击，则直接返回true\n        if long >= 4:\n            return True\n\n    return False\n\n\n# 算法入口\ndef getResult():\n    # 这里i对应第几步，由于题目是从第1步开始算，而这里 i 从0开始算，因此最终返回要i+1\n    for i in range(len(cols)):\n        #  cols[i]代表第 i 步下在第几列\n        if cols[i] < 1 or cols[i] > c:\n            return f\"{i + 1},error\"\n\n        # player落子颜色：1代表红色，2代表蓝色\n        player = 1 if i % 2 == 0 else 2\n\n        # 落子逻辑\n        x, y = r, cols[i]\n        while matrix[x][y] > 0:\n            x -= 1  # 如果当前列底部有棋子，则需要往上查找\n            if x < 1:\n                return f\"{i + 1},error\"  # 如果当前列已经放满棋子，则报错\n\n        matrix[x][y] = player  # 如果当前列底部没有棋子，则可以放入\n\n        # i >= 6，即第七步及之后落子时，才可能产生四连击\n        if i >= 6 and isFour(x, y, player):\n            return f\"{i + 1},{'red' if player == 1 else 'blue'}\"\n\n    # 双方都没有获胜\n    return \"0,draw\"\n\n\n# 调用算法\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}