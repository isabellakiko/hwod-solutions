{
  "id": "129",
  "title": "最大相连男生数学生方阵",
  "examType": "A",
  "score": 200,
  "description": "学校组织活动，将学生排成一个矩形方阵。\n请在矩形方阵中找到最大的位置相连的男生数量。\n这个相连位置在一个直线上，方向可以是水平的，垂直的，成对角线的或者呈反对角线的。\n注：学生个数不会超过10000",
  "inputDesc": "输入的第一行为矩阵的行数和列数，接下来的n行为矩阵元素，元素间用”,”分隔。",
  "outputDesc": "输出一个整数，表示矩阵中最长的位置相连的男生个数。",
  "examples": [
    {
      "input": "3,4\nF,M,M,F\nF,M,M,F\nF,F,F,M",
      "output": "3",
      "explanation": "3x4方阵，中间两列有连续3个M（垂直方向），最长连续男生数为3"
    },
    {
      "input": "4,4\nM,F,F,M\nF,M,M,F\nF,M,M,F\nM,F,F,M",
      "output": "4",
      "explanation": "对角线方向有4个连续的M"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**矩阵遍历+四方向搜索**问题。\n\n**核心思路：**\n- 遍历每个M，向四个方向搜索连续M\n- 四个方向：水平、垂直、对角线、反对角线\n- 记录最大连续M数量\n\n**算法步骤：**\n1. 遍历矩阵找到每个M\n2. 从M出发向四个方向延伸\n3. 统计每个方向连续M的数量\n4. 返回所有方向中的最大值\n\n**时间复杂度**：O(N×M×max(N,M))",
  "codes": {
    "java": "import java.util.*;\n\npublic class Main {\n    public static void getMaxConnected(List<List<String>> students, int row, int column, List<Integer> res) {\n        int len = 1; // 初始化连续的M的个数为1\n        int a = 0, b = 0; // 初始化行和列的索引\n        int m = students.size(), n = students.get(0).size(); // 获取方阵的行数和列数\n        if (column < n) {  // 从左往右搜索\n            a = row;\n            b = column;\n            while (b < n - 1 && students.get(a).get(++b).equals(\"M\")) { // 不越界且下一个元素为M\n                len++; // 连续的M的个数加1\n            }\n            res.add(len); // 把连续的M的个数加入结果数组\n            len = 1; // 重新初始化连续的M的个数为1\n        }\n        if (row < m) {  // 从上往下搜索\n            a = row;\n            b = column;\n            while (a < m - 1 && students.get(++a).get(b).equals(\"M\")) { // 不越界且下一个元素为M\n                len++; // 连续的M的个数加1\n            }\n            res.add(len); // 把连续的M的个数加入结果数组\n            len = 1; // 重新初始化连续的M的个数为1\n        }\n        if (row < m && column < n) {  // 对角线搜索\n            a = row;\n            b = column;\n            while ((a < m - 1 && b < n - 1) && students.get(++a).get(++b).equals(\"M\")) { // 不越界且下一个元素为M\n                len++; // 连续的M的个数加1\n            }\n            res.add(len); // 把连续的M的个数加入结果数组\n            len = 1; // 重新初始化连续的M的个数为1\n        }\n        if (row >= 0 && column < n) {  // 从右往左搜索\n            a = row;\n            b = column;\n            while ((a > 0 && b < n - 1) && students.get(--a).get(++b).equals(\"M\")) { // 不越界且下一个元素为M\n                len++; // 连续的M的个数加1\n            }\n            res.add(len); // 把连续的M的个数加入结果数组\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取矩阵大小\n        String[] dimensions = scanner.nextLine().split(\",\");\n        int row = Integer.parseInt(dimensions[0]);\n        int column = Integer.parseInt(dimensions[1]);\n\n        // 初始化方阵\n        List<List<String>> students = new ArrayList<>();\n        for (int i = 0; i < row; i++) {\n            String[] lineElements = scanner.nextLine().split(\",\");\n            students.add(Arrays.asList(lineElements));\n        }\n        List<Integer> max_res = new ArrayList<>(); // 初始化结果数组\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < column; j++) {\n                // 遇到M则开始找\n                if (students.get(i).get(j).equals(\"M\")) { // 如果当前元素为M\n                    getMaxConnected(students, i, j, max_res); // 在四个方向上搜索连续的M\n                }\n            }\n        }\n        Collections.sort(max_res); // 对结果数组排序\n        System.out.println(max_res.get(max_res.size() - 1)); // 输出最大的连续的M的个数\n\n        scanner.close();\n    }\n}\n\nimport java.util.*;\n\npublic class Main {\n    // 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {1, 1}, {-1, 1}};\n\n    public static void getMaxConnected(List<List<String>> students, int row, int column, List<Integer> res) {\n        int m = students.size(), n = students.get(0).size(); // 获取方阵的行数和列数\n\n        for (int[] dir : DIRECTIONS) {  // 遍历每个方向\n            int len = 1; // 初始化连续的M的个数为1\n            int a = row, b = column; // 初始化起始位置\n\n            // 按当前方向搜索\n            while (a + dir[0] >= 0 && a + dir[0] < m && b + dir[1] >= 0 && b + dir[1] < n\n                    && students.get(a + dir[0]).get(b + dir[1]).equals(\"M\")) {\n                a += dir[0]; // 更新行索引\n                b += dir[1]; // 更新列索引\n                len++; // 连续的M的个数加1\n            }\n\n            res.add(len); // 把连续的M的个数加入结果数组\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // 读取矩阵大小\n        String[] dimensions = scanner.nextLine().split(\",\");\n        int row = Integer.parseInt(dimensions[0]);\n        int column = Integer.parseInt(dimensions[1]);\n\n        // 初始化方阵\n        List<List<String>> students = new ArrayList<>();\n        for (int i = 0; i < row; i++) {\n            String[] lineElements = scanner.nextLine().split(\",\");\n            students.add(Arrays.asList(lineElements));\n        }\n\n        List<Integer> max_res = new ArrayList<>(); // 初始化结果数组\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < column; j++) {\n                // 遇到M则开始找\n                if (students.get(i).get(j).equals(\"M\")) { // 如果当前元素为M\n                    getMaxConnected(students, i, j, max_res); // 在四个方向上搜索连续的M\n                }\n            }\n        }\n        Collections.sort(max_res); // 对结果数组排序\n        System.out.println(max_res.get(max_res.size() - 1)); // 输出最大的连续的M的个数\n\n        scanner.close();\n    }\n}",
    "python": "def get_max_connected(students, row, column, res):\n    length = 1  # 初始化连续的M的个数为1\n    a, b = 0, 0  # 初始化行和列的索引\n    m, n = len(students), len(students[0])  # 获取方阵的行数和列数\n\n    if column < n:  # 从左往右搜索\n        a = row\n        b = column\n        while b < n - 1 and students[a][b + 1] == \"M\":  # 不越界且下一个元素为M\n            b += 1\n            length += 1  # 连续的M的个数加1\n        res.append(length)  # 把连续的M的个数加入结果数组\n        length = 1  # 重新初始化连续的M的个数为1\n\n    if row < m:  # 从上往下搜索\n        a = row\n        b = column\n        while a < m - 1 and students[a + 1][b] == \"M\":  # 不越界且下一个元素为M\n            a += 1\n            length += 1  # 连续的M的个数加1\n        res.append(length)  # 把连续的M的个数加入结果数组\n        length = 1  # 重新初始化连续的M的个数为1\n\n    if row < m and column < n:  # 对角线搜索\n        a = row\n        b = column\n        while a < m - 1 and b < n - 1 and students[a + 1][b + 1] == \"M\":  # 不越界且下一个元素为M\n            a += 1\n            b += 1\n            length += 1  # 连续的M的个数加1\n        res.append(length)  # 把连续的M的个数加入结果数组\n        length = 1  # 重新初始化连续的M的个数为1\n\n    if row >= 0 and column < n:  # 从右往左搜索\n        a = row\n        b = column\n        while a > 0 and b < n - 1 and students[a - 1][b + 1] == \"M\":  # 不越界且下一个元素为M\n            a -= 1\n            b += 1\n            length += 1  # 连续的M的个数加1\n        res.append(length)  # 把连续的M的个数加入结果数组\n\n\nif __name__ == \"__main__\":\n    input_str = input().strip()\n    row, column = map(int, input_str.split(\",\"))\n\n    # 初始化方阵\n    students = []\n    for _ in range(row):\n        student_str = input().strip()\n        students.append(student_str.split(\",\"))\n\n    max_res = []  # 初始化结果数组\n    for i in range(row):\n        for j in range(column):\n            if students[i][j] == \"M\":\n                get_max_connected(students, i, j, max_res)  # 在四个方向上搜索连续的M\n\n    max_res.sort(reverse=True)  # 对结果数组排序\n    print(max_res[0])  # 输出最大的连续的M的个数\n\n\n\nimport sys\n\n# 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\nDIRECTIONS = [\n    (0, 1), (1, 0), (1, 1), (-1, 1)\n]\n\ndef getMaxConnected(students, row, column, res):\n    m = len(students)\n    n = len(students[0])\n\n    for dir in DIRECTIONS:\n        len_m = 1  # 初始化连续的M的个数为1\n        a, b = row, column\n\n        # 按当前方向搜索\n        while (0 <= a + dir[0] < m) and (0 <= b + dir[1] < n) and students[a + dir[0]][b + dir[1]] == \"M\":\n            a += dir[0]  # 更新行索引\n            b += dir[1]  # 更新列索引\n            len_m += 1  # 连续的M的个数加1\n\n        res.append(len_m)  # 把连续的M的个数加入结果数组\n\nif __name__ == \"__main__\":\n    input_str = input().strip()\n    row, column = map(int, input_str.split(\",\"))\n\n    # 初始化方阵\n    students = []\n    for _ in range(row):\n        student_str = input().strip()\n        students.append(student_str.split(\",\"))\n\n    max_res = []  # 初始化结果数组\n    for i in range(row):\n        for j in range(column):\n            if students[i][j] == \"M\":\n                getMaxConnected(students, i, j, max_res)  # 在四个方向上搜索连续的M\n\n    max_res.sort(reverse=True)  # 对结果数组排序\n    print(max_res[0])  # 输出最大的连续的M的个数",
    "javascript": "const readline = require('readline');\n\n// 创建一个接口用于从标准输入输出流读取数据\nconst rl = readline.createInterface({\n  input: process.stdin,  // 输入流为标准输入\n  output: process.stdout // 输出流为标准输出\n});\n\n// 定义一个函数，用于查找从某个点开始的最大连续的'M'数量\nfunction getMaxConnected(students, row, column, res) {\n  let len = 1; // 初始化长度为1（至少包含自身）\n  let a = 0, b = 0; // a和b用于遍历学生方阵\n  const m = students.length, n = students[0].length; // 获取方阵的行数m和列数n\n  \n  // 水平检查：从指定的列位置(column)向右遍历，直到非\"M\"或到达边界\n  if (column < n) {\n    a = row;\n    b = column;\n    while (b < n - 1 && students[a][++b] === \"M\") {\n      len++; // 如果找到\"M\"，长度加1\n    }\n    res.push(len); // 将找到的长度添加到结果数组中\n    len = 1; // 重置长度为1，用于下一次方向检查\n  }\n\n  // 垂直检查：从指定的行位置(row)向下遍历，直到非\"M\"或到达边界\n  if (row < m) {\n    a = row;\n    b = column;\n    while (a < m - 1 && students[++a][b] === \"M\") {\n      len++; // 如果找到\"M\"，长度加1\n    }\n    res.push(len); // 将找到的长度添加到结果数组中\n    len = 1; // 重置长度为1\n  }\n\n  // 对角线检查（左上到右下）：从指定的位置向右下方遍历，直到非\"M\"或到达边界\n  if (row < m && column < n) {\n    a = row;\n    b = column;\n    while ((a < m - 1 && b < n - 1) && students[++a][++b] === \"M\") {\n      len++; // 如果找到\"M\"，长度加1\n    }\n    res.push(len); // 将找到的长度添加到结果数组中\n    len = 1; // 重置长度为1\n  }\n\n  // 反对角线检查（左下到右上）：从指定的位置向右上方遍历，直到非\"M\"或到达边界\n  if (row >= 0 && column < n) {\n    a = row;\n    b = column;\n    while ((a > 0 && b < n - 1) && students[--a][++b] === \"M\") {\n      len++; // 如果找到\"M\"，长度加1\n    }\n    res.push(len); // 将找到的长度添加到结果数组中\n  }\n}\n\n// 监听标准输入的数据，当有输入时触发\nrl.on('line', (input) => {\n  // 解析第一行输入，获取方阵的行数和列数\n  const [row, column] = input.split(\",\").map(Number);\n  const students = []; // 初始化一个二维数组用于存储学生数据\n  \n  // 监听每一行的学生数据输入\n  rl.on('line', (student_str) => {\n    const temp = student_str.split(\",\"); // 将输入按逗号分隔，得到一行学生数据\n    students.push(temp); // 将这一行数据加入students数组\n    \n    // 当读取到的行数等于预期的行数时，开始处理数据\n    if (students.length === row) {\n      let max_res = []; // 初始化结果数组，用于存储每次搜索到的最大长度\n      // 遍历整个方阵\n      for (let i = 0; i < row; i++) {\n        for (let j = 0; j < column; j++) {\n          // 如果当前点是\"M\"，则调用getMaxConnected函数查找\n          if (students[i][j] === \"M\") {\n            getMaxConnected(students, i, j, max_res);\n          }\n        }\n      }\n      // 对找到的所有长度排序，取最大值并输出\n      max_res.sort((a, b) => b - a);\n      console.log(max_res[0]);\n      rl.close(); // 关闭读取接口\n    }\n  });\n});\n\n\nconst readline = require('readline');\n\n// 创建接口以读取输入\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\n// 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\nconst DIRECTIONS = [\n    [0, 1], [1, 0], [1, 1], [-1, 1]\n];\n\nfunction getMaxConnected(students, row, column, res) {\n    const m = students.length;\n    const n = students[0].length;\n\n    for (const dir of DIRECTIONS) {\n        let len = 1; // 初始化连续的M的个数为1\n        let a = row, b = column;\n\n        // 按当前方向搜索\n        while (a + dir[0] >= 0 && a + dir[0] < m && b + dir[1] >= 0 && b + dir[1] < n\n                && students[a + dir[0]][b + dir[1]] === \"M\") {\n            a += dir[0]; // 更新行索引\n            b += dir[1]; // 更新列索引\n            len++; // 连续的M的个数加1\n        }\n\n        res.push(len); // 把连续的M的个数加入结果数组\n    }\n}\n\nrl.on('line', (input) => {\n    const [row, column] = input.split(\",\").map(Number);\n    const students = [];\n\n    rl.on('line', (student_str) => {\n        const temp = student_str.split(\",\");\n        students.push(temp);\n\n        if (students.length === row) {\n            let max_res = [];\n\n            for (let i = 0; i < row; i++) {\n                for (let j = 0; j < column; j++) {\n                    if (students[i][j] === \"M\") {\n                        getMaxConnected(students, i, j, max_res);\n                    }\n                }\n            }\n\n            max_res.sort((a, b) => b - a);\n            console.log(max_res[0]);\n            rl.close();\n        }\n    });\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n \nvoid getMaxConnected(vector<vector<string>>& students, int row, int column, vector<int>& res) {\n    int len = 1; // 初始化连续的M的个数为1\n    int a = 0, b = 0; // 初始化行和列的索引\n    int m = students.size(), n = students[0].size(); // 获取方阵的行数和列数\n    if (column < n) {  // 从左往右搜索\n        a = row;\n        b = column;\n        while (b < n - 1 && students[a][++b] == \"M\") { // 不越界且下一个元素为M\n            len++; // 连续的M的个数加1\n        }\n        res.push_back(len); // 把连续的M的个数加入结果数组\n        len = 1; // 重新初始化连续的M的个数为1\n    }\n    if (row < m) {  // 从上往下搜索\n        a = row;\n        b = column;\n        while (a < m - 1 && students[++a][b] == \"M\") { // 不越界且下一个元素为M\n            len++; // 连续的M的个数加1\n        }\n        res.push_back(len); // 把连续的M的个数加入结果数组\n        len = 1; // 重新初始化连续的M的个数为1\n    }\n    if (row < m && column < n) {  // 对角线搜索\n        a = row;\n        b = column;\n        while ((a < m - 1 && b < n - 1) && students[++a][++b] == \"M\") { // 不越界且下一个元素为M\n            len++; // 连续的M的个数加1\n        }\n        res.push_back(len); // 把连续的M的个数加入结果数组\n        len = 1; // 重新初始化连续的M的个数为1\n    }\n    if (row >= 0 && column < n) {  // 从右往左搜索\n        a = row;\n        b = column;\n        while ((a > 0 && b < n - 1) && students[--a][++b] == \"M\") { // 不越界且下一个元素为M\n            len++; // 连续的M的个数加1\n        }\n        res.push_back(len); // 把连续的M的个数加入结果数组\n    }\n}\n \nint main() {\n    string input_str;\n    getline(cin, input_str);\n\n    // 解析行数和列数\n    stringstream ss(input_str);\n    string temp;\n    getline(ss, temp, ',');\n    int row = stoi(temp);\n    getline(ss, temp);\n    int column = stoi(temp);\n\n    // 初始化方阵\n    vector<vector<string>> students(row, vector<string>(column));\n    for (int i = 0; i < row; ++i) {\n        getline(cin, input_str);\n        stringstream ss(input_str);\n        for (int j = 0; j < column; ++j) {\n            getline(ss, students[i][j], ',');\n        }\n    }\n\n    \n    vector<int> max_res; // 初始化结果数组\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < column; j++) {\n            //遇到M则开始找\n            if (students[i][j] == \"M\") { // 如果当前元素为M\n                getMaxConnected(students, i, j, max_res); // 在四个方向上搜索连续的M\n            }\n        }\n    }\n    sort(max_res.begin(), max_res.end()); // 对结果数组排序\n    cout << max_res[max_res.size()-1]; // 输出最大的连续的M的个数\n    \n    return 0;\n}\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\n// 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\nconst vector<vector<int>> DIRECTIONS = {{0, 1}, {1, 0}, {1, 1}, {-1, 1}};\n\nvoid getMaxConnected(const vector<vector<string>>& students, int row, int column, vector<int>& res) {\n    int m = students.size();\n    int n = students[0].size();\n\n    for (const auto& dir : DIRECTIONS) {\n        int len = 1; // 初始化连续的M的个数为1\n        int a = row, b = column;\n\n        // 按当前方向搜索\n        while (a + dir[0] >= 0 && a + dir[0] < m && b + dir[1] >= 0 && b + dir[1] < n\n                && students[a + dir[0]][b + dir[1]] == \"M\") {\n            a += dir[0]; // 更新行索引\n            b += dir[1]; // 更新列索引\n            len++; // 连续的M的个数加1\n        }\n\n        res.push_back(len); // 把连续的M的个数加入结果数组\n    }\n}\n\nint main() {\n    string input_str;\n    getline(cin, input_str);\n\n    // 解析行数和列数\n    stringstream ss(input_str);\n    string temp;\n    getline(ss, temp, ',');\n    int row = stoi(temp);\n    getline(ss, temp);\n    int column = stoi(temp);\n\n    // 初始化方阵\n    vector<vector<string>> students(row, vector<string>(column));\n    for (int i = 0; i < row; ++i) {\n        getline(cin, input_str);\n        stringstream ss(input_str);\n        for (int j = 0; j < column; ++j) {\n            getline(ss, students[i][j], ',');\n        }\n    }\n\n    vector<int> max_res; // 初始化结果数组\n    for (int i = 0; i < row; i++) {\n        for (int j = 0; j < column; j++) {\n            if (students[i][j] == \"M\") {\n                getMaxConnected(students, i, j, max_res); // 在四个方向上搜索连续的M\n            }\n        }\n    }\n\n    sort(max_res.begin(), max_res.end(), greater<int>()); // 对结果数组排序\n    cout << max_res[0] << endl; // 输出最大的连续的M的个数\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int n, m; // 定义矩阵的行数和列数\n    scanf(\"%d,%d\\n\", &n, &m); // 读取矩阵的行数和列数\n\n    char students[n][m]; // 定义字符矩阵以存储输入\n    for (int i = 0; i < n; i++) { // 遍历每一行\n        for (int j = 0; j < m; j++) { // 遍历每一列\n            scanf(\"%c\", &students[i][j]); // 读取字符并存入矩阵\n            getchar(); // 吃掉换行符或逗号\n        }\n    }\n\n    int max_res[n * m]; // 用于存储每次搜索到的连续M的个数\n    int res_size = 0; // 记录结果数组的实际大小\n\n    // 遍历整个矩阵，查找连续的M\n    for (int i = 0; i < n; i++) { // 遍历行\n        for (int j = 0; j < m; j++) { // 遍历列\n            if (students[i][j] == 'M') { // 如果当前字符是'M'\n                int len = 1; // 初始化连续M的长度为1\n                int a = 0, b = 0; // 初始化行和列索引\n\n                // 从左往右搜索\n                if (j < m) {\n                    a = i;\n                    b = j;\n                    while (b < m - 1 && students[a][++b] == 'M') { // 不越界且下一个元素为M\n                        len++; // 连续的M的个数加1\n                    }\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                    len = 1; // 重置长度为1\n                }\n\n                // 从上往下搜索\n                if (i < n) {\n                    a = i;\n                    b = j;\n                    while (a < n - 1 && students[++a][b] == 'M') { // 不越界且下一个元素为M\n                        len++; // 连续的M的个数加1\n                    }\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                    len = 1; // 重置长度为1\n                }\n\n                // 对角线搜索（左上到右下）\n                if (i < n && j < m) {\n                    a = i;\n                    b = j;\n                    while (a < n - 1 && b < m - 1 && students[++a][++b] == 'M') { // 不越界且下一个元素为M\n                        len++; // 连续的M的个数加1\n                    }\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                    len = 1; // 重置长度为1\n                }\n\n                // 对角线搜索（左下到右上）\n                if (i >= 0 && j < m) {\n                    a = i;\n                    b = j;\n                    while (a > 0 && b < m - 1 && students[--a][++b] == 'M') { // 不越界且下一个元素为M\n                        len++; // 连续的M的个数加1\n                    }\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                }\n            }\n        }\n    }\n\n    // 对结果数组进行排序，找到最大的连续M的个数\n    int max = max_res[0];\n    for (int i = 1; i < res_size; i++) {\n        if (max_res[i] > max) {\n            max = max_res[i];\n        }\n    }\n\n    // 输出最大的连续M的个数\n    printf(\"%d\\n\", max);\n\n    return 0;\n}\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n// 定义四个方向的增量，分别表示：水平、垂直、对角线、反对角线\nconst int DIRECTIONS[4][2] = {{0, 1}, {1, 0}, {1, 1}, {-1, 1}};\n\nint main() {\n    int n, m; // 定义矩阵的行数和列数\n    scanf(\"%d,%d\\n\", &n, &m); // 读取矩阵的行数和列数\n\n    char students[n][m]; // 定义字符矩阵以存储输入\n    for (int i = 0; i < n; i++) { // 遍历每一行\n        for (int j = 0; j < m; j++) { // 遍历每一列\n            scanf(\"%c\", &students[i][j]); // 读取字符并存入矩阵\n            getchar(); // 吃掉换行符或逗号\n        }\n    }\n\n    int max_res[n * m]; // 用于存储每次搜索到的连续M的个数\n    int res_size = 0; // 记录结果数组的实际大小\n\n    // 遍历整个矩阵，查找连续的M\n    for (int i = 0; i < n; i++) { // 遍历行\n        for (int j = 0; j < m; j++) { // 遍历列\n            if (students[i][j] == 'M') { // 如果当前字符是'M'\n                // 在四个方向上搜索\n                for (int d = 0; d < 4; d++) {\n                    int len = 1; // 初始化连续M的长度为1\n                    int a = i, b = j; // 初始化当前的位置\n\n                    // 按当前方向搜索连续的M\n                    while (a + DIRECTIONS[d][0] >= 0 && a + DIRECTIONS[d][0] < n &&\n                           b + DIRECTIONS[d][1] >= 0 && b + DIRECTIONS[d][1] < m &&\n                           students[a + DIRECTIONS[d][0]][b + DIRECTIONS[d][1]] == 'M') {\n                        a += DIRECTIONS[d][0]; // 更新行索引\n                        b += DIRECTIONS[d][1]; // 更新列索引\n                        len++; // 连续的M的个数加1\n                    }\n\n                    max_res[res_size++] = len; // 把找到的连续M的个数存入结果数组\n                }\n            }\n        }\n    }\n\n    // 对结果数组进行排序，找到最大的连续M的个数\n    int max = max_res[0];\n    for (int i = 1; i < res_size; i++) {\n        if (max_res[i] > max) {\n            max = max_res[i];\n        }\n    }\n\n    // 输出最大的连续M的个数\n    printf(\"%d\\n\", max);\n\n    return 0;\n}"
  }
}