{
  "id": "220",
  "title": "计算误码率",
  "examType": "B",
  "score": 200,
  "description": "误码率是最常用的数据通信传输质量指标。它可以理解为“在多少位数据中出现一位差错”。\n移动通信网络中的误码率主要是指比特误码率，其计算公式如下: 比特误码率=错误比特数/传输总比特数，\n为了简单，我们使用字符串来标识通信的信息，一个字符错误了，就认为出现了一个误码\n输入一个标准的字符串，和一个传输后的字符串，计算误码率\n字符串会被压缩， 例:“2A3B4D5X1Z”表示\"AABBBDDDDXXXXXZ\" 用例会保证两个输入字符串解压后长度一致，解压前的长度不一定一致\n每个生成后的字符串长度<100000000。\n",
  "inputDesc": "两行，分别为两种字符串的压缩形式。\n每行字符串 (压缩后的) 长度<100000\n",
  "outputDesc": "一行，错误的字等数量/展开后的总长度\n\n注意：展开后的字符串不含数字\n\n\n本题最简单的做法就是将压缩字符串解压，然后利用一次for循环，对比两个等长的压缩字符串，看有多少个位置的字符不相同。\n但是本题解压后的字符串，最大长度为1 0000 0000，这个数量级对于O(n)时间复杂度来说也会超时。\n另外，解压后的字符串，内存会占到 1 0000 0000 * 1 byte ≈ 96M, 两个字符串就是将近200M，这种方案在内存上也是不友好的。\n\n因此，我们不应该优先考虑上面方案，而是应该考虑基于压缩字符串找不同字符数量。\n\n我的解题思路如下：\n定义两个变量diff和same，分别用于记录输入的两个字符串中不同字符的数量，以及相同字符的数量。\n以用例1举例：\n\n我们可以比较s1,s2的头部压缩字符串，其中，\n压缩字符串由两部分组成：压缩次数num + 压缩字符c\n当前s1,s2的头部压缩字符串是不等长的，因此我们应该取二者最小长度作为比对长度，即\ncompareCount = min(num1, num2)\n之后，继续检查num1, num2的大小关系，如果二者不等的话：\n然后，s1，s2变为了\n\n然后继续，按照上面逻辑处理，直到s1或s2为空。\n\n当然，为了避免频繁的字符串操作，我们可以将s1,s2解析为灵活度更高的链表，链表节点元素即为压缩字符串转化的对象，类似于下面这种\n{ num: 3, c: 'A' }\n",
  "examples": [],
  "solution": "",
  "codes": {
    "java": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  static class ZipStr {\n    int num;\n    char c;\n\n    public ZipStr(int num, char c) {\n      this.num = num;\n      this.c = c;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    String s1 = sc.nextLine();\n    String s2 = sc.nextLine();\n\n    System.out.println(getResult(s1, s2));\n  }\n\n  public static String getResult(String s1, String s2) {\n    LinkedList<ZipStr> link1 = getZipStrLink(s1);\n    LinkedList<ZipStr> link2 = getZipStrLink(s2);\n\n    int diff = 0;\n    int same = 0;\n\n    while (link1.size() > 0) {\n      ZipStr zipStr1 = link1.removeFirst();\n      ZipStr zipStr2 = link2.removeFirst();\n\n      int compareCount = Math.min(zipStr1.num, zipStr2.num);\n\n      if (zipStr1.c != zipStr2.c) {\n        diff += compareCount;\n      } else {\n        same += compareCount;\n      }\n\n      if (zipStr1.num > compareCount) {\n        zipStr1.num -= compareCount;\n        link1.addFirst(zipStr1);\n        continue;\n      }\n\n      if (zipStr2.num > compareCount) {\n        zipStr2.num -= compareCount;\n        link2.addFirst(zipStr2);\n      }\n    }\n\n    return diff + \"/\" + (diff + same);\n  }\n\n  public static LinkedList<ZipStr> getZipStrLink(String s) {\n    LinkedList<ZipStr> link = new LinkedList<>();\n\n    StringBuilder num = new StringBuilder();\n\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n\n      if (c >= '0' && c <= '9') {\n        num.append(c);\n      } else {\n        link.add(new ZipStr(Integer.parseInt(num.toString()), c));\n        num = new StringBuilder();\n      }\n    }\n\n    return link;\n  }\n}",
    "python": "# 输入获取\ns1 = input()\ns2 = input()\n\n\ndef getZipStrLink(s):\n    link = []\n\n    num = []\n\n    for i in range(len(s)):\n        c = s[i]\n\n        if c.isdigit():\n            num.append(c)\n        else:\n            link.append([int(\"\".join(num)), c])\n            num.clear()\n\n    return link\n\n\n# 算法入口\ndef getResult():\n    link1 = getZipStrLink(s1)\n    link2 = getZipStrLink(s2)\n\n    diff = 0\n    same = 0\n\n    while len(link1) > 0:\n        num1, c1 = link1.pop(0)\n        num2, c2 = link2.pop(0)\n\n        compareCount = min(num1, num2)\n\n        if c1 != c2:\n            diff += compareCount\n        else:\n            same += compareCount\n\n        if num1 > num2:\n            link1.insert(0, [num1 - num2, c1])\n        elif num1 < num2:\n            link2.insert(0, [num2 - num1, c2])\n\n    return f\"{diff}/{diff + same}\"\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "",
    "cpp": "",
    "c": ""
  }
}