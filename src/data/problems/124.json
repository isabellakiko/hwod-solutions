{
  "id": "124",
  "title": "打印任务排序",
  "examType": "A",
  "score": 200,
  "description": "某个打印机根据打印队列执行打印任务。打印任务分为九个优先级，分别用数字1-9表示，数字越大优先级越高。打印机每次从队列头部取出第一个任务A，\n然后检查队列余下任务中有没有比A优先级更高的任务，如果有比A优先级高的任务，则将任务A放到队列尾部，否则就执行任务A的打印。\n请编写一个程序，根据输入的打印队列，输出实际的打印顺序。",
  "inputDesc": "输入一行，为每个任务的优先级，优先级之间用逗号隔开，优先级取值范围是1~9。",
  "outputDesc": "输出一行，为每个任务的打印顺序，打印顺序从0开始，用逗号隔开",
  "examples": [
    {
      "input": "9,3,5",
      "output": "0,2,1",
      "explanation": "9最高先打印(序号0)，然后5(序号1)，最后3(序号2)"
    },
    {
      "input": "1,2,2",
      "output": "2,0,1",
      "explanation": "1被移到队尾，先打印两个2(序号0,1)，最后打印1(序号2)"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**队列模拟**问题。\n\n**核心思路：**\n- 模拟打印机处理过程\n- 队首任务若非最高优先级则移到队尾\n- 记录每个任务的实际打印顺序\n\n**简化方法：**\n- 按优先级降序排序（保持稳定排序）\n- 排序后的位置即为打印顺序\n- 原位置映射到新位置\n\n**时间复杂度**：O(N²) 或 O(NlogN)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n \n        String input = scanner.nextLine();\n        \n        // 将输入的字符串按逗号分隔，转换为字符串数组\n        String[] priorityListString = input.split(\",\");\n        \n        // 将字符串数组转换为整型数组，存储每个任务的优先级\n        int[] priorityList = new int[priorityListString.length];\n        for (int i = 0; i < priorityListString.length; i++) {\n            priorityList[i] = Integer.parseInt(priorityListString[i]);\n        }\n        \n        // 创建一个列表，存储任务的初始索引和优先级\n        List<int[]> taskList = new ArrayList<>();\n        for (int i = 0; i < priorityList.length; i++) {\n            taskList.add(new int[]{i, priorityList[i]});  // 任务格式为 {索引, 优先级}\n        }\n        \n        // 按照优先级从大到小排序任务，优先级高的任务在前面\n        taskList.sort(Comparator.comparingInt(x -> -x[1]));\n        \n        // currentTask 变量用于记录当前处理的任务序号\n        int currentTask = 0;\n        List<Integer> printOrder = new ArrayList<>();\n        \n        // 按任务顺序检查并记录每个任务的打印顺序\n        while (currentTask < taskList.size()) {\n            for (int i = 0; i < taskList.size(); i++) {\n                if (taskList.get(i)[0] == currentTask) {  // 如果找到任务的原始索引等于当前处理的任务\n                    printOrder.add(i);  // 将任务在排序后的位置记录为打印顺序\n                }\n            }\n            currentTask++;  // 处理下一个任务\n        }\n        \n        // 构建输出字符串，将每个打印顺序用逗号隔开输出\n        String output = \"\";\n        for (int i = 0; i < printOrder.size(); i++) {\n            output += printOrder.get(i);\n            if (i < printOrder.size() - 1) {\n                output += \",\";\n            }\n        }\n        \n        // 输出最终的打印顺序\n        System.out.println(output);\n    }\n}",
    "python": "priority_list = list(map(int, input().split(',')))\n\n# 创建任务列表，每个任务用 (原始索引, 优先级) 表示\ntask_list = [(i, priority_list[i]) for i in range(len(priority_list))]\n\n# 按照任务的优先级从大到小排序，优先级高的排在前面\ntask_list.sort(key=lambda x: -x[1])\n\n# 初始化当前任务索引，记录打印顺序\ncurrent_task = 0\nprint_order = []\n\n# 遍历任务列表，按照当前任务的原始索引找到其在排序后的位置\nwhile current_task < len(task_list):\n    for i in range(len(task_list)):\n        if task_list[i][0] == current_task:  # 如果找到原始索引等于当前任务\n            print_order.append(i)  # 记录排序后的任务位置\n    current_task += 1  # 处理下一个任务\n\n# 将打印顺序列表转换为逗号分隔的字符串输出\nprint(','.join(map(str, print_order)))",
    "javascript": "const readline = require('readline');\n\n \nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\n \nrl.on('line', (input) => {\n  // 将输入的字符串按逗号分隔并转换为数字列表\n  const priority_list = input.split(',').map(Number);\n\n  // 创建任务列表，包含任务的原始索引和优先级\n  const task_list = priority_list.map((priority, index) => [index, priority]);\n\n  // 按照优先级从高到低排序任务\n  task_list.sort((a, b) => b[1] - a[1]);\n\n  let current_task = 0;\n  const print_order = [];\n\n  // 遍历任务列表，按照原始顺序查找任务的打印顺序\n  while (current_task < task_list.length) {\n    for (let i = 0; i < task_list.length; i++) {\n      if (task_list[i][0] === current_task) {  // 找到原始索引为当前任务的\n        print_order.push(i);  // 记录其在排序后的位置\n      }\n    }\n    current_task++;  // 处理下一个任务\n  }\n\n  // 打印最终的打印顺序，使用逗号分隔\n  console.log(print_order.join(','));\n\n  // 关闭输入接口\n  rl.close()\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    string input;\n    getline(cin, input);  // 读取用户输入的任务优先级字符串\n    \n    vector<int> priority_list;  // 用于存储任务优先级的列表\n    size_t pos = 0;\n    string token;\n\n    // 将输入的字符串按照逗号分隔，依次存入 priority_list 中\n    while ((pos = input.find(',')) != string::npos) {\n        token = input.substr(0, pos);\n        priority_list.push_back(stoi(token));  // 转换为整数并存入列表\n        input.erase(0, pos + 1);\n    }\n    priority_list.push_back(stoi(input));  // 最后一个任务的优先级加入列表\n    \n    // 创建任务列表，包含任务的原始索引和优先级\n    vector<pair<int, int>> task_list;\n    for (int i = 0; i < priority_list.size(); i++) {\n        task_list.push_back(make_pair(i, priority_list[i]));\n    }\n\n    // 按优先级从大到小排序任务列表\n    sort(task_list.begin(), task_list.end(), [](pair<int, int> a, pair<int, int> b) {\n        return a.second > b.second;\n    });\n    \n    int current_task = 0;  // 当前要处理的任务索引\n    vector<int> print_order;  // 存储打印顺序\n\n    // 查找排序后每个任务的打印顺序\n    while (current_task < task_list.size()) {\n        for (int i = 0; i < task_list.size(); i++) {\n            if (task_list[i].first == current_task) {  // 找到原始索引为当前任务的\n                print_order.push_back(i);  // 记录排序后的位置\n            }\n        }\n        current_task++;  // 处理下一个任务\n    }\n    \n \n    for (int i = 0; i < print_order.size(); i++) {\n        cout << print_order[i];\n        if (i != print_order.size() - 1) {\n            cout << \",\";\n        }\n    }\n    \n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// 比较函数，用于按照优先级从大到小排序\nint compare(const void *a, const void *b) {\n    // 将参数强制转换为指向整数数组的指针\n    int *taskA = *(int **)a;\n    int *taskB = *(int **)b;\n    return taskB[1] - taskA[1];  // 按照优先级从大到小排序\n}\n\nint main() {\n    char input[256];\n    \n \n    fgets(input, sizeof(input), stdin);\n\n    // 去除输入中的换行符\n    input[strcspn(input, \"\\n\")] = '\\0';\n\n    // 按照逗号分割输入字符串，计算优先级个数\n    char *token = strtok(input, \",\");\n    int count = 0;\n    int *priorityList = NULL;\n\n    // 分割并转换为整数，存储到priorityList数组中\n    while (token != NULL) {\n        priorityList = realloc(priorityList, sizeof(int) * (count + 1));\n        priorityList[count] = atoi(token);  // 将字符串转换为整数\n        count++;\n        token = strtok(NULL, \",\");\n    }\n\n    // 创建一个二维数组，存储每个任务的初始索引和优先级\n    int **taskList = (int **)malloc(count * sizeof(int *));\n    for (int i = 0; i < count; i++) {\n        taskList[i] = (int *)malloc(2 * sizeof(int));\n        taskList[i][0] = i;             // 存储任务的初始索引\n        taskList[i][1] = priorityList[i]; // 存储任务的优先级\n    }\n\n    // 使用qsort对任务列表按照优先级从大到小进行排序\n    qsort(taskList, count, sizeof(int *), compare);\n\n    // currentTask 变量用于记录当前处理的任务序号\n    int currentTask = 0;\n    int *printOrder = (int *)malloc(count * sizeof(int)); // 用于存储最终的打印顺序\n    int orderIndex = 0;\n\n    // 按任务顺序检查并记录每个任务的打印顺序\n    while (currentTask < count) {\n        for (int i = 0; i < count; i++) {\n            if (taskList[i][0] == currentTask) {  // 如果找到任务的原始索引等于当前处理的任务\n                printOrder[orderIndex++] = i;     // 将任务在排序后的位置记录为打印顺序\n                break;\n            }\n        }\n        currentTask++;  // 处理下一个任务\n    }\n\n    // 输出最终的打印顺序\n    for (int i = 0; i < orderIndex; i++) {\n        printf(\"%d\", printOrder[i]);\n        if (i < orderIndex - 1) {\n            printf(\",\");  // 用逗号分隔\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}"
  }
}