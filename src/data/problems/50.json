{
  "id": "50",
  "title": "考勤信息",
  "examType": "A",
  "score": 100,
  "description": "公司用一个字符串来表示员工的出勤信息\nabsent：缺勤late：迟到leaveearly：早退present：正常上班\n现需根据员工出勤信息，判断本次是否能获得出勤奖，能获得出勤奖的条件如下：\n缺勤不超过一次；没有连续的迟到/早退；任意连续7次考勤，缺勤/迟到/早退不超过3次。",
  "inputDesc": "用户的考勤数据字符串\n记录条数 >= 1；输入字符串长度 < 10000；不存在非法输入；\n如：\n2 present present absent present present leaveearly present absent",
  "outputDesc": "根据考勤数据字符串，如果能得到考勤奖，输出”true”；否则输出”false”， 对于输入示例的结果应为：\ntrue false",
  "examples": [
    {
      "input": "2\npresent\npresent present",
      "output": "true true",
      "explanation": "两个测试用例都是全勤或部分全勤，满足所有条件。"
    },
    {
      "input": "2\npresent\npresent absent present present leaveearly present absent",
      "output": "true false",
      "explanation": "第一个用例全勤，输出true。\n第二个用例有2次缺勤(absent)，超过1次，输出false。"
    },
    {
      "input": "1\nlate late present",
      "output": "false",
      "explanation": "连续两次迟到(late late)，不满足条件2。"
    }
  ],
  "solution": "这个题目要求我们根据员工的出勤信息字符串来判断员工是否可以获得出勤奖。根据题目的描述，有三个条件来判断员工是否能够获得出勤奖。、\n员工要获得出勤奖，必须满足以下三个条件：\n缺勤不超过一次：即字符串中 absent 出现的次数不能超过1次。没有连续的迟到/早退：即字符串中不能有 late 和 leaveearly 这两种情况连续出现。任意连续7次考勤中，缺勤/迟到/早退不超过3次：在任何7次连续考勤记录中，absent、late 和 leaveearly 的总次数不能超过3次。",
  "codes": {
    "java": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建Scanner对象读取输入\n        Scanner scanner = new Scanner(System.in);\n        // 读取测试用例数量\n        int testCases = Integer.parseInt(scanner.nextLine().trim());\n        // 使用StringBuilder来构建所有测试用例的输出结果\n        StringBuilder results = new StringBuilder();\n        // 遍历处理每个测试用例\n        while (testCases-- > 0) {\n            // 读取并分割每个测试用例的考勤记录\n            String[] attendanceRecords = scanner.nextLine().trim().split(\" \");\n            // 判断是否能获得考勤奖，并追加结果到results\n            results.append(canReceiveAward(attendanceRecords) ? \"true\" : \"false\");\n            // 如果还有剩余测试用例，追加一个空格分隔\n            if (testCases > 0) {\n                results.append(\" \");\n            }\n        }\n        // 输出所有测试用例的结果\n        System.out.println(results.toString());\n        // 关闭Scanner\n        scanner.close();\n    }\n\n    // 判断是否能获得考勤奖的方法\n    private static boolean canReceiveAward(String[] records) {\n        // 缺勤次数计数器\n        int absentCount = 0;\n        // 遍历考勤记录\n        for (int i = 0; i < records.length; i++) {\n            // 如果记录为缺勤，增加缺勤计数\n            if (\"absent\".equals(records[i])) {\n                absentCount++;\n                // 如果缺勤超过1次，返回false\n                if (absentCount > 1) return false;\n            }\n            // 如果记录为迟到或早退，且前一天也是迟到或早退，返回false\n            if (\"late\".equals(records[i]) || \"leaveearly\".equals(records[i])) {\n                if (i > 0 && (\"late\".equals(records[i - 1]) || \"leaveearly\".equals(records[i - 1]))) {\n                    return false;\n                }\n            }\n            // 检查任意连续7天的考勤记录\n            if (i >= 6) {\n                int countIn7Days = 0;\n                // 计算连续7天内非正常上班的天数\n                for (int j = i - 6; j <= i; j++) {\n                    if (!\"present\".equals(records[j])) {\n                        countIn7Days++;\n                    }\n                }\n                // 如果连续7天内非正常上班超过3天，返回false\n                if (countIn7Days > 3) return false;\n            }\n        }\n        // 如果所有条件都满足，返回true\n        return true;\n    }\n}",
    "python": "def can_receive_award(records):\n    absent_count = 0  # 用于记录缺勤的次数\n    for i in range(len(records)):  # 遍历考勤记录\n        if records[i] == \"absent\":  # 如果记录为缺勤\n            absent_count += 1  # 缺勤次数加1\n            if absent_count > 1:  # 如果缺勤超过1次\n                return False  # 返回False，表示不能获得考勤奖\n        if records[i] in [\"late\", \"leaveearly\"]:  # 如果记录为迟到或早退\n            # 如果前一天也是迟到或早退，则不能获得考勤奖\n            if i > 0 and records[i - 1] in [\"late\", \"leaveearly\"]:\n                return False\n        if i >= 6:  # 如果记录长度大于等于7，检查任意连续7天的考勤记录\n            # 计算连续7天内非出勤的天数\n            count_in_7_days = sum(1 for j in range(i - 6, i + 1) if records[j] != \"present\")\n            if count_in_7_days > 3:  # 如果连续7天内非出勤天数超过3天\n                return False  # 返回False，表示不能获得考勤奖\n    return True  # 所有条件都满足，返回True，表示可以获得考勤奖\n\n# 读取测试用例的数量\ntest_cases = int(input().strip())\nresults = []  # 用于存储每个测试用例的结果\nfor _ in range(test_cases):  # 遍历每个测试用例\n    # 读取并分割每个测试用例的考勤记录\n    attendance_records = input().strip().split()\n    # 判断是否能获得考勤奖，并将结果添加到results列表中\n    results.append(\"true\" if can_receive_award(attendance_records) else \"false\")\n# 输出所有测试用例的结果，结果之间用空格分隔\nprint(\" \".join(results))",
    "javascript": "// 引入readline模块用于读取命令行输入\nconst readline = require('readline');\n\n// 创建readline接口实例\nconst rl = readline.createInterface({\n    input: process.stdin, // 标准输入流\n    output: process.stdout // 标准输出流\n});\n\n// 定义函数判断是否能获得考勤奖\nconst canReceiveAward = (records) => {\n    let absentCount = 0; // 缺勤次数计数器\n    for (let i = 0; i < records.length; i++) {\n        if (records[i] === 'absent') { // 如果记录为缺勤\n            absentCount++; // 缺勤次数加1\n            if (absentCount > 1) return false; // 缺勤超过1次，返回false\n        }\n        if (records[i] === 'late' || records[i] === 'leaveearly') { // 如果记录为迟到或早退\n            // 如果前一天也是迟到或早退，返回false\n            if (i > 0 && (records[i - 1] === 'late' || records[i - 1] === 'leaveearly')) {\n                return false;\n            }\n        }\n        if (i >= 6) { // 检查任意连续7天的考勤记录\n            let countIn7Days = 0; // 连续7天内非正常上班的天数\n            for (let j = i - 6; j <= i; j++) {\n                if (records[j] !== 'present') { // 如果这7天内有非出勤记录\n                    countIn7Days++;\n                }\n            }\n            if (countIn7Days > 3) return false; // 如果连续7天内非正常上班超过3天，返回false\n        }\n    }\n    return true; // 所有条件都满足，返回true\n};\n\nlet lines = []; // 存储输入行的数组\n\n// 监听命令行输入\nrl.on('line', (line) => {\n    lines.push(line); // 将每行输入存储到lines数组中\n}).on('close', () => { // 输入结束时触发\n    const testCases = parseInt(lines[0], 10); // 解析测试用例数量\n    for (let i = 1; i <= testCases; i++) { // 遍历每个测试用例\n        const attendanceRecords = lines[i].trim().split(\" \"); // 分割考勤记录\n        // 输出每个测试用例的结果，并根据条件添加空格分隔\n        process.stdout.write(canReceiveAward(attendanceRecords) ? \"true\" : \"false\");\n        if (i < testCases) {\n            process.stdout.write(\" \");\n        }\n    }\n    process.exit(0); // 执行完毕后退出程序\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n// 定义一个函数用于判断是否能获得考勤奖\nbool can_receive_award(const vector<string>& records) {\n    int absent_count = 0; // 用于记录缺勤的次数\n    for (size_t i = 0; i < records.size(); ++i) { // 遍历考勤记录\n        if (records[i] == \"absent\") { // 如果记录为缺勤\n            ++absent_count; // 缺勤次数加1\n            if (absent_count > 1) return false; // 如果缺勤超过1次，返回false\n        }\n        if (records[i] == \"late\" || records[i] == \"leaveearly\") { // 如果记录为迟到或早退\n            // 如果前一天也是迟到或早退，则不能获得考勤奖\n            if (i > 0 && (records[i - 1] == \"late\" || records[i - 1] == \"leaveearly\")) {\n                return false;\n            }\n        }\n        if (i >= 6) { // 如果记录长度大于等于7，检查任意连续7天的考勤记录\n            int count_in_7_days = 0; // 计算连续7天内非出勤的天数\n            for (int j = i - 6; j <= i; ++j) {\n                if (records[j] != \"present\") ++count_in_7_days;\n            }\n            if (count_in_7_days > 3) return false; // 如果连续7天内非出勤天数超过3天，返回false\n        }\n    }\n    return true; // 所有条件都满足，返回true\n}\n\nint main() {\n    int test_cases;\n    cin >> test_cases; // 读取测试用例的数量\n    cin.ignore(); // 忽略换行符\n    for (int i = 0; i < test_cases; ++i) {\n        string line;\n        getline(cin, line); // 读取一行考勤记录\n        vector<string> records;\n        size_t pos = 0;\n        while ((pos = line.find(' ')) != string::npos) {\n            records.push_back(line.substr(0, pos));\n            line.erase(0, pos + 1);\n        }\n        records.push_back(line); // 添加最后一个记录\n        cout << (can_receive_award(records) ? \"true\" : \"false\") << \" \";\n    }\n    cout << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_RECORDS 100 // 定义最大记录数\n#define MAX_LENGTH 100  // 定义每条记录的最大长度\n\n// 检查是否可以根据出勤记录获得奖励的函数\nint can_receive_award(char records[][MAX_LENGTH], int count) {\n    int absent_count = 0; // 缺席计数\n    for (int i = 0; i < count; ++i) {\n        // 如果记录为\"absent\"，增加缺席计数\n        if (strcmp(records[i], \"absent\") == 0) {\n            ++absent_count;\n            // 如果缺席超过一次，则不符合条件\n            if (absent_count > 1) return 0; // false\n        }\n        // 如果记录为\"late\"或\"leaveearly\"，检查前一天是否也为\"late\"或\"leaveearly\"\n        if (strcmp(records[i], \"late\") == 0 || strcmp(records[i], \"leaveearly\") == 0) {\n            if (i > 0 && (strcmp(records[i - 1], \"late\") == 0 || strcmp(records[i - 1], \"leaveearly\") == 0)) {\n                return 0; // false\n            }\n        }\n        // 检查连续7天内，非\"present\"的记录是否超过3次\n        if (i >= 6) {\n            int count_in_7_days = 0;\n            for (int j = i - 6; j <= i; ++j) {\n                if (strcmp(records[j], \"present\") != 0) ++count_in_7_days;\n            }\n            if (count_in_7_days > 3) return 0; // false\n        }\n    }\n    return 1; // true，符合条件\n}\n\nint main() {\n    int test_cases;\n    scanf(\"%d\", &test_cases); // 读取测试用例的数量\n\n    for (int t = 0; t < test_cases; ++t) {\n        char records[MAX_RECORDS][MAX_LENGTH]; // 存储记录的数组\n        int records_size = 0; // 记录的实际数量\n\n        // 循环读取每条记录，直到检测到换行符\n        while (scanf(\"%s\", records[records_size]) == 1) {\n            records_size++;\n            if (getchar() == '\\n') break; // 如果检测到换行符，跳出循环\n        }\n\n        // 输出结果，如果符合条件输出\"true\"，否则输出\"false\"\n        printf(\"%s \", can_receive_award(records, records_size) ? \"true\" : \"false\");\n    }\n    printf(\"\\n\");\n    return 0;\n}"
  }
}