{
  "id": "20",
  "title": "恢复数字序列",
  "examType": "A",
  "score": 100,
  "description": "对于一个连续正整数组成的序列，可以将其拼接成一个字符串，再将字符串里的部分字符打乱顺序。如序列8 9 10 11 12，拼接成的字符串为89101112，打乱一部分字符后得到90811211，原来的正整数10就被拆成了0和1。\n现给定一个按如上规则得到的打乱字符的字符串，请将其还原成连续正整数序列，并输出序列中最小的数字。",
  "inputDesc": "输入一行，为打乱字符的字符串和正整数序列的长度，两者间用空格分隔，字符串长度不超过200，正整数不超过1000，保证输入可以还原成唯一序列。",
  "outputDesc": "输出一个数字，为序列中最小的数字。",
  "examples": [
    {
      "input": "19801211 5",
      "output": "8",
      "explanation": "原序列为 8,9,10,11,12，拼接后为 89101112。\n打乱后得到 19801211（字符相同，只是顺序打乱）。\n序列长度为5，最小数字是8。"
    },
    {
      "input": "432111111111 4",
      "output": "111",
      "explanation": "原序列为 111,112,113,114，拼接后为 111112113114。\n打乱后得到 432111111111。\n序列长度为4，最小数字是111。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**枚举 + 字符频次匹配**问题。\n\n**核心思想：**\n- 原序列是连续的K个正整数\n- 打乱后字符的频次不变\n- 枚举起始数字i，检查 [i, i+K-1] 这K个数的字符频次是否与输入匹配\n\n**算法步骤：**\n\n1. 统计输入字符串中每个字符的出现次数，存入 base\n2. 从 i=1 开始枚举起始数字\n3. 对于每个 i，计算序列 [i, i+K-1] 拼接后的字符频次 count\n4. 比较 count 和 base，若完全一致，则 i 就是答案\n5. 若不一致，i++ 继续尝试\n\n**时间复杂度**：O(1000 * K * log(i+K))，最多枚举1000个起始点",
  "codes": {
    "java": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 创建一个Scanner对象，用于读取输入\n        Scanner sc = new Scanner(System.in);\n\n        // 读取输入的打乱字符的字符串\n        String s = sc.next();\n        // 读取输入的正整数序列的长度\n        int k = sc.nextInt();\n\n        // 创建一个HashMap，用于统计打乱字符的字符串中各字符的数量\n        HashMap<Character, Integer> base = new HashMap<>();\n        // 遍历打乱字符的字符串\n        for (int i = 0; i < s.length(); i++) {\n            // 获取字符串中的字符\n            char c = s.charAt(i);\n            // 将字符及其数量存入HashMap\n            base.put(c, base.getOrDefault(c, 0) + 1);\n        }\n\n        // 初始化滑动窗口的起始位置\n        int i = 1;\n        // 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\n        while (i <= 1000 - k + 1) {\n            // 创建一个HashMap，用于计算滑动窗口内各字符的数量\n            HashMap<Character, Integer> count = new HashMap<>();\n            // 遍历滑动窗口内的正整数\n            for (int j = i; j < i + k; j++) {\n                // 将正整数转换为字符串\n                String num = String.valueOf(j);\n                // 遍历正整数字符串中的字符\n                for (int m = 0; m < num.length(); m++) {\n                    // 获取正整数字符串中的字符\n                    char c = num.charAt(m);\n                    // 将字符及其数量存入HashMap\n                    count.put(c, count.getOrDefault(c, 0) + 1);\n                }\n            }\n\n            // 初始化一个布尔变量，用于判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n            boolean isMatch = true;\n            // 遍历打乱字符的字符串中的字符\n            for (Character c : base.keySet()) {\n                // 如果滑动窗口内的字符数量与打乱字符的字符串中的字符数量不一致，将isMatch设为false并跳出循环\n                if (!count.containsKey(c) || count.get(c) - base.get(c) != 0) {\n                    isMatch = false;\n                    break;\n                }\n            }\n\n            // 如果滑动窗口内各字符数量与打乱字符的字符串中各字符数量一致，则输出滑动窗口的起始位置并返回\n            if (isMatch) {\n                System.out.println(i);\n                return;\n            }\n\n            // 更新滑动窗口的起始位置\n            i++;\n        }\n    }\n}",
    "python": "import sys\nfrom collections import defaultdict\n\n# 读取输入的打乱字符的字符串和正整数序列的长度\ns, k = input().strip().split()\nk = int(k)\n\n# 创建一个字典，用于统计打乱字符的字符串中各字符的数量\nbase = defaultdict(int)\nfor c in s:\n    base[c] += 1\n\n# 初始化滑动窗口的起始位置\ni = 1\n# 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\nwhile i <= 1000 - k + 1:\n    # 创建一个字典，用于计算滑动窗口内各字符的数量\n    count = defaultdict(int)\n    # 遍历滑动窗口内的正整数\n    for j in range(i, i + k):\n        # 将正整数转换为字符串\n        num = str(j)\n        # 遍历正整数字符串中的字符\n        for c in num:\n            # 将字符及其数量存入字典\n            count[c] += 1\n\n    # 初始化一个布尔变量，用于判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n    is_match = True\n    # 遍历打乱字符的字符串中的字符\n    for c in base:\n        # 如果滑动窗口内的字符数量与打乱字符的字符串中的字符数量不一致，将is_match设为False并跳出循环\n        if count[c] != base[c]:\n            is_match = False\n            break\n\n    # 如果滑动窗口内各字符数量与打乱字符的字符串中各字符数量一致，则输出滑动窗口的起始位置并退出循环\n    if is_match:\n        print(i)\n        break\n\n    # 更新滑动窗口的起始位置\n    i += 1",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout\n});\n\nrl.on('line', (input) => {\n  // 输入打乱字符的字符串和正整数序列的长度\n  const s = input.split(' ')[0];\n  const k = parseInt(input.split(' ')[1]);\n\n  // 创建一个Map，用于统计打乱字符的字符串中各字符的数量\n  const base = new Map();\n  for (const c of s) {\n    base.set(c, (base.get(c) || 0) + 1);\n  }\n\n  // 初始化滑动窗口的起始位置\n  let i = 1;\n  // 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\n  while (i <= 1000 - k + 1) {\n    // 创建一个Map，用于计算滑动窗口内各字符的数量\n    const count = new Map();\n    // 遍历滑动窗口内的正整数\n    for (let j = i; j < i + k; j++) {\n      // 将正整数转换为字符串\n      const num = String(j);\n      // 遍历正整数字符串中的字符\n      for (const c of num) {\n        // 将字符及其数量存入Map\n        count.set(c, (count.get(c) || 0) + 1);\n      }\n    }\n\n    // 初始化一个布尔变量，用于判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n    let isMatch = true;\n    // 遍历打乱字符的字符串中的字符\n    for (const c of base.keys()) {\n      // 如果滑动窗口内的字符数量与打乱字符的字符串中的字符数量不一致，将isMatch设为false并跳出循环\n      if (!count.has(c) || count.get(c) - base.get(c) !== 0) {\n        isMatch = false;\n        break;\n      }\n    }\n\n    // 如果滑动窗口内各字符数量与打乱字符的字符串中各字符数量一致，则输出滑动窗口的起始位置并返回\n    if (isMatch) {\n      console.log(i);\n      return;\n    }\n\n    // 更新滑动窗口的起始位置\n    i++;\n  }\n});",
    "cpp": "#include <iostream>\n#include <string>\n#include <unordered_map>\n\nint main() {\n    // 创建一个字符串变量，用于读取输入的打乱字符的字符串\n    std::string s;\n    // 创建一个整数变量，用于读取输入的正整数序列的长度\n    int k;\n\n    // 读取输入\n    std::cin >> s >> k;\n\n    // 创建一个unordered_map，用于统计打乱字符的字符串中各字符的数量\n    std::unordered_map<char, int> base;\n    // 遍历打乱字符的字符串\n    for (char c : s) {\n        // 将字符及其数量存入unordered_map\n        base[c]++;\n    }\n\n    // 初始化滑动窗口的起始位置\n    int i = 1;\n    // 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\n    while (i <= 1000 - k + 1) {\n        // 创建一个unordered_map，用于计算滑动窗口内各字符的数量\n        std::unordered_map<char, int> count;\n        // 遍历滑动窗口内的正整数\n        for (int j = i; j < i + k; j++) {\n            // 将正整数转换为字符串\n            std::string num = std::to_string(j);\n            // 遍历正整数字符串中的字符\n            for (char c : num) {\n                // 将字符及其数量存入unordered_map\n                count[c]++;\n            }\n        }\n\n        // 初始化一个布尔变量，用于判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n        bool isMatch = true;\n        // 遍历打乱字符的字符串中的字符\n        for (const auto& p : base) {\n            char c = p.first;\n            // 如果滑动窗口内的字符数量与打乱字符的字符串中的字符数量不一致，将isMatch设为false并跳出循环\n            if (count[c] != base[c]) {\n                isMatch = false;\n                break;\n            }\n        }\n\n        // 如果滑动窗口内各字符数量与打乱字符的字符串中各字符数量一致，则输出滑动窗口的起始位置并返回\n        if (isMatch) {\n            std::cout << i << std::endl;\n            return 0;\n        }\n\n        // 更新滑动窗口的起始位置\n        i++;\n    }\n\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\nint main() {\n    char s[201]; // 输入的打乱字符的字符串，长度不超过200\n    int k;       // 正整数序列的长度\n\n    // 读取输入\n    scanf(\"%s %d\", s, &k);\n\n    int base[10] = {0}; // 用于统计打乱字符的字符串中各数字字符的数量\n\n    // 遍历打乱字符的字符串，统计各字符的数量\n    for (int i = 0; i < strlen(s); i++) {\n        base[s[i] - '0']++; // 将字符数字转为整型进行统计\n    }\n\n    // 初始化滑动窗口的起始位置\n    int i = 1;\n    \n    // 当滑动窗口的起始位置小于等于1000减去序列长度加1时，继续循环\n    while (i <= 1000 - k + 1) {\n        int count[10] = {0}; // 用于计算滑动窗口内各字符的数量\n\n        // 遍历滑动窗口内的正整数\n        for (int j = i; j < i + k; j++) {\n            char num[6];\n            sprintf(num, \"%d\", j); // 将正整数转换为字符串\n            \n            // 遍历正整数字符串中的字符，统计各字符数量\n            for (int x = 0; x < strlen(num); x++) {\n                count[num[x] - '0']++; // 将字符数字转为整型进行统计\n            }\n        }\n\n        // 判断滑动窗口内各字符数量是否与打乱字符的字符串中各字符数量一致\n        bool isMatch = true;\n        for (int c = 0; c < 10; c++) {\n            if (count[c] != base[c]) {\n                isMatch = false;\n                break;\n            }\n        }\n\n        // 如果滑动窗口内各字符数量一致，输出滑动窗口的起始位置并退出程序\n        if (isMatch) {\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n\n        // 更新滑动窗口的起始位置\n        i++;\n    }\n\n    return 0;\n}"
  }
}