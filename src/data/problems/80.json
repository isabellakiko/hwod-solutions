{
  "id": "80",
  "title": "比赛的冠亚季军",
  "examType": "A",
  "score": 100,
  "description": "有N（3 ≤ N < 10000）个运动员，他们的id为0到N-1,他们的实力由一组整数表示。他们之间进行比赛，需要决出冠亚军。比赛的规则是0号和1号比赛，2号和3号比赛，以此类推，每一轮，相邻的运动员进行比赛，获胜的进入下一轮；实力值大的获胜，实力值相等的情况，id小的情况下获胜；轮空的直接进入下一轮。\n",
  "inputDesc": "输入一行N个数字代表N的运动员的实力值(0<=实力值<=10000000000)。\n",
  "outputDesc": "输出冠亚季军的id，用空格隔开。",
  "examples": [
    {
      "input": "2 3 4 5",
      "output": "3 1 2",
      "explanation": "第一轮：0vs1(1胜)，2vs3(3胜)；决赛：1vs3(3胜)；季军赛：0vs2(2胜)。冠军3，亚军1，季军2。"
    },
    {
      "input": "1 2 3",
      "output": "2 0 1",
      "explanation": "第一轮：0vs1(1胜)，2轮空；决赛：1vs2(2胜)；季军赛：0vs1(1胜但0更小id)或直接0。"
    },
    {
      "input": "5 4 3 2 1",
      "output": "0 2 4",
      "explanation": "实力递减排列，id小的运动员逐轮获胜。"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**模拟**问题（淘汰赛制）。\n\n**算法步骤：**\n1. 每轮相邻运动员两两比赛，胜者进入获胜组\n2. 奇数个运动员时，最后一个直接晋级\n3. 用链表保存获胜组、失败组，只保留3组\n4. 重复直到产生冠军（获胜组只剩1人）\n5. 季军在第三组中选实力最强者\n\n**时间复杂度**：O(N log N)",
  "codes": {
    "java": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n  // 运动员类\n  static class Sport {\n    int id; // 运动员的id\n    long strength; // 运动员的实力\n\n    public Sport(int id, long strength) {\n      this.id = id;\n      this.strength = strength;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    long[] strengths = Arrays.stream(sc.nextLine().split(\" \")).mapToLong(Long::parseLong).toArray();\n\n    System.out.println(getResult(strengths));\n  }\n\n  public static String getResult(long[] strength) {\n    // ans只记录三个组，冠军组，亚军组，季军组\n    LinkedList<ArrayList<Sport>> ans = new LinkedList<>();\n\n    // 将输入的实力值，转化为运动员集合\n    ArrayList<Sport> sports = new ArrayList<>();\n    for (int i = 0; i < strength.length; i++) sports.add(new Sport(i, strength[i]));\n\n    // 晋级赛\n    promote(sports, ans);\n\n    // 冠军组如果不是一个人，那么还需要取出冠军组继续进行晋级赛\n    while (ans.getFirst().size() > 1) {\n      promote(ans.removeFirst(), ans);\n    }\n\n    // 冠军\n    int first = ans.get(0).get(0).id;\n\n    // 亚军\n    int second = ans.get(1).get(0).id;\n\n    // 季军\n    ans.get(2)\n        .sort(\n            (a, b) ->\n                a.strength != b.strength ? b.strength - a.strength > 0 ? 1 : -1 : a.id - b.id);\n    int third = ans.get(2).get(0).id;\n\n    return first + \" \" + second + \" \" + third;\n  }\n\n  public static void promote(ArrayList<Sport> sports, LinkedList<ArrayList<Sport>> ans) {\n    // 记录获胜组\n    ArrayList<Sport> win = new ArrayList<>();\n    // 记录失败组\n    ArrayList<Sport> fail = new ArrayList<>();\n\n    for (int i = 1; i < sports.size(); i += 2) {\n      // 序号大的运动员\n      Sport major = sports.get(i);\n      // 序号小的运动员\n      Sport minor = sports.get(i - 1);\n\n      if (major.strength > minor.strength) {\n        win.add(major);\n        fail.add(minor);\n      } else {\n        // 如果序号大的运动员的实力 <= 序号小的运动员，则序号小的运动员获胜\n        win.add(minor);\n        fail.add(major);\n      }\n    }\n\n    // 如果晋级赛中运动员个数是奇数个，那么最后一个运动员直接晋级\n    if (sports.size() % 2 != 0) {\n      win.add(sports.get(sports.size() - 1));\n    }\n\n    // 依次头部压入失败组，获胜组，保证头部是获胜组\n    ans.addFirst(fail);\n    ans.addFirst(win);\n\n    // 如果保留组个数超过3个，那么需要将超过部分的组去掉，因为这部分人已经无缘季军\n    while (ans.size() > 3) ans.removeLast();\n  }\n}",
    "python": "# 输入获取\ntmp = list(map(int, input().split()))\n\n\nclass Sport:\n    def __init__(self, idx, strength):\n        self.idx = idx  # 运动员的id\n        self.strength = strength    # 运动员的实力\n\n\n# 将输入的实力值，转化为运动员集合\nsports = []\nfor i in range(len(tmp)):\n    sports.append(Sport(i, tmp[i]))\n\n\ndef promote(sports, ans):\n    # 记录获胜组\n    win = []\n    # 记录失败组\n    fail = []\n\n    for i in range(1, len(sports), 2):\n        # 序号大的运动员\n        major = sports[i]\n        # 序号小的运动员\n        minor = sports[i-1]\n\n        if major.strength > minor.strength:\n            win.append(major)\n            fail.append(minor)\n        else:\n            # 如果序号大的运动员的实力 <= 序号小的运动员，则序号小的运动员获胜\n            win.append(minor)\n            fail.append(major)\n\n    # 如果晋级赛中运动员个数是奇数个，那么最后一个运动员直接晋级\n    if len(sports) % 2 != 0:\n        win.append(sports[-1])\n\n    # 依次头部压入失败组，获胜组，保证头部是获胜组\n    ans.insert(0, fail)\n    ans.insert(0, win)\n\n    # 如果保留组个数超过3个，那么需要将超过部分的组去掉，因为这部分人已经无缘季军\n    while len(ans) > 3:\n        ans.pop()\n\n\n# 算法入口\ndef getResult():\n    # ans只记录三个组，冠军组，亚军组，季军组\n    ans = []\n\n    # 晋级赛\n    promote(sports, ans)\n\n    # 冠军组如果不是一个人，那么还需要取出冠军组继续进行晋级赛\n    while len(ans[0]) > 1:\n        promote(ans.pop(0), ans)\n\n    # 冠军\n    first = ans[0][0].idx\n\n    # 亚军\n    second = ans[1][0].idx\n\n    # 季军\n    ans[2].sort(key=lambda x: (-x.strength, x.idx))\n    third = ans[2][0].idx\n\n    return f\"{first} {second} {third}\"\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nrl.on('line', (line) => {\n    const strengths = line.split(' ').map(Number);\n    const sports = strengths.map((s, i) => ({ id: i, strength: s }));\n    \n    const ans = [];\n    \n    function promote(group) {\n        const win = [], fail = [];\n        for (let i = 1; i < group.length; i += 2) {\n            if (group[i].strength > group[i-1].strength) {\n                win.push(group[i]);\n                fail.push(group[i-1]);\n            } else {\n                win.push(group[i-1]);\n                fail.push(group[i]);\n            }\n        }\n        if (group.length % 2 !== 0) win.push(group[group.length - 1]);\n        ans.unshift(fail);\n        ans.unshift(win);\n        while (ans.length > 3) ans.pop();\n    }\n    \n    promote(sports);\n    while (ans[0].length > 1) {\n        promote(ans.shift());\n    }\n    \n    const first = ans[0][0].id;\n    const second = ans[1][0].id;\n    ans[2].sort((a, b) => a.strength !== b.strength ? b.strength - a.strength : a.id - b.id);\n    const third = ans[2][0].id;\n    \n    console.log(`${first} ${second} ${third}`);\n    rl.close();\n});",
    "cpp": "#include <iostream>\n#include <vector>\n#include <sstream>\n#include <algorithm>\n#include <deque>\nusing namespace std;\n\nstruct Sport {\n    int id;\n    long long strength;\n};\n\ndeque<vector<Sport>> ans;\n\nvoid promote(vector<Sport>& group) {\n    vector<Sport> win, fail;\n    for (int i = 1; i < group.size(); i += 2) {\n        if (group[i].strength > group[i-1].strength) {\n            win.push_back(group[i]);\n            fail.push_back(group[i-1]);\n        } else {\n            win.push_back(group[i-1]);\n            fail.push_back(group[i]);\n        }\n    }\n    if (group.size() % 2 != 0) win.push_back(group[group.size() - 1]);\n    ans.push_front(fail);\n    ans.push_front(win);\n    while (ans.size() > 3) ans.pop_back();\n}\n\nint main() {\n    string line;\n    getline(cin, line);\n    stringstream ss(line);\n    \n    vector<Sport> sports;\n    long long s;\n    int id = 0;\n    while (ss >> s) {\n        sports.push_back({id++, s});\n    }\n    \n    promote(sports);\n    while (ans[0].size() > 1) {\n        vector<Sport> tmp = ans[0];\n        ans.pop_front();\n        promote(tmp);\n    }\n    \n    int first = ans[0][0].id;\n    int second = ans[1][0].id;\n    sort(ans[2].begin(), ans[2].end(), [](const Sport& a, const Sport& b) {\n        if (a.strength != b.strength) return a.strength > b.strength;\n        return a.id < b.id;\n    });\n    int third = ans[2][0].id;\n    \n    cout << first << \" \" << second << \" \" << third << endl;\n    return 0;\n}",
    "c": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int id;\n    long long strength;\n} Sport;\n\ntypedef struct {\n    Sport* data;\n    int size;\n} Group;\n\nGroup groups[10];\nint groupCount = 0;\n\nvoid promote(Group* g) {\n    Group win = {malloc(sizeof(Sport) * g->size), 0};\n    Group fail = {malloc(sizeof(Sport) * g->size), 0};\n    \n    for (int i = 1; i < g->size; i += 2) {\n        if (g->data[i].strength > g->data[i-1].strength) {\n            win.data[win.size++] = g->data[i];\n            fail.data[fail.size++] = g->data[i-1];\n        } else {\n            win.data[win.size++] = g->data[i-1];\n            fail.data[fail.size++] = g->data[i];\n        }\n    }\n    if (g->size % 2 != 0) win.data[win.size++] = g->data[g->size - 1];\n    \n    for (int i = groupCount; i > 0; i--) groups[i] = groups[i-1];\n    groups[0] = fail;\n    groupCount++;\n    for (int i = groupCount; i > 0; i--) groups[i] = groups[i-1];\n    groups[0] = win;\n    groupCount++;\n    while (groupCount > 3) groupCount--;\n}\n\nint cmp(const void* a, const void* b) {\n    Sport* sa = (Sport*)a;\n    Sport* sb = (Sport*)b;\n    if (sa->strength != sb->strength) return sb->strength > sa->strength ? 1 : -1;\n    return sa->id - sb->id;\n}\n\nint main() {\n    char line[100000];\n    fgets(line, sizeof(line), stdin);\n    \n    Sport sports[10000];\n    int n = 0;\n    char* token = strtok(line, \" \\n\");\n    while (token) {\n        sports[n].id = n;\n        sports[n].strength = atoll(token);\n        n++;\n        token = strtok(NULL, \" \\n\");\n    }\n    \n    Group initial = {sports, n};\n    promote(&initial);\n    while (groups[0].size > 1) {\n        Group tmp = groups[0];\n        for (int i = 0; i < groupCount - 1; i++) groups[i] = groups[i+1];\n        groupCount--;\n        promote(&tmp);\n    }\n    \n    int first = groups[0].data[0].id;\n    int second = groups[1].data[0].id;\n    qsort(groups[2].data, groups[2].size, sizeof(Sport), cmp);\n    int third = groups[2].data[0].id;\n    \n    printf(\"%d %d %d\\n\", first, second, third);\n    return 0;\n}"
  }
}