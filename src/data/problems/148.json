{
  "id": "148",
  "title": "任务最优调度",
  "examType": "A",
  "score": 200,
  "description": "给定一个正整数数组表示待系统执行的任务列表，数组的每一个元素代表一个任务，元素的值表示该任务的类型。\n请计算执行完所有任务所需的最短时间。\n任务执行规则如下:\n任务可以按任意顺序执行，且每个任务执行耗时间均为1个时间单位。两个同类型的任务之间必须有长度为N个单位的冷却时间，比如N为2时，在时间K执行了类型3的任务，那么K+1和K+2两个时间不能执行类型3任务。系统在任何一个单位时间内都可以执行一个任务，或者等待状态。\n说明：数组最大长度为1000，数组最大值1000。\n",
  "inputDesc": "第一行记录一个用半角逗号分隔的数组，数组长度不超过1000，数组元素的值不超过1000，第二行记录任务冷却时间，N为正整数，N<=100。\n",
  "outputDesc": "输出为执行完所有任务所需的最短时间。\n\n\n本题考察贪心算法。\n\n我的解题思路如下：\n首先，我们统计出各种任务的数量，并找出数量最多的任务，比如题目用例中：\n其中任务2的数量最多，有3个，我们假设k=3，那么完成所有任务所需时间至少为：\n(k - 1) * (n + 1) + 1\n画图示意如下：\n\n其中n为冷却时间，k为最多任务的数量。\n如果其他任务数量较少的话，可以直接在任务2的冷却时间中运行。比如题目用例运行图如下：\n\n此时，总用时仍然为 (k - 1) * (n + 1) + 1。\n\n理解了上面公式后，我们可以继续看下几种特殊情况：\n1、数量最多的任务有多个，比如用例\n2,2,2,3,3,3\n2\n此时画图示意如下：\n\n此时至少用时为： (k - 1) * (n + 1) + 2\n\n再比如用例\n2,2,2,3,3,3,4,4,4\n2\n\n此时至少用时为： (k - 1) * (n + 1) + 3\n\n可以发现，如果数量最多的任务有多个，假设为p个，则此时至少用时公式应该为：\n(k - 1) * (n + 1) + p\n\n另外，还有一种特殊情况，如下用例\n2,2,2,3,3,3,4,4,4,5,5,5\n2\n此时任务5有两种执行策略：\n策略一如下：\n\n策略二如下：\n\n很明显策略一更加省时。 因为策略一少了任务5的冷却时间。\n可以发现，此时策略一的用时就是：总任务数量（每个任务执行耗时间均为1个时间单位）\n\n因此：\n即取二者较大值。\n",
  "examples": [
    {
      "input": "2,2,2,3,3,3,4\n2",
      "output": "9",
      "explanation": "任务2和3各3个，冷却时间2。排列如2-3-4-2-3-idle-2-3-idle，共9个时间单位"
    },
    {
      "input": "1,1,1,1\n2",
      "output": "10",
      "explanation": "4个相同任务，冷却2。排列1-idle-idle-1-idle-idle-1-idle-idle-1，共10单位"
    }
  ],
  "solution": "**解题思路：**\n\n本题是一道**贪心算法**问题（LeetCode 621变体）。\n\n**核心思路：**\n- 找出数量最多的任务数k\n- 统计数量为k的任务种类数p\n- 答案为max((k-1)*(n+1)+p, 总任务数)\n\n**算法步骤：**\n1. 统计各类型任务的数量\n2. 找出最大数量k和数量为k的任务种类p\n3. 计算公式结果(k-1)*(n+1)+p\n4. 返回公式结果与总任务数的较大值\n\n**时间复杂度**：O(N)",
  "codes": {
    "java": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n  // 输入获取\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int[] tasks = Arrays.stream(sc.next().split(\",\")).mapToInt(Integer::parseInt).toArray();\n    int n = sc.nextInt();\n\n    System.out.println(getResult(tasks, n));\n  }\n\n  // 算法入口\n  public static int getResult(int[] tasks, int n) {\n    HashMap<Integer, Integer> cnts = new HashMap<>();\n\n    for (int task : tasks) {\n      cnts.put(task, cnts.getOrDefault(task, 0) + 1);\n    }\n\n    // k表示:最多任务的数量\n    // 比如2,2,2,3， 其中任务2数量最多，有3个，则k = 3\n    int k = cnts.values().stream().max((a, b) -> a - b).orElse(0);\n\n    // p表示:数量为k的任务个数\n    // 比如2,2,2,3,3,3,4， 其中数量为3的任务有2个，分别是任务2，任务3，则p=2\n    int p = 0;\n    for (Integer task : cnts.keySet()) {\n      if (cnts.get(task) == k) p++;\n    }\n\n    return Math.max((k - 1) * (n + 1) + p, tasks.length);\n  }\n}",
    "python": "# 输入获取\ntasks = list(map(int, input().split(\",\")))\nn = int(input())\n\n\n# 算法入口\ndef getResult():\n    cnts = {}\n\n    for task in tasks:\n        cnts[task] = cnts.get(task, 0) + 1\n\n    # k表示: 最多任务的数量\n    # 比如2, 2, 2, 3， 其中任务2数量最多，有3个，则k = 3\n    k = max(cnts.values())\n\n    # p表示: 数量为k的任务个数\n    # 比如2, 2, 2, 3, 3, 3, 4， 其中数量为3的任务有2个，分别是任务2，任务3，则p = 2\n    p = 0\n    for task in cnts:\n        if cnts[task] == k:\n            p += 1\n\n    return max((k - 1) * (n + 1) + p, len(tasks))\n\n\n# 算法调用\nprint(getResult())",
    "javascript": "/* JavaScript Node ACM模式 控制台输入获取 */\nconst readline = require(\"readline\");\n\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nconst lines = [];\nrl.on(\"line\", (line) => {\n  lines.push(line);\n\n  if (lines.length === 2) {\n    const tasks = lines[0].split(\",\").map(Number);\n    const n = lines[1] - 0;\n\n    console.log(getResult(tasks, n));\n\n    lines.length = 0;\n  }\n});\n\nfunction getResult(tasks, n) {\n  const cnts = {};\n\n  for (let task of tasks) {\n    cnts[task] ? cnts[task]++ : (cnts[task] = 1);\n  }\n\n  // k表示:最多任务的数量\n  // 比如2,2,2,3， 其中任务2数量最多，有3个，则k = 3\n  const k = Math.max(...Object.values(cnts));\n\n  // p表示:数量为k的任务个数\n  // 比如2,2,2,3,3,3,4， 其中数量为3的任务有2个，分别是任务2，任务3，则p=2\n  let p = 0;\n\n  for (let task in cnts) {\n    if (cnts[task] == k) p++;\n  }\n\n  return Math.max((k - 1) * (n + 1) + p, tasks.length);\n}",
    "cpp": "",
    "c": ""
  }
}