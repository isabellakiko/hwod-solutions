const r="169",n="最大社交距离",o="A",l=200,e=`疫情期间需要大家保证一定的社交距离，公司组织开交流会议。座位一排共 N 个座位，编号分别为[0,N-1],
要求员工一个接着一个进入会议室，并且可以在任何时候离开会议室。
满足：
每当一个员工进入时，需要坐到最大社交距离（最大化自己和其他人的距离的座位）；如果有多个这样的座位，则坐到索引最小的那个座位。`,t=`会议室座位总数 seatNum
1 ≤ seatNum ≤ 500
员工的进出顺序 seatOrLeave 数组
元素值为 1，表示进场 元素值为负数，表示出场（特殊：位置 0 的员工不会离开） 例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上）
元素值为 1，表示进场
元素值为负数，表示出场（特殊：位置 0 的员工不会离开）
例如 -4 表示坐在位置 4 的员工离开（保证有员工坐在该座位上）`,s="最后进来员工，他会坐在第几个位置，如果位置已满，则输出-1。",a=[{input:`10
[1, 1, 1, 1, -4, 1]`,output:"5",explanation:"seat -> 0,空在任何位置都行，但是要给他安排索引最小的位置，也就是座位 0 seat -> 9,要和旁边的人距离最远，也就是座位 9 seat -> 4,要和旁边的人距离最远，应该坐到中间，也就是座位 4 seat -> 2,员工最后坐在 2 号座位上 leave[4], 4 号座位的员工离开 seat -> 5,员工最后坐在 5 号座位上"}],i=`动态维护一个已占用座位的列表，并在每次有员工进入时计算最佳座位，以及在有员工离开时更新座位状态 。
初始化座位状态：使用一个动态数组seat来记录当前已被占用的座位编号。 处理每个操作：遍历给定的操作序列seatOrLeave，对于每个操作： 如果操作为正数（即1），表示有员工进入： 会议室为空：如果当前seat数组为空，说明会议室内没有人，新员工直接坐在0号座位。会议室不为空：遍历seat数组，计算每两个相邻已占座位之间的距离，以及第一个座位到0号座位的距离和最后一个座位到seatNum-1的距离。找到这些距离中的最大值对应的座位，作为新员工的座位。 如果操作为负数，表示有员工离开，根据操作值的绝对值找到对应的座位编号，并从seat数组中移除该座位编号。 更新座位状态：对于进入的员工，将其座位编号添加到seat数组中，并对seat数组进行排序，以便下次操作时能快速找到最佳座位。 输出结果：在处理完所有操作后，输出最后一个进入的员工的座位编号。如果会议室已满，则输出-1。
初始化座位状态：使用一个动态数组seat来记录当前已被占用的座位编号。
处理每个操作：遍历给定的操作序列seatOrLeave，对于每个操作：
如果操作为正数（即1），表示有员工进入： 会议室为空：如果当前seat数组为空，说明会议室内没有人，新员工直接坐在0号座位。会议室不为空：遍历seat数组，计算每两个相邻已占座位之间的距离，以及第一个座位到0号座位的距离和最后一个座位到seatNum-1的距离。找到这些距离中的最大值对应的座位，作为新员工的座位。 如果操作为负数，表示有员工离开，根据操作值的绝对值找到对应的座位编号，并从seat数组中移除该座位编号。
会议室为空：如果当前seat数组为空，说明会议室内没有人，新员工直接坐在0号座位。会议室不为空：遍历seat数组，计算每两个相邻已占座位之间的距离，以及第一个座位到0号座位的距离和最后一个座位到seatNum-1的距离。找到这些距离中的最大值对应的座位，作为新员工的座位。
更新座位状态：对于进入的员工，将其座位编号添加到seat数组中，并对seat数组进行排序，以便下次操作时能快速找到最佳座位。
输出结果：在处理完所有操作后，输出最后一个进入的员工的座位编号。如果会议室已满，则输出-1。`,c=JSON.parse(`{"java":"import java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        // 读取输入\\n        int seatNum = scanner.nextInt();  // 读取座位总数\\n        scanner.nextLine();  // 读取换行符\\n        String str = scanner.nextLine();  // 读取座位占用和离开的操作序列\\n        // 去除字符串首尾的括号并分割成数组\\n        String[] parts = str.substring(1, str.length() - 1).split(\\",\\");\\n        ArrayList<Integer> seatOrLeave = new ArrayList<>();\\n        for (String part : parts) {\\n            seatOrLeave.add(Integer.parseInt(part.trim()));  // 转换为整数并添加到列表\\n        }\\n\\n        // 初始化\\n        ArrayList<Integer> seat = new ArrayList<>();  // 存储已占用的座位\\n        int ans = -1;  // 下一个人的最佳座位号\\n\\n        // 遍历座位占用和离开的操作序列\\n        for (int sol : seatOrLeave) {\\n            if (sol != 1) {\\n                // 如果sol为负数，表示有员工离开，移除对应座位号\\n                seat.remove(Integer.valueOf(-sol));\\n            } else {\\n                // 如果sol为1，表示有员工进入，需要找到最佳座位\\n                if (seat.isEmpty()) {\\n                    // 如果会议室为空，新员工坐在0号座位\\n                    ans = 0;\\n                } else {\\n                    // 如果会议室不为空，找到最大的空闲区间\\n                    int maxDistance = seat.get(0);  // 初始化最大距离为第一个座位号\\n                    ans = 0;  // 初始化最佳座位号为0\\n                    for (int i = 0; i < seat.size(); i++) {\\n                        int distance;\\n                        if (i == seat.size() - 1) {\\n                            // 检查最后一个座位到座位总数之间的距离\\n                            distance = seatNum - 1 - seat.get(i);\\n                        } else {\\n                            // 检查相邻座位之间的距离\\n                            distance = (seat.get(i + 1) - seat.get(i)) / 2;\\n                        }\\n                        if (distance > maxDistance) {\\n                            // 更新最大距离和最佳座位号\\n                            maxDistance = distance;\\n                            ans = (i == seat.size() - 1) ? seatNum - 1 : seat.get(i) + distance;\\n                        }\\n                    }\\n                }\\n\\n                // 如果会议室已满，设置最佳座位号为-1\\n                if (seat.size() == seatNum) {\\n                    ans = -1;\\n                } else {\\n                    // 将新员工的座位号加入到座位列表，并排序\\n                    seat.add(ans);\\n                    Collections.sort(seat);\\n                }\\n            }\\n        }\\n\\n        // 打印最后一个操作后的最佳座位号\\n        System.out.println(ans);\\n        scanner.close();\\n    }\\n}","python":"import math\\n\\n# 读取输入\\nseatNum = int(input())  # 座位总数\\nstr = input()  # 座位占用和离开的操作序列\\nseatOrLeave = list(map(int, str[1:-1].split(\\",\\")))  # 将字符串转换为整数数组\\n\\n# 初始化\\nseat = []  # 存储已占用的座位\\nans = -1  # 下一个人的最佳座位号\\n\\nfor sol in seatOrLeave:  # 遍历座位占用和离开的操作序列\\n    if sol != 1:\\n        # 如果sol为负数，表示有员工离开，移除对应座位号\\n        seat.remove(-sol)\\n    else:\\n        # 如果sol为1，表示有员工进入，需要找到最佳座位\\n        if not seat:\\n            # 如果会议室为空，新员工坐在0号座位\\n            ans = 0\\n        else:\\n            # 如果会议室不为空，找到最大的空闲区间\\n            max_distance = seat[0]  # 初始化最大距离为第一个座位号\\n            ans = 0  # 初始化最佳座位号为0\\n            for i in range(len(seat)):\\n                if i == len(seat) - 1:\\n                    # 检查最后一个座位到座位总数之间的距离\\n                    distance = seatNum - 1 - seat[i]\\n                else:\\n                    # 检查相邻座位之间的距离\\n                    distance = (seat[i + 1] - seat[i]) // 2\\n                if distance > max_distance:\\n                    # 更新最大距离和最佳座位号\\n                    max_distance = distance\\n                    if i == len(seat) - 1:\\n                        ans = seatNum - 1\\n                    else:\\n                        ans = seat[i] + distance\\n\\n        # 如果会议室已满，输出-1\\n        if len(seat) == seatNum:\\n            ans = -1\\n        else:\\n            # 将新员工的座位号加入到座位列表，并排序\\n            seat.append(ans)\\n            seat.sort()\\n\\nprint(ans)","javascript":"const readline = require('readline');\\n// 创建 readline 接口实例\\nconst rl = readline.createInterface({\\n    input: process.stdin,  // 标准输入流\\n    output: process.stdout  // 标准输出流\\n});\\n\\n// 监听 'line' 事件，每次输入一行触发\\nrl.on('line', (seatNum) => {\\n    // 再次监听 'line' 事件，获取座位占用和离开的操作序列\\n    rl.on('line', (str) => {\\n        // 解析输入的字符串，去掉首尾的括号，分割后转换为数字数组\\n        const seatOrLeave = str.slice(1, -1).split(',').map(Number);\\n\\n        let seat = [];  // 存储已占用的座位\\n        let ans = -1;  // 下一个人的最佳座位号\\n\\n        // 遍历操作序列\\n        for (let sol of seatOrLeave) {\\n            if (sol !== 1) {\\n                // 如果操作不是1，表示有员工离开，移除对应座位号\\n                seat = seat.filter(s => s !== -sol);\\n            } else {\\n                // 如果操作是1，表示有员工进入，需要找到最佳座位\\n                if (seat.length === 0) {\\n                    // 如果会议室为空，新员工坐在0号座位\\n                    ans = 0;\\n                } else {\\n                    // 如果会议室不为空，找到最大的空闲区间\\n                    let max_distance = seat[0];  // 初始化最大距离为第一个座位号\\n                    ans = 0;  // 初始化最佳座位号为0\\n                    for (let i = 0; i < seat.length; i++) {\\n                        // 计算当前座位与下一个座位之间的距离\\n                        let distance = i === seat.length - 1 ? seatNum - 1 - seat[i] : Math.floor((seat[i + 1] - seat[i]) / 2);\\n                        if (distance > max_distance) {\\n                            // 如果当前距离大于最大距离，则更新最大距离和最佳座位号\\n                            max_distance = distance;\\n                            ans = i === seat.length - 1 ? seatNum - 1 : seat[i] + distance;\\n                        }\\n                    }\\n                }\\n                // 如果会议室已满，设置最佳座位号为-1\\n                if (seat.length === seatNum) {\\n                    ans = -1;\\n                } else {\\n                    // 将新员工的座位号加入到座位列表，并按升序排序\\n                    seat.push(ans);\\n                    seat.sort((a, b) => a - b);\\n                }\\n            }\\n        }\\n\\n        // 输出最后一个操作后的最佳座位号\\n        console.log(ans);\\n        // 关闭 readline 接口实例\\n        rl.close();\\n    });\\n});","cpp":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <sstream>\\n\\nusing namespace std;\\n\\n// 寻找最佳座位的函数\\nint findBestSeat(const vector<int>& occupiedSeats, int seatNum) {\\n    // 如果还没有人坐，第一个人坐在0号座位\\n    if (occupiedSeats.empty()) return 0;\\n    // 如果只有一个人坐，那么下一个人坐在最后一个座位\\n    if (occupiedSeats.size() == 1) return seatNum - 1;\\n\\n    int maxDistance = 0, bestSeat = -1;\\n    // 检查是否可以在第一个座位坐下（即第一个座位之前的空位）\\n    if (occupiedSeats.front() > 0) {\\n        maxDistance = occupiedSeats.front();\\n        bestSeat = 0;\\n    }\\n    // 检查是否可以在最后一个座位坐下（即最后一个座位之后的空位）\\n    if (seatNum - 1 - occupiedSeats.back() > maxDistance) {\\n        maxDistance = seatNum - 1 - occupiedSeats.back();\\n        bestSeat = seatNum - 1;\\n    }\\n    // 检查中间的最大间隔，寻找最佳座位\\n    for (int i = 1; i < occupiedSeats.size(); ++i) {\\n        int distance = (occupiedSeats[i] - occupiedSeats[i - 1]) / 2;\\n        if (distance > maxDistance) {\\n            maxDistance = distance;\\n            bestSeat = occupiedSeats[i - 1] + distance;\\n        }\\n    }\\n    // 返回最佳座位编号\\n    return bestSeat;\\n}\\n\\nint main() {\\n    int seatNum; // 会议室座位总数\\n    cin >> seatNum;\\n\\n    string input; // 存放员工进出顺序的字符串\\n    cin >> ws; // 忽略前面的空白字符\\n    getline(cin, input); // 读取整行作为字符串\\n\\n    // 处理输入字符串，将其转换为int数组\\n    stringstream ss(input.substr(1, input.size() - 2)); // 去掉字符串的首尾括号\\n    vector<int> seatOrLeave;\\n    int num;\\n    while (ss >> num) {\\n        seatOrLeave.push_back(num);\\n        if (ss.peek() == ',') ss.ignore();\\n    }\\n\\n    vector<int> occupiedSeats; // 存储已占用座位的数组\\n    int lastSeat = -1; // 存储最后一个坐下的员工的座位号\\n\\n    // 遍历员工的进出操作\\n    for (int action : seatOrLeave) {\\n        if (action == 1) { // 进场操作\\n            int bestSeat = findBestSeat(occupiedSeats, seatNum);\\n            if (bestSeat != -1) { // 如果找到了最佳座位\\n                occupiedSeats.push_back(bestSeat); // 更新已占用座位列表\\n                sort(occupiedSeats.begin(), occupiedSeats.end()); // 保持座位列表排序\\n                lastSeat = bestSeat; // 更新最后一个坐下的座位号\\n            }\\n        } else if (action < 0) { // 出场操作\\n            action = -action; // 转为正数，表示座位号\\n            auto it = find(occupiedSeats.begin(), occupiedSeats.end(), action);\\n            if (it != occupiedSeats.end()) occupiedSeats.erase(it); // 从已占用座位中移除\\n        }\\n    }\\n\\n    cout << lastSeat << endl; // 输出最后一个进来员工的座位号\\n\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX_SIZE 500 // 定义最大座位数\\n\\n// 比较函数，用于qsort排序\\nint cmp(const void *a, const void *b) {\\n    return *((int *) a) - *((int *) b);\\n}\\n\\nint main() {\\n    int seatNum; // 座位总数\\n    scanf(\\"%d\\", &seatNum); // 读取座位总数\\n\\n    getchar(); // 读取换行符\\n\\n    int seatOrLeave[MAX_SIZE] = {0}; // 存储进出座位的数组\\n    int seatOrLeave_size = 0; // 进出座位数组的当前大小\\n\\n    // 读取进出座位的序列，支持两种格式：[数字,] 或 数字,\\n    while (scanf(\\"[%d\\", &seatOrLeave[seatOrLeave_size]) || scanf(\\"%d\\", &seatOrLeave[seatOrLeave_size])) {\\n        seatOrLeave_size++; // 数组大小增加\\n        if (getchar() != ',') break; // 如果不是逗号，则停止读取\\n    }\\n\\n    int seat[MAX_SIZE]; // 存储已有人的座位号\\n    int seat_size = 0; // 已有人的座位号数组的当前大小\\n    int lastSeatIdx = -1; // 最后一个坐下的座位号\\n\\n    // 遍历所有进出记录\\n    for (int i = 0; i < seatOrLeave_size; i++) {\\n        int info = seatOrLeave[i]; // 当前记录\\n\\n        // 如果是负数，表示有人离开\\n        if (info < 0) {\\n            int leaveIdx = -info; // 离开的座位号\\n            for (int j = 0; j < seat_size; j++) {\\n                if (seat[j] == leaveIdx) {\\n                    // 移除离开的座位号\\n                    for (int k = j; k < seat_size - 1; k++) {\\n                        seat[k] = seat[k + 1];\\n                    }\\n                    seat_size--; // 座位数组大小减小\\n                    break;\\n                }\\n            }\\n        } else {\\n            // 如果是第一个人，则坐在第一个位置\\n            if (seat_size == 0) {\\n                lastSeatIdx = 0;\\n                seat[seat_size++] = lastSeatIdx;\\n            } else {\\n                int maxDist = -1; // 最大距离\\n                int bestSeat = -1; // 最佳座位\\n\\n                // 检查第一个座位是否空闲\\n                if (seat[0] > 0) {\\n                    maxDist = seat[0];\\n                    bestSeat = 0;\\n                }\\n\\n                // 遍历已坐座位，寻找最佳座位\\n                for (int j = 1; j < seat_size; j++) {\\n                    int dist = (seat[j] - seat[j - 1]) / 2; // 计算距离\\n                    if (dist > maxDist) {\\n                        maxDist = dist;\\n                        bestSeat = seat[j - 1] + dist;\\n                    }\\n                }\\n\\n                // 检查最后一个座位是否空闲\\n                if (seatNum - 1 - seat[seat_size - 1] > maxDist) {\\n                    bestSeat = seatNum - 1;\\n                }\\n\\n                // 如果找到了最佳座位，将其加入数组\\n                if (bestSeat >= 0 && seat_size < seatNum) {\\n                    seat[seat_size++] = bestSeat;\\n                    qsort(seat, seat_size, sizeof(int), cmp); // 排序座位数组\\n                }\\n\\n                lastSeatIdx = bestSeat; // 更新最后一个坐下的座位号\\n            }\\n        }\\n    }\\n\\n    printf(\\"%d\\\\n\\", lastSeatIdx); // 打印最后一个坐下的座位号\\n\\n    return 0;\\n}"}`),u={id:"169",title:n,examType:"A",score:200,description:e,inputDesc:t,outputDesc:s,examples:a,solution:i,codes:c};export{c as codes,u as default,e as description,o as examType,a as examples,r as id,t as inputDesc,s as outputDesc,l as score,i as solution,n as title};
