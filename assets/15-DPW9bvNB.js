const s="15",n="单词接龙",a="A",m=100,t=`单词接龙的规则是：
1. 可用于接龙的单词首字母必须要前一个单词的尾字母相同；
2. 当存在多个首字母相同的单词时，取长度最长的单词，如果长度也相等，则取字典序最小的单词；
3. 已经参与接龙的单词不能重复使用。

现给定一组全部由小写字母组成单词数组，并指定其中的一个单词作为起始单词，进行单词接龙，请输出最长的单词串，单词串是单词拼接而成，中间没有空格。`,r=`输入的第一行为一个非负整数，表示起始单词在数组中的索引K，0 <= K < N ；
输入的第二行为一个非负整数，表示单词的个数N；
接下来的N行，分别表示单词数组中的单词。
备注：
单词个数N的取值范围为[1, 20]；单个单词的长度的取值范围为[1, 30]；`,e="输出一个字符串，表示最终拼接的单词串。",i=[{input:`0
6
word
dd
da
dc
dword
d`,output:"worddwordda",explanation:`单词数组：[word, dd, da, dc, dword, d]，起始索引0即"word"。

接龙过程：
1. word（尾字母d）
2. 以d开头的单词：dd(2), da(2), dc(2), dword(5), d(1) → 选最长"dword"
3. dword（尾字母d）→ 剩余：dd, da, dc, d → 选长度最长(2)且字典序最小"da"

结果：worddwordda`},{input:`4
6
word
dd
da
dc
dword
d`,output:"dwordda",explanation:`起始索引4即"dword"，尾字母d。
剩余以d开头：dd(2), da(2), dc(2), d(1) → 选"da"。
结果：dwordda`}],d=`**解题思路：**

本题是一道**贪心模拟**问题。

**算法步骤：**

1. **初始化**：从索引 K 取出起始单词，加入结果串
2. **循环接龙**：
   - 获取当前单词的尾字母
   - 在剩余单词中找所有以该字母开头的单词
   - 按规则选择：长度最长 > 字典序最小
   - 将选中的单词拼接到结果串，并从候选中移除
3. **终止条件**：没有符合条件的单词时结束

**选词规则优先级**：
1. 首字母必须等于前一个单词的尾字母
2. 优先选长度最长的
3. 长度相同时选字典序最小的

**时间复杂度**：O(n² × m)，n 为单词数，m 为单词平均长度`,o=JSON.parse(`{"java":"import java.util.*;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        \\n        // 输入起始单词的索引\\n        int startIndex = Integer.parseInt(scanner.nextLine());\\n        \\n        // 输入单词的个数\\n        int number = Integer.parseInt(scanner.nextLine());\\n        \\n        // 创建一个存储单词的列表\\n        List<String> wordList = new ArrayList<>();\\n        \\n        // 循环读取单词并添加到列表中\\n        for (int i = 0; i < number; i++) {\\n            wordList.add(scanner.nextLine());\\n        }\\n        \\n        // 初始化结果字符串为起始单词\\n        String result = wordList.get(startIndex);\\n        \\n        // 从列表中移除起始单词\\n        wordList.remove(startIndex);\\n        \\n        // 获取下一个符合条件的单词\\n        String nextWord = getNextWord(wordList, result.charAt(result.length() - 1));\\n        \\n        // 循环直到没有符合条件的单词为止\\n        while (nextWord != null) {\\n            // 拼接下一个单词到结果字符串\\n            result += nextWord;\\n            \\n            // 从列表中移除已使用的单词\\n            wordList.remove(nextWord);\\n            \\n            // 获取下一个符合条件的单词\\n            nextWord = getNextWord(wordList, result.charAt(result.length() - 1));\\n        }\\n        \\n        // 输出最终拼接的单词串\\n        System.out.println(result);\\n    }\\n\\n    public static String getNextWord(List<String> wordList, char suffix) {\\n        // 创建一个映射表，键为单词的首字母，值为以该首字母开头的单词列表\\n        Map<Character, List<String>> map = new HashMap<>();\\n        \\n        // 遍历单词列表，将单词按首字母分类存储到映射表中\\n        for (String word : wordList) {\\n            char firstChar = word.charAt(0);\\n            List<String> tempList = map.getOrDefault(firstChar, new ArrayList<>());\\n            tempList.add(word);\\n            map.put(firstChar, tempList);\\n        }\\n        \\n        // 初始化最长长度和字典序最小的单词\\n        int maxLength = 0;\\n        String minWord = \\"\\";\\n        \\n        // 获取以suffix为首字母的单词列表\\n        List<String> tempList = map.get(suffix);\\n        \\n        // 如果列表为空，则没有符合条件的单词，返回null\\n        if (tempList == null || tempList.isEmpty()) {\\n            return null;\\n        }\\n        \\n        // 遍历单词列表，找到最长长度和字典序最小的单词\\n        for (String word : tempList) {\\n            if (word.length() > maxLength || (word.length() == maxLength && word.compareTo(minWord) < 0)) {\\n                maxLength = word.length();\\n                minWord = word;\\n            }\\n        }\\n        \\n        // 如果最小单词为空，则没有符合条件的单词，返回null\\n        return minWord.isEmpty() ? null : minWord;\\n    }\\n}","python":"import sys\\n\\ndef getNextWord(wordList, suffix):\\n    # 创建一个映射表，键为单词的首字母，值为以该首字母开头的单词列表\\n    map = {}\\n    \\n    # 遍历单词列表，将单词按首字母分类存储到映射表中\\n    for word in wordList:\\n        firstChar = word[0]\\n        tempList = map.get(firstChar, [])\\n        tempList.append(word)\\n        map[firstChar] = tempList\\n    \\n    # 初始化最长长度和字典序最小的单词\\n    maxLength = 0\\n    minWord = \\"\\"\\n    \\n    # 获取以suffix为首字母的单词列表\\n    tempList = map.get(suffix)\\n    \\n    # 如果列表为空，则没有符合条件的单词，返回None\\n    if not tempList:\\n        return None\\n    \\n    # 遍历单词列表，找到最长长度和字典序最小的单词\\n    for word in tempList:\\n        if len(word) > maxLength or (len(word) == maxLength and word < minWord):\\n            maxLength = len(word)\\n            minWord = word\\n    \\n    # 如果最小单词为空，则没有符合条件的单词，返回None\\n    return minWord if minWord else None\\n\\nif __name__ == \\"__main__\\":\\n    # 输入起始单词的索引\\n    startIndex = int(input())\\n    \\n    # 输入单词的个数\\n    number = int(input())\\n    \\n    # 创建一个存储单词的列表\\n    wordList = [input().strip() for _ in range(number)]\\n\\n    \\n    # 初始化结果字符串为起始单词\\n    result = wordList[startIndex]\\n    \\n    # 从列表中移除起始单词\\n    wordList.pop(startIndex)\\n    \\n    # 获取下一个符合条件的单词\\n    nextWord = getNextWord(wordList, result[-1])\\n    \\n    # 循环直到没有符合条件的单词为止\\n    while nextWord:\\n        # 拼接下一个单词到结果字符串\\n        result += nextWord\\n        \\n        # 从列表中移除已使用的单词\\n        wordList.remove(nextWord)\\n        \\n        # 获取下一个符合条件的单词\\n        nextWord = getNextWord(wordList, result[-1])\\n    \\n    # 输出最终拼接的单词串\\n    print(result)","javascript":"const readline = require('readline');\\n\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\n// 根据当前单词列表和后缀字母获取下一个单词\\nfunction getNextWord(wordList, suffix) {\\n    let map = {};\\n    \\n    // 将单词按首字母分组存储在map中\\n    for (let word of wordList) {\\n        let firstChar = word[0];\\n        let tempList = map[firstChar] || [];\\n        tempList.push(word);\\n        map[firstChar] = tempList;\\n    }\\n    \\n    let maxLength = 0;\\n    let minWord = \\"\\";\\n    \\n    // 获取与后缀字母相同的单词列表\\n    let tempList = map[suffix];\\n    \\n    if (!tempList) {\\n        return null;\\n    }\\n    \\n    // 遍历单词列表，找到长度最长且字典序最小的单词\\n    for (let word of tempList) {\\n        if (word.length > maxLength || (word.length === maxLength && word < minWord)) {\\n            maxLength = word.length;\\n            minWord = word;\\n        }\\n    }\\n    \\n    return minWord || null;\\n}\\n\\nlet startIndex = -1;\\nlet number = -1;\\nlet wordList = [];\\nlet count = 0;\\n\\nrl.on(\\"line\\", (line) => {\\n    // 读取输入的起始单词索引\\n    if(startIndex ===-1){\\n        startIndex = parseInt(line);\\n    }\\n    // 读取输入的单词个数\\n    else if(number ===-1 ){\\n        number = parseInt(line);\\n    }\\n    // 读取输入的单词列表\\n    else{\\n        wordList.push(line.trim());\\n        count++;\\n\\n        // 当读取完所有单词时，开始进行单词接龙\\n        if (count === number) {\\n            rl.close();\\n\\n            let result = wordList[startIndex];\\n            wordList.splice(startIndex, 1);\\n\\n            let nextWord = getNextWord(wordList, result[result.length - 1]);\\n\\n            // 循环找到下一个单词并拼接到结果中，直到找不到下一个单词为止\\n            while (nextWord) {\\n                result += nextWord;\\n                wordList.splice(wordList.indexOf(nextWord), 1);\\n                nextWord = getNextWord(wordList, result[result.length - 1]);\\n            }\\n\\n            console.log(result);\\n        }\\n    }\\n});","cpp":"#include <iostream>\\n#include <vector>\\n#include <map>\\n#include <algorithm>\\nusing namespace std;\\n\\nstring getNextWord(vector<string>& wordList, char suffix) {\\n    // 创建一个映射表，键为单词的首字母，值为以该首字母开头的单词列表\\n    map<char, vector<string>> wordMap;\\n    \\n    // 遍历单词列表，将单词按首字母分类存储到映射表中\\n    for (string word : wordList) {\\n        char firstChar = word[0];\\n        vector<string>& tempList = wordMap[firstChar];\\n        tempList.push_back(word);\\n    }\\n    \\n    // 初始化最长长度和字典序最小的单词\\n    int maxLength = 0;\\n    string minWord = \\"\\";\\n    \\n    // 获取以suffix为首字母的单词列表\\n    vector<string>& tempList = wordMap[suffix];\\n    \\n    // 如果列表为空，则没有符合条件的单词，返回空字符串\\n    if (tempList.empty()) {\\n        return \\"\\";\\n    }\\n    \\n    // 遍历单词列表，找到最长长度和字典序最小的单词\\n    for (string word : tempList) {\\n        if (word.length() > maxLength || (word.length() == maxLength && word.compare(minWord) < 0)) {\\n            maxLength = word.length();\\n            minWord = word;\\n        }\\n    }\\n    \\n    // 如果最小单词为空，则没有符合条件的单词，返回空字符串\\n    return minWord.empty() ? \\"\\" : minWord;\\n}\\n\\nint main() {\\n    // 输入起始单词的索引\\n    int startIndex;\\n    cin >> startIndex;\\n    \\n    // 输入单词的个数\\n    int number;\\n    cin >> number;\\n    \\n    // 创建一个存储单词的列表\\n    vector<string> wordList;\\n    \\n    // 循环读取单词并添加到列表中\\n    for (int i = 0; i < number; i++) {\\n        string word;\\n        cin >> word;\\n        wordList.push_back(word);\\n    }\\n    \\n    // 初始化结果字符串为起始单词\\n    string result = wordList[startIndex];\\n    \\n    // 从列表中移除起始单词\\n    wordList.erase(wordList.begin() + startIndex);\\n    \\n    // 获取下一个符合条件的单词\\n    string nextWord = getNextWord(wordList, result[result.length() - 1]);\\n    \\n    // 循环直到没有符合条件的单词为止\\n    while (!nextWord.empty()) {\\n        // 拼接下一个单词到结果字符串\\n        result += nextWord;\\n        \\n        // 从列表中移除已使用的单词\\n        wordList.erase(remove(wordList.begin(), wordList.end(), nextWord), wordList.end());\\n        \\n        // 获取下一个符合条件的单词\\n        nextWord = getNextWord(wordList, result[result.length() - 1]);\\n    }\\n    \\n    // 输出最终拼接的单词串\\n    cout << result << endl;\\n    \\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n// 定义一个宏来表示最大单词数量\\n#define MAX_WORDS 20\\n// 定义一个宏来表示最大单词长度\\n#define MAX_WORD_LENGTH 30\\n\\n// 函数声明\\nchar* getNextWord(char** wordList, int* wordCount, char suffix);\\n\\nint main() {\\n    // 定义变量来存储起始索引和单词数量\\n    int startIndex, number;\\n    \\n    // 输入起始单词的索引\\n    scanf(\\"%d\\", &startIndex);\\n    \\n    // 输入单词的个数\\n    scanf(\\"%d\\", &number);\\n    \\n    // 创建一个存储单词的数组\\n    char* wordList[MAX_WORDS];\\n    for (int i = 0; i < number; i++) {\\n        // 为每个单词分配空间\\n        wordList[i] = (char*)malloc((MAX_WORD_LENGTH + 1) * sizeof(char));\\n        // 读取每个单词\\n        scanf(\\"%s\\", wordList[i]);\\n    }\\n    \\n    // 初始化结果字符串为起始单词\\n    char result[MAX_WORDS * (MAX_WORD_LENGTH + 1)] = \\"\\"; // 最大可能长度\\n    strcpy(result, wordList[startIndex]);\\n    \\n    // 将起始单词从数组中移除\\n    free(wordList[startIndex]);\\n    for (int i = startIndex; i < number - 1; i++) {\\n        wordList[i] = wordList[i + 1];\\n    }\\n    number--; // 减少单词计数\\n    \\n    // 获取下一个符合条件的单词\\n    char nextWord[MAX_WORD_LENGTH + 1];\\n    char* nextWordPtr = getNextWord(wordList, &number, result[strlen(result) - 1]);\\n    \\n    // 循环直到没有符合条件的单词为止\\n    while (nextWordPtr != NULL) {\\n        // 拼接下一个单词到结果字符串\\n        strcat(result, nextWordPtr);\\n        \\n        // 从数组中移除已使用的单词\\n        for (int i = 0; i < number; i++) {\\n            if (strcmp(wordList[i], nextWordPtr) == 0) {\\n                free(wordList[i]);\\n                for (int j = i; j < number - 1; j++) {\\n                    wordList[j] = wordList[j + 1];\\n                }\\n                number--; // 减少单词计数\\n                break;\\n            }\\n        }\\n        \\n        // 获取下一个符合条件的单词\\n        nextWordPtr = getNextWord(wordList, &number, result[strlen(result) - 1]);\\n    }\\n    \\n    // 输出最终拼接的单词串\\n    printf(\\"%s\\\\n\\", result);\\n    \\n    // 释放所有剩余单词的内存\\n    for (int i = 0; i < number; i++) {\\n        free(wordList[i]);\\n    }\\n    \\n    return 0;\\n}\\n\\n// 获取下一个符合条件的单词\\nchar* getNextWord(char** wordList, int* wordCount, char suffix) {\\n    int maxLength = 0; // 用于存储最长的单词长度\\n    char* minWord = NULL; // 用于存储字典序最小的单词\\n    \\n    // 遍历单词列表\\n    for (int i = 0; i < *wordCount; i++) {\\n        if (wordList[i][0] == suffix) { // 如果单词的首字母与给定的suffix相同\\n            int wordLength = strlen(wordList[i]);\\n            // 找到最长长度和字典序最小的单词\\n            if (wordLength > maxLength || \\n                (wordLength == maxLength && (minWord == NULL || strcmp(wordList[i], minWord) < 0))) {\\n                maxLength = wordLength;\\n                minWord = wordList[i];\\n            }\\n        }\\n    }\\n    \\n    // 返回找到的符合条件的单词或NULL\\n    return minWord;\\n}"}`),u={id:"15",title:n,examType:"A",score:100,description:t,inputDesc:r,outputDesc:e,examples:i,solution:d,codes:o};export{o as codes,u as default,t as description,a as examType,i as examples,s as id,r as inputDesc,e as outputDesc,m as score,d as solution,n as title};
