const a="22",p="手机App防沉迷系统",A="A",m=100,n=`智能手机方便了我们生活的同时，也侵占了我们不少的时间。“手机App防沉迷系统”能够让我们每天合理地规划手机App使用时间，在正确的时间做正确的事。
它的大概原理是这样的：
在一天24小时内，可以注册每个App的允许使用时段一个时间段只能使用一个AppApp有优先级，数值越高，优先级越高。注册使用时段时，如果高优先级的App时间和低优先级的时段有冲突，则系统会自动注销低优先级的时段，如果App的优先级相同，则后添加的App不能注册。
请编程实现，根据输入数据注册App，并根据输入的时间点，返回时间点使用的App名称，如果该时间点没有注册任何App，请返回字符串“NA”。`,e=`第一行表示注册的App数量 N（N ≤ 100）
第二部分包括 N 行，每行表示一条App注册数据
最后一行输入一个时间点，程序即返回该时间点使用的App
2 App1 1 09:00 10:00 App2 2 11:00 11:30 09:30
数据说明如下：
N行注册数据以空格分隔，四项数依次表示：App名称、优先级、起始时间、结束时间优先级1~5，数字越大，优先级越高时间格式 HH:MM，小时和分钟都是两位，不足两位前面补0起始时间需小于结束时间，否则注册不上注册信息中的时间段包含起始时间点，不包含结束时间点`,i="输出一个字符串，表示App名称，或NA表示空闲时间",t=[{input:`1
App1 1 09:00 10:00
09:30`,output:"App1",explanation:"只有1个App注册。App1注册在9:00-10:00，查询时间09:30在范围内，输出App1。"},{input:`2
App1 1 09:00 10:00
App2 2 09:10 09:30
09:20`,output:"App2",explanation:`App1(优先级1)和App2(优先级2)时段有冲突。
App2优先级更高，App1被注销。
查询09:20在App2范围内(09:10-09:30)，输出App2。`},{input:`2
App1 1 09:00 10:00
App2 2 09:10 09:30
09:50`,output:"NA",explanation:"App1被App2注销后，09:50不在任何已注册App的时段内，输出NA。"}],r=`**解题思路：**

本题是一道**区间覆盖 + 优先级处理**问题。

**算法步骤：**

1. **逐个注册App**：按输入顺序处理每个App
2. **检查时间冲突**：对于新App，检查与已注册App的时间是否重叠
3. **优先级处理**：
   - 新App优先级更高：注销低优先级的冲突App
   - 新App优先级相同或更低：新App不能注册（跳过）
4. **查询时间**：遍历已注册App，找出包含查询时间的App

**时间冲突判断**：两个区间 [s1,e1) 和 [s2,e2) 重叠的条件是 max(s1,s2) < min(e1,e2)

**注意**：时间段包含起始时间，不包含结束时间（左闭右开区间）

**时间复杂度**：O(N²)`,s=JSON.parse(`{"java":"import java.util.ArrayList;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n    // 定义App类，用于存储App的相关信息\\n    static class App {\\n        String name; // App名称\\n        int priority; // App优先级\\n        int startTime; // App允许使用的起始时间（以分钟为单位）\\n        int endTime; // App允许使用的结束时间（以分钟为单位）\\n\\n        // App类的构造函数，用于创建App对象\\n        public App(String name, int priority, int startTime, int endTime) {\\n            this.name = name;\\n            this.priority = priority;\\n            this.startTime = startTime;\\n            this.endTime = endTime;\\n        }\\n    }\\n\\n    // 主函数\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in); // 创建Scanner对象，用于读取标准输入\\n        int n = sc.nextInt(); // 读取App数量\\n\\n        ArrayList<App> apps = new ArrayList<>(); // 创建App列表，用于存储所有App\\n        for (int i = 0; i < n; i++) {\\n            // 循环读取每个App的信息，并创建App对象添加到列表中\\n            String appName = sc.next();\\n            int appPriority = sc.nextInt();\\n            int appStartTime = convertTime(sc.next());\\n            int appEndTime = convertTime(sc.next());\\n            apps.add(new App(appName, appPriority, appStartTime, appEndTime));\\n        }\\n\\n        int queryTime = convertTime(sc.next()); // 读取查询时间，并转换为分钟\\n        String appAtTime = \\"NA\\"; // 初始化查询时间对应的App名称为\\"NA\\"\\n\\n        // 创建已注册App列表\\n        ArrayList<App> registeredApps = new ArrayList<>();\\n        for (App app : apps) {\\n            if (app.startTime >= app.endTime) continue; // 如果起始时间不小于结束时间，则跳过\\n\\n            // 遍历已注册的App列表，检查时间冲突\\n            for (int i = registeredApps.size() - 1; i >= 0; i--) {\\n                App registered = registeredApps.get(i);\\n                // 如果存在时间冲突\\n                if (Math.max(app.startTime, registered.startTime) < Math.min(app.endTime, registered.endTime)) {\\n                    // 如果当前App的优先级高于已注册App的优先级\\n                    if (app.priority > registered.priority) {\\n                        registeredApps.remove(i); // 注销低优先级的App\\n                    } else {\\n                        continue; // 如果优先级不高，继续检查下一个已注册App\\n                    }\\n                }\\n            }\\n\\n            // 将当前App添加到已注册App列表中\\n            registeredApps.add(app);\\n        }\\n\\n        // 遍历已注册App列表，找到查询时间对应的App\\n        for (App app : registeredApps) {\\n            if (queryTime >= app.startTime && queryTime < app.endTime) {\\n                appAtTime = app.name; // 更新查询时间对应的App名称\\n                break; // 找到后退出循环\\n            }\\n        }\\n\\n        System.out.println(appAtTime); // 输出查询时间对应的App名称\\n    }\\n\\n    // 时间转换函数，将时间字符串转换为以分钟为单位的整数\\n    private static int convertTime(String time) {\\n        String[] parts = time.split(\\":\\"); // 将时间字符串按照\\":\\"分割\\n        return Integer.parseInt(parts[0]) * 60 + Integer.parseInt(parts[1]); // 将小时和分钟转换为分钟\\n    }\\n}","python":"class App:\\n    \\"\\"\\"定义App类，用于存储App的相关信息\\"\\"\\"\\n\\n    def __init__(self, name, priority, start_time, end_time):\\n        self.name = name  # App名称\\n        self.priority = priority  # App优先级\\n        self.start_time = start_time  # App允许使用的起始时间（以分钟为单位）\\n        self.end_time = end_time  # App允许使用的结束时间（以分钟为单位）\\n\\ndef convert_time(time_str):\\n    \\"\\"\\"\\n    时间转换函数，将时间字符串转换为以分钟为单位的整数\\n    :param time_str: 时间字符串，格式为\\"小时:分钟\\"\\n    :return: 转换后的分钟数\\n    \\"\\"\\"\\n    hours, minutes = map(int, time_str.split(\\":\\"))  # 将时间字符串按照\\":\\"分割并转换为整数\\n    return hours * 60 + minutes  # 将小时和分钟转换为分钟\\n\\ndef main():\\n    n = int(input())  # 读取App数量\\n    apps = []  # 创建App列表，用于存储所有App\\n\\n    for _ in range(n):\\n        # 循环读取每个App的信息，并创建App对象添加到列表中\\n        app_name, app_priority, app_start_time, app_end_time = input().split()\\n        app_priority = int(app_priority)\\n        app_start_time = convert_time(app_start_time)\\n        app_end_time = convert_time(app_end_time)\\n        apps.append(App(app_name, app_priority, app_start_time, app_end_time))\\n\\n    query_time = convert_time(input())  # 读取查询时间，并转换为分钟\\n    app_at_time = \\"NA\\"  # 初始化查询时间对应的App名称为\\"NA\\"\\n\\n    # 创建已注册App列表\\n    registered_apps = []\\n    for app in apps:\\n        if app.start_time >= app.end_time:\\n            continue  # 如果起始时间不小于结束时间，则跳过\\n\\n        # 遍历已注册的App列表，检查时间冲突\\n        for i in range(len(registered_apps) - 1, -1, -1):\\n            registered = registered_apps[i]\\n            # 如果存在时间冲突\\n            if max(app.start_time, registered.start_time) < min(app.end_time, registered.end_time):\\n                # 如果当前App的优先级高于已注册App的优先级\\n                if app.priority > registered.priority:\\n                    registered_apps.pop(i)  # 注销低优先级的App\\n                else:\\n                    continue  # 如果优先级不高，继续检查下一个已注册App\\n\\n        # 将当前App添加到已注册App列表中\\n        registered_apps.append(app)\\n\\n    # 遍历已注册App列表，找到查询时间对应的App\\n    for app in registered_apps:\\n        if query_time >= app.start_time and query_time < app.end_time:\\n            app_at_time = app.name  # 更新查询时间对应的App名称\\n            break  # 找到后退出循环\\n\\n    print(app_at_time)  # 输出查询时间对应的App名称\\n\\nif __name__ == \\"__main__\\":\\n    main()","javascript":"const readline = require('readline');\\n\\n// 定义App类，用于存储App的相关信息\\nclass App {\\n  constructor(name, priority, startTime, endTime) {\\n    this.name = name; // App名称\\n    this.priority = priority; // App优先级\\n    this.startTime = startTime; // App允许使用的起始时间（以分钟为单位）\\n    this.endTime = endTime; // App允许使用的结束时间（以分钟为单位）\\n  }\\n}\\n\\n// 创建readline接口实例\\nconst rl = readline.createInterface({\\n  input: process.stdin,\\n  output: process.stdout\\n});\\n\\n// 用于存储输入行的数组\\nconst lines = [];\\n// 读取输入\\nrl.on('line', (line) => {\\n  lines.push(line);\\n}).on('close', () => {\\n  // 当输入完成后开始处理数据\\n  processInput(lines);\\n});\\n\\n// 处理输入数据的函数\\nfunction processInput(lines) {\\n  const n = parseInt(lines.shift()); // 读取App数量\\n  const apps = []; // 创建App列表，用于存储所有App\\n\\n  for (let i = 0; i < n; i++) {\\n    // 循环读取每个App的信息，并创建App对象添加到列表中\\n    const [appName, appPriority, appStartTime, appEndTime] = lines.shift().split(' ');\\n    apps.push(new App(appName, parseInt(appPriority), convertTime(appStartTime), convertTime(appEndTime)));\\n  }\\n\\n  const queryTime = convertTime(lines.shift()); // 读取查询时间，并转换为分钟\\n  let appAtTime = \\"NA\\"; // 初始化查询时间对应的App名称为\\"NA\\"\\n\\n  // 创建已注册App列表\\n  const registeredApps = [];\\n  for (const app of apps) {\\n    if (app.startTime >= app.endTime) continue; // 如果起始时间不小于结束时间，则跳过\\n\\n    // 遍历已注册的App列表，检查时间冲突\\n    for (let i = registeredApps.length - 1; i >= 0; i--) {\\n      const registered = registeredApps[i];\\n      // 如果存在时间冲突\\n      if (Math.max(app.startTime, registered.startTime) < Math.min(app.endTime, registered.endTime)) {\\n        // 如果当前App的优先级高于已注册App的优先级\\n        if (app.priority > registered.priority) {\\n          registeredApps.splice(i, 1); // 注销低优先级的App\\n        } else {\\n          continue; // 如果优先级不高，继续检查下一个已注册App\\n        }\\n      }\\n    }\\n\\n    // 将当前App添加到已注册App列表中\\n    registeredApps.push(app);\\n  }\\n\\n  // 遍历已注册App列表，找到查询时间对应的App\\n  for (const app of registeredApps) {\\n    if (queryTime >= app.startTime && queryTime < app.endTime) {\\n      appAtTime = app.name; // 更新查询时间对应的App名称\\n      break; // 找到后退出循环\\n    }\\n  }\\n\\n  console.log(appAtTime); // 输出查询时间对应的App名称\\n}\\n\\n// 时间转换函数，将时间字符串转换为以分钟为单位的整数\\nfunction convertTime(time) {\\n  const [hours, minutes] = time.split(':').map(Number); // 将时间字符串按照\\":\\"分割并转换为数字\\n  return hours * 60 + minutes; // 将小时和分钟转换为分钟\\n}","cpp":"#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <sstream>\\n\\n// 定义App类，用于存储App的相关信息\\nclass App {\\npublic:\\n    std::string name; // App名称\\n    int priority; // App优先级\\n    int startTime; // App允许使用的起始时间（以分钟为单位）\\n    int endTime; // App允许使用的结束时间（以分钟为单位）\\n\\n    // App类的构造函数，用于创建App对象\\n    App(std::string name, int priority, int startTime, int endTime)\\n        : name(name), priority(priority), startTime(startTime), endTime(endTime) {}\\n};\\n\\n// 时间转换函数，将时间字符串转换为以分钟为单位的整数\\nint convertTime(const std::string& time) {\\n    int hours, minutes;\\n    char colon;\\n    std::istringstream iss(time);\\n    iss >> hours >> colon >> minutes; // 将时间字符串按照\\":\\"分割并转换为小时和分钟\\n    return hours * 60 + minutes; // 将小时和分钟转换为分钟\\n}\\n\\nint main() {\\n    int n; // 读取App数量\\n    std::cin >> n;\\n\\n    std::vector<App> apps; // 创建App列表，用于存储所有App\\n    for (int i = 0; i < n; i++) {\\n        // 循环读取每个App的信息，并创建App对象添加到列表中\\n        std::string appName;\\n        int appPriority, appStartTime, appEndTime;\\n        std::string startTimeStr, endTimeStr;\\n        std::cin >> appName >> appPriority >> startTimeStr >> endTimeStr;\\n        appStartTime = convertTime(startTimeStr);\\n        appEndTime = convertTime(endTimeStr);\\n        apps.emplace_back(appName, appPriority, appStartTime, appEndTime);\\n    }\\n\\n    std::string queryTimeStr;\\n    std::cin >> queryTimeStr;\\n    int queryTime = convertTime(queryTimeStr); // 读取查询时间，并转换为分钟\\n    std::string appAtTime = \\"NA\\"; // 初始化查询时间对应的App名称为\\"NA\\"\\n\\n    std::vector<App> registeredApps; // 创建已注册App列表\\n    for (const App& app : apps) {\\n        if (app.startTime >= app.endTime) continue; // 如果起始时间不小于结束时间，则跳过\\n\\n        // 遍历已注册的App列表，检查时间冲突\\n        for (int i = registeredApps.size() - 1; i >= 0; --i) {\\n            const App& registered = registeredApps[i];\\n            // 如果存在时间冲突\\n            if (std::max(app.startTime, registered.startTime) < std::min(app.endTime, registered.endTime)) {\\n                // 如果当前App的优先级高于已注册App的优先级\\n                if (app.priority > registered.priority) {\\n                    registeredApps.erase(registeredApps.begin() + i); // 注销低优先级的App\\n                } else {\\n                    continue; // 如果优先级不高，继续检查下一个已注册App\\n                }\\n            }\\n        }\\n\\n        // 将当前App添加到已注册App列表中\\n        registeredApps.push_back(app);\\n    }\\n\\n    // 遍历已注册App列表，找到查询时间对应的App\\n    for (const App& app : registeredApps) {\\n        if (queryTime >= app.startTime && queryTime < app.endTime) {\\n            appAtTime = app.name; // 更新查询时间对应的App名称\\n            break; // 找到后退出循环\\n        }\\n    }\\n\\n    std::cout << appAtTime << std::endl; // 输出查询时间对应的App名称\\n\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\n// 定义App结构体，用于存储App的相关信息\\ntypedef struct {\\n    char name[30]; // App名称\\n    int priority;  // App优先级\\n    int startTime; // App允许使用的起始时间（以分钟为单位）\\n    int endTime;   // App允许使用的结束时间（以分钟为单位）\\n} App;\\n\\n// 时间转换函数，将时间字符串转换为以分钟为单位的整数\\nint convertTime(char *time) {\\n    int hours, minutes;\\n    sscanf(time, \\"%d:%d\\", &hours, &minutes); // 将时间字符串按照\\":\\"分割并转换为整数\\n    return hours * 60 + minutes; // 将小时和分钟转换为分钟\\n}\\n\\nint main() {\\n    int n; // 读取App数量\\n    scanf(\\"%d\\", &n);\\n\\n    App *apps = (App *)malloc(n * sizeof(App)); // 创建App数组，用于存储所有App\\n\\n    for (int i = 0; i < n; i++) {\\n        // 循环读取每个App的信息，并创建App对象添加到数组中\\n        scanf(\\"%s %d\\", apps[i].name, &apps[i].priority);\\n        char startTimeStr[6], endTimeStr[6];\\n        scanf(\\"%s %s\\", startTimeStr, endTimeStr);\\n        apps[i].startTime = convertTime(startTimeStr);\\n        apps[i].endTime = convertTime(endTimeStr);\\n    }\\n\\n    char queryTimeStr[6];\\n    scanf(\\"%s\\", queryTimeStr);\\n    int queryTime = convertTime(queryTimeStr); // 读取查询时间，并转换为分钟\\n    char *appAtTime = \\"NA\\"; // 初始化查询时间对应的App名称为\\"NA\\"\\n\\n    // 创建已注册App数组和计数器\\n    App *registeredApps = (App *)malloc(n * sizeof(App));\\n    int registeredCount = 0;\\n\\n    for (int i = 0; i < n; i++) {\\n        if (apps[i].startTime >= apps[i].endTime) continue; // 如果起始时间不小于结束时间，则跳过\\n\\n        // 遍历已注册的App数组，检查时间冲突\\n        for (int j = registeredCount - 1; j >= 0; j--) {\\n            // 如果存在时间冲突\\n            if (apps[i].startTime < registeredApps[j].endTime && apps[i].endTime > registeredApps[j].startTime) {\\n                // 如果当前App的优先级高于已注册App的优先级\\n                if (apps[i].priority > registeredApps[j].priority) {\\n                    // 注销低优先级的App\\n                    for (int k = j; k < registeredCount - 1; k++) {\\n                        registeredApps[k] = registeredApps[k + 1];\\n                    }\\n                    registeredCount--; // 减少已注册App的计数\\n                } else {\\n                    goto continue_outer; // 如果优先级不高，继续检查下一个已注册App\\n                }\\n            }\\n        }\\n\\n        // 将当前App添加到已注册App数组中\\n        registeredApps[registeredCount++] = apps[i];\\n\\n        continue_outer: ; // 标签用于跳过当前循环\\n    }\\n\\n    // 遍历已注册App数组，找到查询时间对应的App\\n    for (int i = 0; i < registeredCount; i++) {\\n        if (queryTime >= registeredApps[i].startTime && queryTime < registeredApps[i].endTime) {\\n            appAtTime = registeredApps[i].name; // 更新查询时间对应的App名称\\n            break; // 找到后退出循环\\n        }\\n    }\\n\\n    printf(\\"%s\\\\n\\", appAtTime); // 输出查询时间对应的App名称\\n\\n    // 释放动态分配的内存\\n    free(apps);\\n    free(registeredApps);\\n\\n    return 0;\\n}"}`),o={id:"22",title:p,examType:"A",score:100,description:n,inputDesc:e,outputDesc:i,examples:t,solution:r,codes:s};export{s as codes,o as default,n as description,A as examType,t as examples,a as id,e as inputDesc,i as outputDesc,m as score,r as solution,p as title};
