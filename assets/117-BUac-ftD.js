const l="117",n="二叉树计算",a="A",u=200,e=`给出一个二叉树如下图所示：

请由该二叉树生成一个新的二叉树，它满足其树中的每个节点将包含原始树中的左子树和右子树的和。

左子树表示该节点左侧叶子节点为根节点的一颗新树；右子树表示该节点右侧叶子节点为根节点的一颗新树。`,r="2行整数，第1行表示二叉树的中序遍历，第2行表示二叉树的前序遍历，以空格分割。",t="1行整数，表示求和树的中序遍历，以空格分割",i=[{input:`-3 12 6 8 9 -10 -7
12 -3 6 -10 8 9 -7`,output:"0 3 0 7 0 2 0",explanation:"根据中序和前序还原二叉树，每个节点值更新为左右子树之和"}],o=`**解题思路：**

本题是一道**二叉树重建+递归**问题。

**核心思路：**
- 根据中序+前序遍历还原二叉树
- 递归更新每个节点值为左右子树之和
- 最后中序遍历输出结果

**算法步骤：**
1. 前序首元素为根，在中序中定位根的位置
2. 递归构建左右子树
3. 后序遍历更新节点值=左子树和+右子树和
4. 中序遍历输出

**时间复杂度**：O(N²)`,d=JSON.parse(`{"java":"import java.util.*;\\nimport java.util.stream.*;\\n\\npublic class Main {\\n\\n    // 方法：根据中序和前序遍历构造二叉树\\n    // 参数：preorder 前序遍历的结果，inorder 中序遍历的结果\\n    public static TreeNode buildTree(int[] preorder, int[] inorder) {\\n        // 调用辅助方法，传入遍历结果和对应的开始结束索引\\n        return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);\\n    }\\n\\n    // 定义树的节点结构\\n    private static class TreeNode {\\n        int val;  // 节点的值\\n        TreeNode left;  // 左子节点\\n        TreeNode right;  // 右子节点\\n        TreeNode(int x) { val = x; }  // 构造方法\\n    }\\n\\n    // 辅助方法：根据中序和前序遍历的一部分构造子树\\n    private static TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) {\\n        // 如果前序遍历的开始索引大于结束索引，说明这部分遍历结果为空，返回null\\n        if (preStart > preEnd) return null;\\n        \\n        // 创建根节点，值为前序遍历的第一个元素\\n        TreeNode root = new TreeNode(preorder[preStart]);\\n        int inIndex = 0; // 初始化中序遍历中根节点的索引\\n        // 在中序遍历中找到根节点的位置\\n        for (int i = inStart; i <= inEnd; i++) {\\n            if (inorder[i] == root.val) {\\n                inIndex = i;\\n                break;\\n            }\\n        }\\n        \\n        // 计算左子树的大小\\n        int leftTreeSize = inIndex - inStart;\\n        \\n        // 递归构造左子树和右子树\\n        root.left = build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inIndex - 1);\\n        root.right = build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inIndex + 1, inEnd);\\n        \\n        // 返回构造好的根节点\\n        return root;\\n    }\\n\\n    // 方法：更新节点值为其所有子节点的和\\n    // 参数：node 需要更新的节点\\n    private static int updateTree(TreeNode node) {\\n        // 如果节点为空，返回0\\n        if (node == null) return 0;\\n        // 递归更新左子树和右子树，并计算子树的和\\n        int leftSum = updateTree(node.left);\\n        int rightSum = updateTree(node.right);\\n        // 保存当前节点的值\\n        int oldVal = node.val;\\n        // 更新当前节点的值为子树的和\\n        node.val = leftSum + rightSum;\\n        // 返回当前子树的和（包括当前节点原来的值）\\n        return node.val + oldVal;\\n    }\\n\\n    // 方法：中序遍历\\n    // 参数：node 需要遍历的节点，result 保存遍历结果的列表\\n    private static void inorderTraversal(TreeNode node, ArrayList<Integer> result) {\\n        // 如果节点为空，直接返回\\n        if (node == null) return;\\n        // 递归遍历左子树\\n        inorderTraversal(node.left, result);\\n        // 将当前节点的值添加到结果列表\\n        result.add(node.val);\\n        // 递归遍历右子树\\n        inorderTraversal(node.right, result);\\n    }\\n\\n    // 主方法\\n    public static void main(String[] args) {\\n        \\n        Scanner sc = new Scanner(System.in);\\n        // 读取一行输入，分割成字符串数组，转换为整数数组，作为中序遍历的结果\\n        int[] inorder = Arrays.stream(sc.nextLine().split(\\" \\")).mapToInt(Integer::parseInt).toArray();\\n        // 同样处理前序遍历的结果\\n        int[] preorder = Arrays.stream(sc.nextLine().split(\\" \\")).mapToInt(Integer::parseInt).toArray();\\n        // 根据中序和前序遍历的结果构造二叉树\\n        TreeNode root = buildTree(preorder, inorder);\\n        // 更新二叉树的节点值\\n        updateTree(root);\\n        // 创建列表，保存中序遍历的结果\\n        ArrayList<Integer> result = new ArrayList<>();\\n        // 中序遍历二叉树，保存结果\\n        inorderTraversal(root, result);\\n        // 打印遍历结果\\n        result.forEach(value -> System.out.print(value + \\" \\"));\\n    }\\n}","python":"class TreeNode:\\n    def __init__(self, x):\\n        self.val = x  # 节点的值\\n        self.left = None  # 左子节点\\n        self.right = None  # 右子节点\\n\\ndef build_tree(preorder, inorder):\\n    # 根据前序和中序遍历结果构造二叉树\\n    if not preorder or not inorder:\\n        return None\\n    # 前序遍历的第一个值是根节点\\n    root = TreeNode(preorder[0])\\n    # 在中序遍历中找到根节点的索引\\n    mid = inorder.index(preorder[0])\\n    # 递归构造左子树和右子树\\n    root.left = build_tree(preorder[1:mid+1], inorder[:mid])\\n    root.right = build_tree(preorder[mid+1:], inorder[mid+1:])\\n    return root\\n\\ndef update_tree(node):\\n    # 更新节点值为其所有子节点的和\\n    if not node:\\n        return 0\\n    left_sum = update_tree(node.left)\\n    right_sum = update_tree(node.right)\\n    old_val = node.val\\n    node.val = left_sum + right_sum\\n    return node.val + old_val\\n\\ndef inorder_traversal(node):\\n    # 中序遍历\\n    if not node:\\n        return []\\n    return inorder_traversal(node.left) + [node.val] + inorder_traversal(node.right)\\n\\nif __name__ == '__main__':\\n    # 输入中序和前序遍历的结果\\n    inorder = list(map(int, input().split()))\\n    preorder = list(map(int, input().split()))\\n    # 构造二叉树\\n    root = build_tree(preorder, inorder)\\n    # 更新二叉树的节点值\\n    update_tree(root)\\n    # 进行中序遍历并打印结果\\n    print(' '.join(map(str, inorder_traversal(root))))","javascript":"class TreeNode {\\n    constructor(x) {\\n        this.val = x;  // 节点的值\\n        this.left = null;  // 左子节点\\n        this.right = null;  // 右子节点\\n    }\\n}\\n\\nfunction buildTree(preorder, inorder) {\\n    // 根据前序和中序遍历结果构造二叉树\\n    if (!preorder.length || !inorder.length) {\\n        return null;\\n    }\\n    let root = new TreeNode(preorder[0]);\\n    let mid = inorder.indexOf(preorder[0]);\\n    root.left = buildTree(preorder.slice(1, mid + 1), inorder.slice(0, mid));\\n    root.right = buildTree(preorder.slice(mid + 1), inorder.slice(mid + 1));\\n    return root;\\n}\\n\\nfunction updateTree(node) {\\n    // 更新节点值为其所有子节点的和\\n    if (!node) {\\n        return 0;\\n    }\\n    let leftSum = updateTree(node.left);\\n    let rightSum = updateTree(node.right);\\n    let oldVal = node.val;\\n    node.val = leftSum + rightSum;\\n    return node.val + oldVal;\\n}\\n\\nfunction inorderTraversal(node) {\\n    // 中序遍历\\n    if (!node) {\\n        return [];\\n    }\\n    return inorderTraversal(node.left).concat([node.val]).concat(inorderTraversal(node.right));\\n}\\n\\nlet readline = require('readline');\\nlet rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\nlet lines = [];\\nrl.on('line', function (line) {\\n    lines.push(line);\\n    if (lines.length === 2) {\\n        rl.close();\\n    }\\n});\\n\\nrl.on('close', function () {\\n    let inorder = lines[0].split(' ').map(Number);\\n    let preorder = lines[1].split(' ').map(Number);\\n    let root = buildTree(preorder, inorder);\\n    updateTree(root);\\n    console.log(inorderTraversal(root).join(' '));\\n});","cpp":"#include <iostream>\\n#include <vector>\\n#include <sstream>\\n\\nusing namespace std;\\n// 定义树的节点结构\\nstruct TreeNode {\\n    int val;  // 节点的值\\n    TreeNode* left;  // 左子节点\\n    TreeNode* right;  // 右子节点\\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}  // 构造方法\\n};\\n\\n// 辅助函数：根据中序和前序遍历的一部分构造子树\\nTreeNode* build(vector<int>& preorder, int preStart, int preEnd, vector<int>& inorder, int inStart, int inEnd) {\\n    // 如果前序遍历的开始索引大于结束索引，说明这部分遍历结果为空，返回null\\n    if (preStart > preEnd) return nullptr;\\n    \\n    // 创建根节点，值为前序遍历的第一个元素\\n    TreeNode* root = new TreeNode(preorder[preStart]);\\n    int inIndex = 0; // 初始化中序遍历中根节点的索引\\n    // 在中序遍历中找到根节点的位置\\n    for (int i = inStart; i <= inEnd; i++) {\\n        if (inorder[i] == root->val) {\\n            inIndex = i;\\n            break;\\n        }\\n    }\\n    \\n    // 计算左子树的大小\\n    int leftTreeSize = inIndex - inStart;\\n    \\n    // 递归构造左子树和右子树\\n    root->left = build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inIndex - 1);\\n    root->right = build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inIndex + 1, inEnd);\\n    \\n    // 返回构造好的根节点\\n    return root;\\n}\\n\\n// 方法：根据中序和前序遍历构造二叉树\\n// 参数：preorder 前序遍历的结果，inorder 中序遍历的结果\\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n    // 调用辅助方法，传入遍历结果和对应的开始结束索引\\n    return build(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);\\n}\\n\\n// 方法：更新节点值为其所有子节点的和\\n// 参数：node 需要更新的节点\\nint updateTree(TreeNode* node) {\\n    // 如果节点为空，返回0\\n    if (node == nullptr) return 0;\\n    // 递归更新左子树和右子树，并计算子树的和\\n    int leftSum = updateTree(node->left);\\n    int rightSum = updateTree(node->right);\\n    // 保存当前节点的值\\n    int oldVal = node->val;\\n    // 更新当前节点的值为子树的和\\n    node->val = leftSum + rightSum;\\n    // 返回当前子树的和（包括当前节点原来的值）\\n    return node->val + oldVal;\\n}\\n\\n// 方法：中序遍历\\n// 参数：node 需要遍历的节点，result 保存遍历结果的列表\\nvoid inorderTraversal(TreeNode* node, vector<int>& result) {\\n    // 如果节点为空，直接返回\\n    if (node == nullptr) return;\\n    // 递归遍历左子树\\n    inorderTraversal(node->left, result);\\n    // 将当前节点的值添加到结果列表\\n    result.push_back(node->val);\\n    // 递归遍历右子树\\n    inorderTraversal(node->right, result);\\n}\\n\\n// 主函数\\nint main() {\\n    string line;\\n    vector<int> inorder;\\n    vector<int> preorder;\\n\\n    // 读取一行输入，分割成字符串数组，转换为整数数组，作为中序遍历的结果\\n    getline(cin, line);\\n    istringstream iss(line);\\n    int num;\\n    while (iss >> num) {\\n        inorder.push_back(num);\\n    }\\n\\n    // 同样处理前序遍历的结果\\n    getline(cin, line);\\n    istringstream iss2(line);\\n    while (iss2 >> num) {\\n        preorder.push_back(num);\\n    }\\n\\n    // 根据中序和前序遍历的结果构造二叉树\\n    TreeNode* root = buildTree(preorder, inorder);\\n    // 更新二叉树的节点值\\n    updateTree(root);\\n    // 创建列表，保存中序遍历的结果\\n    vector<int> result;\\n    // 中序遍历二叉树，保存结果\\n    inorderTraversal(root, result);\\n    // 打印遍历结果\\n    for (int i : result) {\\n        cout << i << \\" \\";\\n    }\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n// 定义树的节点结构体\\ntypedef struct TreeNode {\\n    int val;  // 节点的值\\n    struct TreeNode* left;  // 左子节点\\n    struct TreeNode* right;  // 右子节点\\n} TreeNode;\\n\\n// 创建一个新的树节点\\nTreeNode* newTreeNode(int x) {\\n    TreeNode* node = (TreeNode*)malloc(sizeof(TreeNode));  // 分配内存\\n    node->val = x;  // 设置节点的值\\n    node->left = NULL;  // 设置左子节点为空\\n    node->right = NULL;  // 设置右子节点为空\\n    return node;  // 返回新创建的节点\\n}\\n\\n// 根据前序和中序遍历结果构建子树\\nTreeNode* build(int* preorder, int preStart, int preEnd, int* inorder, int inStart, int inEnd) {\\n    if (preStart > preEnd) return NULL;  // 如果前序遍历的开始位置大于结束位置，说明子树为空，返回NULL\\n    \\n    // 创建根节点，根节点的值就是前序遍历的第一个元素\\n    TreeNode* root = newTreeNode(preorder[preStart]);\\n    int inIndex = 0;  // 初始化中序遍历中根节点的位置\\n    // 在中序遍历中找到根节点的位置\\n    for (int i = inStart; i <= inEnd; i++) {\\n        if (inorder[i] == root->val) {\\n            inIndex = i;\\n            break;\\n        }\\n    }\\n    \\n    // 计算左子树的大小\\n    int leftTreeSize = inIndex - inStart;\\n    // 递归构建左子树和右子树\\n    root->left = build(preorder, preStart + 1, preStart + leftTreeSize, inorder, inStart, inIndex - 1);\\n    root->right = build(preorder, preStart + leftTreeSize + 1, preEnd, inorder, inIndex + 1, inEnd);\\n    \\n    return root;  // 返回构建好的子树\\n}\\n\\n// 根据前序和中序遍历结果构建二叉树\\nTreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {\\n    return build(preorder, 0, preorderSize - 1, inorder, 0, inorderSize - 1);  // 调用build函数\\n}\\n\\n// 更新树的节点值为其子树之和\\nint updateTree(TreeNode* node) {\\n    if (node == NULL) return 0;  // 如果节点为空，返回0\\n    // 递归更新左子树和右子树，并计算子树的和\\n    int leftSum = updateTree(node->left);\\n    int rightSum = updateTree(node->right);\\n    // 保存当前节点的值\\n    int oldVal = node->val;\\n    // 更新当前节点的值为子树的和\\n    node->val = leftSum + rightSum;\\n    // 返回当前子树的和（包括当前节点原来的值）\\n    return node->val + oldVal;\\n}\\n\\n// 中序遍历\\nvoid inorderTraversal(TreeNode* node, int* result, int* resultSize) {\\n    if (node == NULL) return;  // 如果节点为空，直接返回\\n    // 递归遍历左子树\\n    inorderTraversal(node->left, result, resultSize);\\n    // 将当前节点的值添加到结果数组\\n    result[(*resultSize)++] = node->val;\\n    // 递归遍历右子树\\n    inorderTraversal(node->right, result, resultSize);\\n}\\n\\n// 主函数\\nint main() {\\n    int preorderSize = 0, inorderSize = 0;  // 初始化前序和中序遍历结果的大小\\n    int preorder[10000], inorder[10000];  // 前序和中序遍历结果数组\\n\\n    // 读取中序遍历结果\\n    while (scanf(\\"%d\\", &inorder[inorderSize++])) {\\n        if (getchar() != ' ') break;  // 如果读取到的不是空格，说明输入结束，跳出循环\\n    }\\n\\n    // 读取前序遍历结果\\n    while (scanf(\\"%d\\", &preorder[preorderSize++])) {\\n        if (getchar() != ' ') break;  // 如果读取到的不是空格，说明输入结束，跳出循环\\n    }\\n\\n    // 根据前序和中序遍历结果构建二叉树\\n    TreeNode* root = buildTree(preorder, preorderSize, inorder, inorderSize);\\n    // 更新二叉树的节点值\\n    updateTree(root);\\n    // 创建数组，保存中序遍历的结果\\n    int result[10000];\\n    int resultSize = 0;\\n    // 中序遍历二叉树，保存结果\\n    inorderTraversal(root, result, &resultSize);\\n    // 打印遍历结果\\n    for (int i = 0; i < resultSize; i++) {\\n        printf(\\"%d \\", result[i]);\\n    }\\n\\n    // 释放分配的内存（在实际应用中应递归释放整个树的节点）\\n    return 0;\\n}"}`),s={id:"117",title:n,examType:"A",score:200,description:e,inputDesc:r,outputDesc:t,examples:i,solution:o,codes:d};export{d as codes,s as default,e as description,a as examType,i as examples,l as id,r as inputDesc,t as outputDesc,u as score,o as solution,n as title};
