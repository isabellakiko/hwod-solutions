const a="60",n="虚拟理财游戏",o="A",u=100,t=`在一款虚拟游戏中生活，你必须进行投资以增强在虚拟游戏中的资产以免被淘汰出局。
现有一家Bank，它提供有若干理财产品 m 个，风险及投资回报不同，你有 N（元）进行投资，能接收的总风险值为X。
你要在可接受范围内选择最优的投资方式获得最大回报。
备注：
在虚拟游戏中，每项投资风险值相加为总风险值；在虚拟游戏中，最多只能投资2个理财产品；在虚拟游戏中，最小单位为整数，不能拆分为小数；投资额*回报率=投资回报`,e=`第一行：产品数m（1-20） 总投资额N（1-10000） 可接受的总风险X（1-200）
第二行：产品投资回报率序列（1-60）
第三行：产品风险值序列（1-100）
第四行：最大投资额度序列（1-10000）`,r="每个产品的投资额序列",i=[{input:`4 100 10
20 30 40 50
4 5 6 10
30 20 40 30`,output:"30 0 40 0",explanation:`4个产品，总投资额100，风险容忍度10。
产品1和3的风险4+6=10≤10，满足条件。
回报率：产品1(20%)和产品3(40%)
优先投资回报率高的产品3：40单位
剩余60投资产品1，但最大额度30：30单位
总回报：30×20+40×40=2200`},{input:`3 50 5
10 20 30
2 3 6
20 30 40`,output:"20 30 0",explanation:`产品3风险6>5不能单独选。
产品1+2风险2+3=5≤5，可以组合。
回报率：产品2(20%)>产品1(10%)
优先投资产品2：min(50,30)=30
剩余20投资产品1：min(20,20)=20
总回报：20×10+30×20=800`}],s=`**解题思路：**

本题是一道**枚举+贪心**问题。

**约束条件：**
- 最多投资2个产品
- 总风险≤X
- 每个产品投资额≤最大额度

**算法步骤：**

1. 枚举单个产品投资情况
2. 枚举两个产品组合
3. 对于两产品组合，优先投资回报率高的产品
4. 记录最大回报对应的投资方案

**时间复杂度**：O(m²)`,m=JSON.parse(`{"java":"import java.util.Arrays;\\nimport java.util.Scanner;\\nimport java.util.StringJoiner;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        // 创建Scanner对象用于获取用户输入\\n        Scanner sc = new Scanner(System.in);\\n        // 读取一行输入并将其分割为字符串数组，然后转换为整数数组\\n        int[] tmp = Arrays.stream(sc.nextLine().split(\\" \\")).mapToInt(Integer::parseInt).toArray();\\n        // 获取投资项目数量m、总投资额N和风险容忍度X\\n        int m = tmp[0];\\n        int N = tmp[1];\\n        int X = tmp[2];\\n        // 读取每个项目的预期回报率\\n        int[] returns = Arrays.stream(sc.nextLine().split(\\" \\")).mapToInt(Integer::parseInt).toArray();\\n        // 读取每个项目的风险值\\n        int[] risks = Arrays.stream(sc.nextLine().split(\\" \\")).mapToInt(Integer::parseInt).toArray();\\n        // 读取每个项目的最大投资额\\n        int[] maxInvestments = Arrays.stream(sc.nextLine().split(\\" \\")).mapToInt(Integer::parseInt).toArray();\\n\\n        // 初始化最大回报为0\\n        int maxReturn = 0;\\n        // 初始化最大回报对应的投资方案数组\\n        int[] bestInvestments = new int[m];\\n\\n        // 遍历所有项目\\n        for (int i = 0; i < m; i++) {\\n            // 如果单个项目的风险在容忍度范围内\\n            if (risks[i] <= X) {\\n                // 计算对项目i的投资额，不超过总投资额N和项目i的最大投资额\\n                int investmentForI = Math.min(N, maxInvestments[i]);\\n                // 计算当前回报\\n                int currentReturn = investmentForI * returns[i];\\n                // 如果当前回报大于已知的最大回报\\n                if (currentReturn > maxReturn) {\\n                    // 更新最大回报\\n                    maxReturn = currentReturn;\\n                    // 重置最佳投资方案数组，并为项目i分配投资额\\n                    bestInvestments = new int[m];\\n                    bestInvestments[i] = investmentForI;\\n                }\\n            }\\n\\n            // 遍历项目i之后的项目，寻找两个项目的组合投资方案\\n            for (int j = i + 1; j < m; j++) {\\n                // 如果两个项目的风险总和在容忍度范围内\\n                if (risks[i] + risks[j] <= X) {\\n                    int investmentForI, investmentForJ;\\n                    // 根据预期回报率决定投资额分配\\n                    if (returns[i] > returns[j]) {\\n                        // 如果项目i的回报率高于项目j，优先投资项目i\\n                        investmentForI = Math.min(N, maxInvestments[i]);\\n                        investmentForJ = Math.min(N - investmentForI, maxInvestments[j]);\\n                    } else {\\n                        // 如果项目j的回报率高于项目i，优先投资项目j\\n                        investmentForJ = Math.min(N, maxInvestments[j]);\\n                        investmentForI = Math.min(N - investmentForJ, maxInvestments[i]);\\n                    }\\n                    // 计算当前两个项目组合的回报\\n                    int currentReturn = investmentForI * returns[i] + investmentForJ * returns[j];\\n                    // 如果当前回报大于已知的最大回报\\n                    if (currentReturn > maxReturn) {\\n                        // 更新最大回报\\n                        maxReturn = currentReturn;\\n                        // 重置最佳投资方案数组，并为两个项目分配投资额\\n                        bestInvestments = new int[m];\\n                        bestInvestments[i] = investmentForI;\\n                        bestInvestments[j] = investmentForJ;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // 创建StringJoiner对象，用于构建输出格式\\n        StringJoiner sj = new StringJoiner(\\" \\");\\n        // 遍历最佳投资方案数组，将投资额添加到StringJoiner中\\n        for (int investment : bestInvestments) {\\n            sj.add(String.valueOf(investment));\\n        }\\n\\n        // 输出最佳投资方案\\n        System.out.println(sj.toString());\\n        // 关闭Scanner对象\\n        sc.close();\\n    }\\n}","python":"import sys\\n\\n# 读取一行输入并将其转换为整数列表的函数\\ndef read_int_array():\\n    # 使用input()替换sys.stdin.readline()以适应在线编译器\\n    return list(map(int, input().split()))\\n\\n# 读取投资项目数量m、总投资额N和风险容忍度X\\nm, N, X = read_int_array()\\n# 读取每个项目的预期回报率\\nreturns = read_int_array()\\n# 读取每个项目的风险值\\nrisks = read_int_array()\\n# 读取每个项目的最大投资额\\nmax_investments = read_int_array()\\n\\n# 初始化最大回报为0\\nmax_return = 0\\n# 初始化最大回报对应的投资方案列表\\nbest_investments = [0] * m\\n\\n# 遍历所有项目\\nfor i in range(m):\\n    # 检查项目i的风险是否在容忍度X以内\\n    if risks[i] <= X:\\n        # 计算项目i的投资额，不超过总投资额N和项目i的最大投资额\\n        investment_for_i = min(N, max_investments[i])\\n        # 计算当前项目的回报\\n        current_return = investment_for_i * returns[i]\\n        # 如果当前回报大于已知的最大回报\\n        if current_return > max_return:\\n            # 更新最大回报\\n            max_return = current_return\\n            # 重置最佳投资方案列表，并为项目i分配投资额\\n            best_investments = [0] * m\\n            best_investments[i] = investment_for_i\\n\\n    # 遍历项目i之后的项目，寻找两个项目的组合投资方案\\n    for j in range(i + 1, m):\\n        # 如果两个项目的风险总和在容忍度范围内\\n        if risks[i] + risks[j] <= X:\\n            # 根据预期回报率决定投资额分配\\n            if returns[i] > returns[j]:\\n                # 如果项目i的回报率高于项目j，优先投资项目i\\n                investment_for_i = min(N, max_investments[i])\\n                # 计算项目j的剩余可投资额\\n                investment_for_j = min(N - investment_for_i, max_investments[j])\\n            else:\\n                # 如果项目j的回报率高于项目i，优先投资项目j\\n                investment_for_j = min(N, max_investments[j])\\n                # 计算项目i的剩余可投资额\\n                investment_for_i = min(N - investment_for_j, max_investments[i])\\n            # 计算两个项目组合的当前回报\\n            current_return = investment_for_i * returns[i] + investment_for_j * returns[j]\\n            # 如果当前回报大于已知的最大回报\\n            if current_return > max_return:\\n                # 更新最大回报\\n                max_return = current_return\\n                # 重置最佳投资方案列表，并为两个项目分配投资额\\n                best_investments = [0] * m\\n                best_investments[i] = investment_for_i\\n                best_investments[j] = investment_for_j\\n\\n# 输出最佳投资方案\\nprint(' '.join(map(str, best_investments)))","javascript":"const readline = require('readline');\\n\\n// 创建readline接口实例\\nconst rl = readline.createInterface({\\n  input: process.stdin,\\n  output: process.stdout\\n});\\n\\n// 用于存储输入行的数组\\nconst lines = [];\\n\\n// 读取输入行的事件监听\\nrl.on('line', (line) => {\\n  lines.push(line);\\n}).on('close', () => {\\n  // 当输入完成时，开始处理数据\\n\\n  // 读取一行输入并将其转换为整数数组的函数\\n  const readIntArray = (line) => line.split(' ').map(Number);\\n\\n  // 读取投资项目数量m、总投资额N和风险容忍度X\\n  const [m, N, X] = readIntArray(lines[0]);\\n  // 读取每个项目的预期回报率\\n  const returns = readIntArray(lines[1]);\\n  // 读取每个项目的风险值\\n  const risks = readIntArray(lines[2]);\\n  // 读取每个项目的最大投资额\\n  const maxInvestments = readIntArray(lines[3]);\\n\\n  // 初始化最大回报为0\\n  let maxReturn = 0;\\n  // 初始化最大回报对应的投资方案数组\\n  let bestInvestments = new Array(m).fill(0);\\n\\n  // 遍历所有项目\\n  for (let i = 0; i < m; i++) {\\n    // 检查项目i的风险是否在容忍度X以内\\n    if (risks[i] <= X) {\\n      // 计算项目i的投资额，不超过总投资额N和项目i的最大投资额\\n      const investmentForI = Math.min(N, maxInvestments[i]);\\n      // 计算当前项目的回报\\n      const currentReturn = investmentForI * returns[i];\\n      // 如果当前回报大于已知的最大回报\\n      if (currentReturn > maxReturn) {\\n        // 更新最大回报\\n        maxReturn = currentReturn;\\n        // 重置最佳投资方案数组，并为项目i分配投资额\\n        bestInvestments = new Array(m).fill(0);\\n        bestInvestments[i] = investmentForI;\\n      }\\n    }\\n\\n    // 遍历项目i之后的项目，寻找两个项目的组合投资方案\\n    for (let j = i + 1; j < m; j++) {\\n      // 如果两个项目的风险总和在容忍度范围内\\n      if (risks[i] + risks[j] <= X) {\\n        let investmentForI, investmentForJ;\\n        // 根据预期回报率决定投资额分配\\n        if (returns[i] > returns[j]) {\\n          // 如果项目i的回报率高于项目j，优先投资项目i\\n          investmentForI = Math.min(N, maxInvestments[i]);\\n          // 计算项目j的剩余可投资额\\n          investmentForJ = Math.min(N - investmentForI, maxInvestments[j]);\\n        } else {\\n          // 如果项目j的回报率高于项目i，优先投资项目j\\n          investmentForJ = Math.min(N, maxInvestments[j]);\\n          // 计算项目i的剩余可投资额\\n          investmentForI = Math.min(N - investmentForJ, maxInvestments[i]);\\n        }\\n        // 计算两个项目组合的当前回报\\n        const currentReturn = investmentForI * returns[i] + investmentForJ * returns[j];\\n        // 如果当前回报大于已知的最大回报\\n        if (currentReturn > maxReturn) {\\n          // 更新最大回报\\n          maxReturn = currentReturn;\\n          // 重置最佳投资方案数组，并为两个项目分配投资额\\n          bestInvestments = new Array(m).fill(0);\\n          bestInvestments[i] = investmentForI;\\n          bestInvestments[j] = investmentForJ;\\n        }\\n      }\\n    }\\n  }\\n\\n  // 输出最佳投资方案\\n  console.log(bestInvestments.join(' '));\\n});","cpp":"#include <iostream>\\n#include <vector>\\n#include <algorithm>\\n#include <sstream>\\nusing namespace std;\\n\\nvector<int> readIntArray() {\\n    string line;\\n    getline(cin, line); // 读取一行输入\\n    istringstream iss(line);\\n    vector<int> numbers;\\n    int num;\\n    while (iss >> num) { // 将字符串分割并转换为整数数组\\n        numbers.push_back(num);\\n    }\\n    return numbers;\\n}\\n\\nint main() {\\n    // 读取投资项目数量m、总投资额N和风险容忍度X\\n    vector<int> tmp = readIntArray();\\n    int m = tmp[0], N = tmp[1], X = tmp[2];\\n    // 读取每个项目的预期回报率\\n    vector<int> returns = readIntArray();\\n    // 读取每个项目的风险值\\n    vector<int> risks = readIntArray();\\n    // 读取每个项目的最大投资额\\n    vector<int> maxInvestments = readIntArray();\\n\\n    // 初始化最大回报为0\\n    int maxReturn = 0;\\n    // 初始化最大回报对应的投资方案数组\\n    vector<int> bestInvestments(m, 0);\\n\\n    // 遍历所有项目\\n    for (int i = 0; i < m; i++) {\\n        // 如果单个项目的风险在容忍度范围内\\n        if (risks[i] <= X) {\\n            // 计算对项目i的投资额，不超过总投资额N和项目i的最大投资额\\n            int investmentForI = min(N, maxInvestments[i]);\\n            // 计算当前回报\\n            int currentReturn = investmentForI * returns[i];\\n            // 如果当前回报大于已知的最大回报\\n            if (currentReturn > maxReturn) {\\n                // 更新最大回报\\n                maxReturn = currentReturn;\\n                // 重置最佳投资方案数组，并为项目i分配投资额\\n                fill(bestInvestments.begin(), bestInvestments.end(), 0);\\n                bestInvestments[i] = investmentForI;\\n            }\\n        }\\n\\n        // 遍历项目i之后的项目，寻找两个项目的组合投资方案\\n        for (int j = i + 1; j < m; j++) {\\n            // 如果两个项目的风险总和在容忍度范围内\\n            if (risks[i] + risks[j] <= X) {\\n                int investmentForI, investmentForJ;\\n                // 根据预期回报率决定投资额分配\\n                if (returns[i] > returns[j]) {\\n                    // 如果项目i的回报率高于项目j，优先投资项目i\\n                    investmentForI = min(N, maxInvestments[i]);\\n                    investmentForJ = min(N - investmentForI, maxInvestments[j]);\\n                } else {\\n                    // 如果项目j的回报率高于项目i，优先投资项目j\\n                    investmentForJ = min(N, maxInvestments[j]);\\n                    investmentForI = min(N - investmentForJ, maxInvestments[i]);\\n                }\\n                // 计算当前两个项目组合的回报\\n                int currentReturn = investmentForI * returns[i] + investmentForJ * returns[j];\\n                // 如果当前回报大于已知的最大回报\\n                if (currentReturn > maxReturn) {\\n                    // 更新最大回报\\n                    maxReturn = currentReturn;\\n                    // 重置最佳投资方案数组，并为两个项目分配投资额\\n                    fill(bestInvestments.begin(), bestInvestments.end(), 0);\\n                    bestInvestments[i] = investmentForI;\\n                    bestInvestments[j] = investmentForJ;\\n                }\\n            }\\n        }\\n    }\\n\\n    // 输出最佳投资方案\\n    for (int investment : bestInvestments) {\\n        cout << investment << \\" \\";\\n    }\\n    cout << endl;\\n\\n    return 0;\\n}","c":"#include <stdio.h>  // 导入标准输入输出库，用于输入输出\\n#include <string.h> // 导入字符串操作库，用于处理字符串\\n\\n#define MAX_PRODUCTS 20 // 定义最大产品数量常量\\n\\n// 用于读取整数数组的函数\\nvoid readIntArray(int *arr, int size) {\\n    for (int i = 0; i < size; i++) {\\n        scanf(\\"%d\\", &arr[i]); // 循环读取输入的整数并存储到数组中\\n    }\\n}\\n\\nint min(int a, int b) {\\n    return a < b ? a : b; // 返回两个整数中较小的一个\\n}\\n\\nint main() {\\n    int m, N, X; // 分别代表产品数、总投资额和可接受的总风险\\n    scanf(\\"%d %d %d\\", &m, &N, &X); // 读取这三个值\\n\\n    int returns[MAX_PRODUCTS]; // 存储每个产品的投资回报率\\n    readIntArray(returns, m); // 读取投资回报率\\n\\n    int risks[MAX_PRODUCTS]; // 存储每个产品的风险值\\n    readIntArray(risks, m); // 读取风险值\\n\\n    int maxInvestments[MAX_PRODUCTS]; // 存储每个产品的最大投资额度\\n    readIntArray(maxInvestments, m); // 读取最大投资额度\\n\\n    int maxReturn = 0; // 初始化最大回报为0\\n    int bestInvestments[MAX_PRODUCTS] = {0}; // 初始化最佳投资方案数组，初始值全为0\\n\\n    // 遍历所有产品，尝试找到最佳的投资组合\\n    for (int i = 0; i < m; i++) {\\n        // 如果单个产品的风险在可接受范围内\\n        if (risks[i] <= X) {\\n            // 计算对产品i的投资额，不超过总投资额N和产品i的最大投资额\\n            int investmentForI = min(N, maxInvestments[i]);\\n            // 计算当前投资的回报\\n            int currentReturn = investmentForI * returns[i];\\n            // 如果当前回报大于已知的最大回报\\n            if (currentReturn > maxReturn) {\\n                maxReturn = currentReturn; // 更新最大回报\\n                memset(bestInvestments, 0, sizeof(bestInvestments)); // 重置最佳投资方案数组\\n                bestInvestments[i] = investmentForI; // 为产品i分配投资额\\n            }\\n        }\\n\\n        // 遍历产品i之后的产品，寻找两个产品的组合投资方案\\n        for (int j = i + 1; j < m; j++) {\\n            // 如果两个产品的风险总和在可接受范围内\\n            if (risks[i] + risks[j] <= X) {\\n                int investmentForI, investmentForJ;\\n                // 根据回报率决定投资额分配\\n                if (returns[i] > returns[j]) {\\n                    // 如果产品i的回报率高于产品j，优先投资产品i\\n                    investmentForI = min(N, maxInvestments[i]);\\n                    investmentForJ = min(N - investmentForI, maxInvestments[j]);\\n                } else {\\n                    // 如果产品j的回报率高于产品i，优先投资产品j\\n                    investmentForJ = min(N, maxInvestments[j]);\\n                    investmentForI = min(N - investmentForJ, maxInvestments[i]);\\n                }\\n                // 计算当前两个产品组合的回报\\n                int currentReturn = investmentForI * returns[i] + investmentForJ * returns[j];\\n                // 如果当前回报大于已知的最大回报\\n                if (currentReturn > maxReturn) {\\n                    maxReturn = currentReturn; // 更新最大回报\\n                    memset(bestInvestments, 0, sizeof(bestInvestments)); // 重置最佳投资方案数组\\n                    bestInvestments[i] = investmentForI; // 为产品i分配投资额\\n                    bestInvestments[j] = investmentForJ; // 为产品j分配投资额\\n                }\\n            }\\n        }\\n    }\\n\\n    // 输出最佳投资方案\\n    for (int i = 0; i < m; i++) {\\n        printf(\\"%d \\", bestInvestments[i]); // 打印每个产品的投资额\\n    }\\n    printf(\\"\\\\n\\"); // 打印换行符\\n\\n    return 0; // 程序结束\\n}"}`),v={id:"60",title:n,examType:"A",score:100,description:t,inputDesc:e,outputDesc:r,examples:i,solution:s,codes:m};export{m as codes,v as default,t as description,o as examType,i as examples,a as id,e as inputDesc,r as outputDesc,u as score,s as solution,n as title};
