const o="125",n="推荐多样性",m="A",a=200,e=`推荐多样性需要从多个列表中选择元素，一次性要返回 N 屏数据（窗口数量），每屏展示 K 个元素（窗口大小），选择策略：
各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推 每个列表的元素尽量均分为 N 份，如果不够 N 个，也要全部分配完，参考样例图： （1）从第一个列表中选择 4 条 0 1 2 3，分别放到 4 个窗口中 （2）从第二个列表中选择 4 条 10 11 12 13，分别放到 4 个窗口中 （3）从第三个列表中选择 4 条 20 21 22 23，分别放到 4 个窗口中 （4）再从第一个列表中选择 4 条 4 5 6 7，分别放到 4 个窗口中 … （5）再从第一个列表中选择，由于数量不足 4 条，取剩下的 2 条，放到 窗口1 和 窗口2 （6）再从第二个列表中选择，由于数量不足 4 条并且总的元素数达到窗口要求，取 18 19 放到 窗口3 和 窗口4
各个列表元素需要做穿插处理，即先从第一个列表中为每屏选择一个元素，再从第二个列表中为每屏选择一个元素，依次类推
每个列表的元素尽量均分为 N 份，如果不够 N 个，也要全部分配完，参考样例图：
（1）从第一个列表中选择 4 条 0 1 2 3，分别放到 4 个窗口中
（2）从第二个列表中选择 4 条 10 11 12 13，分别放到 4 个窗口中
（3）从第三个列表中选择 4 条 20 21 22 23，分别放到 4 个窗口中
（4）再从第一个列表中选择 4 条 4 5 6 7，分别放到 4 个窗口中
…
（5）再从第一个列表中选择，由于数量不足 4 条，取剩下的 2 条，放到 窗口1 和 窗口2
（6）再从第二个列表中选择，由于数量不足 4 条并且总的元素数达到窗口要求，取 18 19 放到 窗口3 和 窗口4
`,u=`第一行输入为 N，表示需要输出的窗口数量，取值范围 [1, 10]
第二行输入为 K，表示每个窗口需要的元素数量，取值范围 [1, 100]
之后的行数不定（行数取值范围 [1, 10]），表示每个列表输出的元素列表。元素之间以空格隔开，已经过排序处理，每个列表输出的元素数量取值范围 [1, 100]`,i=`输出元素列表，元素数量 = 窗口数量 * 窗口大小，元素之间以空格分隔，多个窗口合并为一个列表输出，参考样例：
先输出窗口1的元素列表，再输出窗口2的元素列表，再输出窗口3的元素列表，最后输出窗口4的元素列表
输入
输出`,t=[{input:`2
2
1 2 3
4 5`,output:"1 4 2 5",explanation:"2个窗口各2个元素。窗口1:[1,4]，窗口2:[2,5]，合并输出"}],r=`**解题思路：**

本题是一道**模拟+队列**问题。

**核心思路：**
- N个窗口，每窗口K个元素
- 多个列表轮流为每个窗口分配元素
- 列表耗尽则跳过，继续下一个列表

**算法步骤：**
1. 用队列存储每个列表的元素
2. 轮流从各列表取N个元素分配到N个窗口
3. 列表为空时移除，继续处理
4. 直到填满N×K个元素
5. 按窗口顺序输出

**时间复杂度**：O(N×K)`,s=JSON.parse(`{"java":"import java.util.*;\\nimport java.util.stream.Collectors;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n\\n        // 读取窗口数量N\\n        int numberOfRows = Integer.parseInt(scanner.nextLine());\\n        // 读取每个窗口需要的元素数量K\\n        int numberOfColumns = Integer.parseInt(scanner.nextLine());\\n\\n        // 创建队列列表，用于存储每个列表的元素\\n        List<Queue<Integer>> queueList = new ArrayList<>();\\n\\n        // 循环读取输入的每个列表，并将其转换为队列存储在queueList中\\n        while (scanner.hasNextLine()) {\\n            String inputLine = scanner.nextLine();\\n            Queue<Integer> numberQueue = Arrays.stream(inputLine.split(\\" \\"))\\n                                               .map(Integer::parseInt)\\n                                               .collect(Collectors.toCollection(LinkedList::new));\\n\\n            queueList.add(numberQueue);\\n        }\\n\\n        // 创建一个数组，用于存储最终的元素排列\\n        int[] matrix = new int[numberOfColumns * numberOfRows];\\n        int matrixIndex = 0; // 用于标记当前填充到matrix数组中的位置\\n        int queueIndex = 0; // 用于标记当前处理的队列索引\\n\\n        // 循环，直到matrix数组被完全填满\\n        while (matrixIndex < matrix.length) {\\n            boolean didRemoveQueue = false; // 标记本轮循环中是否有队列被移除\\n\\n            // 遍历每个窗口，并尝试从当前队列中为每个窗口提取一个元素\\n            for (int i = 0; i < numberOfRows && !queueList.isEmpty(); i++) {\\n                // 如果当前队列为空，则移除该队列\\n                if (queueList.get(queueIndex).isEmpty()) {\\n                    queueList.remove(queueIndex);\\n                    if (queueList.isEmpty()) break; // 如果所有队列都已处理完毕，则退出循环\\n                    queueIndex %= queueList.size(); // 调整队列索引，防止索引越界\\n                    didRemoveQueue = true;\\n                }\\n                // 如果当前队列不为空，则从队列中取出一个元素填充到matrix数组中\\n                if (!queueList.get(queueIndex).isEmpty()) {\\n                    matrix[matrixIndex++] = queueList.get(queueIndex).poll();\\n                    if (matrixIndex >= matrix.length) break; // 如果matrix数组已填满，则退出循环\\n                }\\n            }\\n\\n            // 如果本轮循环没有队列被移除，并且队列列表不为空，则处理下一个队列\\n            if (!didRemoveQueue && !queueList.isEmpty()) {\\n                queueIndex = (queueIndex + 1) % queueList.size();\\n            }\\n        }\\n\\n        // 使用StringBuilder构建最终的输出字符串\\n        StringBuilder sb = new StringBuilder();\\n        // 遍历matrix数组，按照窗口顺序构建输出字符串\\n        for (int row = 0; row < numberOfRows; row++) {\\n            for (int col = 0; col < numberOfColumns; col++) {\\n                sb.append(matrix[col * numberOfRows + row]).append(\\" \\");\\n            }\\n        }\\n\\n        // 输出最终的元素排列，去除末尾的空格\\n        System.out.println(sb.toString().trim());\\n    }\\n}","python":"import sys\\n\\n\\n# 读取窗口数量N\\nnumberOfRows = int(input())\\n# 读取每个窗口需要的元素数量K\\nnumberOfColumns = int(input())\\n\\n# 创建队列列表，用于存储每个列表的元素\\nqueueList = []\\nwhile True:\\n    try:\\n        queueList.append(list(map(int, input().split())))\\n    except:\\n        break\\n \\n\\n# 创建一个列表，用于存储最终的元素排列\\nmatrix = [0] * (numberOfColumns * numberOfRows)\\nmatrixIndex = 0  # 用于标记当前填充到matrix列表中的位置\\nqueueIndex = 0  # 用于标记当前处理的队列索引\\n\\n# 循环，直到matrix列表被完全填满\\nwhile matrixIndex < len(matrix):\\n    didRemoveQueue = False  # 标记本轮循环中是否有队列被移除\\n\\n    # 遍历每个窗口，并尝试从当前队列中为每个窗口提取一个元素\\n    for i in range(numberOfRows):\\n        if not queueList:  # 如果所有队列都已处理完毕，则退出循环\\n            break\\n        # 如果当前队列为空，则移除该队列\\n        if not queueList[queueIndex]:\\n            queueList.pop(queueIndex)\\n            if not queueList:\\n                break\\n            queueIndex %= len(queueList)\\n            didRemoveQueue = True\\n        # 如果当前队列不为空，则从队列中取出一个元素填充到matrix列表中\\n        if queueList and queueList[queueIndex]:\\n            matrix[matrixIndex] = queueList[queueIndex].pop(0)\\n            matrixIndex += 1\\n            if matrixIndex >= len(matrix):\\n                break\\n\\n    # 如果本轮循环没有队列被移除，并且队列列表不为空，则处理下一个队列\\n    if not didRemoveQueue and queueList:\\n        queueIndex = (queueIndex + 1) % len(queueList)\\n\\n# 按照窗口顺序构建输出字符串\\nfor row in range(numberOfRows):\\n    for col in range(numberOfColumns):\\n        print(matrix[col * numberOfRows + row], end=\\" \\")","javascript":"","cpp":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <sstream>\\n#include <string>\\n\\nusing namespace std;\\nint main() {\\n    int numberOfRows, numberOfColumns;\\n    cin >> numberOfRows >> numberOfColumns;\\n    cin.ignore(); // 忽略换行符\\n\\n    vector<queue<int>> queueList;\\n    string inputLine;\\n\\n    // 循环读取输入，每次读取一行，直到输入结束\\n    while (getline(cin, inputLine) && !inputLine.empty()) {\\n        istringstream iss(inputLine);\\n        queue<int> numberQueue;\\n        int number;\\n\\n        // 将一行中的数分割并加入到队列中\\n        while (iss >> number) {\\n            numberQueue.push(number);\\n        }\\n\\n        queueList.push_back(numberQueue);\\n    }\\n\\n    vector<int> matrix(numberOfColumns * numberOfRows, 0);\\n    int matrixIndex = 0;\\n    int queueIndex = 0;\\n\\n    // 循环，直到所有元素被分配完毕\\n    while (matrixIndex < matrix.size()) {\\n        bool didRemoveQueue = false;\\n\\n        for (int i = 0; i < numberOfRows && !queueList.empty(); ++i) {\\n            if (queueList[queueIndex].empty()) {\\n                queueList.erase(queueList.begin() + queueIndex);\\n                if (queueList.empty()) break;\\n                queueIndex %= queueList.size();\\n                didRemoveQueue = true;\\n            }\\n\\n            if (!queueList[queueIndex].empty()) {\\n                matrix[matrixIndex++] = queueList[queueIndex].front();\\n                queueList[queueIndex].pop();\\n                if (matrixIndex >= matrix.size()) break;\\n            }\\n        }\\n\\n        if (!didRemoveQueue && !queueList.empty()) {\\n            queueIndex = (queueIndex + 1) % queueList.size();\\n        }\\n    }\\n\\n    // 按顺序输出结果\\n    for (int row = 0; row < numberOfRows; ++row) {\\n        for (int col = 0; col < numberOfColumns; ++col) {\\n            cout << matrix[col * numberOfRows + row] << \\" \\";\\n        }\\n    }\\n\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <limits.h> // 引入limits.h以使用INT_MIN\\n\\n#define MAX_QUEUE 100 // 定义最大队列数量\\n#define MAX_LENGTH 1000 // 定义每行最大长度\\n\\n// 队列结构体定义\\ntypedef struct {\\n    int *items; // 队列元素数组\\n    int front, rear, size, capacity; // 队列的前端、后端、当前大小和容量\\n} Queue;\\n\\n// 创建队列的函数，参数为队列容量\\nQueue* createQueue(int capacity) {\\n    Queue* queue = (Queue*)malloc(sizeof(Queue)); // 动态分配队列结构体内存\\n    queue->capacity = capacity; // 设置队列容量\\n    queue->front = queue->size = 0; // 初始化队列大小和队列前端索引\\n    queue->rear = capacity - 1; // 初始化队列后端索引\\n    queue->items = (int*)malloc(queue->capacity * sizeof(int)); // 动态分配队列元素数组内存\\n    return queue;\\n}\\n\\n// 检查队列是否已满\\nint isFull(Queue* queue) {\\n    return (queue->size == queue->capacity);\\n}\\n\\n// 检查队列是否为空\\nint isEmpty(Queue* queue) {\\n    return (queue->size == 0);\\n}\\n\\n// 向队列中添加元素\\nvoid enqueue(Queue* queue, int item) {\\n    if (isFull(queue))\\n        return;\\n    queue->rear = (queue->rear + 1) % queue->capacity; // 循环队列中rear的更新\\n    queue->items[queue->rear] = item; // 在rear位置添加元素\\n    queue->size = queue->size + 1; // 更新队列大小\\n}\\n\\n// 从队列中移除元素\\nint dequeue(Queue* queue) {\\n    if (isEmpty(queue))\\n        return INT_MIN; // 如果队列为空，返回INT_MIN\\n    int item = queue->items[queue->front]; // 获取队列前端元素\\n    queue->front = (queue->front + 1) % queue->capacity; // 循环队列中front的更新\\n    queue->size = queue->size - 1; // 更新队列大小\\n    return item;\\n}\\n\\n// 获取队列的前端元素\\nint front(Queue* queue) {\\n    if (isEmpty(queue))\\n        return INT_MIN; // 如果队列为空，返回INT_MIN\\n    return queue->items[queue->front]; // 返回队列前端元素\\n}\\n\\nint main() {\\n    int numberOfRows, numberOfColumns;\\n    scanf(\\"%d %d\\", &numberOfRows, &numberOfColumns); // 读取行数和列数\\n\\n    Queue* queueList[MAX_QUEUE]; // 队列数组\\n    int queueCount = 0; // 实际队列数量\\n    char inputLine[MAX_LENGTH]; // 输入行缓冲\\n\\n    getchar(); // 清空输入缓冲区\\n\\n    // 循环读取输入\\n    while (fgets(inputLine, MAX_LENGTH, stdin) && inputLine[0] != '\\\\n') {\\n        queueList[queueCount] = createQueue(MAX_LENGTH); // 创建新队列\\n        char* token = strtok(inputLine, \\" \\"); // 分割输入行\\n        while (token != NULL) {\\n            enqueue(queueList[queueCount], atoi(token)); // 将数值加入队列\\n            token = strtok(NULL, \\" \\"); // 继续分割\\n        }\\n        queueCount++; // 更新队列数量\\n    }\\n\\n    int* matrix = (int*)malloc(numberOfColumns * numberOfRows * sizeof(int)); // 分配矩阵内存\\n    int matrixIndex = 0; // 矩阵索引\\n    int queueIndex = 0; // 队列索引\\n\\n    // 循环，直到所有元素被分配完毕\\n    while (matrixIndex < numberOfColumns * numberOfRows) {\\n        int didRemoveQueue = 0; // 标记是否移除了队列\\n\\n        for (int i = 0; i < numberOfRows && queueCount > 0; ++i) {\\n            if (isEmpty(queueList[queueIndex])) { // 如果当前队列为空\\n                free(queueList[queueIndex]->items); // 释放队列元素数组内存\\n                free(queueList[queueIndex]); // 释放队列结构体内存\\n                // 移除空队列\\n                for (int j = queueIndex; j < queueCount - 1; ++j) {\\n                    queueList[j] = queueList[j + 1];\\n                }\\n                queueCount--; // 更新队列数量\\n                if (queueCount == 0) break; // 如果没有队列了，退出循环\\n                queueIndex %= queueCount; // 更新队列索引\\n                didRemoveQueue = 1; // 标记已移除队列\\n            }\\n\\n            if (!isEmpty(queueList[queueIndex])) { // 如果当前队列不为空\\n                matrix[matrixIndex++] = dequeue(queueList[queueIndex]); // 从队列中取出元素并放入矩阵\\n                if (matrixIndex >= numberOfColumns * numberOfRows) break; // 如果矩阵已满，退出循环\\n            }\\n        }\\n\\n        if (!didRemoveQueue && queueCount > 0) { // 如果没有移除队列且还有队列\\n            queueIndex = (queueIndex + 1) % queueCount; // 循环更新队列索引\\n        }\\n    }\\n\\n    // 按顺序输出结果\\n    for (int row = 0; row < numberOfRows; ++row) {\\n        for (int col = 0; col < numberOfColumns; ++col) {\\n            printf(\\"%d \\", matrix[col * numberOfRows + row]);\\n        }\\n     }\\n\\n    // 释放内存\\n    for (int i = 0; i < queueCount; ++i) {\\n        free(queueList[i]->items); // 释放队列元素数组内存\\n        free(queueList[i]); // 释放队列结构体内存\\n    }\\n    free(matrix); // 释放矩阵内存\\n\\n    return 0;\\n}"}`),q={id:"125",title:n,examType:"A",score:200,description:e,inputDesc:u,outputDesc:i,examples:t,solution:r,codes:s};export{s as codes,q as default,e as description,m as examType,t as examples,o as id,u as inputDesc,i as outputDesc,a as score,r as solution,n as title};
