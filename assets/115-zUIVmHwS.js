const c="115",n="中文分词模拟器",d="A",l=200,e=`给定一个连续不包含空格的字符串，该字符串仅包含英文小写字母及英文标点符号（逗号、分号、句号），同时给定词库，对该字符串进行精确分词。
说明：
精确分词：字符串分词后，不会出现重叠。即"ilovechina"，不同词库可分割为"i,love,china"，“ilove,china”，不能分割出现重叠的"i,ilove,china"，i 出现重叠 标点符号不成词，仅用于断句 词库：根据外部知识库统计出来的常用词汇例：dictionary = [“i”, “love”, “china”, “lovechina”, “ilove”] 分词原则：采用分词顺序优先且最长匹配原则 “ilovechina”，假设分词结果 [i,ilove,lo,love,ch,china,lovechina]，则输出 [ilove,china] 错误输出：[i,lovechina]，原因：“ilove” > 优先于 “lovechina” 成词 错误输出：[i,love,china]，原因：“ilove” > "i"遵循最长匹配原则
精确分词：字符串分词后，不会出现重叠。即"ilovechina"，不同词库可分割为"i,love,china"，“ilove,china”，不能分割出现重叠的"i,ilove,china"，i 出现重叠
标点符号不成词，仅用于断句
词库：根据外部知识库统计出来的常用词汇例：dictionary = [“i”, “love”, “china”, “lovechina”, “ilove”]
分词原则：采用分词顺序优先且最长匹配原则
“ilovechina”，假设分词结果 [i,ilove,lo,love,ch,china,lovechina]，则输出 [ilove,china]
错误输出：[i,lovechina]，原因：“ilove” > 优先于 “lovechina” 成词
错误输出：[i,love,china]，原因：“ilove” > "i"遵循最长匹配原则`,i=`第一行输入待分词语句 “ilovechina”
字符串长度限制：0 < length < 256
第二行输入中文词库 “i,love,china,ch,na,ve,lo,this,is,this,word”
词库长度限制：1 < length < 100000`,r=`按顺序输出分词结果 “i,love,china”
输入
​
输出
说明 无
输入
输出
说明
单个字母，不在词库中且不成词则输出单个字母
输入
输出
说明
标点符号为英文标点符号`,o=[{input:`ilovechina
i,love,china,ch,na,ve,lo,ilove`,output:"ilove,china",explanation:"ilove比i长，优先匹配ilove，然后匹配china"},{input:"x]",output:"x,]",explanation:"x不在词库中单独输出，]为标点符号单独输出"}],t=`**解题思路：**

本题是一道**Trie树+贪心匹配**问题。

**核心思路：**
- 构建Trie树存储词库
- 顺序优先+最长匹配原则
- 标点符号单独输出

**算法步骤：**
1. 将词库单词插入Trie树
2. 从当前位置开始，找最长匹配的词
3. 找到则输出该词，否则输出单个字符
4. 标点符号直接输出

**时间复杂度**：O(N×L)`,s=JSON.parse(`{"java":"import java.util.*;\\n\\npublic class Main {\\n    // 定义 TrieNode 类，每个节点包含一个布尔值 isWord 和一个 TrieNode 类型的数组 children\\n    static class TrieNode {\\n        boolean isWord;\\n        TrieNode[] children = new TrieNode[26];\\n    }\\n\\n    // 创建 Trie 的根节点\\n    static TrieNode root = new TrieNode();\\n\\n    // 插入方法，用于向 Trie 中插入一个单词\\n    public static void insert(String word) {\\n        TrieNode node = root;\\n        // 遍历单词中的每个字符\\n        for (int i = 0; i < word.length(); i++) {\\n            char c = word.charAt(i);\\n            // 如果当前字符对应的子节点为空，则创建一个新的子节点\\n            if (node.children[c - 'a'] == null) {\\n                node.children[c - 'a'] = new TrieNode();\\n            }\\n            // 移动到下一个子节点\\n            node = node.children[c - 'a'];\\n        }\\n        // 标记当前节点为一个单词的结束\\n        node.isWord = true;\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        // 读取输入的句子，并将其转换为小写\\n        String sentence = scanner.nextLine().toLowerCase();\\n        // 读取输入的字典，字典中的单词以逗号分隔\\n        String[] dictionary = scanner.nextLine().split(\\",\\");\\n        // 将字典中的每个单词插入到 Trie 中\\n        for (String word : dictionary) {\\n            insert(word.toLowerCase());\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n        int i = 0;\\n        // 遍历句子中的每个字符\\n        while (i < sentence.length()) {\\n            // 如果当前字符不是字母，则直接将其添加到结果中\\n            if (sentence.charAt(i) < 'a' || sentence.charAt(i) > 'z') {\\n                result.add(sentence.substring(i, i + 1));\\n                i++;\\n                continue;\\n            }\\n            int j = sentence.length();\\n            // 从句子的末尾开始，寻找以 i 为起点的最长的在字典中存在的单词\\n            while (j > i) {\\n                TrieNode node = root;\\n                boolean isWord = true;\\n                for (int k = i; k < j; k++) {\\n                    // 如果当前字符不是字母，或者在 Trie 中不存在对应的子节点，则说明当前的字符串不是一个单词\\n                    if (sentence.charAt(k) < 'a' || sentence.charAt(k) > 'z' || node.children[sentence.charAt(k) - 'a'] == null) {\\n                        isWord = false;\\n                        break;\\n                    }\\n                    // 移动到下一个子节点\\n                    node = node.children[sentence.charAt(k) - 'a'];\\n                }\\n                // 如果找到了一个单词，则结束循环\\n                if (isWord && node.isWord) {\\n                    break;\\n                }\\n                // 如果没有找到单词，则缩短当前的字符串\\n                j--;\\n            }\\n            // 如果没有找到单词，则将当前字符作为一个单独的单词添加到结果中\\n            if (j == i) {\\n                result.add(sentence.substring(i, i + 1));\\n                i++;\\n            } else {\\n                // 如果找到了单词，则将该单词添加到结果中\\n                result.add(sentence.substring(i, j));\\n                i = j;\\n            }\\n        }\\n\\n        // 输出结果，单词之间以逗号分隔\\n        System.out.println(String.join(\\",\\", result));\\n    }\\n}","python":"# 定义 TrieNode 类，每个节点包含一个布尔值 is_word 和一个 TrieNode 类型的数组 children\\nclass TrieNode:\\n    def __init__(self):\\n        self.is_word = False  # 标记该节点是否为一个单词的结束\\n        self.children = [None] * 26  # 存储子节点的数组，每个元素对应一个字母\\n\\n# 创建 Trie 的根节点\\nroot = TrieNode()\\n\\n# 插入方法，用于向 Trie 中插入一个单词\\ndef insert(word):\\n    node = root  # 从根节点开始\\n    for c in word:\\n        index = ord(c) - ord('a')  # 计算当前字符对应的索引\\n        # 如果当前字符对应的子节点为空，则创建一个新的子节点\\n        if node.children[index] is None:\\n            node.children[index] = TrieNode()\\n        # 移动到下一个子节点\\n        node = node.children[index]\\n    # 标记当前节点为一个单词的结束\\n    node.is_word = True\\n\\n# 输入句子，并将其转换为小写\\nsentence = input().lower()\\n# 输入字典，字典中的单词以逗号分隔\\ndictionary = input().split(\\",\\")\\nfor word in dictionary:\\n    insert(word.lower())  # 将字典中的每个单词插入到 Trie 中\\n\\nresult = []  # 存储结果\\ni = 0\\n# 遍历句子中的每个字符\\nwhile i < len(sentence):\\n    # 如果当前字符不是字母，则直接将其添加到结果中\\n    if not sentence[i].isalpha():\\n        result.append(sentence[i])\\n        i += 1\\n        continue\\n    j = len(sentence)\\n    # 从句子的末尾开始，寻找以 i 为起点的最长的在字典中存在的单词\\n    while j > i:\\n        node = root\\n        is_word = True\\n        for k in range(i, j):\\n            # 如果当前字符不是字母，或者在 Trie 中不存在对应的子节点，则说明当前的字符串不是一个单词\\n            if not sentence[k].isalpha() or node.children[ord(sentence[k]) - ord('a')] is None:\\n                is_word = False\\n                break\\n            # 移动到下一个子节点\\n            node = node.children[ord(sentence[k]) - ord('a')]\\n        # 如果找到了一个单词，则结束循环\\n        if is_word and node.is_word:\\n            break\\n        # 如果没有找到单词，则缩短当前的字符串\\n        j -= 1\\n    # 如果没有找到单词，则将当前字符作为一个单独的单词添加到结果中\\n    if j == i:\\n        result.append(sentence[i])\\n        i += 1\\n    else:\\n        # 如果找到了单词，则将该单词添加到结果中\\n        result.append(sentence[i:j])\\n        i = j\\n\\n# 输出结果，单词之间以逗号分隔\\nprint(\\",\\".join(result))","javascript":"","cpp":"#include <iostream>\\n#include <vector>\\n#include <string>\\n#include <sstream>\\n#include <algorithm> // 添加这一行\\n\\nusing namespace std;\\n\\n// 定义 TrieNode 类，每个节点包含一个布尔值 isWord 和一个 TrieNode 类型的数组 children\\nstruct TrieNode {\\n    bool isWord;\\n    TrieNode* children[26];\\n\\n    TrieNode() {\\n        isWord = false;\\n        for (int i = 0; i < 26; i++) {\\n            children[i] = nullptr;\\n        }\\n    }\\n};\\n\\n// 创建 Trie 的根节点\\nTrieNode* root = new TrieNode();\\n\\n// 插入方法，用于向 Trie 中插入一个单词\\nvoid insert(string word) {\\n    TrieNode* node = root;\\n    // 遍历单词中的每个字符\\n    for (char c : word) {\\n        // 如果当前字符对应的子节点为空，则创建一个新的子节点\\n        if (node->children[c - 'a'] == nullptr) {\\n            node->children[c - 'a'] = new TrieNode();\\n        }\\n        // 移动到下一个子节点\\n        node = node->children[c - 'a'];\\n    }\\n    // 标记当前节点为一个单词的结束\\n    node->isWord = true;\\n}\\n\\nint main() {\\n    // 读取输入的句子，并将其转换为小写\\n    string sentence;\\n    getline(cin, sentence);\\n    transform(sentence.begin(), sentence.end(), sentence.begin(), ::tolower);\\n\\n    // 读取输入的字典，字典中的单词以逗号分隔\\n    string dictionary;\\n    getline(cin, dictionary);\\n    stringstream ss(dictionary);\\n    string word;\\n    while (getline(ss, word, ',')) {\\n        insert(word);\\n    }\\n\\n    vector<string> result;\\n    int i = 0;\\n    // 遍历句子中的每个字符\\n    while (i < sentence.size()) {\\n        // 如果当前字符不是字母，则直接将其添加到结果中\\n        if (!isalpha(sentence[i])) {\\n            result.push_back(sentence.substr(i, 1));\\n            i++;\\n            continue;\\n        }\\n        int j = sentence.size();\\n        // 从句子的末尾开始，寻找以 i 为起点的最长的在字典中存在的单词\\n        while (j > i) {\\n            TrieNode* node = root;\\n            bool isWord = true;\\n            for (int k = i; k < j; k++) {\\n                // 如果当前字符不是字母，或者在 Trie 中不存在对应的子节点，则说明当前的字符串不是一个单词\\n                if (!isalpha(sentence[k]) || node->children[sentence[k] - 'a'] == nullptr) {\\n                    isWord = false;\\n                    break;\\n                }\\n                // 移动到下一个子节点\\n                node = node->children[sentence[k] - 'a'];\\n            }\\n            // 如果找到了一个单词，则结束循环\\n            if (isWord && node->isWord) {\\n                break;\\n            }\\n            // 如果没有找到单词，则缩短当前的字符串\\n            j--;\\n        }\\n        // 如果没有找到单词，则将当前字符作为一个单独的单词添加到结果中\\n        if (j == i) {\\n            result.push_back(sentence.substr(i, 1));\\n            i++;\\n        } else {\\n            // 如果找到了单词，则将该单词添加到结果中\\n            result.push_back(sentence.substr(i, j - i));\\n            i = j;\\n        }\\n    }\\n\\n    // 输出结果，单词之间以逗号分隔\\n    for (int i = 0; i < result.size(); i++) {\\n        if (i > 0) {\\n            cout << \\",\\";\\n        }\\n        cout << result[i];\\n    }\\n    cout << endl;\\n\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n#include <ctype.h>\\n\\n// 定义 TrieNode 结构体，每个节点包含一个布尔值 isWord 和一个 TrieNode 类型的数组 children\\nstruct TrieNode {\\n    int isWord;\\n    struct TrieNode* children[26];\\n};\\n\\n// 创建 Trie 的根节点\\nstruct TrieNode* root;\\n\\n// 插入方法，用于向 Trie 中插入一个单词\\nvoid insert(char* word) {\\n    struct TrieNode* node = root;\\n    // 遍历单词中的每个字符\\n    for (int i = 0; i < strlen(word); i++) {\\n        char c = word[i];\\n        // 如果当前字符对应的子节点为空，则创建一个新的子节点\\n        if (node->children[c - 'a'] == NULL) {\\n            node->children[c - 'a'] = (struct TrieNode*)calloc(1, sizeof(struct TrieNode));\\n        }\\n        // 移动到下一个子节点\\n        node = node->children[c - 'a'];\\n    }\\n    // 标记当前节点为一个单词的结束\\n    node->isWord = 1;\\n}\\n\\nint main() {\\n    root = (struct TrieNode*)calloc(1, sizeof(struct TrieNode));\\n\\n    // 读取输入的句子，并将其转换为小写\\n    char sentence[1000];\\n    fgets(sentence, 1000, stdin);\\n    for (int i = 0; i < strlen(sentence); i++) {\\n        sentence[i] = tolower(sentence[i]);\\n    }\\n\\n    // 读取输入的字典，字典中的单词以逗号分隔\\n    char dictionary[1000];\\n    fgets(dictionary, 1000, stdin);\\n    char* word = strtok(dictionary, \\",\\");\\n    while (word != NULL) {\\n        insert(word);\\n        word = strtok(NULL, \\",\\");\\n    }\\n\\n    char result[1000] = \\"\\";\\n    int i = 0;\\n    // 遍历句子中的每个字符\\n    while (i < strlen(sentence)) {\\n        // 如果当前字符不是字母，则直接将其添加到结果中\\n        if (!isalpha(sentence[i])) {\\n            strncat(result, &sentence[i], 1);\\n            i++;\\n            continue;\\n        }\\n        int j = strlen(sentence);\\n        // 从句子的末尾开始，寻找以 i 为起点的最长的在字典中存在的单词\\n        while (j > i) {\\n            struct TrieNode* node = root;\\n            int isWord = 1;\\n            for (int k = i; k < j; k++) {\\n                // 如果当前字符不是字母，或者在 Trie 中不存在对应的子节点，则说明当前的字符串不是一个单词\\n                if (!isalpha(sentence[k]) || node->children[sentence[k] - 'a'] == NULL) {\\n                    isWord = 0;\\n                    break;\\n                }\\n                // 移动到下一个子节点\\n                node = node->children[sentence[k] - 'a'];\\n            }\\n            // 如果找到了一个单词，则结束循环\\n            if (isWord && node->isWord) {\\n                break;\\n            }\\n            // 如果没有找到单词，则缩短当前的字符串\\n            j--;\\n        }\\n        // 如果没有找到单词，则将当前字符作为一个单独的单词添加到结果中\\n        if (j == i) {\\n            strncat(result, &sentence[i], 1);\\n            i++;\\n        } else {\\n            // 如果找到了单词，则将该单词添加到结果中\\n            char temp[100];\\n            strncpy(temp, &sentence[i], j - i);\\n            temp[j - i] = '\\\\0';\\n            strcat(result, temp);\\n            i = j;\\n        }\\n        strcat(result, \\",\\");\\n    }\\n\\n    // 输出结果，单词之间以逗号分隔\\n    printf(\\"%s\\\\n\\", result);\\n\\n    return 0;\\n}"}`),a={id:"115",title:n,examType:"A",score:200,description:e,inputDesc:i,outputDesc:r,examples:o,solution:t,codes:s};export{s as codes,a as default,e as description,d as examType,o as examples,c as id,i as inputDesc,r as outputDesc,l as score,t as solution,n as title};
