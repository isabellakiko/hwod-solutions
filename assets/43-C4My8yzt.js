const o="43",n="生成哈夫曼树",u="A",s=100,e=`给定长度为 n nn 的无序的数字数组，每个数字代表二叉树的叶子节点的权值，数字数组的值均大于等于 1 11 。请完成一个函数，根据输入的数字数组，生成哈夫曼树，并将哈夫曼树按照中序遍历输出。
为了保证输出的二叉树中序遍历结果统一，增加以下限制:又树节点中，左节点权值小于等于右节点权值，根节点权值为左右节点权值之和。当左右节点权值相同时，左子树高度高度小于等于右子树。
注意: 所有用例保证有效，并能生成哈夫曼树提醒:哈夫曼树又称最优二叉树，是一种带权路径长度最短的一叉树。
所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度(若根结点为 0 00 层，叶结点到根结点的路径长度为叶结点的层数)`,t="例如：由叶子节点 5 15 40 30 10 生成的最优二叉树如下图所示，该树的最短带权路径长度为 40 * 1 + 30 * 2 +5 * 4 + 10 * 4 = 205 。",r="输出一个哈夫曼的中序遍历数组，数值间以空格分隔",i=[{input:`5
5 15 40 30 10`,output:"40 100 5 15 10 30 15 60 30",explanation:`输入5个数：5,15,40,30,10。
构建过程：
1. 合并5+10=15
2. 合并15+15=30
3. 合并30+30=60
4. 合并40+60=100
中序遍历得到结果。`},{input:`4
1 2 3 4`,output:"1 3 2 10 4 7 3",explanation:`输入4个数：1,2,3,4。
构建过程：
1. 合并1+2=3
2. 合并3+3=6
3. 合并4+6=10
中序遍历结果。`}],a=`**解题思路：**

本题是一道**哈夫曼树+优先队列**问题。

**哈夫曼树构建：**
1. 将所有权值放入最小堆
2. 每次取出两个最小节点合并
3. 新节点权值 = 左子节点 + 右子节点
4. 将新节点放回堆中
5. 重复直到只剩一个节点（根）

**排序规则：**
- 左节点权值 ≤ 右节点权值
- 权值相同时，左子树高度 ≤ 右子树高度

**算法步骤：**
1. 用优先队列维护节点（按权值、高度排序）
2. 贪心合并构建哈夫曼树
3. 中序遍历输出结果

**时间复杂度**：O(n log n)`,l=JSON.parse(`{"java":"import java.util.PriorityQueue;\\nimport java.util.Comparator;\\nimport java.util.Scanner;\\nimport java.util.ArrayList;\\n\\n// 定义一个节点类来表示哈夫曼树中的节点\\nclass Node {\\n    int value;       // 节点存储的权值\\n    Node left;       // 指向左子节点的引用\\n    Node right;      // 指向右子节点的引用\\n    int height;      // 节点的高度，用于处理相等权值的情况\\n\\n    // 构造函数\\n    public Node(int v) {\\n        value = v;\\n        left = null;\\n        right = null;\\n        height = 0;\\n    }\\n}\\n\\n// 实现比较器，用于优先队列的比较逻辑\\nclass Compare implements Comparator<Node> {\\n    @Override\\n    public int compare(Node a, Node b) {\\n        // 首先比较节点的权值，若权值相等则比较高度\\n        if (a.value > b.value) return 1;\\n        if (a.value < b.value) return -1;\\n        if (a.height > b.height) return 1;\\n        if (a.height < b.height) return -1;\\n        return 0;\\n    }\\n}\\n\\npublic class Main {\\n    // 构建哈夫曼树的函数\\n    public static Node buildHuffmanTree(ArrayList<Integer> values) {\\n        PriorityQueue<Node> pq = new PriorityQueue<>(new Compare());  // 使用优先队列存储节点\\n        // 为每个权值创建一个节点并添加到优先队列中\\n        for (int value : values) {\\n            pq.add(new Node(value));\\n        }\\n\\n        // 当队列中至少有两个节点时，执行循环\\n        while (pq.size() > 1) {\\n            Node left = pq.poll();  // 弹出最小的节点作为左子节点\\n            Node right = pq.poll(); // 弹出次小的节点作为右子节点\\n\\n            // 创建一个新节点，其权值为左右子节点的权值之和\\n            Node parent = new Node(left.value + right.value);\\n            // 确保左子节点权值不大于右子节点权值，若相等则比较高度\\n            if (left.value > right.value || (left.value == right.value && left.height > right.height)) {\\n                Node temp = left;\\n                left = right;\\n                right = temp;  // 交换左右子节点\\n            }\\n            parent.left = left;\\n            parent.right = right;\\n            parent.height = Math.max(left.height, right.height) + 1;  // 计算新节点的高度\\n            pq.add(parent);  // 将新节点加入优先队列\\n        }\\n        // 返回优先队列中剩余的最后一个节点，即哈夫曼树的根节点\\n        return pq.peek();\\n    }\\n\\n    // 中序遍历哈夫曼树，并将遍历结果保存为字符串\\n    public static void inorderTraversal(Node root, StringBuilder result) {\\n        if (root != null) {\\n            inorderTraversal(root.left, result);  // 遍历左子树\\n            result.append(root.value).append(\\" \\");  // 访问当前节点\\n            inorderTraversal(root.right, result);  // 遍历右子树\\n        }\\n    }\\n\\n    // 主函数\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();  // 读取节点数量\\n        ArrayList<Integer> values = new ArrayList<>();  // 存储所有节点的权值\\n        for (int i = 0; i < n; i++) {\\n            values.add(scanner.nextInt());  // 读取权值\\n        }\\n        Node root = buildHuffmanTree(values);  // 构建哈夫曼树\\n        StringBuilder result = new StringBuilder();  // 用于存储中序遍历结果\\n        inorderTraversal(root, result);  // 执行中序遍历\\n        if (result.length() > 0) {\\n            result.deleteCharAt(result.length() - 1);  // 移除最后的空格\\n        }\\n        System.out.println(result.toString());  // 输出中序遍历结果\\n        scanner.close();\\n    }\\n}","python":"import heapq\\n\\n# 定义Node类，用于构建哈夫曼树的节点\\nclass Node:\\n    def __init__(self, value):\\n        self.value = value  # 节点存储的数值\\n        self.left = None  # 节点的左子节点\\n        self.right = None  # 节点的右子节点\\n        self.height = 0  # 节点的高度\\n\\n    # 重载小于操作符，用于优先队列中比较Node对象\\n    def __lt__(self, other):\\n        # 首先比较节点的权值，如果权值相同，则比较高度\\n        if self.value == other.value:\\n            return self.height < other.height\\n        return self.value < other.value\\n\\n# 构建哈夫曼树的函数\\ndef build_huffman_tree(values):\\n    pq = [Node(value) for value in values]  # 创建Node对象列表\\n    heapq.heapify(pq)  # 将列表转换为最小堆\\n    while len(pq) > 1:  # 当堆中有多于一个节点时\\n        left = heapq.heappop(pq)  # 弹出两个数值最小的节点\\n        right = heapq.heappop(pq)\\n        parent = Node(left.value + right.value)  # 创建新节点，其数值为两个子节点数值之和\\n        parent.left = left  # 设置新节点的左子节点\\n        parent.right = right  # 设置新节点的右子节点\\n        parent.height = max(left.height, right.height) + 1  # 更新节点的高度\\n        heapq.heappush(pq, parent)  # 将新节点加入堆中\\n    return pq[0]  # 返回堆中剩下的最后一个节点，即哈夫曼树的根节点\\n\\n# 中序遍历哈夫曼树的函数\\ndef inorder_traversal(root):\\n    if root is not None:  # 如果当前节点不为空\\n        yield from inorder_traversal(root.left)  # 递归遍历左子树\\n        yield root.value  # 返回当前节点的值\\n        yield from inorder_traversal(root.right)  # 递归遍历右子树\\n \\nn = int(input())  # 从标准输入读取数字的个数\\nvalues = list(map(int, input().split()))  # 从标准输入读取数字，并转换为整数列表\\nroot = build_huffman_tree(values)  # 构建哈夫曼树，并获取根节点\\nresult = ' '.join(map(str, inorder_traversal(root)))  # 对哈夫曼树进行中序遍历，并将结果转换为字符串\\nprint(result)  # 打印中序遍历的结果","javascript":"const readline = require('readline');\\n\\n// 创建命令行读取接口实例\\nconst rl = readline.createInterface({\\n    input: process.stdin,  // 标准输入流\\n    output: process.stdout // 标准输出流\\n});\\n\\n// 监听第一行输入事件，获取节点数量\\nrl.on('line', (n) => {\\n    // 监听第二行输入事件，获取节点权值列表\\n    rl.on('line', (line) => {\\n        const values = line.split(' ').map(Number);  // 将输入的行按空格分割，并将每个元素转换为数字\\n        const root = buildHuffmanTree(values);  // 使用输入的值构建哈夫曼树，并获取根节点\\n        const result = [];  // 初始化中序遍历结果数组\\n        inorderTraversal(root, result);  // 对哈夫曼树进行中序遍历\\n        console.log(result.join(' '));  // 将中序遍历的结果数组转换为字符串并打印\\n        rl.close();  // 关闭读取接口\\n    });\\n});\\n\\n// 定义节点类，用于构建哈夫曼树\\nclass Node {\\n    constructor(value) {\\n        this.value = value;  // 节点的值\\n        this.left = null;    // 节点的左子节点\\n        this.right = null;   // 节点的右子节点\\n    }\\n}\\n\\n// 定义最小优先队列类\\nclass MinPriorityQueue {\\n    constructor() {\\n        this.elements = [];  // 存储队列元素的数组\\n    }\\n\\n    // 入队操作\\n    enqueue(element) {\\n        this.elements.push(element);  // 将新元素添加到数组末尾\\n        this.elements.sort((a, b) => a.value - b.value);  // 对数组进行排序，确保最小元素在数组开头\\n    }\\n\\n    // 出队操作\\n    dequeue() {\\n        return this.elements.shift();  // 移除并返回数组第一个元素\\n    }\\n\\n    // 检查队列是否为空\\n    isEmpty() {\\n        return this.elements.length === 0;  // 队列为空时数组长度为0\\n    }\\n}\\n\\n// 构建哈夫曼树的函数\\nfunction buildHuffmanTree(values) {\\n    const pq = new MinPriorityQueue();  // 创建最小优先队列实例\\n    values.forEach(value => pq.enqueue(new Node(value)));  // 为每个权值创建一个节点并加入队列\\n\\n    while (pq.elements.length > 1) {\\n        const left = pq.dequeue();  // 弹出最小的节点作为左子节点\\n        const right = pq.dequeue();  // 弹出次小的节点作为右子节点\\n\\n        const parent = new Node(left.value + right.value);  // 创建新节点，其权值为左右子节点之和\\n        parent.left = left;  // 设置新节点的左子节点\\n        parent.right = right;  // 设置新节点的右子节点\\n        pq.enqueue(parent);  // 将新节点加入优先队列\\n    }\\n    return pq.dequeue();  // 返回队列中的最后一个节点，即哈夫曼树的根节点\\n}\\n\\n// 中序遍历函数\\nfunction inorderTraversal(node, result) {\\n    if (node) {\\n        inorderTraversal(node.left, result);  // 遍历左子树\\n        result.push(node.value);  // 访问当前节点，并加入结果数组\\n        inorderTraversal(node.right, result);  // 遍历右子树\\n    }\\n}","cpp":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <functional>\\nusing namespace std;\\n\\n// Node结构用于表示哈夫曼树中的节点\\nstruct Node {\\n    int value;       // 节点存储的权值\\n    Node* left;      // 指向左子节点的指针\\n    Node* right;     // 指向右子节点的指针\\n    int height;      // 节点的高度，用于处理相等权值的情况\\n    Node(int v) : value(v), left(nullptr), right(nullptr), height(0) {}\\n};\\n\\n// Compare结构用于定义优先队列的比较方式\\nstruct Compare {\\n    // 重载()操作符，定义比较规则\\n    bool operator()(Node* a, Node* b) {\\n        // 首先比较节点的权值，若权值相等则比较高度\\n        return a->value > b->value || (a->value == b->value && a->height > b->height);\\n    }\\n};\\n\\n// 构建哈夫曼树的函数\\nNode* buildHuffmanTree(const vector<int>& values) {\\n    priority_queue<Node*, vector<Node*>, Compare> pq;  // 定义优先队列存储节点\\n    // 遍历所有权值，为每个权值创建一个节点\\n    for (int value : values) {\\n        pq.push(new Node(value));\\n    }\\n\\n    // 当队列中至少有两个节点时，执行循环\\n    while (pq.size() > 1) {\\n        Node* left = pq.top(); pq.pop();  // 弹出最小的节点作为左子节点\\n        Node* right = pq.top(); pq.pop(); // 弹出次小的节点作为右子节点\\n\\n        // 创建一个新节点，其权值为左右子节点的权值之和\\n        Node* parent = new Node(left->value + right->value);\\n        // 确保左子节点权值不大于右子节点权值，若相等则比较高度\\n        if (left->value > right->value || (left->value == right->value && left->height > right->height)) {\\n            swap(left, right);  // 若需要，交换左右子节点\\n        }\\n        parent->left = left;\\n        parent->right = right;\\n        parent->height = max(left->height, right->height) + 1;  // 计算新节点的高度\\n        pq.push(parent);  // 将新节点加入优先队列\\n    }\\n    // 返回优先队列中剩余的最后一个节点，即哈夫曼树的根节点\\n    return pq.top();\\n}\\n\\n// 中序遍历哈夫曼树，并将遍历结果保存为字符串\\nvoid inorderTraversal(Node* root, string& result) {\\n    if (root) {\\n        inorderTraversal(root->left, result);  // 遍历左子树\\n        result += to_string(root->value) + \\" \\";  // 访问当前节点\\n        inorderTraversal(root->right, result);  // 遍历右子树\\n    }\\n}\\n\\n// 主函数\\nint main() {\\n    int n;  // 存储节点数量\\n    cin >> n;\\n    vector<int> values(n);  // 存储所有节点的权值\\n    for (int i = 0; i < n; ++i) {\\n        cin >> values[i];  // 输入权值\\n    }\\n    Node* root = buildHuffmanTree(values);  // 构建哈夫曼树\\n    string result;  // 用于存储中序遍历结果\\n    inorderTraversal(root, result);  // 执行中序遍历\\n    if (!result.empty()) {\\n        result.pop_back();  // 移除最后的空格\\n    }\\n    cout << result << endl;  // 输出中序遍历结果\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX_SIZE 1000 // 定义最大节点数量，限制优先队列的容量\\n\\n// 哈夫曼树节点结构体定义\\ntypedef struct Node {\\n    int value;           // 节点存储的权值\\n    struct Node *left;   // 指向左子节点的指针\\n    struct Node *right;  // 指向右子节点的指针\\n    int height;          // 节点的高度，用于处理权值相同的情况\\n} Node;\\n\\n// 优先队列结构体定义\\ntypedef struct {\\n    Node *data[MAX_SIZE];  // 存储队列元素的数组\\n    int size;              // 队列当前元素个数\\n} PriorityQueue;\\n\\n// 初始化优先队列\\nvoid initPriorityQueue(PriorityQueue *pq) {\\n    pq->size = 0;\\n}\\n\\n// 创建新节点\\nNode *createNode(int value) {\\n    Node *node = (Node *)malloc(sizeof(Node));\\n    node->value = value;\\n    node->left = NULL;\\n    node->right = NULL;\\n    node->height = 0;\\n    return node;\\n}\\n\\n// 向优先队列添加元素，维持最小堆性质\\nvoid push(PriorityQueue *pq, Node *node) {\\n    int i = pq->size++; // 插入新元素的位置\\n    while (i > 0) {\\n        int parent = (i - 1) / 2; // 计算父节点的位置\\n        if (pq->data[parent]->value < node->value ||\\n            (pq->data[parent]->value == node->value && pq->data[parent]->height <= node->height)) {\\n            break; // 如果当前节点大于父节点，或权值相等但高度不低于父节点，停止调整\\n        }\\n        pq->data[i] = pq->data[parent]; // 否则，将父节点下移\\n        i = parent;\\n    }\\n    pq->data[i] = node; // 插入新节点\\n}\\n\\n// 从优先队列中弹出最小元素\\nNode *pop(PriorityQueue *pq) {\\n    Node *min = pq->data[0];\\n    Node *last = pq->data[--pq->size];\\n    int i = 0;\\n    while (i * 2 + 1 < pq->size) {\\n        int left = i * 2 + 1;\\n        int right = i * 2 + 2;\\n        int smallest = left;\\n        if (right < pq->size && (pq->data[right]->value < pq->data[left]->value ||\\n                                 (pq->data[right]->value == pq->data[left]->value && pq->data[right]->height < pq->data[left]->height))) {\\n            smallest = right;\\n        }\\n        if (last->value < pq->data[smallest]->value ||\\n            (last->value == pq->data[smallest]->value && last->height <= pq->data[smallest]->height)) {\\n            break;\\n        }\\n        pq->data[i] = pq->data[smallest];\\n        i = smallest;\\n    }\\n    pq->data[i] = last;\\n    return min;\\n}\\n\\n// 构建哈夫曼树\\nNode *buildHuffmanTree(int values[], int n) {\\n    PriorityQueue pq;\\n    initPriorityQueue(&pq);\\n    for (int i = 0; i < n; i++) {\\n        push(&pq, createNode(values[i]));\\n    }\\n    while (pq.size > 1) {\\n        Node *left = pop(&pq);\\n        Node *right = pop(&pq);\\n        Node *parent = createNode(left->value + right->value);\\n        if (left->value > right->value || (left->value == right->value && left->height > right->height)) {\\n            Node *temp = left;\\n            left = right;\\n            right = temp;\\n        }\\n        parent->left = left;\\n        parent->right = right;\\n        parent->height = (left->height > right->height ? left->height : right->height) + 1;\\n        push(&pq, parent);\\n    }\\n    return pop(&pq);\\n}\\n\\n// 中序遍历哈夫曼树\\nvoid inorderTraversal(Node *root) {\\n    if (root != NULL) {\\n        inorderTraversal(root->left);\\n        printf(\\"%d \\", root->value);\\n        inorderTraversal(root->right);\\n    }\\n}\\n\\n// 主函数\\nint main() {\\n    int n, values[MAX_SIZE];\\n    scanf(\\"%d\\", &n);\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\"%d\\", &values[i]);\\n    }\\n    Node *root = buildHuffmanTree(values, n);\\n    inorderTraversal(root);\\n   \\n    return 0;\\n}"}`),p={id:"43",title:n,examType:"A",score:100,description:e,inputDesc:t,outputDesc:r,examples:i,solution:a,codes:l};export{l as codes,p as default,e as description,u as examType,i as examples,o as id,t as inputDesc,r as outputDesc,s as score,a as solution,n as title};
