const u="166",n="字符串化繁为简",c="A",o=200,e=`给定一个输入字符串，字符串只可能由英文字母（ ‘a’ ~ ‘z’、‘A’ ~ ‘Z’ ）和左右小括号（ ‘(’、‘)’ ）组成。
当字符里存在小括号时，小括号是成对的，可以有一个或多个小括号对，小括号对不会嵌套，小括号对内可以包含1个或多个英文字母，也可以不包含英文字母。
当小括号对内包含多个英文字母时，这些字母之间是相互等效的关系，而且等效关系可以在不同的小括号对之间传递，即当存在 ‘a’ 和 ‘b’ 等效和存在 ‘b’ 和 ‘c’ 等效时，‘a’ 和 ‘c’ 也等效，另外，同一个英文字母的大写字母和小写字母也相互等效（即使它们分布在不同的括号对里）
需要对这个输入字符串做简化，输出一个新的字符串，输出字符串里只需保留输入字符串里的没有被小括号对包含的字符（按照输入字符串里的字符顺序），并将每个字符替换为在小括号对里包含的且字典序最小的等效字符。
如果简化后的字符串为空，请输出为"0"。
示例 : 输入字符串为"never(dont)give(run)up(f)()"，初始等效字符集合为(‘d’, ‘o’, ‘n’, ‘t’)、(‘r’, ‘u’, ‘n’)，由于等效关系可以传递，因此最终等效字符集合为(‘d’, ‘o’, ‘n’, ‘t’, ‘r’, ‘u’)，将输入字符串里的剩余部分按字典序最小的等效字符替换后得到"devedgivedp’`,t=`input_string
输入为1行，代表输入字符串
输入字符串的长度在1~100000之间`,i=`output_string
输出为1行，代表输出字符串`,r=[{input:"()abd",output:"abd",explanation:'输入字符串里没有被小括号包含的子字符串为"abd"，其中每个字符没有等效字符，输出为"abd"'},{input:"()happy(xyz)new(wxy)year(t)",output:"happwnewwear",explanation:'等效字符集为(‘x’, ‘y’, ‘z’, ‘w’)，输入字符串里没有被小括号包含的子字符串集合为"happynewyear"，将其中字符替换为字典序最小的等效字符后输出为：“happwnewwear”'},{input:"()abcdefgAC(a)(Ab)(C)",output:"AAcdefgAC",explanation:'等效字符集为(‘a’, ‘A’, ‘b’)，输入字符里没有被小括号包含的子字符串集合为"abcdefgAC"，将其中字符替换为字典序最小的等效字符后输出为：“AAcdefgAC”'}],s=`题目的核心要求是对字符串中的字符进行等效关系的解析和替换，其中小括号内的字符表明了字符之间的等效关系，等效关系可以跨多个小括号传递，且大小写字母也视为等效。基于这些等效关系，我们需要替换字符串中未被小括号包围的字符，使用其等效集合中字典序最小的字符进行替换。
具体如下：
等效字符集：当字符被包含在小括号中时，这些字符互相等效。例如在(abd)中，a、b、和d互相等效。 传递性：等效关系具有传递性，即如果a等效于b，且b等效于c，则a也等效于c。例如，如果(a)(Ab)，则由于a和A都等效，并且A和b等效，最终a、A、b三者互相等效。 大小写等效：题目规定不同大小写的同一字母也是等效的，即A等效于a。 输出字符的选择：对于字符串中未被小括号包含的每个字符，需要在其所有等效字符中选择字典序最小的字符进行替换。 示例解释： ()abd：没有括号内字符，所以abd不变。(abd)demand(fb)()for：这里abd和fb中的字符互相等效，因此输出替换后的d、e、m、a、n、d、f、o、r为a、e、m、a、n、a、a、o、r。()happy(xyz)new(wxy)year(t)：这里xyz和wxy中的字符互相等效，t无关系，所以替换happynewyear中的x, y, w为字典序最小的w。()abcdefgAC(a)(Ab)(C)：这里a, A, b互相等效，同时A和C也等效，所以在abcdefgAC中，a, b和C被替换为A。
等效字符集：当字符被包含在小括号中时，这些字符互相等效。例如在(abd)中，a、b、和d互相等效。
传递性：等效关系具有传递性，即如果a等效于b，且b等效于c，则a也等效于c。例如，如果(a)(Ab)，则由于a和A都等效，并且A和b等效，最终a、A、b三者互相等效。
大小写等效：题目规定不同大小写的同一字母也是等效的，即A等效于a。
输出字符的选择：对于字符串中未被小括号包含的每个字符，需要在其所有等效字符中选择字典序最小的字符进行替换。
示例解释：
()abd：没有括号内字符，所以abd不变。(abd)demand(fb)()for：这里abd和fb中的字符互相等效，因此输出替换后的d、e、m、a、n、d、f、o、r为a、e、m、a、n、a、a、o、r。()happy(xyz)new(wxy)year(t)：这里xyz和wxy中的字符互相等效，t无关系，所以替换happynewyear中的x, y, w为字典序最小的w。()abcdefgAC(a)(Ab)(C)：这里a, A, b互相等效，同时A和C也等效，所以在abcdefgAC中，a, b和C被替换为A。`,a=JSON.parse(`{"java":"import java.util.LinkedList;\\nimport java.util.Scanner;\\nimport java.util.TreeSet;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        // 创建一个Scanner对象，用于读取用户输入\\n        Scanner scanner = new Scanner(System.in);\\n        // 读取用户输入的字符串\\n        String inputString = scanner.nextLine();\\n        // 创建一个StringBuilder对象，用于存储最终的输出结果\\n        StringBuilder outputStringBuilder = new StringBuilder();\\n        // 创建一个LinkedList对象，用于存储等价集合\\n        LinkedList<TreeSet<Character>> equivalentSets = new LinkedList<>();\\n\\n        // 用于判断当前是否在括号内部的标志变量\\n        boolean isInsideParentheses = false;\\n\\n        // 遍历输入字符串的每个字符\\n        for (int i = 0; i < inputString.length(); i++) {\\n            // 获取当前字符\\n            char currentChar = inputString.charAt(i);\\n\\n            // 如果当前字符是左括号'('，则表示进入了括号内部\\n            if (currentChar == '(') {\\n                isInsideParentheses = true;\\n                // 创建一个新的等价集合，并将其添加到LinkedList中\\n                equivalentSets.add(new TreeSet<>());\\n            }\\n            // 如果当前字符是右括号')'，则表示离开了括号内部\\n            else if (currentChar == ')') {\\n                isInsideParentheses = false;\\n                // 如果最后一个等价集合为空集合，则将其从LinkedList中移除\\n                if (equivalentSets.getLast().size() == 0) equivalentSets.removeLast();\\n            }\\n            // 如果当前字符既不是左括号也不是右括号\\n            else {\\n                // 如果当前不在括号内部，则直接将字符添加到输出结果中\\n                if (!isInsideParentheses) {\\n                    outputStringBuilder.append(currentChar);\\n                }\\n                // 如果当前在括号内部，则将字符添加到最后一个等价集合中\\n                else {\\n                    equivalentSets.getLast().add(currentChar);\\n                }\\n            }\\n        }\\n\\n        // 用于判断是否进行了合并操作的标志变量\\n        boolean merged = true;\\n        // 循环执行合并操作，直到没有可以合并的等价集合为止\\n        while (merged) {\\n            merged = false;\\n            // 遍历等价集合LinkedList中的每个等价集合\\n            for (int i = 0; i < equivalentSets.size(); i++) {\\n                for (int j = i + 1; j < equivalentSets.size(); j++) {\\n                    boolean canCombine = false;\\n                    // 遍历字母'a'到'z'，判断两个等价集合是否可以合并\\n                    for (char c = 'a'; c <= 'z'; c++) {\\n                        char uppercaseC = (char) (c - 32);\\n                        if ((equivalentSets.get(i).contains(c) || equivalentSets.get(i).contains(uppercaseC)) && (equivalentSets.get(j).contains(c) || equivalentSets.get(j).contains(uppercaseC))) {\\n                            canCombine = true;\\n                            break;\\n                        }\\n                    }\\n                    // 如果可以合并，则将第二个等价集合中的元素合并到第一个等价集合中，并从LinkedList中移除第二个等价集合\\n                    if (canCombine) {\\n                        equivalentSets.get(i).addAll(equivalentSets.get(j));\\n                        equivalentSets.remove(j);\\n                        merged = true;\\n                        break;\\n                    }\\n                }\\n                if (merged) break;\\n            }\\n        }\\n\\n        // 将输出结果转换为字符数组\\n        char[] outputCharArray = outputStringBuilder.toString().toCharArray();\\n\\n        // 对每个等价集合进行处理，将等价集合中的字符替换为集合中的第一个字符\\n        for (TreeSet<Character> eq : equivalentSets) {\\n            Character firstChar = eq.first();\\n            for (int i = 0; i < outputCharArray.length; i++) {\\n                if (eq.contains(outputCharArray[i])) outputCharArray[i] = firstChar;\\n            }\\n        }\\n\\n        // 将字符数组转换为字符串\\n        String resultString = new String(outputCharArray);\\n\\n        // 如果结果字符串为空，则返回\\"0\\"，否则返回结果字符串\\n        String finalResult = resultString.length() == 0 ? \\"0\\" : resultString;\\n        System.out.println(finalResult);\\n    }\\n}","python":"from collections import deque\\nfrom typing import List, Set\\n\\ndef main():\\n    # 创建一个输入函数，用于读取用户输入\\n    input_string = input()\\n    # 创建一个列表，用于存储最终的输出结果\\n    output_string_builder = []\\n    # 创建一个双端队列对象，用于存储等价集合\\n    equivalent_sets = deque()\\n\\n    # 用于判断当前是否在括号内部的标志变量\\n    is_inside_parentheses = False\\n\\n    # 遍历输入字符串的每个字符\\n    for current_char in input_string:\\n        # 如果当前字符是左括号'('，则表示进入了括号内部\\n        if current_char == '(':\\n            is_inside_parentheses = True\\n            # 创建一个新的等价集合，并将其添加到双端队列中\\n            equivalent_sets.append(set())\\n        # 如果当前字符是右括号')'，则表示离开了括号内部\\n        elif current_char == ')':\\n            is_inside_parentheses = False\\n            # 如果最后一个等价集合为空集合，则将其从双端队列中移除\\n            if len(equivalent_sets[-1]) == 0:\\n                equivalent_sets.pop()\\n        # 如果当前字符既不是左括号也不是右括号\\n        else:\\n            # 如果当前不在括号内部，则直接将字符添加到输出结果中\\n            if not is_inside_parentheses:\\n                output_string_builder.append(current_char)\\n            # 如果当前在括号内部，则将字符添加到最后一个等价集合中\\n            else:\\n                equivalent_sets[-1].add(current_char)\\n\\n    # 用于判断是否进行了合并操作的标志变量\\n    merged = True\\n    # 循环执行合并操作，直到没有可以合并的等价集合为止\\n    while merged:\\n        merged = False\\n        # 遍历等价集合双端队列中的每个等价集合\\n        for i in range(len(equivalent_sets)):\\n            for j in range(i + 1, len(equivalent_sets)):\\n                can_combine = False\\n                # 遍历字母'a'到'z'，判断两个等价集合是否可以合并\\n                for c in range(ord('a'), ord('z') + 1):\\n                    uppercase_c = chr(c - 32)\\n                    if (chr(c) in equivalent_sets[i] or uppercase_c in equivalent_sets[i]) and (chr(c) in equivalent_sets[j] or uppercase_c in equivalent_sets[j]):\\n                        can_combine = True\\n                        break\\n                # 如果可以合并，则将第二个等价集合中的元素合并到第一个等价集合中，并从双端队列中移除第二个等价集合\\n                if can_combine:\\n                    equivalent_sets[i].update(equivalent_sets[j])\\n                    del equivalent_sets[j]\\n                    merged = True\\n                    break\\n            if merged:\\n                break\\n\\n    # 对每个等价集合进行处理，将等价集合中的字符替换为集合中的第一个字符\\n    for eq in equivalent_sets:\\n        first_char = min(eq)\\n        for i in range(len(output_string_builder)):\\n            if output_string_builder[i] in eq:\\n                output_string_builder[i] = first_char\\n\\n    # 将字符列表转换为字符串\\n    result_string = ''.join(output_string_builder)\\n\\n    # 如果结果字符串为空，则返回\\"0\\"，否则返回结果字符串\\n    final_result = \\"0\\" if len(result_string) == 0 else result_string\\n    print(final_result)\\n\\nif __name__ == \\"__main__\\":\\n    main()","javascript":"// 导入readline模块，用于读取用户输入\\nconst readline = require('readline');\\n\\n// 创建readline接口实例\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\n// 监听用户输入事件\\nrl.on('line', (input) => {\\n    // 创建一个列表，用于存储最终的输出结果\\n    let outputString = [];\\n    // 创建一个数组，用于存储等价集合\\n    let equivalentSets = [];\\n\\n    // 用于判断当前是否在括号内部的标志变量\\n    let isInsideParentheses = false;\\n\\n    // 遍历输入字符串的每个字符\\n    for (let currentChar of input) {\\n        // 如果当前字符是左括号'('，则表示进入了括号内部\\n        if (currentChar === '(') {\\n            isInsideParentheses = true;\\n            // 创建一个新的等价集合，并将其添加到数组中\\n            equivalentSets.push(new Set());\\n        }\\n        // 如果当前字符是右括号')'，则表示离开了括号内部\\n        else if (currentChar === ')') {\\n            isInsideParentheses = false;\\n            // 如果最后一个等价集合为空集合，则将其从数组中移除\\n            if (equivalentSets[equivalentSets.length - 1].size === 0) {\\n                equivalentSets.pop();\\n            }\\n        }\\n        // 如果当前字符既不是左括号也不是右括号\\n        else {\\n            // 如果当前不在括号内部，则直接将字符添加到输出结果中\\n            if (!isInsideParentheses) {\\n                outputString.push(currentChar);\\n            }\\n            // 如果当前在括号内部，则将字符添加到最后一个等价集合中\\n            else {\\n                equivalentSets[equivalentSets.length - 1].add(currentChar);\\n            }\\n        }\\n    }\\n\\n    // 用于判断是否进行了合并操作的标志变量\\n    let merged = true;\\n    // 循环执行合并操作，直到没有可以合并的等价集合为止\\n    while (merged) {\\n        merged = false;\\n        // 遍历等价集合数组中的每个等价集合\\n        for (let i = 0; i < equivalentSets.length; i++) {\\n            for (let j = i + 1; j < equivalentSets.length; j++) {\\n                let canCombine = false;\\n                // 遍历字母'a'到'z'，判断两个等价集合是否可以合并\\n                for (let c = 'a'.charCodeAt(0); c <= 'z'.charCodeAt(0); c++) {\\n                    let uppercaseC = String.fromCharCode(c - 32);\\n                    if ((equivalentSets[i].has(String.fromCharCode(c)) || equivalentSets[i].has(uppercaseC)) && (equivalentSets[j].has(String.fromCharCode(c)) || equivalentSets[j].has(uppercaseC))) {\\n                        canCombine = true;\\n                        break;\\n                    }\\n                }\\n                // 如果可以合并，则将第二个等价集合中的元素合并到第一个等价集合中，并从数组中移除第二个等价集合\\n                if (canCombine) {\\n                    equivalentSets[i] = new Set([...equivalentSets[i], ...equivalentSets[j]]);\\n                    equivalentSets.splice(j, 1);\\n                    merged = true;\\n                    break;\\n                }\\n            }\\n            if (merged) {\\n                break;\\n            }\\n        }\\n    }\\n\\n    // 对每个等价集合进行处理，将等价集合中的字符替换为集合中的第一个字符\\n    for (let eq of equivalentSets) {\\n        let firstChar = [...eq].sort()[0];\\n        outputString = outputString.map(char => eq.has(char) ? firstChar : char);\\n    }\\n\\n    // 如果结果字符串为空，则返回\\"0\\"，否则返回结果字符串\\n    let finalResult = outputString.length === 0 ? \\"0\\" : outputString.join('');\\n    console.log(finalResult);\\n});","cpp":"#include <iostream>\\n#include <string>\\n#include <vector>\\n#include <set>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nint main() {\\n    // 读取用户输入的字符串\\n    string inputString;\\n    getline(cin, inputString);\\n\\n    // 创建一个字符串，用于存储最终的输出结果\\n    string outputString = \\"\\";\\n\\n    // 创建一个vector对象，用于存储等价集合\\n    vector<set<char>> equivalentSets;\\n\\n    // 用于判断当前是否在括号内部的标志变量\\n    bool isInsideParentheses = false;\\n\\n    // 遍历输入字符串的每个字符\\n    for (char currentChar : inputString) {\\n        // 如果当前字符是左括号'('，则表示进入了括号内部\\n        if (currentChar == '(') {\\n            isInsideParentheses = true;\\n            // 创建一个新的等价集合，并将其添加到vector中\\n            equivalentSets.push_back(set<char>());\\n        }\\n        // 如果当前字符是右括号')'，则表示离开了括号内部\\n        else if (currentChar == ')') {\\n            isInsideParentheses = false;\\n            // 如果最后一个等价集合为空集合，则将其从vector中移除\\n            if (equivalentSets.back().empty()) equivalentSets.pop_back();\\n        }\\n        // 如果当前字符既不是左括号也不是右括号\\n        else {\\n            // 如果当前不在括号内部，则直接将字符添加到输出结果中\\n            if (!isInsideParentheses) {\\n                outputString += currentChar;\\n            }\\n            // 如果当前在括号内部，则将字符添加到最后一个等价集合中\\n            else {\\n                equivalentSets.back().insert(currentChar);\\n            }\\n        }\\n    }\\n\\n    // 用于判断是否进行了合并操作的标志变量\\n    bool merged = true;\\n    // 循环执行合并操作，直到没有可以合并的等价集合为止\\n    while (merged) {\\n        merged = false;\\n        // 遍历等价集合vector中的每个等价集合\\n        for (size_t i = 0; i < equivalentSets.size(); ++i) {\\n            for (size_t j = i + 1; j < equivalentSets.size(); ++j) {\\n                bool canCombine = false;\\n                // 遍历字母'a'到'z'，判断两个等价集合是否可以合并\\n                for (char c = 'a'; c <= 'z'; ++c) {\\n                    char uppercaseC = static_cast<char>(c - 32);\\n                    if ((equivalentSets[i].count(c) || equivalentSets[i].count(uppercaseC)) && (equivalentSets[j].count(c) || equivalentSets[j].count(uppercaseC))) {\\n                        canCombine = true;\\n                        break;\\n                    }\\n                }\\n                // 如果可以合并，则将第二个等价集合中的元素合并到第一个等价集合中，并从vector中移除第二个等价集合\\n                if (canCombine) {\\n                    equivalentSets[i].insert(equivalentSets[j].begin(), equivalentSets[j].end());\\n                    equivalentSets.erase(equivalentSets.begin() + j);\\n                    merged = true;\\n                    break;\\n                }\\n            }\\n            if (merged) break;\\n        }\\n    }\\n\\n    // 对每个等价集合进行处理，将等价集合中的字符替换为集合中的第一个字符\\n    for (const set<char>& eq : equivalentSets) {\\n        char firstChar = *eq.begin();\\n        for (char& c : outputString) {\\n            if (eq.count(c)) c = firstChar;\\n        }\\n    }\\n\\n    // 如果结果字符串为空，则返回\\"0\\"，否则返回结果字符串\\n    string finalResult = outputString.empty() ? \\"0\\" : outputString;\\n    cout << finalResult << endl;\\n\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <string.h>\\n#include <stdlib.h>\\n#include <ctype.h>  // 用于字符大小写转换\\n\\n#define MAX_SIZE 1000  // 定义输入字符串的最大长度\\n\\n// 定义字符集合结构体，用于存储和处理字符\\ntypedef struct {\\n    char elements[256];  // 存储集合中的所有字符\\n    int count[256];      // 对应字符是否在集合中的标记数组\\n} TreeSet;\\n\\n// 初始化字符集合，将所有字符的存在标记置为0\\nvoid initTreeSet(TreeSet *set) {\\n    memset(set->count, 0, sizeof(set->count));  // 使用memset函数初始化计数数组为0\\n}\\n\\n// 向字符集合中添加字符\\nvoid addCharToSet(TreeSet *set, char c) {\\n    int index = (unsigned char)c;  // 将字符转换为无符号字符，避免负索引\\n    if (set->count[index] == 0) {\\n        set->elements[index] = c;  // 如果字符未存在，则添加到元素数组中\\n    }\\n    set->count[index] = 1;  // 标记字符存在\\n}\\n\\n// 检查字符集合中是否包含指定字符\\nint setContains(TreeSet *set, char c) {\\n    return set->count[(unsigned char)c];  // 返回字符存在的标记\\n}\\n\\n// 将两个字符集合合并为一个\\nvoid mergeSets(TreeSet *dest, TreeSet *src) {\\n    for (int i = 0; i < 256; i++) {\\n        if (src->count[i]) {\\n            addCharToSet(dest, src->elements[i]);  // 如果源集合中存在字符，则添加到目标集合中\\n        }\\n    }\\n}\\n\\nint main() {\\n    char inputString[MAX_SIZE];  // 输入字符串\\n    char outputString[MAX_SIZE];  // 输出字符串\\n    int outputIndex = 0;  // 输出字符串索引\\n\\n    TreeSet sets[MAX_SIZE];  // 等价集合数组\\n    int numSets = 0;  // 等价集合数量\\n    int isInsideParentheses = 0;  // 标记是否在括号内部\\n\\n    fgets(inputString, MAX_SIZE, stdin);  // 读取输入字符串\\n    inputString[strcspn(inputString, \\"\\\\n\\")] = 0;  // 移除字符串末尾的换行符\\n\\n    // 遍历输入字符串中的每个字符\\n    for (int i = 0; i < strlen(inputString); i++) {\\n        char currentChar = inputString[i];  // 当前字符\\n        if (currentChar == '(') {\\n            isInsideParentheses = 1;  // 标记进入括号内部\\n            initTreeSet(&sets[numSets++]);  // 初始化新集合并增加集合计数\\n        } else if (currentChar == ')') {\\n            isInsideParentheses = 0;  // 标记离开括号内部\\n        } else {\\n            if (!isInsideParentheses) {\\n                outputString[outputIndex++] = currentChar;  // 如果不在括号内，直接添加到输出字符串\\n            } else {\\n                addCharToSet(&sets[numSets - 1], currentChar);  // 在括号内，添加字符到最新的集合中\\n            }\\n        }\\n    }\\n\\n    // 合并可合并的集合\\n    int merged = 1;\\n    while (merged) {\\n        merged = 0;\\n        for (int i = 0; i < numSets; i++) {\\n            for (int j = i + 1; j < numSets; j++) {\\n                for (char c = 'a'; c <= 'z'; c++) {\\n                    if ((setContains(&sets[i], c) || setContains(&sets[i], toupper(c))) &&\\n                        (setContains(&sets[j], c) || setContains(&sets[j], toupper(c)))) {\\n                        mergeSets(&sets[i], &sets[j]);  // 合并集合\\n\\n                        // 移除已合并的集合\\n                        for (int k = j; k < numSets - 1; k++) {\\n                            sets[k] = sets[k + 1];\\n                        }\\n                        numSets--;\\n                        merged = 1;\\n                        break;\\n                    }\\n                }\\n                if (merged) break;\\n            }\\n            if (merged) break;\\n        }\\n    }\\n\\n    // 应用等价集合的替换规则，将输出中的字符替换为等价集合的首字符\\n    for (int s = 0; s < numSets; s++) {\\n        char firstChar = 0;\\n        for (int c = 0; c < 256; c++) {\\n            if (sets[s].count[c]) {\\n                firstChar = sets[s].elements[c];\\n                break;\\n            }\\n        }\\n        for (int i = 0; i < outputIndex; i++) {\\n            if (setContains(&sets[s], outputString[i])) {\\n                outputString[i] = firstChar;  // 替换字符\\n            }\\n        }\\n    }\\n\\n    outputString[outputIndex] = '\\\\0';  // 确保输出字符串正确终止\\n    printf(\\"%s\\\\n\\", outputIndex ? outputString : \\"0\\");  // 输出最终结果\\n\\n    return 0;\\n}"}`),l={id:"166",title:n,examType:"A",score:200,description:e,inputDesc:t,outputDesc:i,examples:r,solution:s,codes:a};export{a as codes,l as default,e as description,c as examType,r as examples,u as id,t as inputDesc,i as outputDesc,o as score,s as solution,n as title};
