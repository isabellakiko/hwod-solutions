const x="37",n="构成正方形的数量",a="A",p=100,t="输入N个互不相同的二维整数坐标，求这N个坐标可以构成的正方形数量。[内积为零的的两个向量垂直]",i=`第一行输入为N，N代表坐标数量，N为正整数。N <= 100
之后的 K 行输入为坐标x y以空格分隔，x，y为整数，-10<=x, y<=10`,o="输出可以构成的正方形数量。",e=[{input:`3
0 0
1 1
2 0`,output:"0",explanation:"3个点不足以构成正方形，至少需要4个点。"},{input:`4
0 0
1 2
3 1
2 -1`,output:"1",explanation:`4个点：A(0,0), B(1,2), C(3,1), D(2,-1)
构成正方形ABCD，共1个正方形。
验证：AB⊥AD且|AB|=|AD|`},{input:`5
0 0
0 1
1 0
1 1
2 0`,output:"1",explanation:"5个点中，(0,0)(0,1)(1,0)(1,1)构成1个边长为1的正方形。"}],s=`**解题思路：**

本题是一道**几何 + 枚举**问题。

**核心思想：**
- 正方形由4个点构成，已知两点可以推出另外两点
- 对于边AB，旋转90°可得到其他两个顶点

**公式推导：**
已知点A(x1,y1)和B(x2,y2)作为正方形的一条边，另外两点为：
- C: (x1-(y1-y2), y1+(x1-x2))
- D: (x2-(y1-y2), y2+(x1-x2))

或（另一侧）：
- C': (x1+(y1-y2), y1-(x1-x2))
- D': (x2+(y1-y2), y2-(x1-x2))

**算法步骤：**

1. 将所有点存入HashSet便于O(1)查找
2. 枚举所有点对(A,B)作为正方形的一条边
3. 计算可能的另外两点，检查是否存在
4. 每个正方形被计算4次，最后除以4

**时间复杂度**：O(n²)`,r=JSON.parse(`{"java":"import java.util.ArrayList;\\nimport java.util.Scanner;\\n\\n\\n\\npublic class Main {\\n    static class Point {\\n        int x, y;\\n\\n        Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        // 判断两个点是否相等\\n        boolean equals(Point p) {\\n            return this.x == p.x && this.y == p.y;\\n        }\\n    }\\n    // 检查点是否存在于点列表中\\n    static boolean pointExists(ArrayList<Point> points, Point p) {\\n        for (Point point : points) {\\n            if (point.equals(p)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in);\\n        int n = scanner.nextInt();\\n        ArrayList<Point> points = new ArrayList<>();\\n\\n        // 读取所有点的坐标\\n        for (int i = 0; i < n; i++) {\\n            int x = scanner.nextInt();\\n            int y = scanner.nextInt();\\n            points.add(new Point(x, y));\\n        }\\n\\n        int squareCount = 0;\\n\\n        // 遍历所有点对，检查是否能构成正方形\\n        for (int i = 0; i < n; i++) {\\n            Point p1 = points.get(i);\\n\\n            for (int j = i + 1; j < n; j++) {\\n                Point p2 = points.get(j);\\n\\n                // 计算两个可能的对角点\\n                Point p3 = new Point(p1.x - (p1.y - p2.y), p1.y + (p1.x - p2.x));\\n                Point p4 = new Point(p2.x - (p1.y - p2.y), p2.y + (p1.x - p2.x));\\n\\n                if (pointExists(points, p3) && pointExists(points, p4)) {\\n                    squareCount++;\\n                }\\n\\n                // 计算另外两个可能的对角点\\n                Point p5 = new Point(p1.x + (p1.y - p2.y), p1.y - (p1.x - p2.x));\\n                Point p6 = new Point(p2.x + (p1.y - p2.y), p2.y - (p1.x - p2.x));\\n\\n                if (pointExists(points, p5) && pointExists(points, p6)) {\\n                    squareCount++;\\n                }\\n            }\\n        }\\n\\n        // 每个正方形被计算了4次，因此结果需要除以4\\n        System.out.println(squareCount / 4);\\n\\n        scanner.close();\\n    }\\n}\\n// 代码2\\nimport java.util.Scanner;\\nimport java.util.Vector;\\nimport java.util.HashSet;\\n\\npublic class Main {\\n    public static void main(String[] args) {\\n        // 创建Scanner对象，用于从控制台读取输入\\n        Scanner scanner = new Scanner(System.in);\\n        \\n        // 读取第一个输入的整数，表示坐标数量\\n        int n = scanner.nextInt();\\n        // 读取整行输入并忽略换行符\\n        scanner.nextLine();\\n\\n        // 创建一个Vector来存储坐标点的字符串形式\\n        Vector<String> coordinates = new Vector<>(n);\\n        for (int i = 0; i < n; i++) {\\n            // 逐行读取坐标点，并存储到Vector中\\n            coordinates.add(scanner.nextLine());\\n        }\\n\\n        // 初始化正方形计数器\\n        int squareCount = 0;\\n        // 使用HashSet存储坐标点，便于快速查找\\n        HashSet<String> set = new HashSet<>(coordinates);\\n\\n        // 遍历所有坐标点对\\n        for (int i = 0; i < n; i++) {\\n            // 将第一个坐标点分割为x1和y1\\n            String[] coordinate1 = coordinates.get(i).split(\\" \\");\\n            int x1 = Integer.parseInt(coordinate1[0]);\\n            int y1 = Integer.parseInt(coordinate1[1]);\\n\\n            for (int j = i + 1; j < n; j++) {\\n                // 将第二个坐标点分割为x2和y2\\n                String[] coordinate2 = coordinates.get(j).split(\\" \\");\\n                int x2 = Integer.parseInt(coordinate2[0]);\\n                int y2 = Integer.parseInt(coordinate2[1]);\\n\\n                // 计算两个可能的对角点\\n                int x3 = x1 - (y1 - y2), y3 = y1 + (x1 - x2);\\n                int x4 = x2 - (y1 - y2), y4 = y2 + (x1 - x2);\\n\\n                // 检查这两个对角点是否存在于坐标集合中\\n                if (set.contains(x3 + \\" \\" + y3) && set.contains(x4 + \\" \\" + y4)) {\\n                    squareCount++;\\n                }\\n\\n                // 计算另外两个可能的对角点\\n                int x5 = x1 + (y1 - y2), y5 = y1 - (x1 - x2);\\n                int x6 = x2 + (y1 - y2), y6 = y2 - (x1 - x2);\\n\\n                // 检查这两个对角点是否存在于坐标集合中\\n                if (set.contains(x5 + \\" \\" + y5) && set.contains(x6 + \\" \\" + y6)) {\\n                    squareCount++;\\n                }\\n            }\\n        }\\n\\n        // 每个正方形被计算了4次，因此结果需要除以4\\n        System.out.println(squareCount / 4);\\n\\n        // 关闭Scanner对象，释放资源\\n        scanner.close();\\n    }\\n}","python":"# 定义一个函数来判断两个点是否相等\\ndef are_points_equal(p1, p2):\\n    return p1[0] == p2[0] and p1[1] == p2[1]\\n\\n# 定义一个函数来检查一个点是否存在于点列表中\\ndef point_exists(points, p):\\n    for point in points:\\n        if are_points_equal(point, p):\\n            return True\\n    return False\\n\\n# 读取坐标数量\\nn = int(input())\\ncoordinates = []\\n\\n# 读取坐标并存入列表\\nfor _ in range(n):\\n    x, y = map(int, input().split())\\n    coordinates.append((x, y))\\n\\nsquare_count = 0\\n\\n# 遍历所有点对，检查是否能构成正方形\\nfor i in range(n):\\n    x1, y1 = coordinates[i]\\n\\n    for j in range(i + 1, n):\\n        x2, y2 = coordinates[j]\\n\\n        # 计算两个可能的对角点\\n        x3, y3 = x1 - (y1 - y2), y1 + (x1 - x2)\\n        x4, y4 = x2 - (y1 - y2), y2 + (x1 - x2)\\n        p3 = (x3, y3)\\n        p4 = (x4, y4)\\n\\n        if point_exists(coordinates, p3) and point_exists(coordinates, p4):\\n            square_count += 1\\n\\n        # 计算另外两个可能的对角点\\n        x5, y5 = x1 + (y1 - y2), y1 - (x1 - x2)\\n        x6, y6 = x2 + (y1 - y2), y2 - (x1 - x2)\\n        p5 = (x5, y5)\\n        p6 = (x6, y6)\\n\\n        if point_exists(coordinates, p5) and point_exists(coordinates, p6):\\n            square_count += 1\\n\\n# 每个正方形被计算了4次，因此结果需要除以4\\nprint(square_count // 4)\\n\\n\\n\\n# 代码2\\n\\nimport sys\\n\\n# 读取第一个输入的整数，表示坐标数量\\nn = int(input())\\n\\n# 存储坐标的字符串形式的列表\\ncoordinates = []\\nfor i in range(n):\\n    # 读取坐标点的字符串，并去掉两端的空白字符\\n    coordinates.append(input().strip())\\n\\n# 初始化正方形计数器\\nsquareCount = 0\\n# 使用集合存储坐标点，便于快速查找\\ncoordinate_set = set(coordinates)\\n\\n# 遍历所有坐标点对\\nfor i in range(n):\\n    # 将第一个坐标点分割为x1和y1\\n    x1, y1 = map(int, coordinates[i].split())\\n\\n    for j in range(i + 1, n):\\n        # 将第二个坐标点分割为x2和y2\\n        x2, y2 = map(int, coordinates[j].split())\\n\\n        # 计算两个可能的对角点\\n        x3, y3 = x1 - (y1 - y2), y1 + (x1 - x2)\\n        x4, y4 = x2 - (y1 - y2), y2 + (x1 - x2)\\n\\n        # 检查这两个对角点是否存在于坐标集合中\\n        if f\\"{x3} {y3}\\" in coordinate_set and f\\"{x4} {y4}\\" in coordinate_set:\\n            squareCount += 1\\n\\n        # 计算另外两个可能的对角点\\n        x5, y5 = x1 + (y1 - y2), y1 - (x1 - x2)\\n        x6, y6 = x2 + (y1 - y2), y2 - (x1 - x2)\\n\\n        # 检查这两个对角点是否存在于坐标集合中\\n        if f\\"{x5} {y5}\\" in coordinate_set and f\\"{x6} {y6}\\" in coordinate_set:\\n            squareCount += 1\\n\\n# 每个正方形被计算了4次，因此结果需要除以4\\nprint(squareCount // 4)","javascript":"const readline = require('readline');\\nconst rl = readline.createInterface({\\n  input: process.stdin,\\n  output: process.stdout\\n});\\n\\nlet n;\\nlet coordinates = [];\\n\\n// 判断两个点是否相等\\nfunction arePointsEqual(p1, p2) {\\n  return p1[0] === p2[0] && p1[1] === p2[1];\\n}\\n\\n// 检查一个点是否存在于点数组中\\nfunction pointExists(points, p) {\\n  for (let point of points) {\\n    if (arePointsEqual(point, p)) {\\n      return true;\\n    }\\n  }\\n  return false;\\n}\\n\\nrl.on('line', (line) => {\\n  if (n === undefined) {\\n    n = parseInt(line);\\n  } else {\\n    coordinates.push(line.split(' ').map(Number));\\n    if (coordinates.length === n) rl.close();\\n  }\\n});\\n\\nrl.on('close', () => {\\n  let squareCount = 0;\\n\\n  // 遍历所有点对，检查是否能构成正方形\\n  for (let i = 0; i < n; i++) {\\n    let [x1, y1] = coordinates[i];\\n\\n    for (let j = i + 1; j < n; j++) {\\n      let [x2, y2] = coordinates[j];\\n\\n      // 计算两个可能的对角点\\n      let x3 = x1 - (y1 - y2), y3 = y1 + (x1 - x2);\\n      let x4 = x2 - (y1 - y2), y4 = y2 + (x1 - x2);\\n\\n      if (pointExists(coordinates, [x3, y3]) && pointExists(coordinates, [x4, y4])) {\\n        squareCount++;\\n      }\\n\\n      // 计算另外两个可能的对角点\\n      let x5 = x1 + (y1 - y2), y5 = y1 - (x1 - x2);\\n      let x6 = x2 + (y1 - y2), y6 = y2 - (x1 - x2);\\n\\n      if (pointExists(coordinates, [x5, y5]) && pointExists(coordinates, [x6, y6])) {\\n        squareCount++;\\n      }\\n    }\\n  }\\n\\n  // 每个正方形被计算了4次，因此结果需要除以4\\n  console.log(Math.floor(squareCount / 4));\\n});\\n\\n// 代码2\\nconst readline = require('readline');\\n\\n// 创建接口读取标准输入输出\\nconst rl = readline.createInterface({\\n  input: process.stdin,\\n  output: process.stdout\\n});\\n\\nlet n; // 用于存储坐标数量\\nlet coordinates = []; // 存储坐标的数组\\n\\n// 监听每行输入\\nrl.on('line', (line) => {\\n  if (!n) {\\n    // 第一行输入是坐标数量\\n    n = parseInt(line);\\n    return;\\n  }\\n\\n  // 其余的行是坐标点\\n  coordinates.push(line);\\n\\n  // 当输入的坐标数达到n时，关闭输入流\\n  if (coordinates.length === n) {\\n    rl.close();\\n  }\\n});\\n\\n// 当输入完成时\\nrl.on('close', () => {\\n  let squareCount = 0; // 记录正方形数量\\n  let set = new Set(coordinates); // 用集合存储坐标点，便于快速查找\\n\\n  // 遍历所有坐标点对\\n  for (let i = 0; i < n; i++) {\\n    // 将第一个坐标点分割为x1和y1\\n    let [x1, y1] = coordinates[i].split(' ').map(Number);\\n\\n    for (let j = i + 1; j < n; j++) {\\n      // 将第二个坐标点分割为x2和y2\\n      let [x2, y2] = coordinates[j].split(' ').map(Number);\\n\\n      // 计算两个可能的对角点\\n      let x3 = x1 - (y1 - y2), y3 = y1 + (x1 - x2);\\n      let x4 = x2 - (y1 - y2), y4 = y2 + (x1 - x2);\\n\\n      // 检查这两个对角点是否存在于坐标集合中\\n      if (set.has(\`\${x3} \${y3}\`) && set.has(\`\${x4} \${y4}\`)) {\\n        squareCount++;\\n      }\\n\\n      // 计算另外两个可能的对角点\\n      let x5 = x1 + (y1 - y2), y5 = y1 - (x1 - x2);\\n      let x6 = x2 + (y1 - y2), y6 = y2 - (x1 - x2);\\n\\n      // 检查这两个对角点是否存在于坐标集合中\\n      if (set.has(\`\${x5} \${y5}\`) && set.has(\`\${x6} \${y6}\`)) {\\n        squareCount++;\\n      }\\n    }\\n  }\\n\\n  // 每个正方形被计算了4次，因此结果需要除以4\\n  console.log(Math.floor(squareCount / 4));\\n});","cpp":"#include <iostream>\\n#include <vector>\\nusing namespace std;\\n\\n// 定义一个点结构体\\nstruct Point {\\n    int x, y;\\n};\\n\\n// 判断两个点是否相等\\nbool arePointsEqual(Point a, Point b) {\\n    return a.x == b.x && a.y == b.y;\\n}\\n\\n// 检查数组中是否存在某点\\nbool pointExists(vector<Point>& points, Point p) {\\n    for (auto& point : points) {\\n        if (arePointsEqual(point, p)) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n\\nint main() {\\n    int n;\\n    cin >> n;\\n\\n    vector<Point> points(n);\\n\\n    // 读取坐标并存入数组\\n    for (int i = 0; i < n; i++) {\\n        cin >> points[i].x >> points[i].y;\\n    }\\n\\n    int squareCount = 0;\\n\\n    // 遍历所有点对，检查是否能构成正方形\\n    for (int i = 0; i < n; i++) {\\n        int x1 = points[i].x;\\n        int y1 = points[i].y;\\n\\n        for (int j = i + 1; j < n; j++) {\\n            int x2 = points[j].x;\\n            int y2 = points[j].y;\\n\\n            // 计算两个可能的对角点\\n            Point p3 = {x1 - (y1 - y2), y1 + (x1 - x2)};\\n            Point p4 = {x2 - (y1 - y2), y2 + (x1 - x2)};\\n\\n            if (pointExists(points, p3) && pointExists(points, p4)) {\\n                squareCount++;\\n            }\\n\\n            // 计算另外两个可能的对角点\\n            Point p5 = {x1 + (y1 - y2), y1 - (x1 - x2)};\\n            Point p6 = {x2 + (y1 - y2), y2 - (x1 - x2)};\\n\\n            if (pointExists(points, p5) && pointExists(points, p6)) {\\n                squareCount++;\\n            }\\n        }\\n    }\\n\\n    // 每个正方形被计算了4次，因此结果需要除以4\\n    cout << squareCount / 4 << endl;\\n\\n    return 0;\\n}\\n\\n// 代码2\\n#include <iostream>\\n#include <vector>\\n#include <unordered_set>\\nusing namespace std;\\n\\nint main() {\\n    int n;\\n    // 读取坐标数量\\n    cin >> n;\\n    // 忽略换行符\\n    cin.ignore();\\n\\n    // 创建一个二维数组来存储坐标\\n    vector<vector<int>> coordinates(n, vector<int>(2));\\n    for (int i = 0; i < n; i++) {\\n        // 读取坐标并存储到数组中\\n        cin >> coordinates[i][0] >> coordinates[i][1];\\n    }\\n\\n    int squareCount = 0; // 记录正方形数量\\n    unordered_set<string> set;\\n    // 将坐标转换为字符串形式并存入哈希集合\\n    for (int i = 0; i < n; i++) {\\n        set.insert(to_string(coordinates[i][0]) + \\" \\" + to_string(coordinates[i][1]));\\n    }\\n\\n    // 遍历所有坐标点对\\n    for (int i = 0; i < n; i++) {\\n        int x1 = coordinates[i][0];\\n        int y1 = coordinates[i][1];\\n\\n        for (int j = i + 1; j < n; j++) {\\n            int x2 = coordinates[j][0];\\n            int y2 = coordinates[j][1];\\n\\n            // 计算两个可能的对角点\\n            int x3 = x1 - (y1 - y2), y3 = y1 + (x1 - x2);\\n            int x4 = x2 - (y1 - y2), y4 = y2 + (x1 - x2);\\n\\n            // 检查这两个对角点是否存在于坐标集合中\\n            if (set.count(to_string(x3) + \\" \\" + to_string(y3)) && set.count(to_string(x4) + \\" \\" + to_string(y4))) {\\n                squareCount++;\\n            }\\n\\n            // 计算另外两个可能的对角点\\n            int x5 = x1 + (y1 - y2), y5 = y1 - (x1 - x2);\\n            int x6 = x2 + (y1 - y2), y6 = y2 - (x1 - x2);\\n\\n            // 检查这两个对角点是否存在于坐标集合中\\n            if (set.count(to_string(x5) + \\" \\" + to_string(y5)) && set.count(to_string(x6) + \\" \\" + to_string(y6))) {\\n                squareCount++;\\n            }\\n        }\\n    }\\n\\n    // 每个正方形被计算了4次，因此结果需要除以4\\n    cout << squareCount / 4 << endl;\\n\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <string.h>\\n\\ntypedef struct {\\n    int x, y;\\n} Point;\\n\\n// 判断两个点是否相等\\nint arePointsEqual(Point a, Point b) {\\n    return a.x == b.x && a.y == b.y;\\n}\\n\\n// 检查数组中是否存在某点\\nint pointExists(Point points[], int n, Point p) {\\n    for (int i = 0; i < n; i++) {\\n        if (arePointsEqual(points[i], p)) {\\n            return 1;\\n        }\\n    }\\n    return 0;\\n}\\n\\nint main() {\\n    int n;\\n    scanf(\\"%d\\", &n);\\n\\n    Point points[n];\\n\\n    // 读取坐标并存入数组\\n    for (int i = 0; i < n; i++) {\\n        scanf(\\"%d %d\\", &points[i].x, &points[i].y);\\n    }\\n\\n    int squareCount = 0;\\n\\n    // 遍历所有点对，检查是否能构成正方形\\n    for (int i = 0; i < n; i++) {\\n        int x1 = points[i].x;\\n        int y1 = points[i].y;\\n\\n        for (int j = i + 1; j < n; j++) {\\n            int x2 = points[j].x;\\n            int y2 = points[j].y;\\n\\n            // 计算两个可能的对角点\\n            Point p3 = {x1 - (y1 - y2), y1 + (x1 - x2)};\\n            Point p4 = {x2 - (y1 - y2), y2 + (x1 - x2)};\\n\\n            if (pointExists(points, n, p3) && pointExists(points, n, p4)) {\\n                squareCount++;\\n            }\\n\\n            // 计算另外两个可能的对角点\\n            Point p5 = {x1 + (y1 - y2), y1 - (x1 - x2)};\\n            Point p6 = {x2 + (y1 - y2), y2 - (x1 - x2)};\\n\\n            if (pointExists(points, n, p5) && pointExists(points, n, p6)) {\\n                squareCount++;\\n            }\\n        }\\n    }\\n\\n    // 每个正方形被计算了4次，因此结果需要除以4\\n    printf(\\"%d\\\\n\\", squareCount / 4);\\n\\n    return 0;\\n}"}`),y={id:"37",title:n,examType:"A",score:100,description:t,inputDesc:i,outputDesc:o,examples:e,solution:s,codes:r};export{r as codes,y as default,t as description,a as examType,e as examples,x as id,i as inputDesc,o as outputDesc,p as score,s as solution,n as title};
