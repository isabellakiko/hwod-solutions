const o="175",u="跳马",p="A",d=200,n=`输入 m 和 n 两个数，m 和 n 表示一个 m*n 的棋盘。输入棋盘内的数据。棋盘中存在数字和"."两种字符，如果是数字表示该位置是一匹马，如果是"."表示该位置为空的，棋盘内的数字表示为该马能走的最大步数。
例如棋盘内某个位置一个数字为 k，表示该马只能移动 1~k 步的距离。
棋盘内的马移动类似于中国象棋中的马移动，先在水平或者垂直方向上移动一格，然后再将其移动到对角线位置。
棋盘内的马可以移动到同一个位置，同一个位置可以有多匹马。
请问能否将棋盘上所有的马移动到同一个位置，若可以请输入移动的最小步数。若不可以输出 0。`,e=`输入 m 和 n 两个数，m 和 n 表示一个 m*n 的棋盘。输入棋盘内的数据。棋盘中存在数字和"."两种字符，如果是数字表示该位置是一匹马，如果是"."表示该位置为空的，棋盘内的数字表示为该马能走的最大步数。
例如棋盘内某个位置一个数字为 k，表示该马只能移动 1~k 步的距离。
棋盘内的马移动类似于中国象棋中的马移动，先在水平或者垂直方向上移动一格，然后再将其移动到对角线位置。
棋盘内的马可以移动到同一个位置，同一个位置可以有多匹马。
请问能否将棋盘上所有的马移动到同一个位置，若可以请输入移动的最小步数。若不可以输出 0。`,i="能否将棋盘上所有的马移动到同一个位置，若可以请输入移动的最小步数。若不可以输出 0。",t=[{input:`3 3
. . .
. 2 .
. . .`,output:"0",explanation:""},{input:`3 5
4 7 . 4 8
4 7 4 4 .
7 . . . .`,output:"8",explanation:""}],s=`给定的用例是一个3行5列的棋盘，其中一些位置有数字，代表马的位置和它们可以走的最大步数。我们将逐步模拟广度优先搜索（BFS）的过程来找到所有马都能到达的位置，并计算出最小步数。
棋盘布局：
123
步骤：
初始化： 马的位置和最大步数分别为：(0,0,4), (0,1,7), (0,3,4), (0,4,8), (1,0,4), (1,1,7), (1,2,4), (1,3,4), (2,0,7)。 对棋盘上的每个位置进行BFS： 我们需要检查棋盘上的每个位置，看看是否所有马都能到达那里。例如，我们检查位置(0,2)。 对每个马进行BFS： 从马(0,0,4)开始，它可以在4步内到达的位置有限。我们将这些位置和步数记录下来，并检查是否包括(0,2)。接下来，我们对马(0,1,7)执行同样的操作，记录它可以到达的位置和步数。我们重复这个过程，直到考虑了所有的马。 累加步数： 如果所有马都可以在它们的最大步数内到达位置(0,2)，我们将这些步数累加起来。 更新最小步数： 如果我们发现所有马都能到达位置(0,2)，我们将这个累加的步数与当前的最小步数进行比较，并更新最小步数。如果有任何一个马不能到达位置(0,2)，我们将忽略这个位置，并继续检查下一个位置。 重复以上步骤： 我们重复以上步骤，对棋盘上的每个位置进行检查。 得出结果： 在检查完所有位置后，我们得到所有马都能到达的位置的最小步数。如果没有这样的位置，则返回0。
初始化：
马的位置和最大步数分别为：(0,0,4), (0,1,7), (0,3,4), (0,4,8), (1,0,4), (1,1,7), (1,2,4), (1,3,4), (2,0,7)。
对棋盘上的每个位置进行BFS：
我们需要检查棋盘上的每个位置，看看是否所有马都能到达那里。例如，我们检查位置(0,2)。
对每个马进行BFS：
从马(0,0,4)开始，它可以在4步内到达的位置有限。我们将这些位置和步数记录下来，并检查是否包括(0,2)。接下来，我们对马(0,1,7)执行同样的操作，记录它可以到达的位置和步数。我们重复这个过程，直到考虑了所有的马。
累加步数：
如果所有马都可以在它们的最大步数内到达位置(0,2)，我们将这些步数累加起来。
更新最小步数：
如果我们发现所有马都能到达位置(0,2)，我们将这个累加的步数与当前的最小步数进行比较，并更新最小步数。如果有任何一个马不能到达位置(0,2)，我们将忽略这个位置，并继续检查下一个位置。
重复以上步骤：
我们重复以上步骤，对棋盘上的每个位置进行检查。
得出结果：
在检查完所有位置后，我们得到所有马都能到达的位置的最小步数。如果没有这样的位置，则返回0。
初始化数据结构： 读取棋盘的行数和列数。创建一个二维数组来表示棋盘。创建一个列表来存储每个马的位置和它们可以走的最大步数。 广度优先搜索（BFS）： 定义一个函数来执行BFS，该函数将遍历棋盘上的每个位置，尝试找到所有马都能到达的位置，并计算出最小步数。在BFS中，定义马可以走的八个方向。对于棋盘上的每个位置，初始化步数为0，并设置一个标志来判断是否所有马都能到达该位置。 遍历棋盘上的每个位置： 对于棋盘上的每个位置，遍历每个马，使用BFS来判断马是否能到达该位置。对于每个马，使用一个队列来存储它可以到达的位置和对应的步数。使用一个集合来记录已经访问过的位置，避免重复访问。 遍历每个马： 从马的当前位置开始，将其加入队列，并将该位置标记为已访问。当队列不为空时，取出队列的头部元素，这是当前马的位置和步数。如果该位置是目标位置，累加步数并标记找到目标位置。否则，遍历马可以走的八个方向，对于每个方向，计算新的位置并检查是否有效且未访问过。如果新位置有效，将其加入队列并标记为已访问。 更新步数和可能性： 如果找到目标位置，累加步数。如果没有找到目标位置，标记为不可能到达。 计算最小步数： 如果所有马都能到达当前位置，更新最小步数。如果没有任何位置能被所有马到达，返回-1。否则，返回找到的最小步数。
初始化数据结构：
读取棋盘的行数和列数。创建一个二维数组来表示棋盘。创建一个列表来存储每个马的位置和它们可以走的最大步数。
广度优先搜索（BFS）：
定义一个函数来执行BFS，该函数将遍历棋盘上的每个位置，尝试找到所有马都能到达的位置，并计算出最小步数。在BFS中，定义马可以走的八个方向。对于棋盘上的每个位置，初始化步数为0，并设置一个标志来判断是否所有马都能到达该位置。
遍历棋盘上的每个位置：
对于棋盘上的每个位置，遍历每个马，使用BFS来判断马是否能到达该位置。对于每个马，使用一个队列来存储它可以到达的位置和对应的步数。使用一个集合来记录已经访问过的位置，避免重复访问。
遍历每个马：
从马的当前位置开始，将其加入队列，并将该位置标记为已访问。当队列不为空时，取出队列的头部元素，这是当前马的位置和步数。如果该位置是目标位置，累加步数并标记找到目标位置。否则，遍历马可以走的八个方向，对于每个方向，计算新的位置并检查是否有效且未访问过。如果新位置有效，将其加入队列并标记为已访问。
更新步数和可能性：
如果找到目标位置，累加步数。如果没有找到目标位置，标记为不可能到达。
计算最小步数：
如果所有马都能到达当前位置，更新最小步数。如果没有任何位置能被所有马到达，返回-1。否则，返回找到的最小步数。`,r=JSON.parse(`{"java":"import java.io.BufferedReader;\\nimport java.io.IOException;\\nimport java.io.InputStreamReader;\\nimport java.util.LinkedList;\\nimport java.util.Queue;\\nimport java.util.HashSet;\\nimport java.util.Set;\\n\\npublic class Main {\\n    // 定义棋盘的行数和列数\\n    private static int m, n;\\n    // 定义棋盘\\n    private static int[][] board;\\n    // 定义马的位置和步数的列表\\n    private static LinkedList<int[]> horses = new LinkedList<>();\\n\\n    public static void main(String[] args) throws IOException {\\n        // 使用BufferedReader读取输入\\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\\n        // 读取第一行输入，获取棋盘的行数和列数\\n        String[] firstLine = br.readLine().split(\\" \\");\\n        m = Integer.parseInt(firstLine[0]);\\n        n = Integer.parseInt(firstLine[1]);\\n        // 初始化棋盘\\n        board = new int[m][n];\\n\\n        // 读取棋盘上每个位置的输入\\n        for (int i = 0; i < m; i++) {\\n            String[] line = br.readLine().split(\\" \\");\\n            for (int j = 0; j < n; j++) {\\n                // 如果当前位置不是空点，则将马的位置和步数添加到列表中\\n                if (!line[j].equals(\\".\\")) {\\n                    horses.add(new int[]{i, j, Integer.parseInt(line[j])});\\n                }\\n            }\\n        }\\n\\n        // 调用bfs方法并打印结果\\n        System.out.println(bfs());\\n    }\\n\\n    // 定义广度优先搜索方法\\n    private static int bfs() {\\n        // 定义马能走的八个方向\\n        int[][] directions = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};\\n        // 初始化最小步数为最大值\\n        int minSteps = Integer.MAX_VALUE;\\n\\n        // 遍历棋盘上的每个位置\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // 初始化当前位置的步数为0\\n                int steps = 0;\\n                // 标记是否所有马都能到达当前位置\\n                boolean possible = true;\\n\\n                // 遍历每个马\\n                for (int[] horse : horses) {\\n                    // 使用队列进行BFS\\n                    Queue<int[]> queue = new LinkedList<>();\\n                    // 使用集合记录已访问的位置\\n                    Set<String> visited = new HashSet<>();\\n                    // 将当前马的位置和步数0加入队列\\n                    queue.offer(new int[]{horse[0], horse[1], 0});\\n                    // 将当前马的位置添加到已访问集合中\\n                    visited.add(horse[0] + \\",\\" + horse[1]);\\n                    // 标记是否找到当前位置\\n                    boolean found = false;\\n\\n                    // 当队列不为空且可能到达当前位置时\\n                    while (!queue.isEmpty() && possible) {\\n                        // 取出队列头部元素\\n                        int[] current = queue.poll();\\n                        // 如果当前元素位置等于目标位置\\n                        if (current[0] == i && current[1] == j) {\\n                            // 累加步数\\n                            steps += current[2];\\n                            // 标记为找到\\n                            found = true;\\n                            break;\\n                        }\\n\\n                        // 遍历马能走的八个方向\\n                        for (int[] dir : directions) {\\n                            // 计算新的位置\\n                            int nx = current[0] + dir[0];\\n                            int ny = current[1] + dir[1];\\n                            // 如果新位置有效且未访问过，则加入队列\\n                            if (nx >= 0 && nx < m && ny >= 0 && ny < n && current[2] < horse[2] && !visited.contains(nx + \\",\\" + ny)) {\\n                                queue.offer(new int[]{nx, ny, current[2] + 1});\\n                                visited.add(nx + \\",\\" + ny);\\n                            }\\n                        }\\n                    }\\n\\n                    // 如果没有找到目标位置，则标记为不可能到达\\n                    if (!found) {\\n                        possible = false;\\n                    }\\n                }\\n\\n                // 如果所有马都能到达当前位置，则更新最小步数\\n                if (possible) {\\n                    minSteps = Math.min(minSteps, steps);\\n                }\\n            }\\n        }\\n\\n        // 如果最小步数为最大值，则返回0，否则返回最小步数\\n        return minSteps == Integer.MAX_VALUE ? 0 : minSteps;\\n    }\\n}","python":"from collections import deque\\n\\n# 读取棋盘的行数和列数\\nm, n = map(int, input().split())\\n# 初始化棋盘数组，虽然在这个程序中没有直接使用棋盘数据\\nboard = [[0] * n for _ in range(m)]\\n\\n# 存储每个马的位置和它们的最大移动步数\\nhorses = []\\nfor i in range(m):\\n    line = input().split()\\n    for j in range(n):\\n        if line[j] != '.':\\n            # 如果位置不是空点，则记录马的位置和初始步数\\n            horses.append((i, j, int(line[j])))\\n\\ndef bfs():\\n    # 马可以移动的八个方向\\n    directions = [(-1, -2), (-2, -1), (-2, 1), (-1, 2), (1, 2), (2, 1), (2, -1), (1, -2)]\\n    # 初始化最小步数为无穷大\\n    min_steps = float('inf')\\n\\n    # 遍历棋盘上的每一个位置作为目标位置\\n    for i in range(m):\\n        for j in range(n):\\n            steps = 0\\n            possible = True\\n\\n            # 遍历每个马\\n            for horse in horses:\\n                queue = deque([(horse[0], horse[1], 0)])\\n                visited = set()\\n                visited.add((horse[0], horse[1]))\\n                found = False\\n\\n                # 使用 BFS 寻找每个马到目标位置的最短路径\\n                while queue and possible:\\n                    x, y, dist = queue.popleft()\\n                    if (x, y) == (i, j):\\n                        steps += dist\\n                        found = True\\n                        break\\n\\n                    for dx, dy in directions:\\n                        nx, ny = x + dx, y + dy\\n                        # 检查新位置是否有效，并且未被访问过\\n                        if 0 <= nx < m and 0 <= ny < n and dist < horse[2] and (nx, ny) not in visited:\\n                            queue.append((nx, ny, dist + 1))\\n                            visited.add((nx, ny))\\n                \\n                # 如果找不到路径，则此目标位置不可达\\n                if not found:\\n                    possible = False\\n            \\n            # 如果所有马都可以到达此位置，更新最小步数\\n            if possible:\\n                min_steps = min(min_steps, steps)\\n    \\n    # 如果找不到任何可行的解决方案，则返回0，否则返回最小步数\\n    return 0 if min_steps == float('inf') else min_steps\\n\\n# 打印广度优先搜索的结果\\nprint(bfs())","javascript":"// 导入readline模块，用于从标准输入读取数据\\nconst readline = require('readline');\\n// 创建readline接口实例\\nconst rl = readline.createInterface({\\n    input: process.stdin\\n});\\n\\n// 用于存储输入的所有行\\nconst lines = [];\\n// 监听行输入事件\\nrl.on('line', (input) => {\\n    lines.push(input); // 将每行输入存储到 lines 数组中\\n}).on('close', () => { // 输入结束时触发\\n    // 解析第一行数据获取棋盘的行数和列数\\n    const [m, n] = lines[0].split(' ').map(Number);\\n    // 创建一个m行n列的棋盘，初始值为'.'\\n    const board = Array.from({ length: m }, () => Array(n).fill('.'));\\n    // 存储马的位置和步数的数组\\n    const horses = [];\\n\\n    // 遍历输入的棋盘数据\\n    for (let i = 1; i <= m; i++) {\\n        lines[i].split(' ').forEach((cell, j) => {\\n            if (cell !== '.') {\\n                // 如果当前位置有马，则记录其位置和步数\\n                horses.push([i - 1, j, parseInt(cell)]);\\n            }\\n        });\\n    }\\n\\n    // 调用bfs函数计算结果，并打印\\n    console.log(bfs(m, n, horses));\\n});\\n\\n// 定义广度优先搜索函数\\nfunction bfs(m, n, horses) {\\n    // 定义马能走的八个方向\\n    const directions = [[-1, -2], [-2, -1], [-2, 1], [-1, 2], [1, 2], [2, 1], [2, -1], [1, -2]];\\n    // 初始化最小步数为无穷大\\n    let minSteps = Infinity;\\n\\n    // 遍历棋盘的每一个位置\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            let steps = 0; // 存储到达当前位置的总步数\\n            let possible = true; // 标记所有马是否都能到达当前位置\\n\\n            // 遍历每一匹马\\n            for (const [x, y, maxSteps] of horses) {\\n                const queue = [[x, y, 0]]; // 使用队列实现BFS\\n                const visited = new Set(\`\${x},\${y}\`); // 记录已访问的位置\\n\\n                let found = false; // 标记是否找到路径\\n                // 当队列不为空并且仍可能到达当前位置时继续循环\\n                while (queue.length > 0 && possible) {\\n                    const [currentX, currentY, currentSteps] = queue.shift();\\n                    // 如果当前位置是目标位置\\n                    if (currentX === i && currentY === j) {\\n                        steps += currentSteps; // 累加步数\\n                        found = true; // 标记已找到\\n                        break;\\n                    }\\n\\n                    // 遍历马能走的八个方向\\n                    directions.forEach(([dx, dy]) => {\\n                        const nx = currentX + dx;\\n                        const ny = currentY + dy;\\n                        // 检查新位置是否有效并且未被访问过\\n                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && currentSteps < maxSteps && !visited.has(\`\${nx},\${ny}\`)) {\\n                            queue.push([nx, ny, currentSteps + 1]); // 加入新位置到队列\\n                            visited.add(\`\${nx},\${ny}\`); // 标记为已访问\\n                        }\\n                    });\\n                }\\n\\n                // 如果没有找到目标位置，则标记为不可能到达\\n                if (!found) possible = false;\\n            }\\n\\n            // 如果所有马都能到达当前位置，更新最小步数\\n            if (possible) minSteps = Math.min(minSteps, steps);\\n        }\\n    }\\n\\n    // 如果最小步数为无穷大，表示没有可行解，返回0；否则返回最小步数\\n    return minSteps === Infinity ? 0 : minSteps;\\n}","cpp":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <set>\\n#include <string>\\n#include <climits>\\n#include <tuple>  \\n\\nusing namespace std;\\n\\n// 定义棋盘的行数和列数\\nint m, n;\\n// 定义棋盘\\nvector<vector<char>> board;\\n// 定义马的位置和步数的列表\\nvector<tuple<int, int, int>> horses;\\n\\n// 定义广度优先搜索方法\\nint bfs() {\\n    // 定义马能走的八个方向\\n    vector<pair<int, int>> directions = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};\\n    // 初始化最小步数为最大值\\n    int minSteps = INT_MAX;\\n\\n    // 遍历棋盘上的每个位置\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n            // 初始化当前位置的步数为0\\n            int steps = 0;\\n            // 标记是否所有马都能到达当前位置\\n            bool possible = true;\\n\\n            // 遍历每个马\\n            for (auto& horse : horses) {\\n                // 使用队列进行BFS\\n                queue<tuple<int, int, int>> queue;\\n                // 使用集合记录已访问的位置\\n                set<string> visited;\\n                // 获取马的位置和最大步数\\n                int x, y, maxSteps;\\n                tie(x, y, maxSteps) = horse;\\n                // 将当前马的位置和步数0加入队列\\n                queue.push(make_tuple(x, y, 0));\\n                // 将当前马的位置添加到已访问集合中\\n                visited.insert(to_string(x) + \\",\\" + to_string(y));\\n                // 标记是否找到当前位置\\n                bool found = false;\\n\\n                // 当队列不为空且可能到达当前位置时\\n                while (!queue.empty() && possible) {\\n                    // 取出队列头部元素\\n                    tuple<int, int, int> current = queue.front();\\n                    queue.pop();\\n                    int cx, cy, cs;\\n                    tie(cx, cy, cs) = current; // Unpack the tuple\\n                    // 如果当前元素位置等于目标位置\\n                    if (cx == i && cy == j) {\\n                        // 累加步数\\n                        steps += cs;\\n                        // 标记为找到\\n                        found = true;\\n                        break;\\n                    }\\n\\n                    // 遍历马能走的八个方向\\n                    for (auto& dir : directions) {\\n                        // 计算新的位置\\n                        int nx = cx + dir.first;\\n                        int ny = cy + dir.second;\\n                        // 如果新位置有效且未访问过，则加入队列\\n                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && cs < maxSteps && !visited.count(to_string(nx) + \\",\\" + to_string(ny))) {\\n                            queue.push(make_tuple(nx, ny, cs + 1));\\n                            visited.insert(to_string(nx) + \\",\\" + to_string(ny));\\n                        }\\n                    }\\n                }\\n\\n                // 如果没有找到目标位置，则标记为不可能到达\\n                if (!found) {\\n                    possible = false;\\n                }\\n            }\\n\\n            // 如果所有马都能到达当前位置，则更新最小步数\\n            if (possible) {\\n                minSteps = min(minSteps, steps);\\n            }\\n        }\\n    }\\n\\n    // 如果最小步数为最大值，则返回0，否则返回最小步数\\n    return minSteps == INT_MAX ? 0 : minSteps;\\n}\\n\\n// 主函数\\nint main() {\\n    // 读取棋盘的行数和列数\\n    cin >> m >> n;\\n    // 初始化棋盘\\n    board.resize(m, vector<char>(n));\\n    // 读取棋盘上每个位置的输入\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n            cin >> board[i][j];\\n            // 如果当前位置不是空点，则将马的位置和步数添加到列表中\\n            if (board[i][j] != '.') {\\n                horses.emplace_back(i, j, board[i][j] - '0');\\n            }\\n        }\\n    }\\n\\n    // 调用bfs方法并打印结果\\n    cout << bfs() << endl;\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <limits.h>\\n#include <string.h>\\n\\n// 定义棋盘的最大行数和列数\\n#define MAX_M 100\\n#define MAX_N 100\\n\\n// 定义棋盘的行数和列数\\nint m, n;\\n// 定义棋盘\\nchar board[MAX_M][MAX_N];\\n// 定义马的位置和步数的结构体\\ntypedef struct {\\n    int x, y, steps;\\n} Horse;\\n// 定义马的数组\\nHorse horses[MAX_M * MAX_N];\\n// 定义马的数量\\nint horse_count = 0;\\n\\n// 定义队列中的元素结构体\\ntypedef struct {\\n    int x, y, step;\\n} QueueItem;\\n\\n// 定义队列\\nQueueItem queue[MAX_M * MAX_N * 8];\\n// 队列的头和尾\\nint queue_head = 0, queue_tail = 0;\\n\\n// 队列操作函数\\nvoid queue_push(QueueItem item) {\\n    queue[queue_tail++] = item;\\n}\\n\\nQueueItem queue_pop() {\\n    return queue[queue_head++];\\n}\\n\\nint queue_empty() {\\n    return queue_head == queue_tail;\\n}\\n\\n// 定义广度优先搜索方法\\nint bfs() {\\n    // 定义马能走的八个方向\\n    int directions[8][2] = {{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}};\\n    // 初始化最小步数为最大值\\n    int minSteps = INT_MAX;\\n\\n    // 遍历棋盘上的每个位置\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n            // 初始化当前位置的步数为0\\n            int steps = 0;\\n            // 标记是否所有马都能到达当前位置\\n            int possible = 1;\\n\\n            // 遍历每个马\\n            for (int h = 0; h < horse_count; ++h) {\\n                // 使用队列进行BFS\\n                queue_head = queue_tail = 0;\\n                // 使用二维数组记录已访问的位置\\n                int visited[MAX_M][MAX_N];\\n                memset(visited, 0, sizeof(visited));\\n\\n                // 获取马的位置和最大步数\\n                Horse horse = horses[h];\\n                // 将当前马的位置和步数0加入队列\\n                queue_push((QueueItem){horse.x, horse.y, 0});\\n                // 将当前马的位置添加到已访问数组中\\n                visited[horse.x][horse.y] = 1;\\n                // 标记是否找到当前位置\\n                int found = 0;\\n\\n                // 当队列不为空且可能到达当前位置时\\n                while (!queue_empty() && possible) {\\n                    // 取出队列头部元素\\n                    QueueItem current = queue_pop();\\n                    // 如果当前元素位置等于目标位置\\n                    if (current.x == i && current.y == j) {\\n                        // 累加步数\\n                        steps += current.step;\\n                        // 标记为找到\\n                        found = 1;\\n                        break;\\n                    }\\n\\n                    // 遍历马能走的八个方向\\n                    for (int d = 0; d < 8; ++d) {\\n                        // 计算新的位置\\n                        int nx = current.x + directions[d][0];\\n                        int ny = current.y + directions[d][1];\\n                        // 如果新位置有效且未访问过，则加入队列\\n                        if (nx >= 0 && nx < m && ny >= 0 && ny < n && current.step < horse.steps && !visited[nx][ny]) {\\n                            queue_push((QueueItem){nx, ny, current.step + 1});\\n                            visited[nx][ny] = 1;\\n                        }\\n                    }\\n                }\\n\\n                // 如果没有找到目标位置，则标记为不可能到达\\n                if (!found) {\\n                    possible = 0;\\n                }\\n            }\\n\\n            // 如果所有马都能到达当前位置，则更新最小步数\\n            if (possible) {\\n                minSteps = minSteps < steps ? minSteps : steps;\\n            }\\n        }\\n    }\\n\\n    // 如果最小步数为最大值，则返回0，否则返回最小步数\\n    return minSteps == INT_MAX ? 0 : minSteps;\\n}\\n\\n// 主函数\\nint main() {\\n    // 读取棋盘的行数和列数\\n    scanf(\\"%d %d\\", &m, &n);\\n    // 读取棋盘上每个位置的输入\\n    for (int i = 0; i < m; ++i) {\\n        for (int j = 0; j < n; ++j) {\\n            scanf(\\" %c\\", &board[i][j]); // 注意%c前的空格，用于跳过空白字符\\n            // 如果当前位置不是空点，则将马的位置和步数添加到列表中\\n            if (board[i][j] != '.') {\\n                horses[horse_count++] = (Horse){i, j, board[i][j] - '0'};\\n            }\\n        }\\n    }\\n\\n    // 调用bfs方法并打印结果\\n    printf(\\"%d\\\\n\\", bfs());\\n    return 0;\\n}"}`),a={id:"175",title:"跳马",examType:"A",score:200,description:n,inputDesc:e,outputDesc:i,examples:t,solution:s,codes:r};export{r as codes,a as default,n as description,p as examType,t as examples,o as id,e as inputDesc,i as outputDesc,d as score,s as solution,u as title};
