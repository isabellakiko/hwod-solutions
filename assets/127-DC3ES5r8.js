const r="127",n="智能驾驶",a="A",m=200,i=`有一辆汽车需要从 m * n 的地图左上角（起点）开往地图的右下角（终点），去往每一个地区都需要消耗一定的油量，加油站可进行加油。
请你计算汽车确保从从起点到达终点时所需的最少初始油量。
说明：
智能汽车可以上下左右四个方向移动地图上的数字取值是 0 或 -1 或 正整数： -1 ：表示加油站，可以加满油，汽车的油箱容量最大为100；0 ：表示这个地区是障碍物，汽车不能通过正整数：表示汽车走过这个地区的耗油量 如果汽车无论如何都无法到达终点，则返回 -1
-1 ：表示加油站，可以加满油，汽车的油箱容量最大为100；0 ：表示这个地区是障碍物，汽车不能通过正整数：表示汽车走过这个地区的耗油量`,e=`第一行为两个数字，M，N，表示地图的大小为 M * N
0 < M,N ≤ 200
后面一个 M * N 的矩阵，其中的值是 0 或 -1 或正整数，加油站的总数不超过 200 个`,o=`如果汽车无论如何都无法到达终点，则返回 -1
如果汽车可以到达终点，则返回最少的初始油量`,t=[{input:`2,2
10,20
30,40`,output:"60",explanation:"2x2地图，行走路线：右→下，消耗10+20+40=70，最少初始油量60"},{input:`4,4
10,30,30,20
20,30,-1,10
30,20,20,40
40,-1,30,40`,output:"70",explanation:"经过加油站可以加满油"},{input:`4,4
10,30,30,20
20,30,20,10
30,20,10,40
40,20,30,40`,output:"-1",explanation:"无论如何都无法到达终点"}],u=`**解题思路：**

本题是一道**二分答案+BFS**问题。

**核心思路：**
- 二分初始油量（0~100）
- 对每个初始油量，BFS验证能否到达终点
- 遇到加油站(-1)时油量变为100

**算法步骤：**
1. 二分枚举初始油量mid
2. BFS搜索，维护每个位置的最大剩余油量
3. 能到达终点则尝试更小油量，否则增大

**时间复杂度**：O(N×M×log100)`,l=JSON.parse(`{"java":"import java.util.*;\\n\\npublic class Main {\\n    // 定义常量，表示汽车油箱的最大容量\\n    private static final int MAX_FUEL = 100; \\n\\n    public static void main(String[] args) {\\n        Scanner scanner = new Scanner(System.in).useDelimiter(\\",|\\\\\\\\s+\\");\\n        // 读取地图的行数和列数\\n        int numRows = scanner.nextInt();\\n        int numCols = scanner.nextInt();\\n        // 创建地图数组\\n        int[][] map = new int[numRows][numCols];\\n\\n        // 填充地图数组，读取每个单元的值\\n        for (int i = 0; i < numRows; i++) {\\n            for (int j = 0; j < numCols; j++) {\\n                map[i][j] = scanner.nextInt();\\n            }\\n        }\\n\\n        // 计算并获取最小初始油量\\n        int minFuel = findMinimumInitialFuel(map, numRows, numCols);\\n        // 输出计算结果\\n        System.out.println(minFuel);\\n    }\\n\\n    // 使用二分查找方法确定从起点到终点所需的最小初始油量\\n    private static int findMinimumInitialFuel(int[][] map, int numRows, int numCols) {\\n        int low = 0, high = MAX_FUEL, optimalFuel = -1; // 初始化二分查找的上下界及结果\\n\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            // 判断当前中值油量是否足以到达终点\\n            if (canReachDestination(map, mid, numRows, numCols)) {\\n                optimalFuel = mid; // 更新找到的可行油量\\n                high = mid - 1; // 尝试寻找更小的可行油量\\n            } else {\\n                low = mid + 1; // 增加油量尝试\\n            }\\n        }\\n        return optimalFuel; // 返回最小初始油量，如果无法到达则返回-1\\n    }\\n\\n    // 检查给定起始油量是否足以从起点到达终点\\n    private static boolean canReachDestination(int[][] map, int startFuel, int numRows, int numCols) {\\n        if (map[0][0] == 0) return false; // 起点如果是障碍物，则无法出发\\n\\n        // 初始化每个位置的剩余油量数组\\n        int[][] remainingFuel = new int[numRows][numCols];\\n        for (int[] row : remainingFuel) {\\n            Arrays.fill(row, -1);\\n        }\\n        // 设置起点的初始油量\\n        remainingFuel[0][0] = map[0][0] == -1 ? MAX_FUEL : startFuel - map[0][0];\\n        if (remainingFuel[0][0] < 0) return false; // 如果起始油量不足以离开起点，返回false\\n\\n        // 使用优先队列按照油量从大到小进行搜索\\n        PriorityQueue<int[]> priorityQueue = new PriorityQueue<>((a, b) -> b[2] - a[2]);\\n        priorityQueue.offer(new int[]{0, 0, remainingFuel[0][0]});\\n        int[] dx = {0, 1, 0, -1}; // 搜索方向数组x\\n        int[] dy = {1, 0, -1, 0}; // 搜索方向数组y\\n\\n        // BFS搜索\\n        while (!priorityQueue.isEmpty()) {\\n            int[] current = priorityQueue.poll();\\n            int currentRow = current[0], currentCol = current[1], fuel = current[2];\\n\\n            if (currentRow == numRows - 1 && currentCol == numCols - 1) return true; // 如果到达终点，则返回true\\n\\n            // 检查四个方向\\n            for (int direction = 0; direction < 4; direction++) {\\n                int newRow = currentRow + dx[direction], newCol = currentCol + dy[direction];\\n                if (isValid(newRow, newCol, numRows, numCols, map)) { // 检查新位置是否有效\\n                    int newFuel = map[newRow][newCol] == -1 ? MAX_FUEL : fuel - map[newRow][newCol];\\n                    if (newFuel > remainingFuel[newRow][newCol]) {\\n                        remainingFuel[newRow][newCol] = newFuel;\\n                        priorityQueue.offer(new int[]{newRow, newCol, newFuel});\\n                    }\\n                }\\n            }\\n        }\\n        return false; // 如果无法到达终点，则返回false\\n    }\\n\\n    // 判断指定位置是否有效（不越界，非障碍物）\\n    private static boolean isValid(int row, int col, int numRows, int numCols, int[][] map) {\\n        return row >= 0 && row < numRows && col >= 0 && col < numCols && map[row][col] != 0;\\n    }\\n}","python":"import heapq\\n\\n# 定义常量，表示汽车油箱的最大容量\\nMAX_FUEL = 100\\n\\ndef main():\\n    # 从标准输入读取行数和列数，并以逗号分隔\\n    numRows, numCols = map(int, input().split(\\",\\"))\\n    # 读取地图数据，每一行通过逗号分隔，对于每行输入，读取numRows行\\n    map_data = [list(map(int, input().split(\\",\\"))) for _ in range(numRows)]\\n\\n    # 计算并获取最小初始油量\\n    min_fuel = find_minimum_initial_fuel(map_data, numRows, numCols)\\n    # 输出计算得到的最小初始油量\\n    print(min_fuel)\\n\\ndef find_minimum_initial_fuel(map_data, numRows, numCols):\\n    # 初始化二分查找的边界\\n    low, high = 0, MAX_FUEL\\n    optimal_fuel = -1  # 最优的油量值，默认为-1表示未找到\\n\\n    # 二分查找确定合适的起始油量\\n    while low <= high:\\n        mid = (low + high) // 2\\n        # 检查中值油量是否可以从起点到达终点\\n        if can_reach_destination(map_data, mid, numRows, numCols):\\n            optimal_fuel = mid  # 更新找到的最小可行油量\\n            high = mid - 1  # 尝试更小的油量\\n        else:\\n            low = mid + 1  # 增加油量尝试\\n    \\n    return optimal_fuel\\n\\ndef can_reach_destination(map_data, start_fuel, numRows, numCols):\\n    # 如果起点是障碍物，则无法出发\\n    if map_data[0][0] == 0:\\n        return False\\n\\n    # 初始化存储每个单元格剩余油量的二维列表\\n    remaining_fuel = [[-1 for _ in range(numCols)] for _ in range(numRows)]\\n    # 设置起点的初始油量，考虑起点可能为负值消耗的情况\\n    remaining_fuel[0][0] = MAX_FUEL if map_data[0][0] == -1 else start_fuel - map_data[0][0]\\n    if remaining_fuel[0][0] < 0:\\n        return False  # 起始油量不足以离开起点\\n\\n    # 使用优先队列，以最大剩余油量优先处理\\n    priority_queue = []\\n    heapq.heappush(priority_queue, (-remaining_fuel[0][0], 0, 0))\\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 定义上下左右四个方向\\n\\n    # 使用优先队列执行BFS\\n    while priority_queue:\\n        current_fuel, current_row, current_col = heapq.heappop(priority_queue)\\n        current_fuel = -current_fuel  # 因为用了负值来实现最大堆\\n        \\n        # 到达终点检查\\n        if current_row == numRows - 1 and current_col == numCols - 1:\\n            return True\\n        \\n        # 检查四个可能的移动方向\\n        for dx, dy in directions:\\n            new_row, new_col = current_row + dx, current_col + dy\\n            if is_valid(new_row, new_col, numRows, numCols, map_data):\\n                new_fuel = MAX_FUEL if map_data[new_row][new_col] == -1 else current_fuel - map_data[new_row][new_col]\\n                if new_fuel > remaining_fuel[new_row][new_col]:\\n                    remaining_fuel[new_row][new_col] = new_fuel\\n                    heapq.heappush(priority_queue, (-new_fuel, new_row, new_col))\\n                    \\n    return False  # 如果没有找到到达终点的路径则返回False\\n\\ndef is_valid(row, col, numRows, numCols, map_data):\\n    # 检查位置是否有效（不越界且不是障碍物）\\n    return 0 <= row < numRows and 0 <= col < numCols and map_data[row][col] != 0\\n\\nif __name__ == \\"__main__\\":\\n    main()","javascript":"const readline = require('readline');\\n \\nconst rl = readline.createInterface({\\n  input: process.stdin,\\n  output: process.stdout,\\n  terminal: false \\n});\\nconst MAX_FUEL = 100; // 设置最大油量常量\\nconst lines = []; // 创建一个数组来存储从控制台读取的每行数据\\n// 当读取到一行数据时触发，将数据存入 lines 数组\\nrl.on('line', function(line) {\\n  lines.push(line);\\n});\\n\\n// 当所有输入都读取完毕时触发\\nrl.on('close', function() {\\n  // 解析第一行数据为地图的行数和列数\\n  const [numRows, numCols] = lines[0].split(\\",\\").map(Number);\\n  const map = []; // 初始化地图数组\\n  // 根据行数解析后续输入数据填充地图\\n  for (let i = 1; i <= numRows; i++) {\\n    map.push(lines[i].split(\\",\\").map(Number));\\n  }\\n  // 计算最小初始油量\\n  const minFuel = findMinimumInitialFuel(map, numRows, numCols);\\n  // 输出结果\\n  console.log(minFuel);\\n});\\n\\n// 判断是否可以到达目的地的函数\\nfunction canReachDestination(map, startFuel, numRows, numCols) {\\n  if (map[0][0] === 0) return false; // 如果起点是不可通行的，则直接返回 false\\n\\n  // 初始化剩余油量的二维数组\\n  const remainingFuel = Array.from({ length: numRows }, () => Array(numCols).fill(-1));\\n  // 设置起点的初始油量\\n  remainingFuel[0][0] = map[0][0] === -1 ? MAX_FUEL : startFuel - map[0][0];\\n  if (remainingFuel[0][0] < 0) return false; // 如果起点油量不足，返回 false\\n\\n  // 初始化队列并将起点加入队列\\n  const queue = [[0, 0, remainingFuel[0][0]]];\\n  // 定义移动方向的数组\\n  const dx = [0, 1, 0, -1];\\n  const dy = [1, 0, -1, 0];\\n\\n  // 广度优先搜索遍历地图\\n  while (queue.length > 0) {\\n    const [currentRow, currentCol, fuel] = queue.shift();\\n\\n    // 判断是否到达终点\\n    if (currentRow === numRows - 1 && currentCol === numCols - 1) return true;\\n\\n    // 遍历四个可能的移动方向\\n    for (let direction = 0; direction < 4; direction++) {\\n      const newRow = currentRow + dx[direction];\\n      const newCol = currentCol + dy[direction];\\n      // 检查新位置是否有效\\n      if (isValid(newRow, newCol, numRows, numCols, map)) {\\n        // 计算新位置的剩余油量\\n        const newFuel = map[newRow][newCol] === -1 ? MAX_FUEL : fuel - map[newRow][newCol];\\n        // 如果新位置的剩余油量大于之前记录的值，更新并将其加入队列\\n        if (newFuel > remainingFuel[newRow][newCol]) {\\n          remainingFuel[newRow][newCol] = newFuel;\\n          queue.push([newRow, newCol, newFuel]);\\n        }\\n      }\\n    }\\n  }\\n\\n  return false; // 如果没有到达终点，则返回 false\\n}\\n\\n// 检查指定位置是否有效\\nfunction isValid(row, col, numRows, numCols, map) {\\n  return row >= 0 && row < numRows && col >= 0 && col < numCols && map[row][col] !== 0;\\n}\\n\\n// 使用二分搜索确定最小的初始油量的函数\\nfunction findMinimumInitialFuel(map, numRows, numCols) {\\n  let low = 0, high = MAX_FUEL, optimalFuel = -1;\\n  while (low <= high) {\\n    const mid = Math.floor((low + high) / 2);\\n    // 判断中间值油量是否足够\\n    if (canReachDestination(map, mid, numRows, numCols)) {\\n      optimalFuel = mid;\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1;\\n    }\\n  }\\n  return optimalFuel; // 返回找到的最小初始油量\\n}","cpp":"#include <iostream>\\n#include <vector>\\n#include <queue>\\n#include <tuple>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\n// 定义常量，表示汽车油箱的最大容量\\nconst int MAX_FUEL = 100;\\n\\n// 函数声明\\nbool canReachDestination(const vector<vector<int>>& mapData, int startFuel, int numRows, int numCols);\\nbool isValid(int row, int col, int numRows, int numCols, const vector<vector<int>>& mapData);\\n\\n// 寻找从起点到终点所需要的最小初始油量的函数\\nint findMinimumInitialFuel(const vector<vector<int>>& mapData, int numRows, int numCols) {\\n    int low = 0, high = MAX_FUEL, optimalFuel = -1;  // 初始化二分查找的上下界和最优解变量\\n\\n    while (low <= high) {  // 进行二分查找\\n        int mid = (low + high) / 2;\\n        if (canReachDestination(mapData, mid, numRows, numCols)) {\\n            optimalFuel = mid;  // 如果可以到达终点，更新最优解\\n            high = mid - 1;     // 尝试寻找更小的初始油量\\n        } else {\\n            low = mid + 1;      // 如果不可以到达终点，增加初始油量的下限\\n        }\\n    }\\n\\n    return optimalFuel;  // 返回找到的最小初始油量\\n}\\n\\n// 判断给定起始油量能否从起点到达终点的函数\\nbool canReachDestination(const vector<vector<int>>& mapData, int startFuel, int numRows, int numCols) {\\n    if (mapData[0][0] == 0) return false;  // 如果起点是障碍物，直接返回false\\n\\n    vector<vector<int>> remainingFuel(numRows, vector<int>(numCols, -1));  // 初始化每个点的剩余油量数组\\n    remainingFuel[0][0] = (mapData[0][0] == -1) ? MAX_FUEL : startFuel - mapData[0][0];  // 设置起点的初始油量\\n    if (remainingFuel[0][0] < 0) return false;  // 如果起点的初始油量就不足，返回false\\n\\n    priority_queue<tuple<int, int, int>> priorityQueue;  // 使用优先队列存储待处理的点\\n    priorityQueue.push({remainingFuel[0][0], 0, 0});\\n    vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};  // 可以移动的四个方向\\n\\n    while (!priorityQueue.empty()) {\\n        auto [currentFuel, currentRow, currentCol] = priorityQueue.top();  // 取出当前油量最大的点\\n        priorityQueue.pop();\\n\\n        if (currentRow == numRows - 1 && currentCol == numCols - 1) return true;  // 如果到达终点，返回true\\n\\n        // 遍历四个可能的方向\\n        for (auto& dir : directions) {\\n            int newRow = currentRow + dir.first;\\n            int newCol = currentCol + dir.second;\\n            if (isValid(newRow, newCol, numRows, numCols, mapData)) {  // 检查新位置是否有效\\n                int newFuel = (mapData[newRow][newCol] == -1) ? MAX_FUEL : currentFuel - mapData[newRow][newCol];\\n                if (newFuel > remainingFuel[newRow][newCol]) {\\n                    remainingFuel[newRow][newCol] = newFuel;  // 更新剩余油量\\n                    priorityQueue.push({newFuel, newRow, newCol});  // 将新点加入优先队列\\n                }\\n            }\\n        }\\n    }\\n\\n    return false;  // 如果遍历完成后没有找到可到达终点的路径，返回false\\n}\\n\\n// 检查位置是否有效的函数\\nbool isValid(int row, int col, int numRows, int numCols, const vector<vector<int>>& mapData) {\\n    return row >= 0 && row < numRows && col >= 0 && col < numCols && mapData[row][col] != 0;  // 确保不越界且不是障碍物\\n}\\n\\nint main() {\\n    int numRows, numCols;\\n    char comma;\\n\\n    cin >> numRows >> comma >> numCols;  // 读取行数和列数\\n    vector<vector<int>> mapData(numRows, vector<int>(numCols));\\n\\n    for (int i = 0; i < numRows; ++i) {  // 读取地图数据\\n        for (int j = 0; j < numCols; ++j) {\\n            if (j < numCols - 1) {\\n                cin >> mapData[i][j] >> comma;  // 读取每一行的数据，并处理逗号\\n            } else {\\n                cin >> mapData[i][j];\\n            }\\n        }\\n    }\\n\\n    int minFuel = findMinimumInitialFuel(mapData, numRows, numCols);  // 计算最小初始油量\\n    cout << minFuel << endl;  // 输出结果\\n\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n\\n#define MAX_FUEL 100  // 定义最大油量常量\\n\\n// 函数声明\\nint canReachDestination(int **map, int startFuel, int numRows, int numCols);\\nint isValid(int row, int col, int numRows, int numCols, int **map);\\nint findMinimumInitialFuel(int **map, int numRows, int numCols);\\n\\nint main() {\\n    int numRows, numCols;  // 定义行数和列数变量\\n    int **map;  // 定义一个二维数组指针，用于存储地图数据\\n    int i, j;\\n\\n    // 从标准输入读取地图的行数和列数\\n    scanf(\\"%d,%d\\", &numRows, &numCols);\\n\\n    // 为地图分配内存空间\\n    map = (int **)malloc(numRows * sizeof(int *));\\n    for (i = 0; i < numRows; i++) {\\n        map[i] = (int *)malloc(numCols * sizeof(int));\\n    }\\n\\n    // 从标准输入读取地图数据\\n    for (i = 0; i < numRows; i++) {\\n        for (j = 0; j < numCols; j++) {\\n            if (j < numCols - 1)\\n                scanf(\\"%d,\\", &map[i][j]);  // 读取每行中间的数值\\n            else\\n                scanf(\\"%d\\", &map[i][j]);  // 读取每行最后一个数值\\n        }\\n    }\\n\\n    // 计算并返回最小初始油量\\n    int minFuel = findMinimumInitialFuel(map, numRows, numCols);\\n    printf(\\"%d\\\\n\\", minFuel);  // 输出计算结果\\n\\n    // 释放地图内存空间\\n    for (i = 0; i < numRows; i++) {\\n        free(map[i]);\\n    }\\n    free(map);\\n\\n    return 0;\\n}\\n\\n// 判断是否可以到达终点的函数\\nint canReachDestination(int **map, int startFuel, int numRows, int numCols) {\\n    if (map[0][0] == 0) return 0;  // 起点不可通行则返回0\\n\\n    // 初始化剩余油量的二维数组\\n    int **remainingFuel = (int **)malloc(numRows * sizeof(int *));\\n    for (int i = 0; i < numRows; i++) {\\n        remainingFuel[i] = (int *)malloc(numCols * sizeof(int));\\n        for (int j = 0; j < numCols; j++) {\\n            remainingFuel[i][j] = -1;  // 初始化为-1\\n        }\\n    }\\n    remainingFuel[0][0] = (map[0][0] == -1) ? MAX_FUEL : startFuel - map[0][0];\\n    if (remainingFuel[0][0] < 0) return 0;  // 起点油量不足返回0\\n\\n    // 使用队列进行广度优先搜索\\n    int queue[10000][3], front = 0, rear = 0;  // 定义队列及其指针\\n    queue[rear][0] = 0;\\n    queue[rear][1] = 0;\\n    queue[rear][2] = remainingFuel[0][0];\\n    rear++;\\n\\n    int dx[4] = {0, 1, 0, -1};\\n    int dy[4] = {1, 0, -1, 0};\\n\\n    // 遍历队列中的元素\\n    while (front < rear) {\\n        int currentRow = queue[front][0];\\n        int currentCol = queue[front][1];\\n        int fuel = queue[front][2];\\n        front++;\\n\\n        // 到达终点检查\\n        if (currentRow == numRows - 1 && currentCol == numCols - 1) return 1;\\n\\n        // 检查四个方向的可行性\\n        for (int direction = 0; direction < 4; direction++) {\\n            int newRow = currentRow + dx[direction];\\n            int newCol = currentCol + dy[direction];\\n            if (isValid(newRow, newCol, numRows, numCols, map)) {\\n                int newFuel = (map[newRow][newCol] == -1) ? MAX_FUEL : fuel - map[newRow][newCol];\\n                if (newFuel > remainingFuel[newRow][newCol]) {\\n                    remainingFuel[newRow][newCol] = newFuel;\\n                    queue[rear][0] = newRow;\\n                    queue[rear][1] = newCol;\\n                    queue[rear][2] = newFuel;\\n                    rear++;\\n                }\\n            }\\n        }\\n    }\\n\\n    // 释放剩余油量数组内存空间\\n    for (int i = 0; i < numRows; i++) {\\n        free(remainingFuel[i]);\\n    }\\n    free(remainingFuel);\\n\\n    return 0;  // 无法到达终点返回0\\n}\\n\\n// 检查指定位置是否有效的函数\\nint isValid(int row, int col, int numRows, int numCols, int **map) {\\n    return row >= 0 && row < numRows && col >= 0 && col < numCols && map[row][col] != 0;\\n}\\n\\n// 使用二分搜索确定最小初始油量的函数\\nint findMinimumInitialFuel(int **map, int numRows, numCols) {\\n    int low = 0, high = MAX_FUEL, optimalFuel = -1;  // 初始化二分搜索边界和结果\\n    while (low <= high) {\\n        int mid = (low + high) / 2;  // 计算中点\\n        if (canReachDestination(map, mid, numRows, numCols)) {\\n            optimalFuel = mid;  // 更新找到的最小油量\\n            high = mid - 1;  // 继续在更低的范围内搜索\\n        } else {\\n            low = mid + 1;  // 在更高的范围内搜索\\n        }\\n    }\\n    return optimalFuel;  // 返回找到的最小初始油量\\n}"}`),s={id:"127",title:n,examType:"A",score:200,description:i,inputDesc:e,outputDesc:o,examples:t,solution:u,codes:l};export{l as codes,s as default,i as description,a as examType,t as examples,r as id,e as inputDesc,o as outputDesc,m as score,u as solution,n as title};
