const r="143",n="周末爬山",a="A",p=200,t="周末小明准备去爬山锻炼，0代表平地，山的高度使用1到9来表示，小明每次爬山或下山高度只能相差k及k以内，每次只能上下左右一个方向上移动一格，小明从左上角(0,0)位置出发",i=`第一行输入m n k(空格分隔)
代表m*n的二维山地图，k为小明每次爬山或下山高度差的最大值，
然后接下来输入山地图，一共m行n列，均以空格分隔。取值范围：
0 < m ≤ 5000< n ≤ 5000 < k < 5
所有用例输入均为正确格式，且在取值范围内，考生不需要考虑不合法的输入格式。`,e=`请问小明能爬到的最高峰多高，到该最高峰的最短步数，输出以空格分隔。
同高度的山峰输出较短步数。
如果没有可以爬的山峰，则高度和步数都返回0。`,m=[{input:`5 3 1
0 1 2
0 0 0
0 1 2
3 1 0
0 0 9`,output:"2 2",explanation:"从(0,0)出发，高度差限制1，能到达的最高峰高度2在(0,2)，最短步数2"},{input:`4 3 1
0 0 0
0 0 0
9 0 0
0 0 0`,output:"0 0",explanation:"起点高度0，高度差限制1，无法爬到高度9的山峰，返回0 0"}],o=`**解题思路：**

本题是一道**DFS+记忆化搜索**问题。

**核心思路：**
- 从(0,0)出发，只能移动到高度差<=k的相邻格子
- 记录能到达的最高峰及其最短步数

**算法步骤：**
1. 从起点开始DFS，向四个方向探索
2. 若相邻格高度差<=k则可移动
3. 用HashMap记录到达每个高度的最短步数
4. 用memo数组剪枝，避免重复访问
5. 返回最高峰高度和对应最短步数

**时间复杂度**：O(M×N)`,s=JSON.parse(`{"java":"import java.util.HashMap;\\nimport java.util.Scanner;\\n\\npublic class Main {\\n    // 定义一个常量数组，表示上下左右四个方向的偏移量\\n    private static final int[][] OFFSETS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n    public static void main(String[] args) {\\n        Scanner sc = new Scanner(System.in);\\n\\n        // 读取输入的m, n, k\\n        int m = sc.nextInt();\\n        int n = sc.nextInt();\\n        int k = sc.nextInt();\\n\\n        // 初始化山地图矩阵\\n        int[][] matrix = new int[m][n];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                matrix[i][j] = sc.nextInt();\\n            }\\n        }\\n\\n        // 初始化一个哈希表，用于存储到达不同高度的最短步数\\n        HashMap<Integer, Integer> minStepToHeight = new HashMap<>();\\n        minStepToHeight.put(matrix[0][0], 0);\\n\\n        // 初始化一个记忆化数组，用于记录已经访问过的位置和步数\\n        int[][] memo = new int[m][n];\\n        // 初始化一个布尔数组，用于记录已经访问过的位置\\n        boolean[][] visited = new boolean[m][n];\\n        // 调用深度优先搜索函数\\n        dfs(0, 0, 0, minStepToHeight, matrix, m, n, k, memo, visited);\\n\\n        // 计算最高峰的高度和最短步数\\n        int maxHeight = minStepToHeight.keySet().stream().max((a, b) -> a - b).orElse(0);\\n        int minStep = minStepToHeight.get(maxHeight);\\n\\n        // 输出结果\\n        System.out.println(maxHeight + \\" \\" + minStep);\\n    }\\n\\n    // 深度优先搜索函数\\n    public static void dfs(int x, int y, int step, HashMap<Integer, Integer> minStepToHeight, int[][] matrix, int m, int n, int k, int[][] memo, boolean[][] visited) {\\n        // 获取当前位置的高度\\n        int lastHeight = matrix[x][y];\\n\\n        // 遍历四个方向\\n        for (int[] offset : OFFSETS) {\\n            // 计算新的位置\\n            int newX = x + offset[0];\\n            int newY = y + offset[1];\\n\\n            // 检查新位置是否在矩阵范围内\\n            if (newX < 0 || newX >= m || newY < 0 || newY >= n) continue;\\n\\n            // 获取新位置的高度\\n            int curHeight = matrix[newX][newY];\\n\\n            // 检查两个位置的高度差是否在k以内\\n            if (Math.abs(curHeight - lastHeight) <= k) {\\n                // 增加步数\\n                step++;\\n\\n                // 更新到达新高度的最短步数\\n                if (!minStepToHeight.containsKey(curHeight) || minStepToHeight.get(curHeight) > step) {\\n                    minStepToHeight.put(curHeight, step);\\n                }\\n\\n                // 检查记忆化数组，避免重复计算\\n                if (memo[newX][newY] == 0 || memo[newX][newY] > step) {\\n                    // 更新记忆化数组\\n                    memo[newX][newY] = step;\\n                    // 标记当前位置为已访问\\n                    visited[x][y] = true;\\n\\n                    // 递归调用深度优先搜索\\n                    dfs(newX, newY, step, minStepToHeight, matrix, m, n, k, memo, visited);\\n\\n                    // 回溯时，将当前位置标记为未访问\\n                    visited[x][y] = false;\\n                }\\n\\n                // 减少步数\\n                step--;\\n            }\\n        }\\n    }\\n}","python":"from collections import defaultdict\\n\\n# 定义一个常量数组，表示上下左右四个方向的偏移量\\nOFFSETS = [\\n    (-1, 0),\\n    (1, 0),\\n    (0, -1),\\n    (0, 1),\\n]\\n\\n# 深度优先搜索函数\\ndef dfs(x, y, step, min_step_to_height, matrix, m, n, k, memo, visited):\\n    # 获取当前位置的高度\\n    last_height = matrix[x][y]\\n\\n    # 遍历四个方向\\n    for offset in OFFSETS:\\n        # 计算新的位置\\n        new_x = x + offset[0]\\n        new_y = y + offset[1]\\n\\n        # 检查新位置是否在矩阵范围内\\n        if new_x < 0 or new_x >= m or new_y < 0 or new_y >= n:\\n            continue\\n\\n        # 获取新位置的高度\\n        cur_height = matrix[new_x][new_y]\\n\\n        # 检查两个位置的高度差是否在k以内\\n        if abs(cur_height - last_height) <= k:\\n            # 增加步数\\n            step += 1\\n\\n            # 更新到达新高度的最短步数\\n            if cur_height not in min_step_to_height or min_step_to_height[cur_height] > step:\\n                min_step_to_height[cur_height] = step\\n\\n            # 检查记忆化数组，避免重复计算\\n            if memo[new_x][new_y] == 0 or memo[new_x][new_y] > step:\\n                # 更新记忆化数组\\n                memo[new_x][new_y] = step\\n                # 标记当前位置为已访问\\n                visited[x][y] = True\\n\\n                # 递归调用深度优先搜索\\n                dfs(new_x, new_y, step, min_step_to_height, matrix, m, n, k, memo, visited)\\n\\n                # 回溯时，将当前位置标记为未访问\\n                visited[x][y] = False\\n\\n            # 减少步数\\n            step -= 1\\n\\n# 主函数\\ndef main():\\n    # 读取输入的m, n, k\\n    m, n, k = map(int, input().split())\\n    # 初始化山地图矩阵\\n    matrix = [list(map(int, input().split())) for _ in range(m)]\\n\\n    # 初始化一个哈希表，用于存储到达不同高度的最短步数\\n    min_step_to_height = {matrix[0][0]: 0}\\n    # 初始化一个记忆化数组，用于记录已经访问过的位置和步数\\n    memo = [[0] * n for _ in range(m)]\\n    # 初始化一个布尔数组，用于记录已经访问过的位置\\n    visited = [[False] * n for _ in range(m)]\\n\\n    # 调用深度优先搜索函数\\n    dfs(0, 0, 0, min_step_to_height, matrix, m, n, k, memo, visited)\\n\\n    # 计算最高峰的高度和最短步数\\n    max_height = max(min_step_to_height.keys())\\n    min_step = min_step_to_height[max_height]\\n\\n    # 输出结果\\n    print(max_height, min_step)\\n\\n# 程序入口\\nif __name__ == \\"__main__\\":\\n    main()","javascript":"const readline = require('readline');\\nconst rl = readline.createInterface({\\n    input: process.stdin,\\n    output: process.stdout\\n});\\n\\n// 定义一个常量数组，表示上下左右四个方向的偏移量\\nconst OFFSETS = [\\n    [-1, 0],\\n    [1, 0],\\n    [0, -1],\\n    [0, 1],\\n];\\n\\n// 深度优先搜索函数\\nfunction dfs(x, y, step, minStepToHeight, matrix, m, n, k, memo, visited) {\\n    // 获取当前位置的高度\\n    const lastHeight = matrix[x][y];\\n\\n    // 遍历四个方向\\n    for (const offset of OFFSETS) {\\n        // 计算新的位置\\n        const newX = x + offset[0];\\n        const newY = y + offset[1];\\n\\n        // 检查新位置是否在矩阵范围内\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n) {\\n            continue;\\n        }\\n\\n        // 获取新位置的高度\\n        const curHeight = matrix[newX][newY];\\n\\n        // 检查两个位置的高度差是否在k以内\\n        if (Math.abs(curHeight - lastHeight) <= k) {\\n            // 增加步数\\n            step += 1;\\n\\n            // 更新到达新高度的最短步数\\n            if (!(curHeight in minStepToHeight) || minStepToHeight[curHeight] > step) {\\n                minStepToHeight[curHeight] = step;\\n            }\\n\\n            // 检查记忆化数组，避免重复计算\\n            if (memo[newX][newY] === 0 || memo[newX][newY] > step) {\\n                // 更新记忆化数组\\n                memo[newX][newY] = step;\\n                // 标记当前位置为已访问\\n                visited[x][y] = true;\\n\\n                // 递归调用深度优先搜索\\n                dfs(newX, newY, step, minStepToHeight, matrix, m, n, k, memo, visited);\\n\\n                // 回溯时，将当前位置标记为未访问\\n                visited[x][y] = false;\\n            }\\n\\n            // 减少步数\\n            step -= 1;\\n        }\\n    }\\n}\\nconst inputLines = [];\\n\\nrl.on('line', input => {\\n    inputLines.push(input);\\n    if (inputLines.length === parseInt(inputLines[0].split(' ')[0], 10) + 1) {\\n        rl.close();\\n        const [m, n, k] = inputLines[0].split(' ').map(Number);\\n        const matrix = inputLines.slice(1).map(line => line.split(' ').map(Number));\\n\\n\\n        // 初始化一个哈希表，用于存储到达不同高度的最短步数\\n        const minStepToHeight = { [matrix[0][0]]: 0 };\\n        // 初始化一个记忆化数组，用于记录已经访问过的位置和步数\\n        const memo = Array.from({ length: m }, () => Array(n).fill(0));\\n        // 初始化一个布尔数组，用于记录已经访问过的位置\\n        const visited = Array.from({ length: m }, () => Array(n).fill(false));\\n\\n        // 调用深度优先搜索函数\\n        dfs(0, 0, 0, minStepToHeight, matrix, m, n, k, memo, visited);\\n\\n        // 计算最高峰的高度和最短步数\\n        const max_height = Math.max(...Object.keys(minStepToHeight).map(Number));\\n        const min_step = minStepToHeight[max_height];\\n\\n        // 输出结果\\n        console.log(max_height, min_step);\\n\\n        rl.close();\\n    }\\n})","cpp":"#include <iostream>\\n#include <vector>\\n#include <unordered_map>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\n// 定义一个常量数组，表示上下左右四个方向的偏移量\\nconst vector<vector<int>> OFFSETS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n\\n// 深度优先搜索函数\\nvoid dfs(int x, int y, int step, unordered_map<int, int> &minStepToHeight, vector<vector<int>> &matrix, int m, int n, int k, vector<vector<int>> &memo, vector<vector<bool>> &visited) {\\n    // 获取当前位置的高度\\n    int lastHeight = matrix[x][y];\\n\\n    // 遍历四个方向\\n    for (const auto &offset : OFFSETS) {\\n        // 计算新的位置\\n        int newX = x + offset[0];\\n        int newY = y + offset[1];\\n\\n        // 检查新位置是否在矩阵范围内\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n) continue;\\n\\n        // 获取新位置的高度\\n        int curHeight = matrix[newX][newY];\\n\\n        // 检查两个位置的高度差是否在k以内\\n        if (abs(curHeight - lastHeight) <= k) {\\n            // 增加步数\\n            step++;\\n\\n            // 更新到达新高度的最短步数\\n            if (minStepToHeight.find(curHeight) == minStepToHeight.end() || minStepToHeight[curHeight] > step) {\\n                minStepToHeight[curHeight] = step;\\n            }\\n\\n            // 检查记忆化数组，避免重复计算\\n            if (memo[newX][newY] == 0 || memo[newX][newY] > step) {\\n                // 更新记忆化数组\\n                memo[newX][newY] = step;\\n                // 标记当前位置为已访问\\n                visited[x][y] = true;\\n\\n                // 递归调用深度优先搜索\\n                dfs(newX, newY, step, minStepToHeight, matrix, m, n, k, memo, visited);\\n\\n                // 回溯时，将当前位置标记为未访问\\n                visited[x][y] = false;\\n            }\\n\\n            // 减少步数\\n            step--;\\n        }\\n    }\\n}\\n\\nint main() {\\n    int m, n, k;\\n    cin >> m >> n >> k;\\n\\n    // 初始化山地图矩阵\\n    vector<vector<int>> matrix(m, vector<int>(n));\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < n; j++) {\\n            cin >> matrix[i][j];\\n        }\\n    }\\n\\n    // 初始化一个哈希表，用于存储到达不同高度的最短步数\\n    unordered_map<int, int> minStepToHeight;\\n    minStepToHeight[matrix[0][0]] = 0;\\n\\n    // 初始化一个记忆化数组，用于记录已经访问过的位置和步数\\n    vector<vector<int>> memo(m, vector<int>(n));\\n    // 初始化一个布尔数组，用于记录已经访问过的位置\\n    vector<vector<bool>> visited(m, vector<bool>(n));\\n    // 调用深度优先搜索函数\\n    dfs(0, 0, 0, minStepToHeight, matrix, m, n, k, memo, visited);\\n\\n    // 计算最高峰的高度和最短步数\\n    int maxHeight = 0;\\n    int minStep = 0;\\n    for (const auto &entry : minStepToHeight) {\\n        if (entry.first > maxHeight) {\\n            maxHeight = entry.first;\\n            minStep = entry.second;\\n        }\\n    }\\n\\n    // 输出结果\\n    cout << maxHeight << \\" \\" << minStep << endl;\\n\\n    return 0;\\n}","c":"#include <stdio.h>\\n#include <stdlib.h>\\n#include <stdbool.h>\\n#include <math.h>\\n\\n// 定义四个方向的偏移量：上、下、左、右\\nint OFFSETS[4][2] = {\\n    {-1, 0},  // 上\\n    {1, 0},   // 下\\n    {0, -1},  // 左\\n    {0, 1}    // 右\\n};\\n\\n// 深度优先搜索函数\\nvoid dfs(int x, int y, int step, int **minStepToHeight, int **matrix, int m, int n, int k, int **memo, bool **visited) {\\n    // 获取当前位置的高度\\n    int lastHeight = matrix[x][y];\\n\\n    // 遍历四个方向\\n    for (int i = 0; i < 4; i++) {\\n        int newX = x + OFFSETS[i][0];  // 新位置的行坐标\\n        int newY = y + OFFSETS[i][1];  // 新位置的列坐标\\n\\n        // 检查新位置是否在地图范围内\\n        if (newX < 0 || newX >= m || newY < 0 || newY >= n) {\\n            continue;\\n        }\\n\\n        // 获取新位置的高度\\n        int curHeight = matrix[newX][newY];\\n\\n        // 检查高度差是否在k以内\\n        if (abs(curHeight - lastHeight) <= k) {\\n            step++;  // 增加步数\\n\\n            // 更新到达新高度的最短步数\\n            if (minStepToHeight[curHeight][0] == 0 || minStepToHeight[curHeight][0] > step) {\\n                minStepToHeight[curHeight][0] = step;\\n            }\\n\\n            // 检查记忆数组，避免重复计算\\n            if (memo[newX][newY] == 0 || memo[newX][newY] > step) {\\n                memo[newX][newY] = step;    // 更新记忆化数组\\n                visited[x][y] = true;       // 标记当前位置为已访问\\n\\n                // 递归调用深度优先搜索\\n                dfs(newX, newY, step, minStepToHeight, matrix, m, n, k, memo, visited);\\n\\n                visited[x][y] = false;      // 回溯时标记当前位置为未访问\\n            }\\n\\n            step--;  // 回溯时步数减少\\n        }\\n    }\\n}\\n\\nint main() {\\n    int m, n, k;\\n    scanf(\\"%d %d %d\\", &m, &n, &k);  // 输入m, n, k的值\\n\\n    // 动态分配二维数组用于存储山地图\\n    int **matrix = (int **)malloc(m * sizeof(int *));\\n    for (int i = 0; i < m; i++) {\\n        matrix[i] = (int *)malloc(n * sizeof(int));\\n        for (int j = 0; j < n; j++) {\\n            scanf(\\"%d\\", &matrix[i][j]);  // 读取山地图\\n        }\\n    }\\n\\n    // 初始化用于存储到达不同高度的最短步数数组\\n    int **minStepToHeight = (int **)malloc(10 * sizeof(int *));\\n    for (int i = 0; i < 10; i++) {\\n        minStepToHeight[i] = (int *)calloc(1, sizeof(int));  // 初始最短步数为0\\n    }\\n\\n    // 初始化记忆化数组，用于记录已经访问过的位置和步数\\n    int **memo = (int **)malloc(m * sizeof(int *));\\n    for (int i = 0; i < m; i++) {\\n        memo[i] = (int *)calloc(n, sizeof(int));\\n    }\\n\\n    // 初始化访问数组，记录已访问位置\\n    bool **visited = (bool **)malloc(m * sizeof(bool *));\\n    for (int i = 0; i < m; i++) {\\n        visited[i] = (bool *)calloc(n, sizeof(bool));\\n    }\\n\\n    // 初始化时从起点 (0,0) 开始\\n    minStepToHeight[matrix[0][0]][0] = 0;\\n\\n    // 调用深度优先搜索\\n    dfs(0, 0, 0, minStepToHeight, matrix, m, n, k, memo, visited);\\n\\n    // 查找能够到达的最高峰及其最短步数\\n    int max_height = 0;\\n    int min_step = 0;\\n\\n    for (int i = 0; i < 10; i++) {\\n        if (minStepToHeight[i][0] != 0) {\\n            max_height = i;      // 更新最高峰高度\\n            min_step = minStepToHeight[i][0];  // 获取最短步数\\n        }\\n    }\\n\\n    // 输出结果，如果无法到达任何峰值，输出0 0\\n    if (max_height == 0) {\\n        printf(\\"0 0\\\\n\\");\\n    } else {\\n        printf(\\"%d %d\\\\n\\", max_height, min_step);\\n    }\\n\\n    // 释放动态分配的内存\\n    for (int i = 0; i < m; i++) {\\n        free(matrix[i]);\\n        free(memo[i]);\\n        free(visited[i]);\\n    }\\n    free(matrix);\\n    free(memo);\\n    free(visited);\\n\\n    for (int i = 0; i < 10; i++) {\\n        free(minStepToHeight[i]);\\n    }\\n    free(minStepToHeight);\\n\\n    return 0;\\n}"}`),h={id:"143",title:n,examType:"A",score:200,description:t,inputDesc:i,outputDesc:e,examples:m,solution:o,codes:s};export{s as codes,h as default,t as description,a as examType,m as examples,r as id,i as inputDesc,e as outputDesc,p as score,o as solution,n as title};
